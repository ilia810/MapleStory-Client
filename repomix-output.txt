This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/includes/**, **.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.claude/settings.local.json
.gitignore
Audio/Audio.cpp
Audio/Audio.h
build_integrated.bat
build_nx_extractor.bat
build_simple.bat
build.bat
Character/ActiveBuffs.cpp
Character/ActiveBuffs.h
Character/Buff.cpp
Character/Buff.h
Character/Char.cpp
Character/Char.h
Character/CharEffect.cpp
Character/CharEffect.h
Character/CharStats.cpp
Character/CharStats.h
Character/EquipStat.cpp
Character/EquipStat.h
Character/ExpTable.cpp
Character/ExpTable.h
Character/Inventory/Equip.cpp
Character/Inventory/Equip.h
Character/Inventory/EquipQuality.cpp
Character/Inventory/EquipQuality.h
Character/Inventory/Inventory.cpp
Character/Inventory/Inventory.h
Character/Inventory/InventoryType.cpp
Character/Inventory/InventoryType.h
Character/Inventory/Item.cpp
Character/Inventory/Item.h
Character/Inventory/Pet.cpp
Character/Inventory/Pet.h
Character/Inventory/Weapon.cpp
Character/Inventory/Weapon.h
Character/Job.cpp
Character/Job.h
Character/Look/Afterimage.cpp
Character/Look/Afterimage.h
Character/Look/Body.cpp
Character/Look/Body.h
Character/Look/BodyDrawInfo.cpp
Character/Look/BodyDrawInfo.h
Character/Look/CharEquips.cpp
Character/Look/CharEquips.h
Character/Look/CharLook.cpp
Character/Look/CharLook.h
Character/Look/Clothing.cpp
Character/Look/Clothing.h
Character/Look/EquipSlot.cpp
Character/Look/EquipSlot.h
Character/Look/Face.cpp
Character/Look/Face.h
Character/Look/Hair.cpp
Character/Look/Hair.h
Character/Look/PetLook.cpp
Character/Look/PetLook.h
Character/Look/Stance.cpp
Character/Look/Stance.h
Character/MapleStat.cpp
Character/MapleStat.h
Character/MonsterBook.cpp
Character/MonsterBook.h
Character/OtherChar.cpp
Character/OtherChar.h
Character/PassiveBuffs.cpp
Character/PassiveBuffs.h
Character/Player.cpp
Character/Player.h
Character/PlayerStates.cpp
Character/PlayerStates.h
Character/QuestLog.cpp
Character/QuestLog.h
Character/SkillBook.cpp
Character/SkillBook.h
Character/SkillId.h
Character/StatCaps.h
Character/TeleportRock.cpp
Character/TeleportRock.h
Configuration.cpp
Configuration.h
Constants.h
Data/BulletData.cpp
Data/BulletData.h
Data/EquipData.cpp
Data/EquipData.h
Data/ItemData.cpp
Data/ItemData.h
Data/JobData.cpp
Data/JobData.h
Data/SkillData.cpp
Data/SkillData.h
Data/WeaponData.cpp
Data/WeaponData.h
debug_nx.cpp
Error.h
extract_all_nx_structures.cpp
Gameplay/Camera.cpp
Gameplay/Camera.h
Gameplay/Combat/Attack.h
Gameplay/Combat/Bullet.cpp
Gameplay/Combat/Bullet.h
Gameplay/Combat/Combat.cpp
Gameplay/Combat/Combat.h
Gameplay/Combat/DamageNumber.cpp
Gameplay/Combat/DamageNumber.h
Gameplay/Combat/RegularAttack.cpp
Gameplay/Combat/RegularAttack.h
Gameplay/Combat/Skill.cpp
Gameplay/Combat/Skill.h
Gameplay/Combat/SkillAction.cpp
Gameplay/Combat/SkillAction.h
Gameplay/Combat/SkillBullet.cpp
Gameplay/Combat/SkillBullet.h
Gameplay/Combat/SkillHitEffect.cpp
Gameplay/Combat/SkillHitEffect.h
Gameplay/Combat/SkillSound.cpp
Gameplay/Combat/SkillSound.h
Gameplay/Combat/SkillUseEffect.cpp
Gameplay/Combat/SkillUseEffect.h
Gameplay/Combat/SpecialMove.h
Gameplay/MapleMap/Drop.cpp
Gameplay/MapleMap/Drop.h
Gameplay/MapleMap/ItemDrop.cpp
Gameplay/MapleMap/ItemDrop.h
Gameplay/MapleMap/Layer.h
Gameplay/MapleMap/MapBackgrounds.cpp
Gameplay/MapleMap/MapBackgrounds.h
Gameplay/MapleMap/MapChars.cpp
Gameplay/MapleMap/MapChars.h
Gameplay/MapleMap/MapDrops.cpp
Gameplay/MapleMap/MapDrops.h
Gameplay/MapleMap/MapEffect.cpp
Gameplay/MapleMap/MapEffect.h
Gameplay/MapleMap/MapInfo.cpp
Gameplay/MapleMap/MapInfo.h
Gameplay/MapleMap/MapMobs.cpp
Gameplay/MapleMap/MapMobs.h
Gameplay/MapleMap/MapNpcs.cpp
Gameplay/MapleMap/MapNpcs.h
Gameplay/MapleMap/MapObject.cpp
Gameplay/MapleMap/MapObject.h
Gameplay/MapleMap/MapObjects.cpp
Gameplay/MapleMap/MapObjects.h
Gameplay/MapleMap/MapPortals.cpp
Gameplay/MapleMap/MapPortals.h
Gameplay/MapleMap/MapReactors.cpp
Gameplay/MapleMap/MapReactors.h
Gameplay/MapleMap/MapTilesObjs.cpp
Gameplay/MapleMap/MapTilesObjs.h
Gameplay/MapleMap/MesoDrop.cpp
Gameplay/MapleMap/MesoDrop.h
Gameplay/MapleMap/Mob.cpp
Gameplay/MapleMap/Mob.h
Gameplay/MapleMap/Npc.cpp
Gameplay/MapleMap/Npc.h
Gameplay/MapleMap/Obj.cpp
Gameplay/MapleMap/Obj.h
Gameplay/MapleMap/Portal.cpp
Gameplay/MapleMap/Portal.h
Gameplay/MapleMap/Reactor.cpp
Gameplay/MapleMap/Reactor.h
Gameplay/MapleMap/Tile.cpp
Gameplay/MapleMap/Tile.h
Gameplay/Movement.h
Gameplay/Physics/Foothold.cpp
Gameplay/Physics/Foothold.h
Gameplay/Physics/FootholdTree.cpp
Gameplay/Physics/FootholdTree.h
Gameplay/Physics/Physics.cpp
Gameplay/Physics/Physics.h
Gameplay/Physics/PhysicsObject.h
Gameplay/Playable.h
Gameplay/Spawn.cpp
Gameplay/Spawn.h
Gameplay/Stage.cpp
Gameplay/Stage.h
Graphics/Animation.cpp
Graphics/Animation.h
Graphics/Color.cpp
Graphics/Color.h
Graphics/DrawArgument.h
Graphics/EffectLayer.cpp
Graphics/EffectLayer.h
Graphics/Geometry.cpp
Graphics/Geometry.h
Graphics/GraphicsGL.cpp
Graphics/GraphicsGL.h
Graphics/SpecialText.h
Graphics/Sprite.cpp
Graphics/Sprite.h
Graphics/Text.cpp
Graphics/Text.h
Graphics/Texture.cpp
Graphics/Texture.h
install_dependencies.bat
IO/Components/AreaButton.cpp
IO/Components/AreaButton.h
IO/Components/Button.cpp
IO/Components/Button.h
IO/Components/Charset.cpp
IO/Components/Charset.h
IO/Components/ChatBalloon.cpp
IO/Components/ChatBalloon.h
IO/Components/EquipTooltip.cpp
IO/Components/EquipTooltip.h
IO/Components/Gauge.cpp
IO/Components/Gauge.h
IO/Components/Icon.cpp
IO/Components/Icon.h
IO/Components/IconCover.cpp
IO/Components/IconCover.h
IO/Components/ItemTooltip.cpp
IO/Components/ItemTooltip.h
IO/Components/MapleButton.cpp
IO/Components/MapleButton.h
IO/Components/MapleComboBox.cpp
IO/Components/MapleComboBox.h
IO/Components/MapleFrame.cpp
IO/Components/MapleFrame.h
IO/Components/MapTooltip.cpp
IO/Components/MapTooltip.h
IO/Components/NameTag.cpp
IO/Components/NameTag.h
IO/Components/NpcText.cpp
IO/Components/ScrollingNotice.cpp
IO/Components/ScrollingNotice.h
IO/Components/SkillTooltip.cpp
IO/Components/SkillTooltip.h
IO/Components/Slider.cpp
IO/Components/Slider.h
IO/Components/StatefulIcon.cpp
IO/Components/StatefulIcon.h
IO/Components/Textfield.cpp
IO/Components/Textfield.h
IO/Components/TextTooltip.cpp
IO/Components/TextTooltip.h
IO/Components/Tooltip.h
IO/Components/TwoSpriteButton.cpp
IO/Components/TwoSpriteButton.h
IO/Cursor.cpp
IO/Cursor.h
IO/KeyAction.h
IO/Keyboard.cpp
IO/Keyboard.h
IO/KeyConfig.h
IO/KeyType.h
IO/Messages.cpp
IO/Messages.h
IO/UI.cpp
IO/UI.h
IO/UIDragElement.h
IO/UIElement.cpp
IO/UIElement.h
IO/UIState.h
IO/UIStateCashShop.cpp
IO/UIStateCashShop.h
IO/UIStateGame.cpp
IO/UIStateGame.h
IO/UIStateLogin.cpp
IO/UIStateLogin.h
IO/UITypes/UIAranCreation.h
IO/UITypes/UIBuffList.cpp
IO/UITypes/UIBuffList.h
IO/UITypes/UICashShop.cpp
IO/UITypes/UICashShop.h
IO/UITypes/UIChannel.cpp
IO/UITypes/UIChannel.h
IO/UITypes/UICharInfo.cpp
IO/UITypes/UICharInfo.h
IO/UITypes/UICharSelect.cpp
IO/UITypes/UICharSelect.h
IO/UITypes/UIChat.cpp
IO/UITypes/UIChat.h
IO/UITypes/UIChatBar.cpp
IO/UITypes/UIChatBar.h
IO/UITypes/UICommonCreation.cpp
IO/UITypes/UICommonCreation.h
IO/UITypes/UICygnusCreation.h
IO/UITypes/UIEquipInventory.cpp
IO/UITypes/UIEquipInventory.h
IO/UITypes/UIEvent.cpp
IO/UITypes/UIEvent.h
IO/UITypes/UIExplorerCreation.h
IO/UITypes/UIGender.cpp
IO/UITypes/UIGender.h
IO/UITypes/UIItemInventory.cpp
IO/UITypes/UIItemInventory.h
IO/UITypes/UIJoypad.cpp
IO/UITypes/UIJoypad.h
IO/UITypes/UIKeyConfig.cpp
IO/UITypes/UIKeyConfig.h
IO/UITypes/UILogin.cpp
IO/UITypes/UILogin.cpp.backup
IO/UITypes/UILogin.h
IO/UITypes/UILoginNotice.cpp
IO/UITypes/UILoginNotice.h
IO/UITypes/UILoginWait.cpp
IO/UITypes/UILoginWait.h
IO/UITypes/UILogo.cpp
IO/UITypes/UILogo.h
IO/UITypes/UIMiniMap.cpp
IO/UITypes/UIMiniMap.h
IO/UITypes/UINotice.cpp
IO/UITypes/UINotice.h
IO/UITypes/UINpcTalk.cpp
IO/UITypes/UINpcTalk.h
IO/UITypes/UIOptionMenu.cpp
IO/UITypes/UIOptionMenu.h
IO/UITypes/UIQuestLog.cpp
IO/UITypes/UIQuestLog.h
IO/UITypes/UIQuit.cpp
IO/UITypes/UIQuit.h
IO/UITypes/UIRaceSelect.cpp
IO/UITypes/UIRaceSelect.h
IO/UITypes/UIRegion.cpp
IO/UITypes/UIRegion.h
IO/UITypes/UIShop.cpp
IO/UITypes/UIShop.h
IO/UITypes/UISkillBook.cpp
IO/UITypes/UISkillBook.h
IO/UITypes/UISoftKey.cpp
IO/UITypes/UISoftKey.h
IO/UITypes/UIStatsInfo.cpp
IO/UITypes/UIStatsInfo.h
IO/UITypes/UIStatusBar.cpp
IO/UITypes/UIStatusBar.h
IO/UITypes/UIStatusMessenger.cpp
IO/UITypes/UIStatusMessenger.h
IO/UITypes/UITermsOfService.cpp
IO/UITypes/UITermsOfService.h
IO/UITypes/UIUserList.cpp
IO/UITypes/UIUserList.h
IO/UITypes/UIWorldMap.cpp
IO/UITypes/UIWorldMap.h
IO/UITypes/UIWorldSelect.cpp
IO/UITypes/UIWorldSelect.h
IO/Window.cpp
IO/Window.h
libs/WzLib.lib.recipe
LICENSE
MapleStory.cpp
MapleStory.h
MapleStory.sln
MapleStory.vcxproj
MapleStory.vcxproj.backup
MapleStory.vcxproj.filters
Net/Cryptography.cpp
Net/Cryptography.h
Net/Handlers/AttackHandlers.cpp
Net/Handlers/AttackHandlers.h
Net/Handlers/CashShopHandlers.cpp
Net/Handlers/CashShopHandlers.h
Net/Handlers/CommonHandlers.cpp
Net/Handlers/CommonHandlers.h
Net/Handlers/Helpers/CashShopParser.cpp
Net/Handlers/Helpers/CashShopParser.h
Net/Handlers/Helpers/CharacterParser.cpp
Net/Handlers/Helpers/CharacterParser.h
Net/Handlers/Helpers/ItemParser.cpp
Net/Handlers/Helpers/ItemParser.h
Net/Handlers/Helpers/LoginParser.cpp
Net/Handlers/Helpers/LoginParser.h
Net/Handlers/Helpers/MovementParser.cpp
Net/Handlers/Helpers/MovementParser.h
Net/Handlers/InventoryHandlers.cpp
Net/Handlers/InventoryHandlers.h
Net/Handlers/LoginHandlers.cpp
Net/Handlers/LoginHandlers.h
Net/Handlers/MapObjectHandlers.cpp
Net/Handlers/MapObjectHandlers.h
Net/Handlers/MessagingHandlers.cpp
Net/Handlers/MessagingHandlers.h
Net/Handlers/NpcInteractionHandlers.cpp
Net/Handlers/NpcInteractionHandlers.h
Net/Handlers/PlayerHandlers.cpp
Net/Handlers/PlayerHandlers.h
Net/Handlers/PlayerInteractionHandlers.cpp
Net/Handlers/PlayerInteractionHandlers.h
Net/Handlers/SetFieldHandlers.cpp
Net/Handlers/SetFieldHandlers.h
Net/Handlers/TestingHandlers.cpp
Net/Handlers/TestingHandlers.h
Net/InPacket.cpp
Net/InPacket.h
Net/Login.h
Net/NetConstants.h
Net/OutPacket.cpp
Net/OutPacket.h
Net/PacketError.h
Net/PacketHandler.h
Net/Packets/AttackAndSkillPackets.h
Net/Packets/CharCreationPackets.h
Net/Packets/CommonPackets.h
Net/Packets/GameplayPackets.h
Net/Packets/InventoryPackets.h
Net/Packets/LoginPackets.h
Net/Packets/MessagingPackets.h
Net/Packets/MovementPacket.h
Net/Packets/NpcInteractionPackets.h
Net/Packets/PlayerInteractionPackets.h
Net/Packets/PlayerPackets.h
Net/Packets/SelectCharPackets.h
Net/PacketSwitch.cpp
Net/PacketSwitch.h
Net/Session.cpp
Net/Session.h
Net/SocketAsio.cpp
Net/SocketAsio.h
Net/SocketWinsock.cpp
Net/SocketWinsock.h
NoLifeNx_build/.git/config
NoLifeNx_build/.git/description
NoLifeNx_build/.git/HEAD
NoLifeNx_build/.git/hooks/applypatch-msg.sample
NoLifeNx_build/.git/hooks/commit-msg.sample
NoLifeNx_build/.git/hooks/fsmonitor-watchman.sample
NoLifeNx_build/.git/hooks/post-update.sample
NoLifeNx_build/.git/hooks/pre-applypatch.sample
NoLifeNx_build/.git/hooks/pre-commit.sample
NoLifeNx_build/.git/hooks/pre-merge-commit.sample
NoLifeNx_build/.git/hooks/pre-push.sample
NoLifeNx_build/.git/hooks/pre-rebase.sample
NoLifeNx_build/.git/hooks/pre-receive.sample
NoLifeNx_build/.git/hooks/prepare-commit-msg.sample
NoLifeNx_build/.git/hooks/push-to-checkout.sample
NoLifeNx_build/.git/hooks/sendemail-validate.sample
NoLifeNx_build/.git/hooks/update.sample
NoLifeNx_build/.git/info/exclude
NoLifeNx_build/.git/logs/HEAD
NoLifeNx_build/.git/logs/refs/heads/update
NoLifeNx_build/.git/logs/refs/remotes/origin/HEAD
NoLifeNx_build/.git/packed-refs
NoLifeNx_build/.git/refs/heads/update
NoLifeNx_build/.git/refs/remotes/origin/HEAD
NoLifeNx_build/.gitignore
NoLifeNx_build/audio.cpp
NoLifeNx_build/audio.hpp
NoLifeNx_build/bitmap.cpp
NoLifeNx_build/bitmap.hpp
NoLifeNx_build/file_impl.hpp
NoLifeNx_build/file.cpp
NoLifeNx_build/file.hpp
NoLifeNx_build/node_impl.hpp
NoLifeNx_build/node.cpp
NoLifeNx_build/node.hpp
NoLifeNx_build/NoLifeNx.sln
NoLifeNx_build/NoLifeNx.vcxproj
NoLifeNx_build/NoLifeNx.vcxproj.filters
NoLifeNx_build/nx.cpp
NoLifeNx_build/nx.hpp
NoLifeNx_build/nxfwd.hpp
NoLifeNx_build/README.md
NoLifeWzToNx/convert_all_wz.bat
nul
README_BUILD.md
README.md
resource.h
run_client.bat
setup_nx_conversion.bat
Template/BoolPair.h
Template/Cache.h
Template/Enumeration.h
Template/EnumMap.h
Template/Interpolated.h
Template/Optional.h
Template/Point.h
Template/Range.h
Template/Rectangle.h
Template/Singleton.h
Template/TimedQueue.h
Template/TypeMap.h
Timer.h
Util/AssetRegistry.cpp
Util/AssetRegistry.h
Util/AssetRegistryTest.cpp
Util/Assets.h
Util/HardwareInfo.h
Util/Lerp.h
Util/Misc.cpp
Util/Misc.h
Util/NxFiles.cpp
Util/NxFiles.h
Util/QuadTree.h
Util/Randomizer.h
Util/ScreenResolution.h
Util/TimedBool.h
Util/UINodes.cpp
Util/UINodes.h
Util/WzFiles.cpp
Util/WzFiles.h
V87_COMPATIBILITY_CHANGES.md

================================================================
Files
================================================================

================
File: .claude/settings.local.json
================
{
  "permissions": {
    "allow": [
      "Bash(find:*)",
      "Bash(git reset:*)",
      "Bash(git checkout:*)",
      "Bash(ls:*)",
      "WebFetch(domain:nxformat.github.io)",
      "Bash(g++:*)",
      "Bash(dir:*)",
      "Bash(cp:*)",
      "Bash(python:*)",
      "Bash(msbuild:*)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" MapleStory.vcxproj /p:Configuration=Debug /p:Platform=x64)",
      "Bash(MSBuild:*)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" MapleStory.sln /p:Configuration=Debug /p:Platform=x64)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" MapleStory.sln /p:Configuration=Debug /p:Platform=x64 /verbosity:minimal)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" MapleStory.vcxproj -p:Configuration=Debug -p:Platform=x64)",
      "Bash(xcopy:*)",
      "Bash(robocopy:*)",
      "Bash(copy:*)",
      "Bash(.MapleStory.exe)",
      "Bash(./MapleStory.exe)",
      "Bash(.build_nx_extractor.bat)",
      "Bash(./build_nx_extractor.bat)",
      "Bash(cmd.exe:*)",
      "Bash(set EXTRACT_ALL_NX=1)",
      "Bash(timeout:*)",
      "Bash(mkdir:*)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" MapleStory.sln -p:Configuration=Debug -p:Platform=x64)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" Journey.sln /p:Configuration=Debug /p:Platform=x64)",
      "Bash(build.bat debug x64)",
      "Bash(./build.bat debug x64)",
      "Bash(cmd /c:*)",
      "Bash(touch:*)",
      "Bash(taskkill:*)",
      "Bash(true)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" MapleStory.vcxproj /p:Configuration=Debug /p:Platform=x64 /v:minimal)",
      "Bash(/dev/null)",
      "Bash(rmdir:*)",
      "Bash(rm:*)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" MapleStory.sln /p:Configuration=Debug /p:Platform=x64 /t:Clean)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" MapleStory.sln /p:Configuration=Debug /p:Platform=x64 /t:Rebuild)",
      "Bash(.build.bat)",
      "Bash(build.bat)",
      "Bash(powershell:*)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" NoLifeNx.sln /p:Configuration=Release /p:Platform=x64)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" NoLifeNx.vcxproj -p:Configuration=Release -p:Platform=x64)",
      "Bash('C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe' MapleStory.vcxproj -p:Configuration=Debug -p:Platform=x64 -t:Rebuild)",
      "Bash('C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe' MapleStory.vcxproj -p:Configuration=Debug -p:Platform=x64)",
      "Bash('C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe' NoLifeNx.vcxproj -p:Configuration=Release -p:Platform=x64)",
      "Bash(devenv:*)",
      "Bash(cl.exe:*)",
      "Bash(lib.exe:*)",
      "Bash(call \"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvarsx86_amd64.bat\")",
      "Bash(cl:*)",
      "Bash(lib:*)",
      "Bash(cmd //c:*)",
      "Bash(\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" NoLifeNx.vcxproj /p:Configuration=Release /p:Platform=x64 /rebuild)",
      "Bash(\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" NoLifeNx.vcxproj /p:Configuration=Release /p:Platform=x64)",
      "Bash(\"/c/Program Files (x86)/Microsoft Visual Studio/2019/Community/MSBuild/Current/Bin/MSBuild.exe\" NoLifeNx.vcxproj //p:Configuration=Release //p:Platform=x64)",
      "Bash(\"C:\\HeavenClient\\MapleStory-Client\\build.bat\")",
      "Bash(./build.bat)",
      "Bash(MSYS_NO_PATHCONV=1 cmd.exe /c \"cd /d C:\\HeavenClient\\MapleStory-Client && build.bat\")",
      "Bash(MSYS_NO_PATHCONV=1 cmd.exe /c \"cd /d C:\\HeavenClient\\MapleStory-Client && build_simple.bat\")",
      "Bash(MSYS_NO_PATHCONV=1 MSBuild.exe \"includes/NoLifeNx/NoLifeNx.vcxproj\" /p:Configuration=Release /p:Platform=x64)",
      "Bash(MSYS_NO_PATHCONV=1 \"/c/Program Files/Microsoft Visual Studio/2022/Community/MSBuild/Current/Bin/MSBuild.exe\" \"includes/NoLifeNx/NoLifeNx.vcxproj\" /p:Configuration=Release /p:Platform=x64)",
      "Bash(MSYS_NO_PATHCONV=1 \"/c/Program Files/Microsoft Visual Studio/2022/Community/MSBuild/Current/Bin/MSBuild.exe\" \"NoLifeNx.vcxproj\" /p:Configuration=Release /p:Platform=x64)",
      "Bash(MSYS_NO_PATHCONV=1 \"/c/Program Files/Microsoft Visual Studio/2022/Community/MSBuild/Current/Bin/MSBuild.exe\" \"NoLifeNx.vcxproj\" /p:Configuration=Release /p:Platform=x64 /t:Rebuild)",
      "Bash(build_integrated.bat)",
      "Bash(C:HeavenClientbuild_integrated.bat)",
      "Bash(.build_integrated.bat)",
      "Bash(./build_integrated.bat)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" \"NoLifeNx.vcxproj\" /p:Configuration=Debug /p:Platform=x64 /t:Rebuild /v:minimal)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" NoLifeNx.vcxproj /p:Configuration=Debug /p:Platform=x64 /t:Rebuild /v:minimal)",
      "Bash(/c/Program Files/Microsoft Visual Studio/2022/Community/MSBuild/Current/Bin/MSBuild.exe NoLifeNx.vcxproj /p:Configuration=Debug /p:Platform=x64 /t:Rebuild /v:minimal)",
      "Bash(\"run_client.bat\")",
      "Bash(./run_client.bat)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" \"MapleStory.sln\" /p:Configuration=Release /p:Platform=Win32 /m /v:minimal)",
      "Bash(\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" MapleStory.sln /p:Configuration=Release /p:Platform=Win32 /m /v:minimal)",
      "Bash(grep:*)",
      "Bash(.build.bat debug x64)"
    ],
    "deny": []
  }
}

================
File: .gitignore
================
/.vs
/x64
/x86

*.aps
*.log
*.tlog
*.vcxproj.user

*.nx
*.wz
Settings

/includes/WzLib

================
File: Audio/Audio.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Audio.h"

#include "../Configuration.h"

#include <bass.h>

#ifdef USE_NX
#include <nlnx/audio.hpp>
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Sound::Sound(Name name)
	{
		id = soundids[name];
	}

	Sound::Sound(int32_t itemid)
	{
		auto fitemid = format_id(itemid);

		if (itemids.find(fitemid) != itemids.end())
		{
			id = itemids.at(fitemid);
		}
		else
		{
			auto pid = (10000 * (itemid / 10000));
			auto fpid = format_id(pid);

			if (itemids.find(fpid) != itemids.end())
				id = itemids.at(fpid);
			else
				id = itemids.at("02000000");
		}
	}

	Sound::Sound(nl::node src)
	{
		id = add_sound(src);
	}

	Sound::Sound()
	{
		id = 0;
	}

	void Sound::play() const
	{
		if (id > 0)
			play(id);
	}

	Error Sound::init()
	{
		if (!BASS_Init(-1, 44100, 0, nullptr, 0))
		{
			// For testing purposes, continue without audio instead of failing
			std::cout << "[DEBUG] BASS audio initialization failed, continuing without audio..." << std::endl;
			return Error::Code::NONE;  // Continue without audio
		}

		std::cout << "[DEBUG] BASS audio initialized successfully" << std::endl;
		nl::node uisrc = nl::nx::Sound["UI.img"];

		add_sound(Sound::Name::BUTTONCLICK, uisrc["BtMouseClick"]);
		add_sound(Sound::Name::BUTTONOVER, uisrc["BtMouseOver"]);
		add_sound(Sound::Name::CHARSELECT, uisrc["CharSelect"]);
		add_sound(Sound::Name::DLGNOTICE, uisrc["DlgNotice"]);
		add_sound(Sound::Name::MENUDOWN, uisrc["MenuDown"]);
		add_sound(Sound::Name::MENUUP, uisrc["MenuUp"]);
		add_sound(Sound::Name::RACESELECT, uisrc["RaceSelect"]);
		add_sound(Sound::Name::SCROLLUP, uisrc["ScrollUp"]);
		add_sound(Sound::Name::SELECTMAP, uisrc["SelectMap"]);
		add_sound(Sound::Name::TAB, uisrc["Tab"]);
		add_sound(Sound::Name::WORLDSELECT, uisrc["WorldSelect"]);
		add_sound(Sound::Name::DRAGSTART, uisrc["DragStart"]);
		add_sound(Sound::Name::DRAGEND, uisrc["DragEnd"]);
		add_sound(Sound::Name::WORLDMAPOPEN, uisrc["WorldmapOpen"]);
		add_sound(Sound::Name::WORLDMAPCLOSE, uisrc["WorldmapClose"]);

		nl::node gamesrc = nl::nx::Sound["Game.img"];

		add_sound(Sound::Name::GAMESTART, gamesrc["GameIn"]);
		add_sound(Sound::Name::JUMP, gamesrc["Jump"]);
		add_sound(Sound::Name::DROP, gamesrc["DropItem"]);
		add_sound(Sound::Name::PICKUP, gamesrc["PickUpItem"]);
		add_sound(Sound::Name::PORTAL, gamesrc["Portal"]);
		add_sound(Sound::Name::LEVELUP, gamesrc["LevelUp"]);
		add_sound(Sound::Name::TOMBSTONE, gamesrc["Tombstone"]);

		nl::node itemsrc = nl::nx::Sound["Item.img"];

		for (auto node : itemsrc)
			add_sound(node.name(), node["Use"]);

		uint8_t volume = Setting<SFXVolume>::get().load();

		if (!set_sfxvolume(volume))
			return Error::Code::AUDIO;

		return Error::Code::NONE;
	}

	void Sound::close()
	{
		BASS_Free();
	}

	bool Sound::set_sfxvolume(uint8_t vol)
	{
		return BASS_SetConfig(BASS_CONFIG_GVOL_SAMPLE, vol * 100) == TRUE;
	}

	void Sound::play(size_t id)
	{
		if (!samples.count(id))
			return;

		HCHANNEL channel = BASS_SampleGetChannel((HSAMPLE)samples.at(id), false);
		BASS_ChannelPlay(channel, true);
	}

	size_t Sound::add_sound(nl::node src)
	{
		nl::audio ad = src;

		auto data = reinterpret_cast<const void*>(ad.data());

		if (data)
		{
			size_t id = ad.id();

			if (samples.find(id) != samples.end())
				return 0;

			samples[id] = BASS_SampleLoad(true, data, 82, (DWORD)ad.length(), 4, BASS_SAMPLE_OVER_POS);

			return id;
		}
		else
		{
			return 0;
		}
	}

	void Sound::add_sound(Name name, nl::node src)
	{
		size_t id = add_sound(src);

		if (id)
			soundids[name] = id;
	}

	void Sound::add_sound(std::string itemid, nl::node src)
	{
		size_t id = add_sound(src);

		if (id)
			itemids[itemid] = id;
	}

	std::string Sound::format_id(int32_t itemid)
	{
		std::string strid = std::to_string(itemid);
		strid.insert(0, 8 - strid.size(), '0');

		return strid;
	}

	std::unordered_map<size_t, uint64_t> Sound::samples;
	EnumMap<Sound::Name, size_t> Sound::soundids;
	std::unordered_map<std::string, size_t> Sound::itemids;

	Music::Music(std::string p)
	{
		path = p;
	}

	void Music::play() const
	{
		static HSTREAM stream = 0;
		static std::string bgmpath = "";

		if (path == bgmpath)
			return;

		// Try Sound002 fallback, then Sound directly (v83 single file)
		nl::audio ad = nl::nx::Sound002.resolve(path);
		if (!ad.data()) {
			ad = nl::nx::Sound.resolve(path);
		}
		auto data = reinterpret_cast<const void*>(ad.data());

		if (data)
		{
			if (stream)
			{
				BASS_ChannelStop(stream);
				BASS_StreamFree(stream);
			}

			stream = BASS_StreamCreateFile(true, data, 82, ad.length(), BASS_SAMPLE_FLOAT | BASS_SAMPLE_LOOP);
			BASS_ChannelPlay(stream, true);

			bgmpath = path;
		}
	}

	void Music::play_once() const
	{
		static HSTREAM stream = 0;
		static std::string bgmpath = "";

		if (path == bgmpath)
			return;

		// Try Sound002 fallback, then Sound directly (v83 single file)
		nl::audio ad = nl::nx::Sound002.resolve(path);
		if (!ad.data()) {
			ad = nl::nx::Sound.resolve(path);
		}
		auto data = reinterpret_cast<const void*>(ad.data());

		if (data)
		{
			if (stream)
			{
				BASS_ChannelStop(stream);
				BASS_StreamFree(stream);
			}

			stream = BASS_StreamCreateFile(true, data, 82, ad.length(), BASS_SAMPLE_FLOAT);
			BASS_ChannelPlay(stream, true);

			bgmpath = path;
		}
	}

	Error Music::init()
	{
		uint8_t volume = Setting<BGMVolume>::get().load();

		if (!set_bgmvolume(volume))
		{
			std::cout << "[DEBUG] Music volume setting failed, continuing without audio..." << std::endl;
			return Error::Code::NONE;  // Continue without audio
		}

		std::cout << "[DEBUG] Music initialized successfully" << std::endl;
		return Error::Code::NONE;
	}

	bool Music::set_bgmvolume(uint8_t vol)
	{
		return BASS_SetConfig(BASS_CONFIG_GVOL_STREAM, vol * 100) == TRUE;
	}
}

================
File: Audio/Audio.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Error.h"
#include "../MapleStory.h"

#include "../Template/EnumMap.h"

#include <unordered_map>

#ifdef USE_NX
#include <nlnx/node.hpp>
#else
#include "../Util/WzFiles.h"
#endif

namespace ms
{
	class Sound
	{
	public:
		// Preloaded sounds
		enum Name
		{
			/// UI
			BUTTONCLICK,
			BUTTONOVER,
			CHARSELECT,
			DLGNOTICE,
			MENUDOWN,
			MENUUP,
			RACESELECT,
			SCROLLUP,
			SELECTMAP,
			TAB,
			WORLDSELECT,
			DRAGSTART,
			DRAGEND,
			WORLDMAPOPEN,
			WORLDMAPCLOSE,

			/// Login
			GAMESTART,

			/// Game
			JUMP,
			DROP,
			PICKUP,
			PORTAL,
			LEVELUP,
			TOMBSTONE,
			LENGTH
		};

		Sound(Name name);
		Sound(int32_t itemid);
		Sound(nl::node src);
		Sound();

		void play() const;

		static Error init();
		static void close();
		static bool set_sfxvolume(uint8_t volume);

	private:
		size_t id;

		static void play(size_t id);

		static size_t add_sound(nl::node src);
		static void add_sound(Name name, nl::node src);
		static void add_sound(std::string itemid, nl::node src);

		static std::string format_id(int32_t itemid);

		static std::unordered_map<size_t, uint64_t> samples;
		static EnumMap<Name, size_t> soundids;
		static std::unordered_map<std::string, size_t> itemids;
	};

	class Music
	{
	public:
		Music(std::string path);

		void play() const;
		void play_once() const;

		static Error init();
		static bool set_bgmvolume(uint8_t volume);

	private:
		std::string path;
	};
}

================
File: build_integrated.bat
================
@echo off
echo ========================================
echo Integrated Build Script - NoLifeNx + Client
echo ========================================

set "NOLIFENX_DIR=C:\HeavenClient\NoLifeNx"
set "CLIENT_DIR=C:\HeavenClient\MapleStory-Client"
set "MSBUILD_PATH=C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\MSBuild.exe"

echo Step 1: Copy modified NoLifeNx source files
copy /Y "%CLIENT_DIR%\includes\NoLifeNx\nlnx\node.cpp" "%NOLIFENX_DIR%\node.cpp"
if %ERRORLEVEL% NEQ 0 (
    echo ERROR: Failed to copy node.cpp
    pause
    exit /b 1
)

echo Step 2: Clean and rebuild NoLifeNx library (Debug)
cd /d "%NOLIFENX_DIR%"
if exist "x64\Debug\*.obj" del /Q "x64\Debug\*.obj" 2>nul
if exist "x64\obj-Debug\*.obj" del /Q "x64\obj-Debug\*.obj" 2>nul
"%MSBUILD_PATH%" "NoLifeNx.vcxproj" /p:Configuration=Debug /p:Platform=x64 /t:Rebuild /v:minimal
if %ERRORLEVEL% NEQ 0 (
    echo ERROR: NoLifeNx Debug build failed
    pause
    exit /b 1
)

echo Step 3: Copy NoLifeNx Debug lib to client directory
copy /Y "%NOLIFENX_DIR%\x64\Debug\NoLifeNx.lib" "%CLIENT_DIR%\includes\NoLifeNx\nlnx\x64\Debug\NoLifeNx.lib"
if %ERRORLEVEL% NEQ 0 (
    echo ERROR: Failed to copy NoLifeNx Debug lib
    pause
    exit /b 1
)

echo Step 4: Clean and rebuild NoLifeNx library (Release)
"%MSBUILD_PATH%" "NoLifeNx.vcxproj" /p:Configuration=Release /p:Platform=x64 /t:Rebuild /v:minimal
if %ERRORLEVEL% NEQ 0 (
    echo ERROR: NoLifeNx Release build failed
    pause
    exit /b 1
)

echo Step 5: Copy NoLifeNx Release lib to client directory
copy /Y "%NOLIFENX_DIR%\x64\Release\NoLifeNx.lib" "%CLIENT_DIR%\includes\NoLifeNx\nlnx\x64\Release\NoLifeNx.lib"
if %ERRORLEVEL% NEQ 0 (
    echo ERROR: Failed to copy NoLifeNx Release lib
    pause
    exit /b 1
)

echo Step 6: Verify library files exist
if not exist "%CLIENT_DIR%\includes\NoLifeNx\nlnx\x64\Debug\NoLifeNx.lib" (
    echo ERROR: Debug library not found in client directory
    pause
    exit /b 1
)
if not exist "%CLIENT_DIR%\includes\NoLifeNx\nlnx\x64\Release\NoLifeNx.lib" (
    echo ERROR: Release library not found in client directory
    pause
    exit /b 1
)

echo ========================================
echo NoLifeNx libraries updated successfully!
echo ========================================
echo Debug lib:   %CLIENT_DIR%\includes\NoLifeNx\nlnx\x64\Debug\NoLifeNx.lib
echo Release lib: %CLIENT_DIR%\includes\NoLifeNx\nlnx\x64\Release\NoLifeNx.lib
echo ========================================
echo Now rebuild the client in Visual Studio
echo ========================================
pause

================
File: build_nx_extractor.bat
================
@echo off
echo Building NX Structure Extractor...

REM Compile the nx structure extractor
"C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\x86_amd64\cl.exe" ^
    /I"includes\glew-2.1.0\include\GL" ^
    /I"includes\freetype\include" ^
    /I"includes\glfw-3.3.2.bin.WIN64\include\GLFW" ^
    /I"includes\stb" ^
    /I"includes\bass24\c" ^
    /I"includes\NoLifeNx" ^
    /D USE_NX ^
    /D _CONSOLE ^
    /EHsc ^
    extract_all_nx_structures.cpp ^
    /Fe:nx_extractor.exe ^
    /link ^
    /LIBPATH:"includes\glew-2.1.0\lib\Release\x64" ^
    /LIBPATH:"includes\freetype\win64" ^
    /LIBPATH:"includes\glfw-3.3.2.bin.WIN64\lib-vc2015" ^
    /LIBPATH:"includes\bass24\c\x64" ^
    /LIBPATH:"includes\NoLifeNx\nlnx\x64\Debug" ^
    glew32s.lib freetype.lib glfw3.lib bass.lib OpenGL32.lib kernel32.lib user32.lib

if %ERRORLEVEL% EQU 0 (
    echo Build successful! Running nx extractor...
    echo.
    nx_extractor.exe
) else (
    echo Build failed!
    pause
)

================
File: build_simple.bat
================
@echo off
setlocal enabledelayedexpansion

echo HeavenClient Simple Build Script
echo =================================
echo.

:: Find MSBuild
set "MSBUILD="
for %%i in (2022 2019 2017) do (
    for %%j in (Enterprise Professional Community) do (
        if exist "%ProgramFiles%\Microsoft Visual Studio\%%i\%%j\MSBuild\Current\Bin\MSBuild.exe" (
            set "MSBUILD=%ProgramFiles%\Microsoft Visual Studio\%%i\%%j\MSBuild\Current\Bin\MSBuild.exe"
            echo Found VS%%i %%j
            goto :found
        )
        if exist "%ProgramFiles(x86)%\Microsoft Visual Studio\%%i\%%j\MSBuild\Current\Bin\MSBuild.exe" (
            set "MSBUILD=%ProgramFiles(x86)%\Microsoft Visual Studio\%%i\%%j\MSBuild\Current\Bin\MSBuild.exe"
            echo Found VS%%i %%j
            goto :found
        )
    )
)

if exist "%ProgramFiles(x86)%\Microsoft Visual Studio\2017\Community\MSBuild\15.0\Bin\MSBuild.exe" (
    set "MSBUILD=%ProgramFiles(x86)%\Microsoft Visual Studio\2017\Community\MSBuild\15.0\Bin\MSBuild.exe"
    echo Found VS2017 Community
    goto :found
)

echo ERROR: No Visual Studio installation found!
echo Please install Visual Studio 2019 or 2022 with C++ workload
pause
exit /b 1

:found
echo Using: !MSBUILD!
echo.

:: Build
echo Building MapleStory.sln...
"!MSBUILD!" "MapleStory.sln" /p:Configuration=Release /p:Platform=x64 /m /v:minimal /nologo

if !errorlevel! neq 0 (
    echo.
    echo BUILD FAILED!
    pause
    exit /b 1
)

echo.
echo BUILD SUCCESSFUL!
echo Output: x64\Release\MapleStory.exe
pause

================
File: build.bat
================
@echo off
echo HeavenClient Build Script
echo =========================
echo.

:: —————————————————————————————————————————————
:: 1) Locate MSBuild.exe from any VS2015+ install
:: —————————————————————————————————————————————
set "MSBUILD="

:: Check for VS2022 first (most recent)
if exist "%ProgramFiles%\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\MSBuild.exe" if not defined MSBUILD (
    set "MSBUILD=%ProgramFiles%\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\MSBuild.exe"
    echo Found VS2022 Community
)
if exist "%ProgramFiles%\Microsoft Visual Studio\2022\Professional\MSBuild\Current\Bin\MSBuild.exe" if not defined MSBUILD (
    set "MSBUILD=%ProgramFiles%\Microsoft Visual Studio\2022\Professional\MSBuild\Current\Bin\MSBuild.exe"
    echo Found VS2022 Professional
)
if exist "%ProgramFiles%\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\MSBuild.exe" if not defined MSBUILD (
    set "MSBUILD=%ProgramFiles%\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\MSBuild.exe"
    echo Found VS2022 Enterprise
)

:: Check for VS2019
if exist "%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\MSBuild.exe" if not defined MSBUILD (
    set "MSBUILD=%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\MSBuild.exe"
    echo Found VS2019 Community
)
if exist "%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Professional\MSBuild\Current\Bin\MSBuild.exe" if not defined MSBUILD (
    set "MSBUILD=%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Professional\MSBuild\Current\Bin\MSBuild.exe"
    echo Found VS2019 Professional
)
if exist "%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Enterprise\MSBuild\Current\Bin\MSBuild.exe" if not defined MSBUILD (
    set "MSBUILD=%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Enterprise\MSBuild\Current\Bin\MSBuild.exe"
    echo Found VS2019 Enterprise
)

:: Check for VS2017
if exist "%ProgramFiles(x86)%\Microsoft Visual Studio\2017\Community\MSBuild\15.0\Bin\MSBuild.exe" if not defined MSBUILD (
    set "MSBUILD=%ProgramFiles(x86)%\Microsoft Visual Studio\2017\Community\MSBuild\15.0\Bin\MSBuild.exe"
    echo Found VS2017 Community
)

:: Check for standalone MSBuild (VS2015)
if exist "%ProgramFiles(x86)%\MSBuild\14.0\Bin\MSBuild.exe" if not defined MSBUILD (
    set "MSBUILD=%ProgramFiles(x86)%\MSBuild\14.0\Bin\MSBuild.exe"
    echo Found MSBuild 14.0 (VS2015)
)

if not defined MSBUILD (
    echo ERROR: MSBuild not found!
    echo Please install Visual Studio 2019/2022 Community Edition or newer:
    echo   https://visualstudio.microsoft.com/downloads/
    echo.
    echo Also ensure you have the "MSVC v143 - VS 2022 C++ x64/x86 build tools" workload
    echo and "Windows 10/11 SDK" installed.
    pause
    exit /b 1
)

echo Using MSBuild at: %MSBUILD%
echo.

:: ————————————————————————
:: 2) Default build configuration
:: ————————————————————————
set "CONFIG=Release"
set "PLATFORM=x64"

:: override by command-line:  build.bat debug x86
if /i "%~1"=="debug"  set "CONFIG=Debug"
if /i "%~1"=="release" set "CONFIG=Release"
if /i "%~2"=="x86"    set "PLATFORM=x86"
if /i "%~2"=="x64"    set "PLATFORM=x64"

echo Configuration: %CONFIG%
echo Platform:      %PLATFORM%
echo.

:: ————————————————————————
:: 3) Clean previous build artefacts
:: ————————————————————————
echo Cleaning previous build...
if exist "x64"    rmdir /s /q "x64" 2>nul
if exist "x86"    rmdir /s /q "x86" 2>nul
if exist ".vs"    rmdir /s /q ".vs" 2>nul
if exist "debug.log"     del /q "debug.log" 2>nul
if exist "MapleStory.aps" del /q "MapleStory.aps" 2>nul
if exist "Settings"      del /q "Settings" 2>nul
echo.

:: ————————————————————————
:: 4) Build the solution
:: ————————————————————————
echo Building MapleStory.sln...
"%MSBUILD%" "MapleStory.sln" /p:Configuration=%CONFIG% /p:Platform=%PLATFORM% /m /v:minimal
if errorlevel 1 (
    echo.
    echo ********** BUILD FAILED! **********
    echo Common issues:
    echo  1) Missing Windows SDK (e.g. 8.1 or 10)
    echo  2) Missing Platform Toolset v140 (install VS2015 build tools)
    echo  3) Missing include/dependencies folder
    echo.
    pause
    exit /b 1
)

echo.
echo BUILD SUCCEEDED!
echo Output: %PLATFORM%\%CONFIG%\MapleStory.exe
echo.

:: ——————————————————————————
:: 5) Check for required NX data
:: ——————————————————————————
set "MISSING_NX=0"
for %%F in ^
  (Base Character Effect Etc Item Map Mob Morph Npc Quest Reactor Skill Sound String TamingMob UI) do (
    if not exist "%%F.nx" set "MISSING_NX=1"
)

if "%MISSING_NX%"=="1" (
    echo WARNING: Some .nx files are missing!
    set /p "R=Convert WZ→NX from C:\Users\me\Downloads\PERISH\MapleStory? (y/n) " 
    if /i "%R%"=="y" (
        echo Running NX conversion...
        call setup_nx_conversion.bat
    ) else (
        echo You can convert later with setup_nx_conversion.bat
    )
) else (
    echo All .nx files present.
)

echo.
echo === Build complete! You can now run the client. ===
pause

================
File: Character/ActiveBuffs.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "ActiveBuffs.h"

namespace ms
{
	template <EquipStat::Id STAT>
	void SimpleStatBuff<STAT>::apply_to(CharStats& stats, int16_t value) const
	{
		stats.add_buff(STAT, value);
	}

	template <EquipStat::Id STAT>
	void PercentageStatBuff<STAT>::apply_to(CharStats& stats, int16_t value) const
	{
		stats.add_percent(STAT, static_cast<float>(value) / 100);
	}

	void MapleWarriorBuff::apply_to(CharStats& stats, int16_t value) const
	{
		stats.add_percent(EquipStat::Id::STR, static_cast<float>(value) / 100);
		stats.add_percent(EquipStat::Id::DEX, static_cast<float>(value) / 100);
		stats.add_percent(EquipStat::Id::INT, static_cast<float>(value) / 100);
		stats.add_percent(EquipStat::Id::LUK, static_cast<float>(value) / 100);
	}

	void StanceBuff::apply_to(CharStats& stats, int16_t value) const
	{
		stats.set_stance(static_cast<float>(value) / 100);
	}

	void BoosterBuff::apply_to(CharStats& stats, int16_t value) const
	{
		stats.set_attackspeed(static_cast<int8_t>(value));
	}

	ActiveBuffs::ActiveBuffs()
	{
		buffs[Buffstat::Id::MAPLE_WARRIOR] = std::make_unique<MapleWarriorBuff>();
		buffs[Buffstat::Id::STANCE] = std::make_unique<StanceBuff>();
		buffs[Buffstat::Id::BOOSTER] = std::make_unique<BoosterBuff>();
		buffs[Buffstat::Id::WATK] = std::make_unique<SimpleStatBuff<EquipStat::Id::WATK>>();
		buffs[Buffstat::Id::WDEF] = std::make_unique<SimpleStatBuff<EquipStat::Id::WDEF>>();
		buffs[Buffstat::Id::MATK] = std::make_unique<SimpleStatBuff<EquipStat::Id::MAGIC>>();
		buffs[Buffstat::Id::MDEF] = std::make_unique<SimpleStatBuff<EquipStat::Id::MDEF>>();
		buffs[Buffstat::Id::SPEED] = std::make_unique<SimpleStatBuff<EquipStat::Id::SPEED>>();
		buffs[Buffstat::Id::JUMP] = std::make_unique<SimpleStatBuff<EquipStat::Id::JUMP>>();
		buffs[Buffstat::Id::HYPERBODYHP] = std::make_unique<PercentageStatBuff<EquipStat::Id::HP>>();
		buffs[Buffstat::Id::HYPERBODYMP] = std::make_unique<PercentageStatBuff<EquipStat::Id::MP>>();
	}

	void ActiveBuffs::apply_buff(CharStats& stats, Buffstat::Id stat, int16_t value) const
	{
		if (auto& buff = buffs[stat])
			buff->apply_to(stats, value);
	}
}

================
File: Character/ActiveBuffs.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Buff.h"
#include "CharStats.h"

#include <memory>

namespace ms
{
	// Interface for active buffs which are applied to character stats
	class ActiveBuff
	{
	public:
		virtual ~ActiveBuff() {}

		virtual void apply_to(CharStats& stats, int16_t value) const = 0;
	};

	template<EquipStat::Id STAT>
	// Template for buffs which just add their value to a stat
	class SimpleStatBuff : public ActiveBuff
	{
		void apply_to(CharStats& stats, int16_t value) const override;
	};

	template<EquipStat::Id STAT>
	// Template for buffs which apply an increase by percentage
	class PercentageStatBuff : public ActiveBuff
	{
		void apply_to(CharStats& stats, int16_t value) const override;
	};

	// Buff for MAPLEWARRIOR
	class MapleWarriorBuff : public ActiveBuff
	{
		void apply_to(CharStats& stats, int16_t value) const override;
	};

	// Buff for STANCE
	class StanceBuff : public ActiveBuff
	{
		void apply_to(CharStats& stats, int16_t value) const override;
	};

	// Buff for BOOSTER
	class BoosterBuff : public ActiveBuff
	{
		void apply_to(CharStats& stats, int16_t value) const override;
	};

	class ActiveBuffs
	{
	public:
		// Register all buffs effects
		ActiveBuffs();

		// Return the buff effect associated with the buff stat
		void apply_buff(CharStats& stats, Buffstat::Id stat, int16_t value) const;

	private:
		EnumMap<Buffstat::Id, std::unique_ptr<ActiveBuff>> buffs;
	};
}

================
File: Character/Buff.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Buff.h"

namespace ms
{
	namespace Buffstat
	{
		const std::unordered_map<Id, uint64_t> first_codes =
		{
			{ Id::DASH2, 0x8000000000000L },
			{ Id::DASH, 0x10000000000000L },
			{ Id::ELEMENTAL_RESET, 0x200000000L },
			{ Id::ARAN_COMBO, 0x1000000000L },
			{ Id::COMBO_DRAIN, 0x2000000000L },
			{ Id::COMBO_BARRIER, 0x4000000000L },
			{ Id::BODY_PRESSURE, 0x8000000000L },
			{ Id::SMART_KNOCKBACK, 0x10000000000L },
			{ Id::PYRAMID_PQ, 0x20000000000L },
			{ Id::ENERGY_CHARGE, 0x4000000000000L },
			{ Id::MONSTER_RIDING, 0x20000000000000L },
			{ Id::HOMING_BEACON, 0x80000000000000L },
			{ Id::SPEED_INFUSION, 0x100000000000000L }
		};

		const std::unordered_map<Id, uint64_t> second_codes =
		{
			{ Id::NONE, 0x0 },
			{ Id::MORPH, 0x2 },
			{ Id::RECOVERY, 0x4 },
			{ Id::MAPLE_WARRIOR, 0x8 },
			{ Id::STANCE, 0x10 },
			{ Id::SHARP_EYES, 0x20 },
			{ Id::MANA_REFLECTION, 0x40 },
			{ Id::SHADOW_CLAW, 0x100 },
			{ Id::INFINITY_, 0x200 },
			{ Id::HOLY_SHIELD, 0x400 },
			{ Id::HAMSTRING, 0x800 },
			{ Id::BLIND, 0x1000 },
			{ Id::CONCENTRATE, 0x2000 },
			{ Id::ECHO_OF_HERO, 0x8000 },
			{ Id::GHOST_MORPH, 0x20000 },
			{ Id::AURA, 0x40000 },
			{ Id::CONFUSE, 0x80000 },
			{ Id::BERSERK_FURY, 0x8000000 },
			{ Id::DIVINE_BODY, 0x10000000 },
			{ Id::SPARK, 0x20000000L },
			{ Id::FINALATTACK, 0x80000000L },
			{ Id::BATTLESHIP, 0xA00000040L },
			{ Id::WATK, 0x100000000L },
			{ Id::WDEF, 0x200000000L },
			{ Id::MATK, 0x400000000L },
			{ Id::MDEF, 0x800000000L },
			{ Id::ACC, 0x1000000000L },
			{ Id::AVOID, 0x2000000000L },
			{ Id::HANDS, 0x4000000000L },
			{ Id::SHOWDASH, 0x4000000000L },
			{ Id::SPEED, 0x8000000000L },
			{ Id::JUMP, 0x10000000000L },
			{ Id::MAGIC_GUARD, 0x20000000000L },
			{ Id::DARKSIGHT, 0x40000000000L },
			{ Id::BOOSTER, 0x80000000000L },
			{ Id::POWERGUARD, 0x100000000000L },
			{ Id::HYPERBODYHP, 0x200000000000L },
			{ Id::HYPERBODYMP, 0x400000000000L },
			{ Id::INVINCIBLE, 0x800000000000L },
			{ Id::SOULARROW, 0x1000000000000L },
			{ Id::STUN, 0x2000000000000L },
			{ Id::POISON, 0x4000000000000L },
			{ Id::SEAL, 0x8000000000000L },
			{ Id::DARKNESS, 0x10000000000000L },
			{ Id::COMBO, 0x20000000000000L },
			{ Id::SUMMON, 0x20000000000000L },
			{ Id::WK_CHARGE, 0x40000000000000L },
			{ Id::DRAGONBLOOD, 0x80000000000000L },
			{ Id::HOLY_SYMBOL, 0x100000000000000L },
			{ Id::MESOUP, 0x200000000000000L },
			{ Id::SHADOWPARTNER, 0x400000000000000L },
			{ Id::PICKPOCKET, 0x800000000000000L },
			{ Id::PUPPET, 0x800000000000000L },
			{ Id::MESOGUARD, 0x1000000000000000L },
			{ Id::WEAKEN, 0x4000000000000000L }
		};
	}
}

================
File: Character/Buff.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cstdint>
#include <unordered_map>

namespace ms
{
	namespace Buffstat
	{
		enum Id
		{
			NONE,
			MORPH,
			RECOVERY,
			MAPLE_WARRIOR,
			STANCE,
			SHARP_EYES,
			MANA_REFLECTION,
			SHADOW_CLAW,
			INFINITY_,
			HOLY_SHIELD,
			HAMSTRING,
			BLIND,
			CONCENTRATE,
			ECHO_OF_HERO,
			GHOST_MORPH,
			AURA,
			CONFUSE,
			BERSERK_FURY,
			DIVINE_BODY,
			SPARK,
			FINALATTACK,
			BATTLESHIP,
			WATK,
			WDEF,
			MATK,
			MDEF,
			ACC,
			AVOID,
			HANDS,
			SHOWDASH,
			SPEED,
			JUMP,
			MAGIC_GUARD,
			DARKSIGHT,
			BOOSTER,
			POWERGUARD,
			HYPERBODYHP,
			HYPERBODYMP,
			INVINCIBLE,
			SOULARROW,
			STUN,
			POISON,
			SEAL,
			DARKNESS,
			COMBO,
			SUMMON,
			WK_CHARGE,
			DRAGONBLOOD,
			HOLY_SYMBOL,
			MESOUP,
			SHADOWPARTNER,
			PICKPOCKET,
			PUPPET,
			MESOGUARD,
			WEAKEN,
			DASH,
			DASH2,
			ELEMENTAL_RESET,
			ARAN_COMBO,
			COMBO_DRAIN,
			COMBO_BARRIER,
			BODY_PRESSURE,
			SMART_KNOCKBACK,
			PYRAMID_PQ,
			ENERGY_CHARGE,
			MONSTER_RIDING,
			HOMING_BEACON,
			SPEED_INFUSION,
			LENGTH
		};

		extern const std::unordered_map<Id, uint64_t> first_codes;
		extern const std::unordered_map<Id, uint64_t> second_codes;
	}

	struct Buff
	{
		Buffstat::Id stat;
		int16_t value;
		int32_t skillid;
		int32_t duration;

		constexpr Buff(Buffstat::Id stat, int16_t value, int32_t skillid, int32_t duration) : stat(stat), value(value), skillid(skillid), duration(duration) {}
		constexpr Buff() : Buff(Buffstat::Id::NONE, 0, 0, 0) {}
	};
}

================
File: Character/Char.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Char.h"

#include "../Data/WeaponData.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Char::Char(int32_t o, const CharLook& lk, const std::string& name) : MapObject(o), look(lk), look_preview(lk), namelabel(Text(Text::Font::A13M, Text::Alignment::CENTER, Color::Name::WHITE, Text::Background::NAMETAG, name)) {}

	void Char::draw(double viewx, double viewy, float alpha) const
	{
		Point<int16_t> absp = phobj.get_absolute(viewx, viewy, alpha);

		effects.drawbelow(absp, alpha);

		Color color;

		if (invincible)
		{
			float phi = invincible.alpha() * 30;
			float rgb = 0.9f - 0.5f * std::abs(std::sinf(phi));

			color = Color(rgb, rgb, rgb, 1.0f);
		}
		else
		{
			color = Color::Code::CWHITE;
		}

		look.draw(DrawArgument(absp, color), alpha);

		afterimage.draw(look.get_frame(), DrawArgument(absp, facing_right), alpha);

		if (ironbody)
		{
			float ibalpha = ironbody.alpha();
			float scale = 1.0f + ibalpha;
			float opacity = 1.0f - ibalpha;

			look.draw(DrawArgument(absp, scale, scale, opacity), alpha);
		}

		for (auto& pet : pets)
			if (pet.get_itemid())
				pet.draw(viewx, viewy, alpha);

		// If ever changing code for namelabel confirm placements with map 10000
		namelabel.draw(absp + Point<int16_t>(0, -4));
		chatballoon.draw(absp - Point<int16_t>(0, 85));

		effects.drawabove(absp, alpha);

		for (auto& number : damagenumbers)
			number.draw(viewx, viewy, alpha);
	}

	void Char::draw_preview(Point<int16_t> position, float alpha) const
	{
		look_preview.draw(position, false, Stance::Id::STAND1, Expression::Id::DEFAULT);
	}

	bool Char::update(const Physics& physics, float speed)
	{
		damagenumbers.remove_if(
			[](DamageNumber& number)
			{
				return number.update();
			}
		);

		effects.update();
		chatballoon.update();
		invincible.update();
		ironbody.update();

		for (auto& pet : pets)
		{
			if (pet.get_itemid())
			{
				switch (state)
				{
				case State::LADDER:
				case State::ROPE:
					pet.set_stance(PetLook::Stance::HANG);
					break;
				case State::SWIM:
					pet.set_stance(PetLook::Stance::FLY);
					break;
				default:
					if (pet.get_stance() == PetLook::Stance::HANG || pet.get_stance() == PetLook::Stance::FLY)
						pet.set_stance(PetLook::Stance::STAND);

					break;
				}

				pet.update(physics, get_position());
			}
		}

		uint16_t stancespeed = 0;

		if (speed >= 1.0f / Constants::TIMESTEP)
			stancespeed = static_cast<uint16_t>(Constants::TIMESTEP * speed);

		afterimage.update(look.get_frame(), stancespeed);

		return look.update(stancespeed);
	}

	float Char::get_stancespeed() const
	{
		if (attacking)
			return get_real_attackspeed();

		switch (state)
		{
		case State::WALK:
			return static_cast<float>(std::abs(phobj.hspeed));
		case State::LADDER:
		case State::ROPE:
			return static_cast<float>(std::abs(phobj.vspeed));
		default:
			return 1.0f;
		}
	}

	float Char::get_real_attackspeed() const
	{
		int8_t speed = get_integer_attackspeed();

		return 1.7f - static_cast<float>(speed) / 10;
	}

	uint16_t Char::get_attackdelay(size_t no) const
	{
		uint8_t first_frame = afterimage.get_first_frame();
		uint16_t delay = look.get_attackdelay(no, first_frame);
		float fspeed = get_real_attackspeed();

		return static_cast<uint16_t>(delay / fspeed);
	}

	int8_t Char::update(const Physics& physics)
	{
		update(physics, 1.0f);

		return get_layer();
	}

	int8_t Char::get_layer() const
	{
		return is_climbing() ? 7 : phobj.fhlayer;
	}

	void Char::show_attack_effect(Animation toshow, int8_t z)
	{
		float attackspeed = get_real_attackspeed();

		effects.add(toshow, DrawArgument(facing_right), z, attackspeed);
	}

	void Char::show_effect_id(CharEffect::Id toshow)
	{
		effects.add(chareffects[toshow]);
	}

	void Char::show_iron_body()
	{
		ironbody.set_for(500);
	}

	void Char::show_damage(int32_t damage)
	{
		int16_t start_y = phobj.get_y() - 60;
		int16_t x = phobj.get_x() - 10;

		damagenumbers.emplace_back(DamageNumber::Type::TOPLAYER, damage, start_y, x);

		look.set_alerted(5000);
		invincible.set_for(2000);
	}

	void Char::speak(const std::string& line)
	{
		chatballoon.change_text(line);
	}

	void Char::change_look(MapleStat::Id stat, int32_t id)
	{
		switch (stat)
		{
		case MapleStat::Id::SKIN:
			look.set_body(id);
			break;
		case MapleStat::Id::FACE:
			look.set_face(id);
			break;
		case MapleStat::Id::HAIR:
			look.set_hair(id);
			break;
		}
	}

	void Char::set_state(uint8_t statebyte)
	{
		if (statebyte % 2 == 1)
		{
			set_direction(false);

			statebyte -= 1;
		}
		else
		{
			set_direction(true);
		}

		Char::State newstate = by_value(statebyte);
		set_state(newstate);
	}

	void Char::set_expression(int32_t expid)
	{
		Expression::Id expression = Expression::byaction(expid);
		look.set_expression(expression);
	}

	void Char::attack(const std::string& action)
	{
		look.set_action(action);

		attacking = true;
		look.set_alerted(5000);
	}

	void Char::attack(Stance::Id stance)
	{
		look.attack(stance);

		attacking = true;
		look.set_alerted(5000);
	}

	void Char::attack(bool degenerate)
	{
		look.attack(degenerate);

		attacking = true;
		look.set_alerted(5000);
	}

	void Char::set_afterimage(int32_t skill_id)
	{
		int32_t weapon_id = look.get_equips().get_weapon();

		if (weapon_id <= 0)
			return;

		const WeaponData& weapon = WeaponData::get(weapon_id);

		std::string stance_name = Stance::names[look.get_stance()];
		int16_t weapon_level = weapon.get_equipdata().get_reqstat(MapleStat::Id::LEVEL);
		const std::string& ai_name = weapon.get_afterimage();

		afterimage = Afterimage(skill_id, ai_name, stance_name, weapon_level);
	}

	const Afterimage& Char::get_afterimage() const
	{
		return afterimage;
	}

	void Char::set_direction(bool f)
	{
		facing_right = f;
		look.set_direction(f);
	}

	void Char::set_state(State st)
	{
		state = st;

		Stance::Id stance = Stance::by_state(state);
		look.set_stance(stance);
	}

	void Char::add_pet(uint8_t index, int32_t iid, const std::string& name, int32_t uniqueid, Point<int16_t> pos, uint8_t stance, int32_t fhid)
	{
		if (index > 2)
			return;

		pets[index] = PetLook(iid, name, uniqueid, pos, stance, fhid);
	}

	void Char::remove_pet(uint8_t index, bool hunger)
	{
		if (index > 2)
			return;

		pets[index] = PetLook();

		if (hunger)
		{
			// TODO: Empty
		}
	}

	bool Char::is_invincible() const
	{
		return invincible == true;
	}

	bool Char::is_sitting() const
	{
		return state == State::SIT;
	}

	bool Char::is_climbing() const
	{
		return state == State::LADDER || state == State::ROPE;
	}

	bool Char::is_twohanded() const
	{
		return look.get_equips().is_twohanded();
	}

	Weapon::Type Char::get_weapontype() const
	{
		int32_t weapon_id = look.get_equips().get_weapon();

		if (weapon_id <= 0)
			return Weapon::Type::NONE;

		return WeaponData::get(weapon_id).get_type();
	}

	bool Char::getflip() const
	{
		return facing_right;
	}

	std::string Char::get_name() const
	{
		return namelabel.get_text();
	}

	CharLook& Char::get_look()
	{
		return look;
	}

	const CharLook& Char::get_look() const
	{
		return look;
	}

	PhysicsObject& Char::get_phobj()
	{
		return phobj;
	}

	void Char::init()
	{
		CharLook::init();

		nl::node src = nl::nx::Effect["BasicEff.img"];

		for (auto iter : CharEffect::PATHS)
			chareffects.emplace(iter.first, src.resolve(iter.second));
	}

	EnumMap<CharEffect::Id, Animation> Char::chareffects;
}

================
File: Character/Char.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "CharEffect.h"

#include "Inventory/Weapon.h"
#include "Look/Afterimage.h"
#include "Look/CharLook.h"
#include "Look/PetLook.h"

#include "../Graphics/EffectLayer.h"

#include "../Gameplay/Combat/DamageNumber.h"
#include "../Gameplay/MapleMap/MapObject.h"
#include "../IO/Components/ChatBalloon.h"

namespace ms
{
	// Base for characters, e.g. the player and other clients on the same map.
	class Char : public MapObject
	{
	public:
		// Player states which determine animation and state 
		// Values are used in movement packets (Add one if facing left)
		enum State : int8_t
		{
			WALK = 2,
			STAND = 4,
			FALL = 6,
			ALERT = 8,
			PRONE = 10,
			SWIM = 12,
			LADDER = 14,
			ROPE = 16,
			DIED = 18,
			SIT = 20
		};

		static State by_value(int8_t value)
		{
			return static_cast<State>(value);
		}

		// Draw look, NameTag, effects and chat bubble.
		void draw(double viewx, double viewy, float alpha) const override;
		// Draw look
		void draw_preview(Point<int16_t> position, float alpha) const;
		// Update look and movements
		int8_t update(const Physics& physics) override;
		// Return the current map layer, or seven if on a ladder or rope.
		int8_t get_layer() const override;

		// Check whether the character is invincible
		virtual bool is_invincible() const;
		// Return the character's level
		virtual uint16_t get_level() const = 0;
		// Return the a skill's level from the character
		virtual int32_t get_skilllevel(int32_t skillid) const = 0;
		// Return the character's base attacking speed
		virtual int8_t get_integer_attackspeed() const = 0;

		// Return the attack speed as a multiplier
		float get_real_attackspeed() const;
		// Return the delay until applying an attack
		uint16_t get_attackdelay(size_t no) const;

		// Set if the character sprite is mirrored (true = facing right)
		virtual void set_direction(bool flipped);
		// Change the character's state
		virtual void set_state(State newstate);
		// Change the character's stance to an attack action
		void attack(const std::string& action);
		// Change the character's stance to an attack stance
		void attack(Stance::Id stance);
		// Change the character's stance to it's regular attack
		void attack(bool degenerate);
		// Set the afterimage for an attack
		void set_afterimage(int32_t skill_id);
		// Return the current afterimage
		const Afterimage& get_afterimage() const;

		// Display an animation as an effect with the character
		void show_attack_effect(Animation animation, int8_t z);
		// Display an animation as an effect on top of the character
		void show_effect_id(CharEffect::Id toshow);
		// Display the iron body skill animation
		void show_iron_body();
		// Display damage over the characters head
		void show_damage(int32_t damage);
		// Display a chat bubble with the specified line in it
		void speak(const std::string& line);
		// Change a part of the character's look
		void change_look(MapleStat::Id stat, int32_t id);
		// Change the character's state by id
		void set_state(uint8_t statebyte);
		// Change the character's face expression by id
		void set_expression(int32_t expression);

		// Add a pet with the specified stats
		void add_pet(uint8_t index, int32_t iid, const std::string& name, int32_t uniqueid, Point<int16_t> pos, uint8_t stance, int32_t fhid);
		// Remove a pet with the specified index and reason
		void remove_pet(uint8_t index, bool hunger);

		// Return if the character is facing left
		bool getflip() const;
		// Return the name of this character
		std::string get_name() const;

		// Return if the char is in the Char::State::SIT state
		bool is_sitting() const;
		// Return if the char is in the Char::State::LADDER or Char::State::ROPE state
		bool is_climbing() const;
		// Return whether the character sprite uses stances for two-handed weapons
		bool is_twohanded() const;
		// Return the type of the currently equipped weapon
		Weapon::Type get_weapontype() const;

		// Obtain a reference to this character's look
		CharLook& get_look();
		// Obtain a constant reference to this character's look
		const CharLook& get_look() const;
		// Return a reference to this characters's physics
		PhysicsObject& get_phobj();

		// Initialize character effects
		static void init();

	protected:
		Char(int32_t oid, const CharLook& look, const std::string& name);

		// Update the character's animation with the given speed
		bool update(const Physics& physics, float speed);
		// Get a speed modifier for the current stance
		float get_stancespeed() const;

		CharLook look;
		CharLook look_preview;
		PetLook pets[3];

		State state;
		bool attacking;
		bool facing_right;

	private:
		Text namelabel;
		ChatBalloon chatballoon;
		EffectLayer effects;
		Afterimage afterimage;
		TimedBool invincible;
		TimedBool ironbody;
		std::list<DamageNumber> damagenumbers;

		static EnumMap<CharEffect::Id, Animation> chareffects;
	};
}

================
File: Character/CharEffect.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "CharEffect.h"

namespace ms
{
	const EnumMap<CharEffect::Id, const char*> CharEffect::PATHS =
	{
		"LevelUp",
		"JobChanged",
		"Enchant/Success",
		"Enchant/Failure",
		"MonsterBook/cardGet"
	};
}

================
File: Character/CharEffect.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Template/EnumMap.h"

namespace ms
{
	namespace CharEffect
	{
		// Character effects from Effect.wz
		enum Id
		{
			LEVELUP,
			JOBCHANGE,
			SCROLL_SUCCESS,
			SCROLL_FAILURE,
			MONSTER_CARD,
			LENGTH
		};

		extern const EnumMap<Id, const char*> PATHS;
	}
}

================
File: Character/CharStats.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "CharStats.h"

#include "StatCaps.h"

namespace ms
{
	CharStats::CharStats(const StatsEntry& s) : name(s.name), petids(s.petids), exp(s.exp), mapid(s.mapid), portal(s.portal), rank(s.rank), jobrank(s.jobrank), basestats(s.stats), female(s.female)
	{
		job = basestats[MapleStat::Id::JOB];

		init_totalstats();
	}

	CharStats::CharStats() {}

	void CharStats::init_totalstats()
	{
		totalstats.clear();
		buffdeltas.clear();
		percentages.clear();

		totalstats[EquipStat::Id::HP] = get_stat(MapleStat::Id::MAXHP);
		totalstats[EquipStat::Id::MP] = get_stat(MapleStat::Id::MAXMP);
		totalstats[EquipStat::Id::STR] = get_stat(MapleStat::Id::STR);
		totalstats[EquipStat::Id::DEX] = get_stat(MapleStat::Id::DEX);
		totalstats[EquipStat::Id::INT] = get_stat(MapleStat::Id::INT);
		totalstats[EquipStat::Id::LUK] = get_stat(MapleStat::Id::LUK);
		totalstats[EquipStat::Id::SPEED] = 100;
		totalstats[EquipStat::Id::JUMP] = 100;

		maxdamage = 0;
		mindamage = 0;
		honor = 0;
		attackspeed = 0;
		projectilerange = 400;
		mastery = 0.0f;
		critical = 0.05f;
		mincrit = 0.5f;
		maxcrit = 0.75f;
		damagepercent = 0.0f;
		bossdmg = 0.0f;
		ignoredef = 0.0f;
		stance = 0.0f;
		resiststatus = 0.0f;
		reducedamage = 0.0f;
	}

	void CharStats::close_totalstats()
	{
		totalstats[EquipStat::Id::ACC] += calculateaccuracy();

		for (auto iter : percentages)
		{
			EquipStat::Id stat = iter.first;
			int32_t total = totalstats[stat];
			total += static_cast<int32_t>(total * iter.second);
			set_total(stat, total);
		}

		int32_t primary = get_primary_stat();
		int32_t secondary = get_secondary_stat();
		int32_t attack = get_total(EquipStat::Id::WATK);
		float multiplier = damagepercent + static_cast<float>(attack) / 100;
		maxdamage = static_cast<int32_t>((primary + secondary) * multiplier);
		mindamage = static_cast<int32_t>(((primary * 0.9f * mastery) + secondary) * multiplier);
	}

	int32_t CharStats::calculateaccuracy() const
	{
		int32_t totaldex = get_total(EquipStat::Id::DEX);
		int32_t totalluk = get_total(EquipStat::Id::LUK);

		return static_cast<int32_t>(totaldex * 0.8f + totalluk * 0.5f);
	}

	int32_t CharStats::get_primary_stat() const
	{
		EquipStat::Id primary = job.get_primary(weapontype);

		return static_cast<int32_t>(get_multiplier() * get_total(primary));
	}

	int32_t CharStats::get_secondary_stat() const
	{
		EquipStat::Id secondary = job.get_secondary(weapontype);

		return get_total(secondary);
	}

	float CharStats::get_multiplier() const
	{
		switch (weapontype)
		{
		case Weapon::Type::SWORD_1H:
			return 4.0f;
		case Weapon::Type::AXE_1H:
		case Weapon::Type::MACE_1H:
		case Weapon::Type::WAND:
		case Weapon::Type::STAFF:
			return 4.4f;
		case Weapon::Type::DAGGER:
		case Weapon::Type::CROSSBOW:
		case Weapon::Type::CLAW:
		case Weapon::Type::GUN:
			return 3.6f;
		case Weapon::Type::SWORD_2H:
			return 4.6f;
		case Weapon::Type::AXE_2H:
		case Weapon::Type::MACE_2H:
		case Weapon::Type::KNUCKLE:
			return 4.8f;
		case Weapon::Type::SPEAR:
		case Weapon::Type::POLEARM:
			return 5.0f;
		case Weapon::Type::BOW:
			return 3.4f;
		default:
			return 0.0f;
		}
	}

	void CharStats::set_stat(MapleStat::Id stat, uint16_t value)
	{
		basestats[stat] = value;
	}

	void CharStats::set_total(EquipStat::Id stat, int32_t value)
	{
		auto iter = EQSTAT_CAPS.find(stat);

		if (iter != EQSTAT_CAPS.end())
		{
			int32_t cap_value = iter->second;

			if (value > cap_value)
				value = cap_value;
		}

		totalstats[stat] = value;
	}

	void CharStats::add_buff(EquipStat::Id stat, int32_t value)
	{
		int32_t current = get_total(stat);
		set_total(stat, current + value);
		buffdeltas[stat] += value;
	}

	void CharStats::add_value(EquipStat::Id stat, int32_t value)
	{
		int32_t current = get_total(stat);
		set_total(stat, current + value);
	}

	void CharStats::add_percent(EquipStat::Id stat, float percent)
	{
		percentages[stat] += percent;
	}

	void CharStats::set_weapontype(Weapon::Type w)
	{
		weapontype = w;
	}

	void CharStats::set_exp(int64_t e)
	{
		exp = e;
	}

	void CharStats::set_portal(uint8_t p)
	{
		portal = p;
	}

	void CharStats::set_mastery(float m)
	{
		mastery = 0.5f + m;
	}

	void CharStats::set_damagepercent(float d)
	{
		damagepercent = d;
	}

	void CharStats::set_reducedamage(float r)
	{
		reducedamage = r;
	}

	void CharStats::change_job(uint16_t id)
	{
		basestats[MapleStat::Id::JOB] = id;
		job.change_job(id);
	}

	int32_t CharStats::calculate_damage(int32_t mobatk) const
	{
		// TODO: Random stuff, need to find the actual formula somewhere.
		auto weapon_def = get_total(EquipStat::Id::WDEF);

		if (weapon_def == 0)
			return mobatk;

		int32_t reduceatk = mobatk / 2 + mobatk / weapon_def;

		return reduceatk - static_cast<int32_t>(reduceatk * reducedamage);
	}

	bool CharStats::is_damage_buffed() const
	{
		return get_buffdelta(EquipStat::Id::WATK) > 0 || get_buffdelta(EquipStat::Id::MAGIC) > 0;
	}

	uint16_t CharStats::get_stat(MapleStat::Id stat) const
	{
		return basestats[stat];
	}

	int32_t CharStats::get_total(EquipStat::Id stat) const
	{
		return totalstats[stat];
	}

	int32_t CharStats::get_buffdelta(EquipStat::Id stat) const
	{
		return buffdeltas[stat];
	}

	Rectangle<int16_t> CharStats::get_range() const
	{
		return Rectangle<int16_t>(-projectilerange, -5, -50, 50);
	}

	void CharStats::set_mapid(int32_t id)
	{
		mapid = id;
	}

	int32_t CharStats::get_mapid() const
	{
		return mapid;
	}

	uint8_t CharStats::get_portal() const
	{
		return portal;
	}

	int64_t CharStats::get_exp() const
	{
		return exp;
	}

	const std::string& CharStats::get_name() const
	{
		return name;
	}

	const std::string& CharStats::get_jobname() const
	{
		return job.get_name();
	}

	Weapon::Type CharStats::get_weapontype() const
	{
		return weapontype;
	}

	float CharStats::get_mastery() const
	{
		return mastery;
	}

	float CharStats::get_critical() const
	{
		return critical;
	}

	float CharStats::get_mincrit() const
	{
		return mincrit;
	}

	float CharStats::get_maxcrit() const
	{
		return maxcrit;
	}

	float CharStats::get_reducedamage() const
	{
		return reducedamage;
	}

	float CharStats::get_bossdmg() const
	{
		return bossdmg;
	}

	float CharStats::get_ignoredef() const
	{
		return ignoredef;
	}

	void CharStats::set_stance(float s)
	{
		stance = s;
	}

	float CharStats::get_stance() const
	{
		return stance;
	}

	float CharStats::get_resistance() const
	{
		return resiststatus;
	}

	int32_t CharStats::get_maxdamage() const
	{
		return maxdamage;
	}

	int32_t CharStats::get_mindamage() const
	{
		return mindamage;
	}

	uint16_t CharStats::get_honor() const
	{
		return honor;
	}

	void CharStats::set_attackspeed(int8_t as)
	{
		attackspeed = as;
	}

	int8_t CharStats::get_attackspeed() const
	{
		return attackspeed;
	}

	const Job& CharStats::get_job() const
	{
		return job;
	}

	bool CharStats::get_female() const
	{
		return female;
	}
}

================
File: Character/CharStats.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Job.h"

#include "../Net/Login.h"
#include "../Template/Rectangle.h"

namespace ms
{
	class CharStats
	{
	public:
		CharStats(const StatsEntry& entry);
		CharStats();

		void init_totalstats();
		void set_stat(MapleStat::Id stat, uint16_t value);
		void set_total(EquipStat::Id stat, int32_t value);
		void add_buff(EquipStat::Id stat, int32_t value);
		void add_value(EquipStat::Id stat, int32_t value);
		void add_percent(EquipStat::Id stat, float percent);
		void close_totalstats();

		void set_weapontype(Weapon::Type weapontype);
		void set_exp(int64_t exp);
		void set_portal(uint8_t portal);
		void set_mastery(float mastery);
		void set_damagepercent(float damagepercent);
		void set_reducedamage(float reducedamage);

		void change_job(uint16_t id);

		int32_t calculate_damage(int32_t mobatk) const;

		bool is_damage_buffed() const;
		uint16_t get_stat(MapleStat::Id stat) const;
		int32_t get_total(EquipStat::Id stat) const;
		int32_t get_buffdelta(EquipStat::Id stat) const;
		Rectangle<int16_t> get_range() const;

		void set_mapid(int32_t id);
		int32_t get_mapid() const;
		uint8_t get_portal() const;
		int64_t get_exp() const;
		const std::string& get_name() const;
		const std::string& get_jobname() const;
		Weapon::Type get_weapontype() const;
		float get_mastery() const;
		float get_critical() const;
		float get_mincrit() const;
		float get_maxcrit() const;
		float get_reducedamage() const;
		float get_bossdmg() const;
		float get_ignoredef() const;
		void set_stance(float stance);
		float get_stance() const;
		float get_resistance() const;
		int32_t get_maxdamage() const;
		int32_t get_mindamage() const;
		uint16_t get_honor() const;
		void set_attackspeed(int8_t speed);
		int8_t get_attackspeed() const;
		const Job& get_job() const;
		bool get_female() const;

	private:
		int32_t calculateaccuracy() const;
		int32_t get_primary_stat() const;
		int32_t get_secondary_stat() const;
		float get_multiplier() const;

		std::string name;
		std::vector<int64_t> petids;
		Job job;
		int64_t exp;
		int32_t mapid;
		uint8_t portal;
		std::pair<int32_t, int8_t> rank;
		std::pair<int32_t, int8_t> jobrank;
		EnumMap<MapleStat::Id, uint16_t> basestats;
		EnumMap<EquipStat::Id, int32_t> totalstats;
		EnumMap<EquipStat::Id, int32_t> buffdeltas;
		EnumMap<EquipStat::Id, float> percentages;
		int32_t maxdamage;
		int32_t mindamage;
		uint16_t honor;
		int8_t attackspeed;
		int16_t projectilerange;
		Weapon::Type weapontype;
		float mastery;
		float critical;
		float mincrit;
		float maxcrit;
		float damagepercent;
		float bossdmg;
		float ignoredef;
		float stance;
		float resiststatus;
		float reducedamage;
		bool female;
	};
}

================
File: Character/EquipStat.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "EquipStat.h"

namespace ms
{
	namespace EquipStat
	{
		Id by_id(size_t id)
		{
			return static_cast<Id>(id);
		}

		int32_t value_of(Id value)
		{
			return value;
		}

		const char* names[Id::LENGTH] =
		{
			"STR",
			"DEX",
			"INT",
			"LUK",
			"MaxHP",
			"MaxMP",
			"Attack Power",
			"Magic Attack",
			"Defense",

			// TODO: Does current GMS use these anymore?
			"MAGIC DEFENSE",
			"ACCURACY",
			"AVOID",
			"HANDS",

			"Speed",
			"Jump"
		};
	}
}

================
File: Character/EquipStat.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Template/Enumeration.h"

namespace ms
{
	namespace EquipStat
	{
		enum Id
		{
			STR,
			DEX,
			INT,
			LUK,
			HP,
			MP,
			WATK,
			MAGIC,
			WDEF,
			MDEF,
			ACC,
			AVOID,
			HANDS,
			SPEED,
			JUMP,
			LENGTH
		};

		Id by_id(size_t id);
		int32_t value_of(Id value);

		constexpr Enumeration<Id> values;
		extern const char* names[Id::LENGTH];
	};
}

================
File: Character/ExpTable.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "ExpTable.h"

namespace ms
{
	const std::array<int64_t, ExpTable::LEVELCAP> ExpTable::values =
	{
		1,			15,			34,			57,			92,			135,		372,		560,		840,		1242,		// Levels   1 -  10
		1144,		1573,		2144,		2800,		3640,		4700,		5893,		7360,		9144,		11120,		// Levels  11 -  20
		13477,		16268,		19320,		22880,		27008,		31477,		36600,		42444,		48720,		55813,		// Levels  21 -  30
		63800,		86784,		98208,		110932,		124432,		139372,		155865,		173280,		192400,		213345,		// Levels  31 -  40
		235372,		259392,		285532,		312928,		342624,		374760,		408336,		445544,		483532,		524160,		// Levels  41 -  50
		567772,		598886,		631704,		666321,		702836,		741351,		781976,		824828,		870028,		917625,		// Levels  51 -  60
		967995,		1021041,	1076994,	1136013,	1198266,	1263930,	1333194,	1406252,	1483314,	1564600,	// Levels  61 -  70
		1650340,	1740778,	1836173,	1936794,	2042930,	2154882,	2272970,	2397528,	2528912,	2667496,	// Levels  71 -  80
		2813674,	2967863,	3130502,	3302053,	3483005,	3673873,	3875201,	4087562,	4311559,	4547832,	// Levels  81 -  90
		4797053,	5059931,	5337215,	5629694,	5938202,	6263614,	6606860,	6968915,	7350811,	7753635,	// Levels  91 - 100
		8178534,	8626718,	9099462,	9598112,	10124088,	10678888,	11264090,	11881362,	12532461,	13219239,	// Levels 101 - 110
		13943653,	14707765,	15513750,	16363902,	17260644,	18206527,	19204245,	20256637,	21366700,	22537594,	// Levels 111 - 120
		23772654,	25075395,	26449526,	27898960,	29427822,	31040466,	32741483,	34535716,	36428273,	38424542,	// Levels 121 - 130
		40530206,	42751262,	45094030,	47565183,	50171755,	52921167,	55821246,	58880250,	62106888,	65510344,	// Levels 131 - 140
		69100311,	72887008,	76881216,	81094306,	85594273,	90225770,	95170142,	100385466,	105886589,	111689174,	// Levels 141 - 150
		117809740,	124265714,	131075474,	138258410,	145834970,	153826726,	162256430,	171148082,	180526997,	190419876,	// Levels 151 - 160
		200854885,	211861732,	223471711,	223471711,	248635353,	262260570,	276632449,	291791906,	307782102,	324648562,	// Levels 161 - 170
		342439302,	361204976,	380999008,	401877754,	423900654,	447130410,	471633156,	497478653,	524740482,	553496261,	// Levels 171 - 180
		583827855,	615821622,	649568646,	685165008,	722712050,	762316670,	804091623,	848155844,	894634784,	943660770,	// Levels 181 - 190
		995373379,	1049919840,	1107455447,	1168144006,	1232158297,	1299680571,	1370903066,	1446028554,	1525246918,	1608855764,	// Levels 191 - 200
		1697021059																												// Level  201
	};
}

================
File: Character/ExpTable.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <array>

namespace ms
{
	namespace ExpTable
	{
		constexpr size_t LEVELCAP = 201;
		extern const std::array<int64_t, LEVELCAP> values;
	}
}

================
File: Character/Inventory/Equip.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Equip.h"

namespace ms
{
	Equip::Equip(int32_t item_id, int64_t expiration, const std::string& owner, int16_t flags, uint8_t slots, uint8_t level, const EnumMap<EquipStat::Id, uint16_t>& stats, uint8_t itemlevel, int16_t itemexp, int32_t vicious) : item_id(item_id), expiration(expiration), owner(owner), flags(flags), slots(slots), level(level), stats(stats), itemlevel(itemlevel), itemexp(itemexp), vicious(vicious)
	{
		potrank = Equip::Potential::POT_NONE;
		quality = EquipQuality::check_quality(item_id, level > 0, stats);
	}

	int32_t Equip::get_item_id() const
	{
		return item_id;
	}

	int64_t Equip::get_expiration() const
	{
		return expiration;
	}

	const std::string& Equip::get_owner() const
	{
		return owner;
	}

	int16_t Equip::get_flags() const
	{
		return flags;
	}

	uint8_t Equip::get_slots() const
	{
		return slots;
	}

	uint8_t Equip::get_level() const
	{
		return level;
	}

	uint8_t Equip::get_itemlevel() const
	{
		return itemlevel;
	}

	uint16_t Equip::get_stat(EquipStat::Id type) const
	{
		return stats[type];
	}

	int32_t Equip::get_vicious() const
	{
		return vicious;
	}

	Equip::Potential Equip::get_potrank() const
	{
		return potrank;
	}

	EquipQuality::Id Equip::get_quality() const
	{
		return quality;
	}
}

================
File: Character/Inventory/Equip.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "EquipQuality.h"

namespace ms
{
	class Equip
	{
	public:
		enum Potential
		{
			POT_NONE,
			POT_HIDDEN,
			POT_RARE,
			POT_EPIC,
			POT_UNIQUE,
			POT_LEGENDARY,
			LENGTH
		};

		Equip(int32_t item_id, int64_t expiration, const std::string& owner, int16_t flags, uint8_t slots, uint8_t level, const EnumMap<EquipStat::Id, uint16_t>& stats, uint8_t itemlevel, int16_t itemexp, int32_t vicious);

		int32_t get_item_id() const;
		int64_t get_expiration() const;
		const std::string& get_owner() const;
		int16_t get_flags() const;
		uint8_t get_slots() const;
		uint8_t get_level() const;
		uint8_t get_itemlevel() const;
		uint16_t get_stat(EquipStat::Id type) const;
		int32_t get_vicious() const;
		Potential get_potrank() const;
		EquipQuality::Id get_quality() const;

	private:
		EnumMap<EquipStat::Id, uint16_t> stats;
		int32_t item_id;
		int64_t expiration;
		std::string owner;
		int16_t flags;
		uint8_t slots;
		uint8_t level;
		uint8_t itemlevel;
		int16_t itemexp;
		int32_t vicious;
		Potential potrank;
		EquipQuality::Id quality;
	};
}

================
File: Character/Inventory/EquipQuality.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "EquipQuality.h"

#include "../../Data/EquipData.h"

namespace ms
{
	EquipQuality::Id EquipQuality::check_quality(int32_t item_id, bool scrolled, const EnumMap<EquipStat::Id, uint16_t>& stats)
	{
		const EquipData& data = EquipData::get(item_id);

		int16_t delta = 0;

		for (auto iter : stats)
		{
			EquipStat::Id es = iter.first;
			uint16_t stat = iter.second;
			uint16_t defstat = data.get_defstat(es);
			delta += stat - defstat;
		}

		if (delta < -5)
			return scrolled ? EquipQuality::Id::ORANGE : EquipQuality::Id::GREY;
		else if (delta < 7)
			return scrolled ? EquipQuality::Id::ORANGE : EquipQuality::Id::WHITE;
		else if (delta < 14)
			return EquipQuality::Id::BLUE;
		else if (delta < 21)
			return EquipQuality::Id::VIOLET;
		else
			return EquipQuality::Id::GOLD;
	}
}

================
File: Character/Inventory/EquipQuality.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../EquipStat.h"

#include "../../Template/EnumMap.h"

namespace ms
{
	namespace EquipQuality
	{
		enum Id
		{
			GREY,
			WHITE,
			ORANGE,
			BLUE,
			VIOLET,
			GOLD
		};

		Id check_quality(int32_t item_id, bool scrolled, const EnumMap<EquipStat::Id, uint16_t>& stats);
	}
}

================
File: Character/Inventory/Inventory.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Inventory.h"

#include "../../Data/BulletData.h"
#include "../../Data/EquipData.h"

#include <iostream>

namespace ms
{
	Inventory::Inventory()
	{
		bulletslot = 0;
		meso = 0;
		running_uid = 0;
		slotmaxima[InventoryType::Id::EQUIPPED] = EquipSlot::Id::LENGTH;
	}

	void Inventory::recalc_stats(Weapon::Type type)
	{
		totalstats.clear();

		for (auto& iter : inventories[InventoryType::Id::EQUIPPED])
		{
			auto equip_iter = equips.find(iter.second.unique_id);

			if (equip_iter != equips.end())
			{
				const Equip& equip = equip_iter->second;

				for (auto stat_iter : totalstats)
					stat_iter.second += equip.get_stat(stat_iter.first);
			}
		}

		int32_t prefix;

		switch (type)
		{
		case Weapon::Type::BOW:
			prefix = 2060;
			break;
		case Weapon::Type::CROSSBOW:
			prefix = 2061;
			break;
		case Weapon::Type::CLAW:
			prefix = 2070;
			break;
		case Weapon::Type::GUN:
			prefix = 2330;
			break;
		default:
			prefix = 0;
			break;
		}

		bulletslot = 0;

		if (prefix)
		{
			for (auto& iter : inventories[InventoryType::Id::USE])
			{
				const Slot& slot = iter.second;

				if (slot.count && slot.item_id / 1000 == prefix)
				{
					bulletslot = iter.first;
					break;
				}
			}
		}

		if (int32_t bulletid = get_bulletid())
			totalstats[EquipStat::Id::WATK] += BulletData::get(bulletid).get_watk();
	}

	void Inventory::set_meso(int64_t m)
	{
		meso = m;
	}

	void Inventory::set_slotmax(InventoryType::Id type, uint8_t slotmax)
	{
		slotmaxima[type] = slotmax;
	}

	void Inventory::add_item(InventoryType::Id invtype, int16_t slot, int32_t item_id, bool cash, int64_t expire, uint16_t count, const std::string& owner, int16_t flags)
	{
		items.emplace(
			std::piecewise_construct,
			std::forward_as_tuple(add_slot(invtype, slot, item_id, count, cash)),
			std::forward_as_tuple(item_id, expire, owner, flags)
			);
	}

	void Inventory::add_pet(InventoryType::Id invtype, int16_t slot, int32_t item_id, bool cash, int64_t expire, const std::string& name, int8_t level, int16_t closeness, int8_t fullness)
	{
		pets.emplace(
			std::piecewise_construct,
			std::forward_as_tuple(add_slot(invtype, slot, item_id, 1, cash)),
			std::forward_as_tuple(item_id, expire, name, level, closeness, fullness)
			);
	}

	void Inventory::add_equip(InventoryType::Id invtype, int16_t slot, int32_t item_id, bool cash, int64_t expire, uint8_t slots, uint8_t level, const EnumMap<EquipStat::Id, uint16_t>& stats, const std::string& owner, int16_t flag, uint8_t ilevel, uint16_t iexp, int32_t vicious)
	{
		equips.emplace(
			std::piecewise_construct,
			std::forward_as_tuple(add_slot(invtype, slot, item_id, 1, cash)),
			std::forward_as_tuple(item_id, expire, owner, flag, slots, level, stats, ilevel, iexp, vicious)
			);
	}

	void Inventory::remove(InventoryType::Id type, int16_t slot)
	{
		auto iter = inventories[type].find(slot);

		if (iter == inventories[type].end())
			return;

		int32_t unique_id = iter->second.unique_id;
		inventories[type].erase(iter);

		switch (type)
		{
		case InventoryType::Id::EQUIPPED:
		case InventoryType::Id::EQUIP:
			equips.erase(unique_id);
			break;
		case InventoryType::Id::CASH:
			items.erase(unique_id);
			pets.erase(unique_id);
			break;
		default:
			items.erase(unique_id);
			break;
		}
	}

	void Inventory::swap(InventoryType::Id firsttype, int16_t firstslot, InventoryType::Id secondtype, int16_t secondslot)
	{
		Slot first = std::move(inventories[firsttype][firstslot]);
		inventories[firsttype][firstslot] = std::move(inventories[secondtype][secondslot]);
		inventories[secondtype][secondslot] = std::move(first);

		if (!inventories[firsttype][firstslot].item_id)
			remove(firsttype, firstslot);

		if (!inventories[secondtype][secondslot].item_id)
			remove(secondtype, secondslot);
	}

	int32_t Inventory::add_slot(InventoryType::Id type, int16_t slot, int32_t item_id, int16_t count, bool cash)
	{
		running_uid++;
		inventories[type][slot] = { running_uid, item_id, count, cash };

		return running_uid;
	}

	void Inventory::change_count(InventoryType::Id type, int16_t slot, int16_t count)
	{
		auto iter = inventories[type].find(slot);

		if (iter != inventories[type].end())
			iter->second.count = count;
	}

	void Inventory::modify(InventoryType::Id type, int16_t slot, int8_t mode, int16_t arg, Movement move)
	{
		if (slot < 0)
		{
			slot = -slot;
			type = InventoryType::Id::EQUIPPED;
		}

		arg = (arg < 0) ? -arg : arg;

		switch (mode)
		{
		case Modification::CHANGECOUNT:
			change_count(type, slot, arg);
			break;
		case Modification::SWAP:
			switch (move)
			{
			case Movement::MOVE_INTERNAL:
				swap(type, slot, type, arg);
				break;
			case Movement::MOVE_UNEQUIP:
				swap(InventoryType::Id::EQUIPPED, slot, InventoryType::Id::EQUIP, arg);
				break;
			case Movement::MOVE_EQUIP:
				swap(InventoryType::Id::EQUIP, slot, InventoryType::Id::EQUIPPED, arg);
				break;
			}

			break;
		case Modification::REMOVE:
			remove(type, slot);
			break;
		}
	}

	uint8_t Inventory::get_slotmax(InventoryType::Id type) const
	{
		if (type == InventoryType::Id::DEC)
			return slotmaxima[InventoryType::Id::CASH];

		return slotmaxima[type];
	}

	uint16_t Inventory::get_stat(EquipStat::Id type) const
	{
		return totalstats[type];
	}

	int64_t Inventory::get_meso() const
	{
		return meso;
	}

	bool Inventory::has_projectile() const
	{
		return bulletslot > 0;
	}

	bool Inventory::has_equipped(EquipSlot::Id slot) const
	{
		return inventories[InventoryType::Id::EQUIPPED].count(slot) > 0;
	}

	int16_t Inventory::get_bulletslot() const
	{
		return bulletslot;
	}

	uint16_t Inventory::get_bulletcount() const
	{
		return get_item_count(InventoryType::Id::USE, bulletslot);
	}

	int32_t Inventory::get_bulletid() const
	{
		return get_item_id(InventoryType::Id::USE, bulletslot);
	}

	EquipSlot::Id Inventory::find_equipslot(int32_t itemid) const
	{
		const EquipData& cloth = EquipData::get(itemid);

		if (!cloth.is_valid())
			return EquipSlot::Id::NONE;

		EquipSlot::Id eqslot = cloth.get_eqslot();

		if (eqslot == EquipSlot::Id::RING1)
		{
			if (!has_equipped(EquipSlot::Id::RING2))
				return EquipSlot::Id::RING2;

			if (!has_equipped(EquipSlot::Id::RING3))
				return EquipSlot::Id::RING3;

			if (!has_equipped(EquipSlot::Id::RING4))
				return EquipSlot::Id::RING4;

			return EquipSlot::Id::RING1;
		}
		else
		{
			return eqslot;
		}
	}

	int16_t Inventory::find_free_slot(InventoryType::Id type) const
	{
		int16_t counter = 1;

		for (auto& iter : inventories[type])
		{
			if (iter.first != counter)
				return counter;

			counter++;
		}

		return counter <= slotmaxima[type] ? counter : 0;
	}

	int16_t Inventory::find_item(InventoryType::Id type, int32_t itemid) const
	{
		for (auto& iter : inventories[type])
			if (iter.second.item_id == itemid)
				return iter.first;

		return 0;
	}

	int16_t Inventory::get_item_count(InventoryType::Id type, int16_t slot) const
	{
		auto iter = inventories[type].find(slot);

		if (iter != inventories[type].end())
			return iter->second.count;
		else
			return 0;
	}

	int16_t Inventory::get_total_item_count(int32_t itemid) const
	{
		InventoryType::Id type = InventoryType::by_item_id(itemid);

		int16_t total_count = 0;

		for (auto& iter : inventories[type])
			if (iter.second.item_id == itemid)
				total_count += iter.second.count;

		return total_count;
	}

	int32_t Inventory::get_item_id(InventoryType::Id type, int16_t slot) const
	{
		auto iter = inventories[type].find(slot);

		if (iter != inventories[type].end())
			return iter->second.item_id;
		else
			return 0;
	}

	Optional<const Equip> Inventory::get_equip(InventoryType::Id type, int16_t slot) const
	{
		if (type != InventoryType::Id::EQUIPPED && type != InventoryType::Id::EQUIP)
			return {};

		auto slot_iter = inventories[type].find(slot);

		if (slot_iter == inventories[type].end())
			return {};

		auto equip_iter = equips.find(slot_iter->second.unique_id);

		if (equip_iter == equips.end())
			return {};

		return equip_iter->second;
	}

	Inventory::Movement Inventory::movementbyvalue(int8_t value)
	{
		if (value >= Inventory::Movement::MOVE_INTERNAL && value <= Inventory::Movement::MOVE_EQUIP)
			return static_cast<Movement>(value);

		LOG(LOG_DEBUG, "Unknown Inventory::Movement value: [" << value << "]");

		return Inventory::Movement::MOVE_NONE;
	}
}

================
File: Character/Inventory/Inventory.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Equip.h"
#include "InventoryType.h"
#include "Item.h"
#include "Pet.h"
#include "Weapon.h"

#include "../Look/EquipSlot.h"

#include "../../Template/Optional.h"

#include <map>
#include <unordered_map>

namespace ms
{
	// The player's inventory
	class Inventory
	{
	public:
		enum Movement : int8_t
		{
			MOVE_NONE = -1,
			MOVE_INTERNAL = 0,
			MOVE_UNEQUIP = 1,
			MOVE_EQUIP = 2
		};

		enum Modification : int8_t
		{
			ADD,
			CHANGECOUNT,
			SWAP,
			REMOVE,
			ADDCOUNT
		};

		// Return the move type by value
		static Movement movementbyvalue(int8_t value);

		Inventory();

		// Recalculate sums of equip stats
		void recalc_stats(Weapon::Type weapontype);
		// Set the meso amount
		void set_meso(int64_t meso);
		// Set the number of slots for a given inventory
		void set_slotmax(InventoryType::Id type, uint8_t value);

		// Modify the inventory with info from a packet
		void modify(InventoryType::Id type, int16_t pos, int8_t mode, int16_t arg, Movement movement);
		// Add a general item
		void add_item(InventoryType::Id type, int16_t slot, int32_t itemid, bool cash, int64_t expire, uint16_t count, const std::string& owner, int16_t flag);
		// Add a pet item
		void add_pet(InventoryType::Id type, int16_t slot, int32_t itemid, bool cash, int64_t expire, const std::string& name, int8_t level, int16_t closeness, int8_t fullness);
		// Add an equip item
		void add_equip(InventoryType::Id type, int16_t slot, int32_t itemid, bool cash, int64_t expire, uint8_t slots, uint8_t level, const EnumMap<EquipStat::Id, uint16_t>& stats, const std::string& owner, int16_t flag, uint8_t itemlevel, uint16_t itemexp, int32_t vicious);

		// Check if the use inventory contains at least one projectile
		bool has_projectile() const;
		// Return if an equip is equipped in the specified slot
		bool has_equipped(EquipSlot::Id slot) const;
		// Return the currently active projectile slot
		int16_t get_bulletslot() const;
		// Return the count of the currently active projectile
		uint16_t get_bulletcount() const;
		// Return the itemid of the currently active projectile
		int32_t get_bulletid() const;
		// Return the number of slots for the specified inventory
		uint8_t get_slotmax(InventoryType::Id type) const;
		// Return a total stat
		uint16_t get_stat(EquipStat::Id type) const;
		// Return the amount of meso
		int64_t get_meso() const;
		// Find a free slot for the specified equip
		EquipSlot::Id find_equipslot(int32_t itemid) const;
		// Find a free slot in the specified inventory
		int16_t find_free_slot(InventoryType::Id type) const;
		// Return the first slot which contains the specified item
		int16_t find_item(InventoryType::Id type, int32_t itemid) const;
		// Return the count of an item
		// Returns zero if the slot is empty
		int16_t get_item_count(InventoryType::Id type, int16_t slot) const;
		// Return the total count of an item
		// Returns zero if no instances of the item was found
		int16_t get_total_item_count(int32_t itemid) const;
		// Return the id of an item
		// Returns zero if the slot is empty
		int32_t get_item_id(InventoryType::Id type, int16_t slot) const;

		// Return a pointer to an equip
		Optional<const Equip> get_equip(InventoryType::Id type, int16_t slot) const;

	private:
		// Add an inventory slot and return the unique_id
		int32_t add_slot(InventoryType::Id type, int16_t slot, int32_t item_id, int16_t count, bool cash);
		// Change the quantity of an item
		void change_count(InventoryType::Id type, int16_t slot, int16_t count);
		// Swap two items
		void swap(InventoryType::Id firsttype, int16_t firstslot, InventoryType::Id secondtype, int16_t secondslot);
		// Remove an item
		void remove(InventoryType::Id type, int16_t slot);

		struct Slot
		{
			int32_t unique_id;
			int32_t item_id;
			int16_t count;
			bool cash;
		};

		EnumMap<InventoryType::Id, std::map<int16_t, Slot>> inventories;
		std::unordered_map<int32_t, Item> items;
		std::unordered_map<int32_t, Equip> equips;
		std::unordered_map<int32_t, Pet> pets;
		int32_t running_uid;

		EnumMap<EquipStat::Id, uint16_t> totalstats;
		EnumMap<InventoryType::Id, uint8_t> slotmaxima;
		int64_t meso;
		int16_t bulletslot;
	};
}

================
File: Character/Inventory/InventoryType.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "InventoryType.h"

#include "../../MapleStory.h"

#include <iostream>

namespace ms
{
	InventoryType::Id InventoryType::by_item_id(int32_t item_id)
	{
		constexpr Id values_by_id[7] =
		{
			NONE,
			EQUIP,
			USE,
			SETUP,
			ETC,
			CASH,
			DEC
		};

		int32_t prefix = item_id / 1000000;

		return (prefix > Id::NONE && prefix <= Id::CASH) ? values_by_id[prefix] : Id::NONE;
	}

	InventoryType::Id InventoryType::by_value(int8_t value)
	{
		switch (value)
		{
		case -1:
			return Id::EQUIPPED;
		case 1:
			return Id::EQUIP;
		case 2:
			return Id::USE;
		case 3:
			return Id::SETUP;
		case 4:
			return Id::ETC;
		case 5:
			return Id::CASH;
		case 6:
			return Id::DEC;
		}

		LOG(LOG_DEBUG, "Unknown InventoryType::Id value: [" << value << "]");

		return Id::NONE;
	}
}

================
File: Character/Inventory/InventoryType.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cstdint>

namespace ms
{
	namespace InventoryType
	{
		// Inventory types
		enum Id : int8_t
		{
			NONE,
			EQUIP,
			USE,
			SETUP,
			ETC,
			CASH,
			DEC,
			EQUIPPED,
			LENGTH
		};

		// Return the inventory type by item id
		Id by_item_id(int32_t item_id);
		// Return the inventory type by value
		Id by_value(int8_t value);
	}

	struct InventoryPosition
	{
		InventoryType::Id type;
		int16_t slot;
	};
}

================
File: Character/Inventory/Item.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Item.h"

namespace ms
{
	Item::Item(int32_t item_id, int64_t expiration, const std::string& owner, int16_t flags) : item_id(item_id), expiration(expiration), owner(owner), flags(flags) {}
}

================
File: Character/Inventory/Item.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cstdint>
#include <string>

namespace ms
{
	class Item
	{
	public:
		Item(int32_t itemid, int64_t expiration, const std::string& owner, int16_t flags);

	private:
		int32_t item_id;
		int64_t expiration;
		std::string owner;
		int16_t flags;
	};
}

================
File: Character/Inventory/Pet.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Pet.h"

namespace ms
{
	Pet::Pet(int32_t item_id, int64_t expiration, const std::string& petname, uint8_t level, uint16_t closeness, uint8_t fullness) : item_id(item_id), expiration(expiration), petname(petname), petlevel(level), closeness(closeness), fullness(fullness) {}
}

================
File: Character/Inventory/Pet.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <string>
#include <cstdint>

namespace ms
{
	class Pet
	{
	public:
		Pet(int32_t item_id, int64_t expiration, const std::string& name, uint8_t level, uint16_t closeness, uint8_t fullness);

	private:
		int32_t item_id;
		int64_t expiration;
		std::string petname;
		uint8_t petlevel;
		uint16_t closeness;
		uint8_t fullness;
	};
}

================
File: Character/Inventory/Weapon.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Weapon.h"

#include "../../MapleStory.h"

#include <iostream>

namespace ms
{
	Weapon::Type Weapon::by_value(int32_t value)
	{
		if (value < 130 || (value > 133 && value < 137) || value == 139 || (value > 149 && value < 170) || value > 170)
		{
			if (value != 100)
				LOG(LOG_DEBUG, "Unknown Weapon::Type value: [" << value << "]");

			return Weapon::NONE;
		}

		return static_cast<Type>(value);
	}
}

================
File: Character/Inventory/Weapon.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cstdint>

namespace ms
{
	namespace Weapon
	{
		enum Type
		{
			NONE = 0,
			SWORD_1H = 130,
			AXE_1H = 131,
			MACE_1H = 132,
			DAGGER = 133,
			WAND = 137,
			STAFF = 138,
			SWORD_2H = 140,
			AXE_2H = 141,
			MACE_2H = 142,
			SPEAR = 143,
			POLEARM = 144,
			BOW = 145,
			CROSSBOW = 146,
			CLAW = 147,
			KNUCKLE = 148,
			GUN = 149,
			CASH = 170
		};

		Type by_value(int32_t value);
	};
}

================
File: Character/Job.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Job.h"

namespace ms
{
	Job::Job(uint16_t i)
	{
		change_job(i);
	}

	Job::Job()
	{
		change_job(0);
	}

	void Job::change_job(uint16_t i)
	{
		id = i;
		name = get_name(id);

		if (id == 0)
			level = Level::BEGINNER;
		else if (id % 100 == 0)
			level = Level::FIRST;
		else if (id % 10 == 0)
			level = Level::SECOND;
		else if (id % 10 == 1)
			level = Level::THIRD;
		else
			level = Level::FOURTH;
	}

	bool Job::is_sub_job(uint16_t subid) const
	{
		for (int32_t lvit = BEGINNER; lvit <= FOURTH; lvit++)
		{
			Level lv = static_cast<Level>(lvit);

			if (subid == get_subjob(lv))
				return true;
		}

		return false;
	}

	bool Job::can_use(int32_t skill_id) const
	{
		uint16_t required = static_cast<uint16_t>(skill_id / 10000);
		return is_sub_job(required);
	}

	uint16_t Job::get_id() const
	{
		return id;
	}

	uint16_t Job::get_subjob(Level lv) const
	{
		if (lv <= level)
		{
			switch (lv)
			{
				case Level::BEGINNER:
					return 0;
				case Level::FIRST:
					return (id / 100) * 100;
				case Level::SECOND:
					return (id / 10) * 10;
				case Level::THIRD:
					return (level == Level::FOURTH) ? id - 1 : id;
				case Level::FOURTH:
					return id;
			}
		}

		return 0;
	}

	const std::string& Job::get_name() const
	{
		return name;
	}

	Job::Level Job::get_level() const
	{
		return level;
	}

	std::string Job::get_name(uint16_t jid) const
	{
		switch (jid)
		{
			case 0:
				return "Beginner";
			case 100:
				return "Swordsman";
			case 110:
				return "Fighter";
			case 111:
				return "Crusader";
			case 112:
				return "Hero";
			case 120:
				return "Page";
			case 121:
				return "White Knight";
			case 122:
				return "Paladin";
			case 130:
				return "Spearman";
			case 131:
				return "Dragon Knight";
			case 132:
				return "Dark Knight";
			case 200:
				return "Magician";
			case 210:
				return "Wizard (F/P)";
			case 211:
				return "Mage (F/P)";
			case 212:
				return "Archmage (F/P)";
			case 220:
				return "Wizard (I/L)";
			case 221:
				return "Mage (I/L)";
			case 222:
				return "Archmage (I/L)";
			case 230:
				return "Cleric";
			case 231:
				return "Priest";
			case 232:
				return "Bishop";
			case 300:
				return "Archer";
			case 310:
				return "Hunter";
			case 311:
				return "Ranger";
			case 312:
				return "Bowmaster";
			case 320:
				return "Crossbowman";
			case 321:
				return "Sniper";
			case 322:
				return "Marksman";
			case 400:
				return "Rogue";
			case 410:
				return "Assassin";
			case 411:
				return "Hermit";
			case 412:
				return "Nightlord";
			case 420:
				return "Bandit";
			case 421:
				return "Chief Bandit";
			case 422:
				return "Shadower";
			case 500:
				return "Pirate";
			case 510:
				return "Brawler";
			case 511:
				return "Marauder";
			case 512:
				return "Buccaneer";
			case 520:
				return "Gunslinger";
			case 521:
				return "Outlaw";
			case 522:
				return "Corsair";
			case 1000:
				return "Noblesse";
			case 1100:
			case 1110:
			case 1111:
			case 1112:
				return "Dawn Warrior";
			case 1200:
			case 1210:
			case 1211:
			case 1212:
				return "Blaze Wizard";
			case 1300:
			case 1310:
			case 1311:
			case 1312:
				return "Wind Archer";
			case 1400:
			case 1410:
			case 1411:
			case 1412:
				return "Night Walker";
			case 1500:
			case 1510:
			case 1511:
			case 1512:
				return "Thunder Breaker";
			case 2000:
			case 2100:
			case 2110:
			case 2111:
			case 2112:
				return "Aran";
			case 900:
				return "GM";
			case 910:
				return "SuperGM";
			default:
				return "";
		}
	}

	EquipStat::Id Job::get_primary(Weapon::Type weapontype) const
	{
		switch (id / 100)
		{
			case 2:
				return EquipStat::Id::INT;
			case 3:
				return EquipStat::Id::DEX;
			case 4:
				return EquipStat::Id::LUK;
			case 5:
				return (weapontype == Weapon::Type::GUN) ? EquipStat::Id::DEX : EquipStat::Id::STR;
			default:
				return EquipStat::Id::STR;
		}
	}

	EquipStat::Id Job::get_secondary(Weapon::Type weapontype) const
	{
		switch (id / 100)
		{
			case 2:
				return EquipStat::Id::LUK;
			case 3:
				return EquipStat::Id::STR;
			case 4:
				return EquipStat::Id::DEX;
			case 5:
				return (weapontype == Weapon::Type::GUN) ? EquipStat::Id::STR : EquipStat::Id::DEX;
			default:
				return EquipStat::Id::DEX;
		}
	}
}

================
File: Character/Job.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "EquipStat.h"

#include "Inventory/Weapon.h"

namespace ms
{
	class Job
	{
	public:
		enum Level : uint16_t
		{
			BEGINNER,
			FIRST,
			SECOND,
			THIRD,
			FOURTH
		};

		static Level get_next_level(Level level)
		{
			switch (level)
			{
				case BEGINNER:
					return FIRST;
				case FIRST:
					return SECOND;
				case SECOND:
					return THIRD;
				default:
					return FOURTH;
			}
		}

		Job(uint16_t id);
		Job();

		void change_job(uint16_t id);
		bool is_sub_job(uint16_t subid) const;
		bool can_use(int32_t skill_id) const;
		uint16_t get_id() const;
		uint16_t get_subjob(Level level) const;
		Level get_level() const;
		const std::string& get_name() const;
		EquipStat::Id get_primary(Weapon::Type weapontype) const;
		EquipStat::Id get_secondary(Weapon::Type weapontype) const;

	private:
		std::string get_name(uint16_t id) const;

		std::string name;
		uint16_t id;
		Level level;
	};
}

================
File: Character/Look/Afterimage.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Afterimage.h"

#include "../../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Afterimage::Afterimage(int32_t skill_id, const std::string& name, const std::string& stance_name, int16_t level)
	{
		nl::node src;

		if (skill_id > 0)
		{
			std::string strid = string_format::extend_id(skill_id, 7);
			src = nl::nx::Skill[strid.substr(0, 3) + ".img"]["skill"][strid]["afterimage"][name][stance_name];
		}

		if (!src)
			src = nl::nx::Character["Afterimage"][name + ".img"][level / 10][stance_name];

		range = src;
		firstframe = 0;
		displayed = false;

		for (nl::node sub : src)
		{
			uint8_t frame = string_conversion::or_default<uint8_t>(sub.name(), 255);

			if (frame < 255)
			{
				animation = sub;
				firstframe = frame;
			}
		}
	}

	Afterimage::Afterimage()
	{
		firstframe = 0;
		displayed = true;
	}

	void Afterimage::draw(uint8_t stframe, const DrawArgument& args, float alpha) const
	{
		if (!displayed && stframe >= firstframe)
			animation.draw(args, alpha);
	}

	void Afterimage::update(uint8_t stframe, uint16_t timestep)
	{
		if (!displayed && stframe >= firstframe)
			displayed = animation.update(timestep);
	}

	uint8_t Afterimage::get_first_frame() const
	{
		return firstframe;
	}

	Rectangle<int16_t> Afterimage::get_range() const
	{
		return range;
	}
}

================
File: Character/Look/Afterimage.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Graphics/Animation.h"

namespace ms
{
	class Afterimage
	{
	public:
		Afterimage(int32_t skill_id, const std::string& name, const std::string& stance, int16_t level);
		Afterimage();

		void draw(uint8_t stframe, const DrawArgument& args, float alpha) const;
		void update(uint8_t stframe, uint16_t timestep);

		uint8_t get_first_frame() const;
		Rectangle<int16_t> get_range() const;

	private:
		Animation animation;
		Rectangle<int16_t> range;
		uint8_t firstframe;
		bool displayed;
	};
}

================
File: Character/Look/Body.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Body.h"

#include "../../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Body::Body(int32_t skin, const BodyDrawInfo& drawinfo)
	{
		std::string strid = string_format::extend_id(skin, 2);
		nl::node bodynode = nl::nx::Character["000020" + strid + ".img"];
		nl::node headnode = nl::nx::Character["000120" + strid + ".img"];

		for (auto iter : Stance::names)
		{
			Stance::Id stance = iter.first;
			const std::string& stancename = iter.second;

			nl::node stancenode = bodynode[stancename];

			if (!stancenode)
				continue;

			for (uint8_t frame = 0; nl::node framenode = stancenode[frame]; ++frame)
			{
				for (nl::node partnode : framenode)
				{
					std::string part = partnode.name();

					if (part != "delay" && part != "face")
					{
						std::string z = partnode["z"];
						Body::Layer layer = layer_by_name(z);

						if (layer == Body::Layer::NONE)
							continue;

						Point<int16_t> shift;

						switch (layer)
						{
							case Body::Layer::HAND_BELOW_WEAPON:
								shift = drawinfo.get_hand_position(stance, frame);
								shift -= partnode["map"]["handMove"];
								break;
							default:
								shift = drawinfo.get_body_position(stance, frame);
								shift -= partnode["map"]["navel"];
								break;
						}

						stances[stance][layer]
							.emplace(frame, partnode)
							.first->second.shift(shift);
					}
				}

				for (nl::node partnode : headnode[stancename][frame])
				{
					std::string part = partnode.name();
					Body::Layer layer = layer_by_name(part);

					if (layer == Body::Layer::NONE)
						continue;

					Point<int16_t> shift = drawinfo.get_head_position(stance, frame);

					stances[stance][layer]
						.emplace(frame, partnode)
						.first->second.shift(shift);
				}
			}
		}

		constexpr size_t NUM_SKINTYPES = 13;

		constexpr const char* skintypes[NUM_SKINTYPES] =
		{
			"Light",
			"Tan",
			"Dark",
			"Pale",
			"Ashen",
			"Green",
			"",
			"",
			"",
			"Ghostly",
			"Pale Pink",
			"Clay",
			"Alabaster"
		};

		if (skin < NUM_SKINTYPES)
			name = skintypes[skin];

		if (name == "")
		{
			LOG(LOG_DEBUG, "Skin [" << skin << "] is using the default value.");

			name = nl::nx::String["Eqp.img"]["Eqp"]["Skin"][skin]["name"];
		}
	}

	void Body::draw(Layer layer, Stance::Id stance, uint8_t frame, const DrawArgument& args) const
	{
		auto frameit = stances[stance][layer].find(frame);

		if (frameit == stances[stance][layer].end())
			return;

		frameit->second.draw(args);
	}

	const std::string& Body::get_name() const
	{
		return name;
	}

	Body::Layer Body::layer_by_name(const std::string& name)
	{
		auto layer_iter = layers_by_name.find(name);

		if (layer_iter == layers_by_name.end())
		{
			if (name != "")
				single_console::log_message("[Body::layer_by_name] Unknown Layer name: [" + name + "]");

			return Body::Layer::NONE;
		}

		return layer_iter->second;
	}

	const std::unordered_map<std::string, Body::Layer> Body::layers_by_name =
	{
		{ "body",						Body::Layer::BODY						},
		{ "backBody",					Body::Layer::BODY						},
		{ "arm",						Body::Layer::ARM						},
		{ "armBelowHead",				Body::Layer::ARM_BELOW_HEAD				},
		{ "armBelowHeadOverMailChest",	Body::Layer::ARM_BELOW_HEAD_OVER_MAIL	},
		{ "armOverHair",				Body::Layer::ARM_OVER_HAIR				},
		{ "armOverHairBelowWeapon",		Body::Layer::ARM_OVER_HAIR_BELOW_WEAPON	},
		{ "handBelowWeapon",			Body::Layer::HAND_BELOW_WEAPON			},
		{ "handOverHair",				Body::Layer::HAND_OVER_HAIR				},
		{ "handOverWeapon",				Body::Layer::HAND_OVER_WEAPON			},
		{ "ear",						Body::Layer::EAR						},
		{ "head",						Body::Layer::HEAD						},
		{ "highlefEar",					Body::Layer::HIGH_LEF_EAR				},
		{ "humanEar",					Body::Layer::HUMAN_EAR					},
		{ "lefEar",						Body::Layer::LEF_EAR					}
	};
}

================
File: Character/Look/Body.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "BodyDrawInfo.h"

#include "../../Graphics/Texture.h"

namespace ms
{
	class Body
	{
	public:
		enum Layer
		{
			NONE,
			BODY,
			ARM,
			ARM_BELOW_HEAD,
			ARM_BELOW_HEAD_OVER_MAIL,
			ARM_OVER_HAIR,
			ARM_OVER_HAIR_BELOW_WEAPON,
			HAND_BELOW_WEAPON,
			HAND_OVER_HAIR,
			HAND_OVER_WEAPON,
			EAR,
			HEAD,
			HIGH_LEF_EAR,
			HUMAN_EAR,
			LEF_EAR,
			NUM_LAYERS
		};

		Body(int32_t skin, const BodyDrawInfo& drawinfo);

		void draw(Layer layer, Stance::Id stance, uint8_t frame, const DrawArgument& args) const;

		const std::string& get_name() const;

		static Layer layer_by_name(const std::string& name);

	private:
		std::unordered_map<uint8_t, Texture> stances[Stance::Id::LENGTH][Layer::NUM_LAYERS];
		std::string name;

		static const std::unordered_map<std::string, Layer> layers_by_name;
	};
}

================
File: Character/Look/BodyDrawInfo.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "BodyDrawInfo.h"

#include "Body.h"

#include "../../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	void BodyDrawInfo::init()
	{
		nl::node bodynode = nl::nx::Character["00002000.img"];
		nl::node headnode = nl::nx::Character["00012000.img"];

		for (nl::node stancenode : bodynode)
		{
			std::string ststr = stancenode.name();

			uint16_t attackdelay = 0;

			for (uint8_t frame = 0; nl::node framenode = stancenode[frame]; ++frame)
			{
				bool isaction = framenode["action"].data_type() == nl::node::type::string;

				if (isaction)
				{
					BodyAction action = framenode;
					body_actions[ststr][frame] = action;

					if (action.isattackframe())
						attack_delays[ststr].push_back(attackdelay);

					attackdelay += action.get_delay();
				}
				else
				{
					Stance::Id stance = Stance::by_string(ststr);

					if (stance == Stance::Id::NONE || stance == Stance::Id::LENGTH)
					{
						single_console::log_message("[BodyDrawInfo::init] Unknown Stance::Id name: [" + ststr + "]");
						continue;
					}

					int16_t delay = framenode["delay"];

					if (delay <= 0)
						delay = 100;

					stance_delays[stance][frame] = delay;

					std::unordered_map<Body::Layer, std::unordered_map<std::string, Point<int16_t>>> bodyshiftmap;

					for (auto partnode : framenode)
					{
						std::string part = partnode.name();

						if (part != "delay" && part != "face")
						{
							std::string zstr = partnode["z"];
							Body::Layer z = Body::layer_by_name(zstr);

							for (auto mapnode : partnode["map"])
								bodyshiftmap[z].emplace(mapnode.name(), mapnode);
						}
					}

					nl::node headmap = headnode[ststr][frame]["head"]["map"];

					for (auto mapnode : headmap)
						bodyshiftmap[Body::Layer::HEAD].emplace(mapnode.name(), mapnode);

					body_positions[stance][frame] = bodyshiftmap[Body::Layer::BODY]["navel"];

					arm_positions[stance][frame] = bodyshiftmap.count(Body::Layer::ARM) ?
						(bodyshiftmap[Body::Layer::ARM]["hand"] - bodyshiftmap[Body::Layer::ARM]["navel"] + bodyshiftmap[Body::Layer::BODY]["navel"]) :
						(bodyshiftmap[Body::Layer::ARM_OVER_HAIR]["hand"] - bodyshiftmap[Body::Layer::ARM_OVER_HAIR]["navel"] + bodyshiftmap[Body::Layer::BODY]["navel"]);

					hand_positions[stance][frame] = bodyshiftmap[Body::Layer::HAND_BELOW_WEAPON]["handMove"];
					head_positions[stance][frame] = bodyshiftmap[Body::Layer::BODY]["neck"] - bodyshiftmap[Body::Layer::HEAD]["neck"];
					face_positions[stance][frame] = bodyshiftmap[Body::Layer::BODY]["neck"] - bodyshiftmap[Body::Layer::HEAD]["neck"] + bodyshiftmap[Body::Layer::HEAD]["brow"];
					hair_positions[stance][frame] = bodyshiftmap[Body::Layer::HEAD]["brow"] - bodyshiftmap[Body::Layer::HEAD]["neck"] + bodyshiftmap[Body::Layer::BODY]["neck"];
				}
			}
		}
	}

	Point<int16_t> BodyDrawInfo::get_body_position(Stance::Id stance, uint8_t frame) const
	{
		auto iter = body_positions[stance].find(frame);

		if (iter == body_positions[stance].end())
			return {};

		return iter->second;
	}

	Point<int16_t> BodyDrawInfo::get_arm_position(Stance::Id stance, uint8_t frame) const
	{
		auto iter = arm_positions[stance].find(frame);

		if (iter == arm_positions[stance].end())
			return {};

		return iter->second;
	}

	Point<int16_t> BodyDrawInfo::get_hand_position(Stance::Id stance, uint8_t frame) const
	{
		auto iter = hand_positions[stance].find(frame);

		if (iter == hand_positions[stance].end())
			return {};

		return iter->second;
	}

	Point<int16_t> BodyDrawInfo::get_head_position(Stance::Id stance, uint8_t frame) const
	{
		auto iter = head_positions[stance].find(frame);

		if (iter == head_positions[stance].end())
			return {};

		return iter->second;
	}

	Point<int16_t> BodyDrawInfo::gethairpos(Stance::Id stance, uint8_t frame) const
	{
		auto iter = hair_positions[stance].find(frame);

		if (iter == hair_positions[stance].end())
			return {};

		return iter->second;
	}

	Point<int16_t> BodyDrawInfo::getfacepos(Stance::Id stance, uint8_t frame) const
	{
		auto iter = face_positions[stance].find(frame);

		if (iter == face_positions[stance].end())
			return {};

		return iter->second;
	}

	uint8_t BodyDrawInfo::nextframe(Stance::Id stance, uint8_t frame) const
	{
		if (stance_delays[stance].count(frame + 1))
			return frame + 1;
		else
			return 0;
	}

	uint16_t BodyDrawInfo::get_delay(Stance::Id stance, uint8_t frame) const
	{
		auto iter = stance_delays[stance].find(frame);

		if (iter == stance_delays[stance].end())
			return 100;

		return iter->second;
	}

	uint16_t BodyDrawInfo::get_attackdelay(std::string action, size_t no) const
	{
		auto action_iter = attack_delays.find(action);

		if (action_iter != attack_delays.end())
			if (no < action_iter->second.size())
				return action_iter->second[no];

		return 0;
	}

	uint8_t BodyDrawInfo::next_actionframe(std::string action, uint8_t frame) const
	{
		auto action_iter = body_actions.find(action);

		if (action_iter != body_actions.end())
			if (action_iter->second.count(frame + 1))
				return frame + 1;

		return 0;
	}

	const BodyAction* BodyDrawInfo::get_action(std::string action, uint8_t frame) const
	{
		auto action_iter = body_actions.find(action);

		if (action_iter != body_actions.end())
		{
			auto frame_iter = action_iter->second.find(frame);

			if (frame_iter != action_iter->second.end())
				return &(frame_iter->second);
		}

		return nullptr;
	}
}

================
File: Character/Look/BodyDrawInfo.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Stance.h"

#include "../../Template/Point.h"

#include <unordered_map>

namespace ms
{
	// A frame of animation for a skill or similar 'meta-stance' 
	// This simply redirects to a different stance and frame to use
	class BodyAction
	{
	public:
		BodyAction(nl::node src)
		{
			stance = Stance::by_string(src["action"]);
			frame = src["frame"];
			move = src["move"];

			int16_t sgndelay = src["delay"];

			if (sgndelay == 0)
				sgndelay = 100;

			if (sgndelay > 0)
			{
				delay = sgndelay;
				attackframe = true;
			}
			else if (sgndelay < 0)
			{
				delay = -sgndelay;
				attackframe = false;
			}
		}

		BodyAction() {}

		bool isattackframe() const
		{
			return attackframe;
		}

		uint8_t get_frame() const
		{
			return frame;
		}

		uint16_t get_delay() const
		{
			return delay;
		}

		Point<int16_t> get_move() const
		{
			return move;
		}

		Stance::Id get_stance() const
		{
			return stance;
		}

	private:
		Stance::Id stance;
		uint8_t frame;
		uint16_t delay;
		Point<int16_t> move;
		bool attackframe;
	};

	class BodyDrawInfo
	{
	public:
		void init();

		Point<int16_t> get_body_position(Stance::Id stance, uint8_t frame) const;
		Point<int16_t> get_arm_position(Stance::Id stance, uint8_t frame) const;
		Point<int16_t> get_hand_position(Stance::Id stance, uint8_t frame) const;
		Point<int16_t> get_head_position(Stance::Id stance, uint8_t frame) const;
		Point<int16_t> gethairpos(Stance::Id stance, uint8_t frame) const;
		Point<int16_t> getfacepos(Stance::Id stance, uint8_t frame) const;
		uint8_t nextframe(Stance::Id stance, uint8_t frame) const;
		uint16_t get_delay(Stance::Id stance, uint8_t frame) const;

		uint16_t get_attackdelay(std::string action, size_t no) const;
		uint8_t next_actionframe(std::string action, uint8_t frame) const;
		const BodyAction* get_action(std::string action, uint8_t frame) const;

	private:
		std::unordered_map<uint8_t, Point<int16_t>> body_positions[Stance::Id::LENGTH];
		std::unordered_map<uint8_t, Point<int16_t>> arm_positions[Stance::Id::LENGTH];
		std::unordered_map<uint8_t, Point<int16_t>> hand_positions[Stance::Id::LENGTH];
		std::unordered_map<uint8_t, Point<int16_t>> head_positions[Stance::Id::LENGTH];
		std::unordered_map<uint8_t, Point<int16_t>> hair_positions[Stance::Id::LENGTH];
		std::unordered_map<uint8_t, Point<int16_t>> face_positions[Stance::Id::LENGTH];
		std::unordered_map<uint8_t, uint16_t> stance_delays[Stance::Id::LENGTH];

		std::unordered_map<std::string, std::unordered_map<uint8_t, BodyAction>> body_actions;
		std::unordered_map<std::string, std::vector<uint16_t>> attack_delays;
	};
}

================
File: Character/Look/CharEquips.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "CharEquips.h"

namespace ms
{
	CharEquips::CharEquips()
	{
		for (auto iter : clothes)
			iter.second = nullptr;
	}

	void CharEquips::draw(EquipSlot::Id slot, Stance::Id stance, Clothing::Layer layer, uint8_t frame, const DrawArgument& args) const
	{
		if (const Clothing* cloth = clothes[slot])
			cloth->draw(stance, layer, frame, args);
	}

	void CharEquips::add_equip(int32_t itemid, const BodyDrawInfo& drawinfo)
	{
		if (itemid <= 0)
			return;

		auto iter = cloth_cache.find(itemid);

		if (iter == cloth_cache.end())
		{
			iter = cloth_cache.emplace(
				std::piecewise_construct,
				std::forward_as_tuple(itemid),
				std::forward_as_tuple(itemid, drawinfo)
				).first;
		}

		const Clothing& cloth = iter->second;

		EquipSlot::Id slot = cloth.get_eqslot();
		clothes[slot] = &cloth;
	}

	void CharEquips::remove_equip(EquipSlot::Id slot)
	{
		clothes[slot] = nullptr;
	}

	bool CharEquips::is_visible(EquipSlot::Id slot) const
	{
		if (const Clothing* cloth = clothes[slot])
			return cloth->is_transparent() == false;
		else
			return false;
	}

	bool CharEquips::comparelayer(EquipSlot::Id slot, Stance::Id stance, Clothing::Layer layer) const
	{
		if (const Clothing* cloth = clothes[slot])
			return cloth->contains_layer(stance, layer);
		else
			return false;
	}

	bool CharEquips::has_overall() const
	{
		return get_equip(EquipSlot::Id::TOP) / 10000 == 105;
	}

	bool CharEquips::has_weapon() const
	{
		return get_weapon() != 0;
	}

	bool CharEquips::is_twohanded() const
	{
		if (const Clothing* weapon = clothes[EquipSlot::Id::WEAPON])
			return weapon->is_twohanded();
		else
			return false;
	}

	CharEquips::CapType CharEquips::getcaptype() const
	{
		if (const Clothing* cap = clothes[EquipSlot::Id::HAT])
		{
			const std::string& vslot = cap->get_vslot();
			if (vslot == "CpH1H5")
				return CharEquips::CapType::HALFCOVER;
			else if (vslot == "CpH1H5AyAs")
				return CharEquips::CapType::FULLCOVER;
			else if (vslot == "CpH5")
				return CharEquips::CapType::HEADBAND;
			else
				return CharEquips::CapType::NONE;
		}
		else
		{
			return CharEquips::CapType::NONE;
		}
	}

	Stance::Id CharEquips::adjust_stance(Stance::Id stance) const
	{
		if (const Clothing* weapon = clothes[EquipSlot::Id::WEAPON])
		{
			switch (stance)
			{
			case Stance::Id::STAND1:
			case Stance::Id::STAND2:
				return weapon->get_stand();
			case Stance::Id::WALK1:
			case Stance::Id::WALK2:
				return weapon->get_walk();
			default:
				return stance;
			}
		}
		else
		{
			return stance;
		}
	}

	int32_t CharEquips::get_equip(EquipSlot::Id slot) const
	{
		if (const Clothing* cloth = clothes[slot])
			return cloth->get_id();
		else
			return 0;
	}

	int32_t CharEquips::get_weapon() const
	{
		return get_equip(EquipSlot::Id::WEAPON);
	}

	std::unordered_map<int32_t, Clothing> CharEquips::cloth_cache;
}

================
File: Character/Look/CharEquips.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Clothing.h"

namespace ms
{
	// A characters equipment (The visual part)
	class CharEquips
	{
	public:
		// Cap types (vslot)
		enum CapType
		{
			NONE,
			HEADBAND,
			HAIRPIN,
			HALFCOVER,
			FULLCOVER
		};

		// Initialize pointers with zero
		CharEquips();

		// Draw an equip
		void draw(EquipSlot::Id slot, Stance::Id stance, Clothing::Layer layer, uint8_t frame, const DrawArgument& args) const;
		// Add an equip, if not in cache, the equip is created from the files.
		void add_equip(int32_t itemid, const BodyDrawInfo& drawinfo);
		// Remove an equip
		void remove_equip(EquipSlot::Id slot);

		// Check if an equip is visible
		bool is_visible(EquipSlot::Id slot) const;
		// Check if the equip at the specified slot in the specified stance contains a part on the specified layer
		bool comparelayer(EquipSlot::Id slot, Stance::Id stance, Clothing::Layer layer) const;
		// Return if there is an overall equipped
		bool has_overall() const;
		// Return if there is a weapon equipped
		bool has_weapon() const;
		// Return whether the equipped weapon is twohanded
		bool is_twohanded() const;
		// Return the cap type (vslot)
		CapType getcaptype() const;
		// Return a stance which has been adjusted to the equipped weapon type
		Stance::Id adjust_stance(Stance::Id stance) const;
		// Return the item id of the equip at the specified slot
		int32_t get_equip(EquipSlot::Id slot) const;
		// Return the item id of the equipped weapon
		int32_t get_weapon() const;

	private:
		EnumMap<EquipSlot::Id, const Clothing*> clothes;

		static std::unordered_map<int32_t, Clothing> cloth_cache;
	};
}

================
File: Character/Look/CharLook.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "CharLook.h"

#include "../../Data/WeaponData.h"

namespace ms
{
	CharLook::CharLook(const LookEntry& entry)
	{
		reset();

		set_body(entry.skin);
		set_hair(entry.hairid);
		set_face(entry.faceid);

		add_equip(Clothing::TOP_DEFAULT_ID);
		add_equip(Clothing::BOTTOM_DEFAULT_ID);

		for (auto& equip : entry.equips)
			add_equip(equip.second);
	}

	CharLook::CharLook()
	{
		reset();

		body = nullptr;
		hair = nullptr;
		face = nullptr;
	}

	void CharLook::reset()
	{
		flip = true;

		action = nullptr;
		actionstr = "";
		actframe = 0;

		set_stance(Stance::Id::STAND1);
		stframe.set(0);
		stelapsed = 0;

		set_expression(Expression::Id::DEFAULT);
		expframe.set(0);
		expelapsed = 0;
	}

	void CharLook::draw(const DrawArgument& args, Stance::Id interstance, Expression::Id interexpression, uint8_t interframe, uint8_t interexpframe) const
	{
		Point<int16_t> faceshift = drawinfo.getfacepos(interstance, interframe);
		DrawArgument faceargs = args + DrawArgument{ faceshift, false, Point<int16_t>(0, 0) };

		if (Stance::is_climbing(interstance))
		{
			body->draw(Body::Layer::BODY, interstance, interframe, args);
			equips.draw(EquipSlot::Id::GLOVES, interstance, Clothing::Layer::GLOVE, interframe, args);
			equips.draw(EquipSlot::Id::SHOES, interstance, Clothing::Layer::SHOES, interframe, args);
			equips.draw(EquipSlot::Id::BOTTOM_DEFAULT, interstance, Clothing::Layer::PANTS_DEFAULT, interframe, args);
			equips.draw(EquipSlot::Id::BOTTOM, interstance, Clothing::Layer::PANTS, interframe, args);
			equips.draw(EquipSlot::Id::TOP_DEFAULT, interstance, Clothing::Layer::TOP_DEFAULT, interframe, args);
			equips.draw(EquipSlot::Id::TOP, interstance, Clothing::Layer::TOP, interframe, args);
			equips.draw(EquipSlot::Id::TOP, interstance, Clothing::Layer::MAIL, interframe, args);
			equips.draw(EquipSlot::Id::CAPE, interstance, Clothing::Layer::CAPE, interframe, args);
			body->draw(Body::Layer::HEAD, interstance, interframe, args);
			equips.draw(EquipSlot::Id::EARACC, interstance, Clothing::Layer::EARRINGS, interframe, args);

			switch (equips.getcaptype())
			{
				case CharEquips::CapType::NONE:
					hair->draw(Hair::Layer::BACK, interstance, interframe, args);
					break;
				case CharEquips::CapType::HEADBAND:
					equips.draw(EquipSlot::Id::HAT, interstance, Clothing::Layer::CAP, interframe, args);
					hair->draw(Hair::Layer::BACK, interstance, interframe, args);
					break;
				case CharEquips::CapType::HALFCOVER:
					hair->draw(Hair::Layer::BELOWCAP, interstance, interframe, args);
					equips.draw(EquipSlot::Id::HAT, interstance, Clothing::Layer::CAP, interframe, args);
					break;
				case CharEquips::CapType::FULLCOVER:
					equips.draw(EquipSlot::Id::HAT, interstance, Clothing::Layer::CAP, interframe, args);
					break;
			}

			equips.draw(EquipSlot::Id::SHIELD, interstance, Clothing::Layer::BACKSHIELD, interframe, args);
			equips.draw(EquipSlot::Id::WEAPON, interstance, Clothing::Layer::BACKWEAPON, interframe, args);
		}
		else
		{
			hair->draw(Hair::Layer::BELOWBODY, interstance, interframe, args);
			equips.draw(EquipSlot::Id::CAPE, interstance, Clothing::Layer::CAPE, interframe, args);
			equips.draw(EquipSlot::Id::SHIELD, interstance, Clothing::Layer::SHIELD_BELOW_BODY, interframe, args);
			equips.draw(EquipSlot::Id::WEAPON, interstance, Clothing::Layer::WEAPON_BELOW_BODY, interframe, args);
			equips.draw(EquipSlot::Id::HAT, interstance, Clothing::Layer::CAP_BELOW_BODY, interframe, args);
			body->draw(Body::Layer::BODY, interstance, interframe, args);
			equips.draw(EquipSlot::Id::GLOVES, interstance, Clothing::Layer::WRIST_OVER_BODY, interframe, args);
			equips.draw(EquipSlot::Id::GLOVES, interstance, Clothing::Layer::GLOVE_OVER_BODY, interframe, args);
			equips.draw(EquipSlot::Id::SHOES, interstance, Clothing::Layer::SHOES, interframe, args);
			body->draw(Body::Layer::ARM_BELOW_HEAD, interstance, interframe, args);

			if (equips.has_overall())
			{
				equips.draw(EquipSlot::Id::TOP, interstance, Clothing::Layer::MAIL, interframe, args);
			}
			else
			{
				equips.draw(EquipSlot::Id::BOTTOM_DEFAULT, interstance, Clothing::Layer::PANTS_DEFAULT, interframe, args);
				equips.draw(EquipSlot::Id::BOTTOM, interstance, Clothing::Layer::PANTS, interframe, args);
				equips.draw(EquipSlot::Id::TOP_DEFAULT, interstance, Clothing::Layer::TOP_DEFAULT, interframe, args);
				equips.draw(EquipSlot::Id::TOP, interstance, Clothing::Layer::TOP, interframe, args);
			}

			body->draw(Body::Layer::ARM_BELOW_HEAD_OVER_MAIL, interstance, interframe, args);
			equips.draw(EquipSlot::Id::SHIELD, interstance, Clothing::Layer::SHIELD_OVER_HAIR, interframe, args);
			equips.draw(EquipSlot::Id::EARACC, interstance, Clothing::Layer::EARRINGS, interframe, args);
			body->draw(Body::Layer::HEAD, interstance, interframe, args);
			body->draw(Body::Layer::HUMAN_EAR, interstance, interframe, args + Point<int16_t>(0, 1));
			hair->draw(Hair::Layer::SHADE, interstance, interframe, args);
			hair->draw(Hair::Layer::DEFAULT, interstance, interframe, args);
			face->draw(interexpression, interexpframe, faceargs);
			equips.draw(EquipSlot::Id::FACE, interstance, Clothing::Layer::FACEACC, 0, faceargs);
			equips.draw(EquipSlot::Id::EYEACC, interstance, Clothing::Layer::EYEACC, interframe, args);
			equips.draw(EquipSlot::Id::SHIELD, interstance, Clothing::Layer::SHIELD, interframe, args);

			switch (equips.getcaptype())
			{
				case CharEquips::CapType::NONE:
					hair->draw(Hair::Layer::OVERHEAD, interstance, interframe, args);
					break;
				case CharEquips::CapType::HEADBAND:
					equips.draw(EquipSlot::Id::HAT, interstance, Clothing::Layer::CAP, interframe, args);
					hair->draw(Hair::Layer::DEFAULT, interstance, interframe, args);
					hair->draw(Hair::Layer::OVERHEAD, interstance, interframe, args);
					equips.draw(EquipSlot::Id::HAT, interstance, Clothing::Layer::CAP_OVER_HAIR, interframe, args);
					break;
				case CharEquips::CapType::HALFCOVER:
					hair->draw(Hair::Layer::DEFAULT, interstance, interframe, args);
					equips.draw(EquipSlot::Id::HAT, interstance, Clothing::Layer::CAP, interframe, args);
					break;
				case CharEquips::CapType::FULLCOVER:
					equips.draw(EquipSlot::Id::HAT, interstance, Clothing::Layer::CAP, interframe, args);
					break;
			}

			equips.draw(EquipSlot::Id::WEAPON, interstance, Clothing::Layer::WEAPON_BELOW_ARM, interframe, args);

			if (is_twohanded(interstance))
			{
				body->draw(Body::Layer::ARM, interstance, interframe, args);
				equips.draw(EquipSlot::Id::TOP, interstance, Clothing::Layer::MAILARM, interframe, args);
				equips.draw(EquipSlot::Id::WEAPON, interstance, Clothing::Layer::WEAPON, interframe, args);
			}
			else
			{
				equips.draw(EquipSlot::Id::WEAPON, interstance, Clothing::Layer::WEAPON, interframe, args);
				body->draw(Body::Layer::ARM, interstance, interframe, args);
				equips.draw(EquipSlot::Id::TOP, interstance, Clothing::Layer::MAILARM, interframe, args);
			}

			equips.draw(EquipSlot::Id::GLOVES, interstance, Clothing::Layer::WRIST, interframe, args);
			equips.draw(EquipSlot::Id::GLOVES, interstance, Clothing::Layer::GLOVE, interframe, args);
			equips.draw(EquipSlot::Id::WEAPON, interstance, Clothing::Layer::WEAPON_OVER_GLOVE, interframe, args);

			body->draw(Body::Layer::HAND_BELOW_WEAPON, interstance, interframe, args);

			body->draw(Body::Layer::ARM_OVER_HAIR, interstance, interframe, args);
			body->draw(Body::Layer::ARM_OVER_HAIR_BELOW_WEAPON, interstance, interframe, args);
			equips.draw(EquipSlot::Id::WEAPON, interstance, Clothing::Layer::WEAPON_OVER_HAND, interframe, args);
			equips.draw(EquipSlot::Id::WEAPON, interstance, Clothing::Layer::WEAPON_OVER_BODY, interframe, args);
			body->draw(Body::Layer::HAND_OVER_HAIR, interstance, interframe, args);
			body->draw(Body::Layer::HAND_OVER_WEAPON, interstance, interframe, args);

			equips.draw(EquipSlot::Id::GLOVES, interstance, Clothing::Layer::WRIST_OVER_HAIR, interframe, args);
			equips.draw(EquipSlot::Id::GLOVES, interstance, Clothing::Layer::GLOVE_OVER_HAIR, interframe, args);
		}
	}

	void CharLook::draw(const DrawArgument& args, float alpha) const
	{
		if (!body || !hair || !face)
			return;

		Point<int16_t> acmove;

		if (action)
			acmove = action->get_move();

		DrawArgument relargs = { acmove, flip };

		Stance::Id interstance = stance.get(alpha);
		Expression::Id interexpression = expression.get(alpha);
		uint8_t interframe = stframe.get(alpha);
		uint8_t interexpframe = expframe.get(alpha);

		switch (interstance)
		{
			case Stance::Id::STAND1:
			case Stance::Id::STAND2:
			{
				if (alerted)
					interstance = Stance::Id::ALERT;

				break;
			}
		}

		draw(relargs + args, interstance, interexpression, interframe, interexpframe);
	}

	void CharLook::draw(Point<int16_t> position, bool flipped, Stance::Id interstance, Expression::Id interexpression) const
	{
		interstance = equips.adjust_stance(interstance);
		draw({ position, flipped }, interstance, interexpression, 0, 0);
	}

	bool CharLook::update(uint16_t timestep)
	{
		if (timestep == 0)
		{
			stance.normalize();
			stframe.normalize();
			expression.normalize();
			expframe.normalize();
			return false;
		}

		alerted.update();
		expcooldown.update();

		bool aniend = false;

		if (action == nullptr)
		{
			uint16_t delay = get_delay(stance.get(), stframe.get());
			uint16_t delta = delay - stelapsed;

			if (timestep >= delta)
			{
				stelapsed = timestep - delta;

				uint8_t nextframe = getnextframe(stance.get(), stframe.get());
				float threshold = static_cast<float>(delta) / timestep;
				stframe.next(nextframe, threshold);

				if (stframe == 0)
					aniend = true;
			}
			else
			{
				stance.normalize();
				stframe.normalize();

				stelapsed += timestep;
			}
		}
		else
		{
			uint16_t delay = action->get_delay();
			uint16_t delta = delay - stelapsed;

			if (timestep >= delta)
			{
				stelapsed = timestep - delta;
				actframe = drawinfo.next_actionframe(actionstr, actframe);

				if (actframe > 0)
				{
					action = drawinfo.get_action(actionstr, actframe);

					float threshold = static_cast<float>(delta) / timestep;
					stance.next(action->get_stance(), threshold);
					stframe.next(action->get_frame(), threshold);
				}
				else
				{
					aniend = true;
					action = nullptr;
					actionstr = "";
					set_stance(Stance::Id::STAND1);
				}
			}
			else
			{
				stance.normalize();
				stframe.normalize();

				stelapsed += timestep;
			}
		}

		uint16_t expdelay = face->get_delay(expression.get(), expframe.get());
		uint16_t expdelta = expdelay - expelapsed;

		if (timestep >= expdelta)
		{
			expelapsed = timestep - expdelta;

			uint8_t nextexpframe = face->nextframe(expression.get(), expframe.get());
			float fcthreshold = static_cast<float>(expdelta) / timestep;
			expframe.next(nextexpframe, fcthreshold);

			if (expframe == 0)
			{
				if (expression == Expression::Id::DEFAULT)
					expression.next(Expression::Id::BLINK, fcthreshold);
				else
					expression.next(Expression::Id::DEFAULT, fcthreshold);
			}
		}
		else
		{
			expression.normalize();
			expframe.normalize();

			expelapsed += timestep;
		}

		return aniend;
	}

	void CharLook::set_body(int32_t skin_id)
	{
		auto iter = bodytypes.find(skin_id);

		if (iter == bodytypes.end())
		{
			iter = bodytypes.emplace(
				std::piecewise_construct,
				std::forward_as_tuple(skin_id),
				std::forward_as_tuple(skin_id, drawinfo)
			).first;
		}

		body = &iter->second;
	}

	void CharLook::set_hair(int32_t hair_id)
	{
		auto iter = hairstyles.find(hair_id);

		if (iter == hairstyles.end())
		{
			iter = hairstyles.emplace(
				std::piecewise_construct,
				std::forward_as_tuple(hair_id),
				std::forward_as_tuple(hair_id, drawinfo)
			).first;
		}

		hair = &iter->second;
	}

	void CharLook::set_face(int32_t face_id)
	{
		auto iter = facetypes.find(face_id);

		if (iter == facetypes.end())
			iter = facetypes.emplace(face_id, face_id).first;

		face = &iter->second;
	}

	void CharLook::updatetwohanded()
	{
		Stance::Id basestance = Stance::baseof(stance.get());
		set_stance(basestance);
	}

	void CharLook::add_equip(int32_t itemid)
	{
		equips.add_equip(itemid, drawinfo);
		updatetwohanded();
	}

	void CharLook::remove_equip(EquipSlot::Id slot)
	{
		equips.remove_equip(slot);

		if (slot == EquipSlot::Id::WEAPON)
			updatetwohanded();
	}

	void CharLook::attack(bool degenerate)
	{
		int32_t weapon_id = equips.get_weapon();

		if (weapon_id <= 0)
			return;

		const WeaponData& weapon = WeaponData::get(weapon_id);

		uint8_t attacktype = weapon.get_attack();

		if (attacktype == 9 && !degenerate)
		{
			stance.set(Stance::Id::SHOT);
			set_action("handgun");
		}
		else
		{
			stance.set(getattackstance(attacktype, degenerate));
			stframe.set(0);
			stelapsed = 0;
		}

		weapon.get_usesound(degenerate).play();
	}

	void CharLook::attack(Stance::Id newstance)
	{
		if (action || newstance == Stance::Id::NONE)
			return;

		switch (newstance)
		{
			case Stance::Id::SHOT:
				set_action("handgun");
				break;
			default:
				set_stance(newstance);
				break;
		}
	}

	void CharLook::set_stance(Stance::Id newstance)
	{
		if (action || newstance == Stance::Id::NONE)
			return;

		Stance::Id adjstance = equips.adjust_stance(newstance);

		if (stance != adjstance)
		{
			stance.set(adjstance);
			stframe.set(0);
			stelapsed = 0;
		}
	}

	Stance::Id CharLook::getattackstance(uint8_t attack, bool degenerate) const
	{
		if (stance == Stance::Id::PRONE)
			return Stance::Id::PRONESTAB;

		enum Attack
		{
			NONE = 0,
			S1A1M1D = 1,
			SPEAR = 2,
			BOW = 3,
			CROSSBOW = 4,
			S2A2M2 = 5,
			WAND = 6,
			CLAW = 7,
			GUN = 9,
			NUM_ATTACKS
		};

		static const std::array<std::vector<Stance::Id>, Attack::NUM_ATTACKS> degen_stances = {
			{
				{ Stance::Id::NONE },
				{ Stance::Id::NONE },
				{ Stance::Id::NONE },
				{ Stance::Id::SWINGT1, Stance::Id::SWINGT3 },
				{ Stance::Id::SWINGT1, Stance::Id::STABT1 },
				{ Stance::Id::NONE },
				{ Stance::Id::NONE },
				{ Stance::Id::SWINGT1, Stance::Id::STABT1 },
				{ Stance::Id::NONE },
				{ Stance::Id::SWINGP1, Stance::Id::STABT2 }
			}
		};

		static const std::array<std::vector<Stance::Id>, NUM_ATTACKS> attack_stances = {
			{
				{ Stance::Id::NONE },
				{ Stance::Id::STABO1, Stance::Id::STABO2, Stance::Id::SWINGO1, Stance::Id::SWINGO2, Stance::Id::SWINGO3 },
				{ Stance::Id::STABT1, Stance::Id::SWINGP1 },
				{ Stance::Id::SHOOT1 },
				{ Stance::Id::SHOOT2 },
				{ Stance::Id::STABO1, Stance::Id::STABO2, Stance::Id::SWINGT1, Stance::Id::SWINGT2, Stance::Id::SWINGT3 },
				{ Stance::Id::SWINGO1, Stance::Id::SWINGO2 },
				{ Stance::Id::SWINGO1, Stance::Id::SWINGO2 },
				{ Stance::Id::NONE },
				{ Stance::Id::SHOT }
			}
		};

		if (attack <= Attack::NONE || attack >= Attack::NUM_ATTACKS)
			return Stance::Id::STAND1;

		const auto& stances = degenerate ? degen_stances[attack] : attack_stances[attack];

		if (stances.empty())
			return Stance::Id::STAND1;

		size_t index = randomizer.next_int(stances.size());

		return stances[index];
	}

	uint16_t CharLook::get_delay(Stance::Id st, uint8_t fr) const
	{
		return drawinfo.get_delay(st, fr);
	}

	uint8_t CharLook::getnextframe(Stance::Id st, uint8_t fr) const
	{
		return drawinfo.nextframe(st, fr);
	}

	void CharLook::set_expression(Expression::Id newexpression)
	{
		if (expression != newexpression && !expcooldown)
		{
			expression.set(newexpression);
			expframe.set(0);

			expelapsed = 0;
			expcooldown.set_for(5000);
		}
	}

	void CharLook::set_action(const std::string& acstr)
	{
		if (acstr == actionstr || acstr == "")
			return;

		if (Stance::Id ac_stance = Stance::by_string(acstr))
		{
			set_stance(ac_stance);
		}
		else
		{
			action = drawinfo.get_action(acstr, 0);

			if (action)
			{
				actframe = 0;
				stelapsed = 0;
				actionstr = acstr;

				stance.set(action->get_stance());
				stframe.set(action->get_frame());
			}
		}
	}

	void CharLook::set_direction(bool f)
	{
		flip = f;
	}

	void CharLook::set_alerted(int64_t millis)
	{
		alerted.set_for(millis);
	}

	bool CharLook::get_alerted() const
	{
		return (bool)alerted;
	}

	bool CharLook::is_twohanded(Stance::Id st) const
	{
		switch (st)
		{
			case Stance::Id::STAND1:
			case Stance::Id::WALK1:
				return false;
			case Stance::Id::STAND2:
			case Stance::Id::WALK2:
				return true;
			default:
				return equips.is_twohanded();
		}
	}

	uint16_t CharLook::get_attackdelay(size_t no, uint8_t first_frame) const
	{
		if (action)
		{
			return drawinfo.get_attackdelay(actionstr, no);
		}
		else
		{
			uint16_t delay = 0;

			for (uint8_t frame = 0; frame < first_frame; frame++)
				delay += get_delay(stance.get(), frame);

			return delay;
		}
	}

	uint8_t CharLook::get_frame() const
	{
		return stframe.get();
	}

	Stance::Id CharLook::get_stance() const
	{
		return stance.get();
	}

	const Body* CharLook::get_body() const
	{
		return body;
	}

	const Hair* CharLook::get_hair() const
	{
		return hair;
	}

	const Face* CharLook::get_face() const
	{
		return face;
	}

	const CharEquips& CharLook::get_equips() const
	{
		return equips;
	}

	void CharLook::init()
	{
		drawinfo.init();
	}

	BodyDrawInfo CharLook::drawinfo;
	std::unordered_map<int32_t, Hair> CharLook::hairstyles;
	std::unordered_map<int32_t, Face> CharLook::facetypes;
	std::unordered_map<int32_t, Body> CharLook::bodytypes;
}

================
File: Character/Look/CharLook.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Body.h"
#include "CharEquips.h"
#include "Face.h"
#include "Hair.h"

#include "../../Net/Login.h"
#include "../../Template/Interpolated.h"
#include "../../Util/Randomizer.h"
#include "../../Util/TimedBool.h"

namespace ms
{
	class CharLook
	{
	public:
		CharLook(const LookEntry& entry);
		CharLook();

		void reset();
		void draw(const DrawArgument& args, float alpha) const;
		void draw(Point<int16_t> pos, bool flip, Stance::Id stance, Expression::Id expression) const;
		bool update(uint16_t timestep);

		void set_hair(int32_t hairid);
		void set_body(int32_t skinid);
		void set_face(int32_t faceid);
		void add_equip(int32_t equipid);
		void remove_equip(EquipSlot::Id slot);

		void attack(bool degenerate);
		void attack(Stance::Id stance);
		void set_stance(Stance::Id stance);
		void set_expression(Expression::Id expression);
		void set_action(const std::string& action);
		void set_direction(bool mirrored);
		void set_alerted(int64_t millis);
		bool get_alerted() const;

		bool is_twohanded(Stance::Id stance) const;
		uint16_t get_attackdelay(size_t no, uint8_t first_frame) const;
		uint8_t get_frame() const;
		Stance::Id get_stance() const;

		const Body* get_body() const;
		const Hair* get_hair() const;
		const Face* get_face() const;
		const CharEquips& get_equips() const;

		// Initialize drawinfo
		static void init();

	private:
		void updatetwohanded();
		void draw(const DrawArgument& args, Stance::Id interstance, Expression::Id interexp, uint8_t interframe, uint8_t interfcframe) const;
		uint16_t get_delay(Stance::Id stance, uint8_t frame) const;
		uint8_t getnextframe(Stance::Id stance, uint8_t frame) const;
		Stance::Id getattackstance(uint8_t attack, bool degenerate) const;

		Nominal<Stance::Id> stance;
		Nominal<uint8_t> stframe;
		uint16_t stelapsed;

		Nominal<Expression::Id> expression;
		Nominal<uint8_t> expframe;
		uint16_t expelapsed;
		TimedBool expcooldown;

		bool flip;

		const BodyAction* action;
		std::string actionstr;
		uint8_t actframe;

		const Body* body;
		const Hair* hair;
		const Face* face;
		CharEquips equips;

		Randomizer randomizer;
		TimedBool alerted;

		static BodyDrawInfo drawinfo;
		static std::unordered_map<int32_t, Hair> hairstyles;
		static std::unordered_map<int32_t, Face> facetypes;
		static std::unordered_map<int32_t, Body> bodytypes;
	};
}

================
File: Character/Look/Clothing.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Clothing.h"

#include "../../Data/WeaponData.h"

#include <unordered_set>

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Clothing::Clothing(int32_t id, const BodyDrawInfo& drawinfo) : itemid(id)
	{
		const EquipData& equipdata = EquipData::get(itemid);

		eqslot = equipdata.get_eqslot();

		if (itemid == TOP_DEFAULT_ID)
			eqslot = EquipSlot::Id::TOP_DEFAULT;
		else if (itemid == BOTTOM_DEFAULT_ID)
			eqslot = EquipSlot::Id::BOTTOM_DEFAULT;

		if (eqslot == EquipSlot::Id::WEAPON)
			twohanded = WeaponData::get(itemid).is_twohanded();
		else
			twohanded = false;

		constexpr size_t NON_WEAPON_TYPES = 15;
		constexpr size_t WEAPON_OFFSET = NON_WEAPON_TYPES + 15;
		constexpr size_t WEAPON_TYPES = 20;

		constexpr Clothing::Layer layers[NON_WEAPON_TYPES] =
		{
			Clothing::Layer::CAP,
			Clothing::Layer::FACEACC,
			Clothing::Layer::EYEACC,
			Clothing::Layer::EARRINGS,
			Clothing::Layer::TOP,
			Clothing::Layer::MAIL,
			Clothing::Layer::PANTS,
			Clothing::Layer::SHOES,
			Clothing::Layer::GLOVE,
			Clothing::Layer::SHIELD,
			Clothing::Layer::CAPE,
			Clothing::Layer::RING,
			Clothing::Layer::PENDANT,
			Clothing::Layer::BELT,
			Clothing::Layer::MEDAL
		};

		Clothing::Layer chlayer;
		size_t index = (itemid / 10000) - 100;

		if (itemid == TOP_DEFAULT_ID)
			chlayer = Clothing::Layer::TOP_DEFAULT;
		else if (itemid == BOTTOM_DEFAULT_ID)
			chlayer = Clothing::Layer::PANTS_DEFAULT;
		else if (index < NON_WEAPON_TYPES)
			chlayer = layers[index];
		else if (index >= WEAPON_OFFSET && index < WEAPON_OFFSET + WEAPON_TYPES)
			chlayer = Clothing::Layer::WEAPON;
		else
			chlayer = Clothing::Layer::CAPE;

		std::string strid = "0" + std::to_string(itemid);
		std::string category = equipdata.get_itemdata().get_category();
		nl::node src = nl::nx::Character[category][strid + ".img"];
		nl::node info = src["info"];

		vslot = info["vslot"];

		switch (int32_t standno = info["stand"])
		{
			case 1:
				stand = Stance::Id::STAND1;
				break;
			case 2:
				stand = Stance::Id::STAND2;
				break;
			default:
				stand = twohanded ? Stance::Id::STAND2 : Stance::Id::STAND1;
				break;
		}

		switch (int32_t walkno = info["walk"])
		{
			case 1:
				walk = Stance::Id::WALK1;
				break;
			case 2:
				walk = Stance::Id::WALK2;
				break;
			default:
				walk = twohanded ? Stance::Id::WALK2 : Stance::Id::WALK1;
				break;
		}

		for (auto iter : Stance::names)
		{
			Stance::Id stance = iter.first;
			const std::string& stancename = iter.second;

			nl::node stancenode = src[stancename];

			if (!stancenode)
				continue;

			for (uint8_t frame = 0; nl::node framenode = stancenode[frame]; ++frame)
			{
				for (nl::node partnode : framenode)
				{
					std::string part = partnode.name();

					if (!partnode || partnode.data_type() != nl::node::type::bitmap)
						continue;

					Clothing::Layer z = chlayer;
					std::string zs = partnode["z"];

					if (part == "mailArm")
					{
						z = Clothing::Layer::MAILARM;
					}
					else
					{
						auto sublayer_iter = sublayernames.find(zs);

						if (sublayer_iter != sublayernames.end())
							z = sublayer_iter->second;
					}

					std::string parent;
					Point<int16_t> parentpos;

					for (auto mapnode : partnode["map"])
					{
						if (mapnode.data_type() == nl::node::type::vector)
						{
							parent = mapnode.name();
							parentpos = mapnode;
						}
					}

					nl::node mapnode = partnode["map"];
					Point<int16_t> shift;

					switch (eqslot)
					{
						case EquipSlot::Id::FACE:
						{
							shift -= parentpos;
							break;
						}
						case EquipSlot::Id::SHOES:
						case EquipSlot::Id::GLOVES:
						case EquipSlot::Id::TOP:
						case EquipSlot::Id::TOP_DEFAULT:
						case EquipSlot::Id::BOTTOM:
						case EquipSlot::Id::BOTTOM_DEFAULT:
						case EquipSlot::Id::CAPE:
						{
							shift = drawinfo.get_body_position(stance, frame) - parentpos;
							break;
						}
						case EquipSlot::Id::HAT:
						case EquipSlot::Id::EARACC:
						case EquipSlot::Id::EYEACC:
						{
							shift = drawinfo.getfacepos(stance, frame) - parentpos;
							break;
						}
						case EquipSlot::Id::SHIELD:
						case EquipSlot::Id::WEAPON:
						{
							if (parent == "handMove")
								shift += drawinfo.get_hand_position(stance, frame);
							else if (parent == "hand")
								shift += drawinfo.get_arm_position(stance, frame);
							else if (parent == "navel")
								shift += drawinfo.get_body_position(stance, frame);

							shift -= parentpos;
							break;
						}
					}

					stances[stance][z].emplace(frame, partnode)->second.shift(shift);
				}
			}
		}

		static const std::unordered_set<int32_t> transparents =
		{
			1002186
		};

		transparent = transparents.count(itemid) > 0;
	}

	void Clothing::draw(Stance::Id stance, Layer layer, uint8_t frame, const DrawArgument& args) const
	{
		auto range = stances[stance][layer].equal_range(frame);

		for (auto& iter = range.first; iter != range.second; ++iter)
			iter->second.draw(args);
	}

	bool Clothing::contains_layer(Stance::Id stance, Layer layer) const
	{
		return !stances[stance][layer].empty();
	}

	bool Clothing::is_transparent() const
	{
		return transparent;
	}

	bool Clothing::is_twohanded() const
	{
		return twohanded;
	}

	int32_t Clothing::get_id() const
	{
		return itemid;
	}

	Stance::Id Clothing::get_stand() const
	{
		return stand;
	}

	Stance::Id Clothing::get_walk() const
	{
		return walk;
	}

	EquipSlot::Id Clothing::get_eqslot() const
	{
		return eqslot;
	}

	const std::string& Clothing::get_vslot() const
	{
		return vslot;
	}

	const std::unordered_map<std::string, Clothing::Layer> Clothing::sublayernames =
	{
		// WEAPON
		{ "weaponOverHand",			Clothing::Layer::WEAPON_OVER_HAND	},
		{ "weaponOverGlove",		Clothing::Layer::WEAPON_OVER_GLOVE	},
		{ "weaponOverBody",			Clothing::Layer::WEAPON_OVER_BODY	},
		{ "weaponBelowArm",			Clothing::Layer::WEAPON_BELOW_ARM	},
		{ "weaponBelowBody",		Clothing::Layer::WEAPON_BELOW_BODY	},
		{ "backWeaponOverShield",	Clothing::Layer::BACKWEAPON			},
		// SHIELD
		{ "shieldOverHair",			Clothing::Layer::SHIELD_OVER_HAIR	},
		{ "shieldBelowBody",		Clothing::Layer::SHIELD_BELOW_BODY	},
		{ "backShield",				Clothing::Layer::BACKSHIELD			},
		// GLOVE
		{ "gloveWrist",				Clothing::Layer::WRIST				},
		{ "gloveOverHair",			Clothing::Layer::GLOVE_OVER_HAIR	},
		{ "gloveOverBody",			Clothing::Layer::GLOVE_OVER_BODY	},
		{ "gloveWristOverHair",		Clothing::Layer::WRIST_OVER_HAIR	},
		{ "gloveWristOverBody",		Clothing::Layer::WRIST_OVER_BODY	},
		// CAP
		{ "capOverHair",			Clothing::Layer::CAP_OVER_HAIR		},
		{ "capBelowBody",			Clothing::Layer::CAP_BELOW_BODY		},
	};
}

================
File: Character/Look/Clothing.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "BodyDrawInfo.h"
#include "EquipSlot.h"

#include "../../Graphics/Texture.h"

namespace ms
{
	class Clothing
	{
	public:
		// Defaults when no clothes are equipped
		static constexpr int32_t TOP_DEFAULT_ID = 1042399;
		static constexpr int32_t BOTTOM_DEFAULT_ID = 1060026;

		enum Layer
		{
			CAPE,
			SHOES,
			PANTS,
			TOP,
			MAIL,
			MAILARM,
			EARRINGS,
			FACEACC,
			EYEACC,
			PENDANT,
			BELT,
			MEDAL,
			RING,
			CAP,
			CAP_BELOW_BODY,
			CAP_OVER_HAIR,
			GLOVE,
			WRIST,
			GLOVE_OVER_HAIR,
			WRIST_OVER_HAIR,
			GLOVE_OVER_BODY,
			WRIST_OVER_BODY,
			SHIELD,
			BACKSHIELD,
			SHIELD_BELOW_BODY,
			SHIELD_OVER_HAIR,
			WEAPON,
			BACKWEAPON,
			WEAPON_BELOW_ARM,
			WEAPON_BELOW_BODY,
			WEAPON_OVER_HAND,
			WEAPON_OVER_BODY,
			WEAPON_OVER_GLOVE,
			PANTS_DEFAULT,
			TOP_DEFAULT,
			NUM_LAYERS
		};

		// Construct a new equip
		Clothing(int32_t itemid, const BodyDrawInfo& drawinfo);

		// Draw the equip
		void draw(Stance::Id stance, Layer layer, uint8_t frame, const DrawArgument& args) const;
		// Check if a part of the equip lies on the specified layer while in the specified stance
		bool contains_layer(Stance::Id stance, Layer layer) const;

		// Return whether the equip is invisible
		bool is_transparent() const;
		// Return whether this equip uses twohanded stances
		bool is_twohanded() const;
		// Return the item id
		int32_t get_id() const;
		// Return the equip slot for this cloth
		EquipSlot::Id get_eqslot() const;
		// Return the standing stance to use while equipped
		Stance::Id get_stand() const;
		// Return the walking stance to use while equipped
		Stance::Id get_walk() const;
		// Return the vslot, used to distinguish some layering types.
		const std::string& get_vslot() const;

	private:
		EnumMap<Stance::Id, EnumMap<Layer, std::unordered_multimap<uint8_t, Texture>, Layer::NUM_LAYERS>> stances;
		int32_t itemid;
		EquipSlot::Id eqslot;
		Stance::Id walk;
		Stance::Id stand;
		std::string vslot;
		bool twohanded;
		bool transparent;

		static const std::unordered_map<std::string, Layer> sublayernames;
	};
}

================
File: Character/Look/EquipSlot.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "EquipSlot.h"

#include "../../MapleStory.h"

#include <iostream>

namespace ms
{
	namespace EquipSlot
	{
		Id by_id(size_t id)
		{
			if (id >= Id::LENGTH)
			{
				LOG(LOG_DEBUG, "Unknown EquipSlot::Id id: [" << id << "]");

				return Id::NONE;
			}

			return static_cast<Id>(id);
		}
	}
}

================
File: Character/Look/EquipSlot.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Template/Enumeration.h"
#include "../../Template/EnumMap.h"

namespace ms
{
	namespace EquipSlot
	{
		enum Id : int16_t
		{
			NONE,
			HAT,
			FACE,
			EYEACC,
			EARACC,
			TOP,
			BOTTOM,
			SHOES,
			GLOVES,
			CAPE,
			SHIELD,		// TODO: Where is this now?
			WEAPON,
			RING1,
			RING2,
			RING3 = 15,
			RING4,
			PENDANT1,
			TAMEDMOB,	// TODO: Where is this now?
			SADDLE,		// TODO: Where is this now?
			MEDAL = 49,
			BELT = 50,
			POCKET,		// TODO: What is the proper value for this?
			BOOK,		// TODO: What is the proper value for this?
			PENDANT2,	// TODO: What is the proper value for this?
			SHOULDER,	// TODO: What is the proper value for this?
			ANDROID,	// TODO: What is the proper value for this?
			EMBLEM,		// TODO: What is the proper value for this?
			BADGE,		// TODO: What is the proper value for this?
			SUBWEAPON,	// TODO: What is the proper value for this?
			HEART,		// TODO: What is the proper value for this?
			TOP_DEFAULT,
			BOTTOM_DEFAULT,
			LENGTH
		};

		Id by_id(size_t id);

		constexpr Enumeration<Id> values;
	};
}

================
File: Character/Look/Face.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Face.h"

#include <iostream>

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Expression::Id Expression::byaction(size_t action)
	{
		action -= 98;

		if (action < Expression::Id::LENGTH)
			return static_cast<Id>(action);

		LOG(LOG_DEBUG, "Unknown Expression::Id action: [" << action << "]");

		return Expression::Id::DEFAULT;
	}

	const EnumMap<Expression::Id, std::string> Expression::names =
	{
		"default",
		"blink",
		"hit",
		"smile",
		"troubled",
		"cry",
		"angry",
		"bewildered",
		"stunned",
		"blaze",
		"bowing",
		"cheers",
		"chu",
		"dam",
		"despair",
		"glitter",
		"hot",
		"hum",
		"love",
		"oops",
		"pain",
		"shine",
		"vomit",
		"wink"
	};

	Face::Face(int32_t faceid)
	{
		std::string strid = "000" + std::to_string(faceid);
		nl::node facenode = nl::nx::Character["Face"][strid + ".img"];

		for (auto iter : Expression::names)
		{
			Expression::Id exp = iter.first;

			if (exp == Expression::Id::DEFAULT)
			{
				expressions[Expression::Id::DEFAULT].emplace(0, facenode["default"]);
			}
			else
			{
				const std::string& expname = iter.second;
				nl::node expnode = facenode[expname];

				for (uint8_t frame = 0; nl::node framenode = expnode[frame]; ++frame)
					expressions[exp].emplace(frame, framenode);
			}
		}

		name = nl::nx::String["Eqp.img"]["Eqp"]["Face"][std::to_string(faceid)]["name"];
	}

	void Face::draw(Expression::Id expression, uint8_t frame, const DrawArgument& args) const
	{
		auto frameit = expressions[expression].find(frame);

		if (frameit != expressions[expression].end())
			frameit->second.texture.draw(args);
	}

	uint8_t Face::nextframe(Expression::Id exp, uint8_t frame) const
	{
		return expressions[exp].count(frame + 1) ? frame + 1 : 0;
	}

	int16_t Face::get_delay(Expression::Id exp, uint8_t frame) const
	{
		auto delayit = expressions[exp].find(frame);
		return delayit != expressions[exp].end() ? delayit->second.delay : 100;
	}

	const std::string& Face::get_name() const
	{
		return name;
	}
}

================
File: Character/Look/Face.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "BodyDrawInfo.h"

#include "../../Graphics/Texture.h"

namespace ms
{
	class Expression
	{
	public:
		enum Id
		{
			DEFAULT,
			BLINK,
			HIT,
			SMILE,
			TROUBLED,
			CRY,
			ANGRY,
			BEWILDERED,
			STUNNED,
			BLAZE,
			BOWING,
			CHEERS,
			CHU,
			DAM,
			DESPAIR,
			GLITTER,
			HOT,
			HUM,
			LOVE,
			OOPS,
			PAIN,
			SHINE,
			VOMIT,
			WINK,
			LENGTH
		};

		static Id byaction(size_t action);

		static const EnumMap<Id, std::string> names;
	};

	class Face
	{
	public:
		Face(int32_t faceid);

		void draw(Expression::Id expression, uint8_t frame, const DrawArgument& args) const;

		uint8_t nextframe(Expression::Id expression, uint8_t frame) const;
		int16_t get_delay(Expression::Id expression, uint8_t frame) const;
		const std::string& get_name() const;

	private:
		struct Frame
		{
			Texture texture;
			uint16_t delay;

			Frame(nl::node src)
			{
				texture = src["face"];

				Point<int16_t> shift = src["face"]["map"]["brow"];
				texture.shift(-shift);

				delay = src["delay"];

				if (delay == 0)
					delay = 2500;
			}
		};

		std::unordered_map<uint8_t, Frame> expressions[Expression::Id::LENGTH];
		std::string name;
	};
}

================
File: Character/Look/Hair.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Hair.h"

#include <iostream>

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Hair::Hair(int32_t hairid, const BodyDrawInfo& drawinfo)
	{
		nl::node hairnode = nl::nx::Character["Hair"]["000" + std::to_string(hairid) + ".img"];

		for (auto stance_iter : Stance::names)
		{
			Stance::Id stance = stance_iter.first;
			const std::string& stancename = stance_iter.second;

			nl::node stancenode = hairnode[stancename];

			if (!stancenode)
				continue;

			for (uint8_t frame = 0; nl::node framenode = stancenode[frame]; ++frame)
			{
				for (nl::node layernode : framenode)
				{
					std::string layername = layernode.name();
					auto layer_iter = layers_by_name.find(layername);

					if (layer_iter == layers_by_name.end())
					{
						LOG(LOG_DEBUG, "Unknown Hair::Layer name: [" << layername << "]\tLocation: [" << hairnode.name() << "][" << stancename << "][" << frame << "]");
						continue;
					}

					Layer layer = layer_iter->second;

					Point<int16_t> brow = layernode["map"]["brow"];
					Point<int16_t> shift = drawinfo.gethairpos(stance, frame) - brow;

					if (Texture(layernode).is_valid())
					{
						stances[stance][layer]
							.emplace(frame, layernode)
							.first->second.shift(shift);

						continue;
					}

					std::string defaultstancename = "default";

					if (layername.substr(0, 4) == "back")
						defaultstancename = "backDefault";

					nl::node defaultnode = hairnode[defaultstancename][layername];

					if (Texture(defaultnode).is_valid())
					{
						stances[stance][layer]
							.emplace(frame, defaultnode)
							.first->second.shift(shift);

						continue;
					}

					nl::node defaultnode2 = defaultnode["0"];

					if (Texture(defaultnode2).is_valid())
					{
						stances[stance][layer]
							.emplace(frame, defaultnode2)
							.first->second.shift(shift);

						continue;
					}

					LOG(LOG_DEBUG, "Invalid Hair::Layer texture\tName: [" << layername << "]\tLocation: [" << hairnode.name() << "][" << stancename << "][" << frame << "]");
				}
			}
		}

		name = nl::nx::String["Eqp.img"]["Eqp"]["Hair"][std::to_string(hairid)]["name"];

		constexpr size_t NUM_COLORS = 8;

		constexpr const char* haircolors[NUM_COLORS] =
		{
			"Black", "Red", "Orange", "Blonde", "Green", "Blue", "Violet", "Brown"
		};

		size_t index = hairid % 10;
		color = (index < NUM_COLORS) ? haircolors[index] : "";
	}

	void Hair::draw(Layer layer, Stance::Id stance, uint8_t frame, const DrawArgument& args) const
	{
		auto frameit = stances[stance][layer].find(frame);

		if (frameit == stances[stance][layer].end())
			return;

		frameit->second.draw(args);
	}

	const std::string& Hair::get_name() const
	{
		return name;
	}

	const std::string& Hair::getcolor() const
	{
		return color;
	}

	const std::unordered_map<std::string, Hair::Layer> Hair::layers_by_name =
	{
		{ "hair",					Hair::Layer::DEFAULT		},
		{ "hairBelowBody",			Hair::Layer::BELOWBODY		},
		{ "hairOverHead",			Hair::Layer::OVERHEAD		},
		{ "hairShade",				Hair::Layer::SHADE			},
		{ "backHair",				Hair::Layer::BACK			},
		{ "backHairBelowCap",		Hair::Layer::BELOWCAP		},
		{ "backHairBelowCapNarrow",	Hair::Layer::BELOWCAPNARROW },
		{ "backHairBelowCapWide",	Hair::Layer::BELOWCAPWIDE	}
	};
}

================
File: Character/Look/Hair.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "BodyDrawInfo.h"

#include "../../Graphics/Texture.h"

namespace ms
{
	class Hair
	{
	public:
		enum Layer
		{
			NONE,
			DEFAULT,
			BELOWBODY,
			OVERHEAD,
			SHADE,
			BACK,
			BELOWCAP,
			BELOWCAPNARROW,
			BELOWCAPWIDE,
			NUM_LAYERS
		};

		Hair(int32_t hairid, const BodyDrawInfo& drawinfo);

		void draw(Layer layer, Stance::Id stance, uint8_t frame, const DrawArgument& args) const;

		const std::string& get_name() const;
		const std::string& getcolor() const;

	private:
		std::unordered_map<uint8_t, Texture> stances[Stance::Id::LENGTH][Layer::NUM_LAYERS];
		std::string name;
		std::string color;

		static const std::unordered_map<std::string, Layer> layers_by_name;
	};
}

================
File: Character/Look/PetLook.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "PetLook.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	PetLook::PetLook(int32_t iid, std::string nm, int32_t uqid, Point<int16_t> pos, uint8_t st, int32_t)
	{
		itemid = iid;
		name = nm;
		uniqueid = uqid;

		set_position(pos.x(), pos.y());
		set_stance(st);

		namelabel = Text(Text::Font::A13M, Text::Alignment::CENTER, Color::Name::WHITE, Text::Background::NAMETAG, name);

		std::string strid = std::to_string(iid);
		nl::node src = nl::nx::Item["Pet"][strid + ".img"];

		animations[Stance::MOVE] = src["move"];
		animations[Stance::STAND] = src["stand0"];
		animations[Stance::JUMP] = src["jump"];
		animations[Stance::ALERT] = src["alert"];
		animations[Stance::PRONE] = src["prone"];
		animations[Stance::FLY] = src["fly"];
		animations[Stance::HANG] = src["hang"];

		nl::node effsrc = nl::nx::Effect["PetEff.img"][strid];

		animations[Stance::WARP] = effsrc["warp"];
	}

	PetLook::PetLook()
	{
		itemid = 0;
		name = "";
		uniqueid = 0;
		stance = Stance::STAND;
	}

	void PetLook::draw(double viewx, double viewy, float alpha) const
	{
		Point<int16_t> absp = phobj.get_absolute(viewx, viewy, alpha);

		animations[stance].draw(DrawArgument(absp, flip), alpha);
		namelabel.draw(absp);
	}

	void PetLook::update(const Physics& physics, Point<int16_t> charpos)
	{
		static const double PETWALKFORCE = 0.35;
		static const double PETFLYFORCE = 0.2;

		Point<int16_t> curpos = phobj.get_position();

		switch (stance)
		{
		case Stance::STAND:
		case Stance::MOVE:
			if (curpos.distance(charpos) > 150)
			{
				set_position(charpos.x(), charpos.y());
			}
			else
			{
				if (charpos.x() - curpos.x() > 50)
				{
					phobj.hforce = PETWALKFORCE;
					flip = true;

					set_stance(Stance::MOVE);
				}
				else if (charpos.x() - curpos.x() < -50)
				{
					phobj.hforce = -PETWALKFORCE;
					flip = false;

					set_stance(Stance::MOVE);
				}
				else
				{
					phobj.hforce = 0.0;

					set_stance(Stance::STAND);
				}
			}

			phobj.type = PhysicsObject::Type::NORMAL;
			phobj.clear_flag(PhysicsObject::Flag::NOGRAVITY);
			break;
		case Stance::HANG:
			set_position(charpos.x(), charpos.y());
			phobj.set_flag(PhysicsObject::Flag::NOGRAVITY);
			break;
		case Stance::FLY:
			if ((charpos - curpos).length() > 250)
			{
				set_position(charpos.x(), charpos.y());
			}
			else
			{
				if (charpos.x() - curpos.x() > 50)
				{
					phobj.hforce = PETFLYFORCE;
					flip = true;
				}
				else if (charpos.x() - curpos.x() < -50)
				{
					phobj.hforce = -PETFLYFORCE;
					flip = false;
				}
				else
				{
					phobj.hforce = 0.0f;
				}

				if (charpos.y() - curpos.y() > 50.0f)
					phobj.vforce = PETFLYFORCE;
				else if (charpos.y() - curpos.y() < -50.0f)
					phobj.vforce = -PETFLYFORCE;
				else
					phobj.vforce = 0.0f;
			}

			phobj.type = PhysicsObject::Type::FLYING;
			phobj.clear_flag(PhysicsObject::Flag::NOGRAVITY);
			break;
		}

		physics.move_object(phobj);

		animations[stance].update();
	}

	void PetLook::set_position(int16_t x, int16_t y)
	{
		phobj.set_x(x);
		phobj.set_y(y);
	}

	void PetLook::set_stance(Stance st)
	{
		if (stance != st)
		{
			stance = st;
			animations[stance].reset();
		}
	}

	void PetLook::set_stance(uint8_t stancebyte)
	{
		flip = stancebyte % 2 == 1;
		stance = stancebyvalue(stancebyte);
	}

	int32_t PetLook::get_itemid() const
	{
		return itemid;
	}

	PetLook::Stance PetLook::get_stance() const
	{
		return stance;
	}
}

================
File: Character/Look/PetLook.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Graphics/Animation.h"
#include "../../Graphics/Text.h"
#include "../../Template/EnumMap.h"

#include "../../Gameplay/Physics/Physics.h"

namespace ms
{
	class PetLook
	{
	public:
		enum Stance : uint8_t
		{
			MOVE,
			STAND,
			JUMP,
			ALERT,
			PRONE,
			FLY,
			HANG,
			WARP,
			LENGTH
		};

		static Stance stancebyvalue(uint8_t value)
		{
			uint8_t valueh = value / 2;

			return valueh >= LENGTH ? STAND : static_cast<Stance>(valueh);
		}

		PetLook(int32_t iid, std::string name, int32_t uniqueid, Point<int16_t> pos, uint8_t stance, int32_t fhid);
		PetLook();

		void draw(double viewx, double viewy, float alpha) const;
		void update(const Physics& physics, Point<int16_t> charpos);

		void set_position(int16_t xpos, int16_t ypos);
		void set_stance(Stance stance);
		void set_stance(uint8_t stancebyte);

		int32_t get_itemid() const;
		Stance get_stance() const;

	private:
		int32_t itemid;
		std::string name;
		int32_t uniqueid;
		Stance stance;
		bool flip;

		EnumMap<Stance, Animation> animations;
		PhysicsObject phobj;
		Text namelabel;
	};
}

================
File: Character/Look/Stance.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Stance.h"

#include "../../Util/Misc.h"

#include <iostream>

namespace ms
{
	Stance::Id Stance::by_state(int8_t state)
	{
		int8_t index = (state / 2) - 1;

		if (index < 0 || index > 10)
			return WALK1;

		constexpr Id statevalues[10] =
		{
			WALK1,
			STAND1,
			JUMP,
			ALERT,
			PRONE,
			FLY,
			LADDER,
			ROPE,
			DEAD,
			SIT
		};

		return statevalues[index];
	}

	Stance::Id Stance::by_id(uint8_t id)
	{
		if (id <= NONE || id >= LENGTH)
			return NONE;

		return static_cast<Stance::Id>(id);
	}

	Stance::Id Stance::by_string(const std::string& name)
	{
		for (auto iter : names)
			if (iter.second == name)
				return iter.first;

		single_console::log_message("[Stance::by_string] Unknown Id name: [" + name + "]");

		return NONE;
	}

	bool Stance::is_climbing(Id value)
	{
		return value == LADDER || value == ROPE;
	}

	Stance::Id Stance::baseof(Id value)
	{
		switch (value)
		{
			case STAND2:
				return STAND1;
			case WALK2:
				return WALK1;
			default:
				return value;
		}
	}

	Stance::Id Stance::secondof(Id value)
	{
		switch (value)
		{
			case STAND1:
				return STAND2;
			case WALK1:
				return WALK2;
			default:
				return value;
		}
	}

	const EnumMap<Stance::Id, std::string> Stance::names =
	{
		"",
		"alert",
		"dead",
		"fly",
		"heal",
		"jump",
		"ladder",
		"prone",
		"proneStab",
		"rope",
		"shot",
		"shoot1",
		"shoot2",
		"shootF",
		"sit",
		"stabO1",
		"stabO2",
		"stabOF",
		"stabT1",
		"stabT2",
		"stabTF",
		"stand1",
		"stand2",
		"swingO1",
		"swingO2",
		"swingO3",
		"swingOF",
		"swingP1",
		"swingP2",
		"swingPF",
		"swingT1",
		"swingT2",
		"swingT3",
		"swingTF",
		"walk1",
		"walk2"
	};
}

================
File: Character/Look/Stance.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Template/EnumMap.h"

#include <string>

namespace ms
{
	namespace Stance
	{
		enum Id : uint8_t
		{
			NONE,
			ALERT,
			DEAD,
			FLY,
			HEAL,
			JUMP,
			LADDER,
			PRONE,
			PRONESTAB,
			ROPE,
			SHOT,
			SHOOT1,
			SHOOT2,
			SHOOTF,
			SIT,
			STABO1,
			STABO2,
			STABOF,
			STABT1,
			STABT2,
			STABTF,
			STAND1,
			STAND2,
			SWINGO1,
			SWINGO2,
			SWINGO3,
			SWINGOF,
			SWINGP1,
			SWINGP2,
			SWINGPF,
			SWINGT1,
			SWINGT2,
			SWINGT3,
			SWINGTF,
			WALK1,
			WALK2,
			LENGTH
		};

		Id by_state(int8_t state);
		Id by_id(uint8_t id);
		Id by_string(const std::string& name);

		bool is_climbing(Id value);
		Id baseof(Id value);
		Id secondof(Id value);

		extern const EnumMap<Id, std::string> names;
	};
}

================
File: Character/MapleStat.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapleStat.h"

#include "../../MapleStory.h"

#include <iostream>

namespace ms
{
	namespace MapleStat
	{
		Id by_id(size_t id)
		{
			if (id >= LENGTH)
				LOG(LOG_DEBUG, "Unknown MapleStat::Id id: [" << id << "]");

			return static_cast<Id>(id);
		}

		const EnumMap<Id, int32_t> codes =
		{
			0x1,
			0x2,
			0x4,
			0x10,
			0x20,
			0x40,
			0x80,
			0x100,
			0x200,
			0x400,
			0x800,
			0x1000,
			0x2000,
			0x4000,
			0x8000,
			0x10000,
			0x20000,
			0x40000,
			0x180008,
			0x200000
		};
	}
}

================
File: Character/MapleStat.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Template/EnumMap.h"

namespace ms
{
	namespace MapleStat
	{
		enum Id
		{
			SKIN,
			FACE,
			HAIR,
			LEVEL,
			JOB,
			STR,
			DEX,
			INT,
			LUK,
			HP,
			MAXHP,
			MP,
			MAXMP,
			AP,
			SP,
			EXP,
			FAME,
			MESO,
			PET,
			GACHAEXP,
			LENGTH
		};

		Id by_id(size_t id);

		extern const EnumMap<Id, int32_t> codes;
	};
}

================
File: Character/MonsterBook.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MonsterBook.h"

namespace ms
{
	MonsterBook::MonsterBook()
	{
		cover = 0;
	}

	void MonsterBook::set_cover(int32_t cov)
	{
		cover = cov;
	}

	void MonsterBook::add_card(int16_t card, int8_t level)
	{
		cards[card] = level;
	}
}

================
File: Character/MonsterBook.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <map>

namespace ms
{
	// Class that represents the monster card collection of an individual character
	class MonsterBook
	{
	public:
		MonsterBook();

		void set_cover(int32_t);
		void add_card(int16_t, int8_t);
	private:
		int32_t cover;
		std::map<int16_t, int8_t> cards;
	};
}

================
File: Character/OtherChar.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "OtherChar.h"

#include "../Constants.h"

namespace ms
{
	OtherChar::OtherChar(int32_t charid, const CharLook& look, uint16_t level, int16_t job, const std::string& name, int8_t stance, Point<int16_t> position) : Char(charid, look, name), level(level), job(job)
	{
		set_position(position);

		lastmove.xpos = position.x();
		lastmove.ypos = position.y();
		lastmove.newstate = stance;
		timer = 0;

		attackspeed = 6;
		attacking = false;
	}

	int8_t OtherChar::update(const Physics& physics)
	{
		if (timer > 1)
		{
			timer--;
		}
		else if (timer == 1)
		{
			if (!movements.empty())
			{
				lastmove = movements.front();
				movements.pop();
			}
			else
			{
				timer = 0;
			}
		}

		if (!attacking)
		{
			uint8_t laststate = lastmove.newstate;
			set_state(laststate);
		}

		phobj.hspeed = lastmove.xpos - phobj.crnt_x();
		phobj.vspeed = lastmove.ypos - phobj.crnt_y();
		phobj.move();

		physics.get_fht().update_fh(phobj);

		bool aniend = Char::update(physics, get_stancespeed());

		if (aniend && attacking)
			attacking = false;

		return get_layer();
	}

	void OtherChar::send_movement(const std::vector<Movement>& newmoves)
	{
		movements.push(newmoves.back());

		if (timer == 0)
		{
			constexpr uint16_t DELAY = 50;
			timer = DELAY;
		}
	}

	void OtherChar::update_skill(int32_t skillid, uint8_t skilllevel)
	{
		skilllevels[skillid] = skilllevel;
	}

	void OtherChar::update_speed(uint8_t as)
	{
		attackspeed = as;
	}

	void OtherChar::update_look(const LookEntry& newlook)
	{
		look = newlook;

		uint8_t laststate = lastmove.newstate;
		set_state(laststate);
	}

	int8_t OtherChar::get_integer_attackspeed() const
	{
		return attackspeed;
	}

	uint16_t OtherChar::get_level() const
	{
		return level;
	}

	int32_t OtherChar::get_skilllevel(int32_t skillid) const
	{
		auto iter = skilllevels.find(skillid);

		if (iter == skilllevels.end())
			return 0;

		return iter->second;
	}
}

================
File: Character/OtherChar.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Char.h"

#include "Look/CharLook.h"

#include "../Gameplay/Movement.h"

#include <queue>
#include <vector>

namespace ms
{
	// Other client players
	class OtherChar : public Char
	{
	public:
		OtherChar(int32_t charid, const CharLook& look, uint16_t level, int16_t job, const std::string& name, int8_t stance, Point<int16_t> position);

		// Update the character
		int8_t update(const Physics& physics) override;
		// Add the movements which this character will go through next
		void send_movement(const std::vector<Movement>& movements);

		// Update a skill level
		void update_skill(int32_t skillid, uint8_t skilllevel);
		// Update the attack speed
		void update_speed(uint8_t attackspeed);
		// Update the character look
		void update_look(const LookEntry& look);

		// Return the character's attacking speed
		int8_t get_integer_attackspeed() const override;
		// Return the character's level
		uint16_t get_level() const override;
		// Return the character's level of a skill
		int32_t get_skilllevel(int32_t skillid) const override;

	private:
		uint16_t level;
		int16_t job;
		std::queue<Movement> movements;
		Movement lastmove;
		uint16_t timer;

		std::unordered_map<int32_t, uint8_t> skilllevels;
		uint8_t attackspeed;
	};
}

================
File: Character/PassiveBuffs.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "PassiveBuffs.h"

#include "SkillId.h"

#include "../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	bool ConditionlessBuff::is_applicable(CharStats&, nl::node) const
	{
		return true;
	}

	void AngelBlessingBuff::apply_to(CharStats& stats, nl::node level) const
	{
		stats.add_value(EquipStat::Id::WATK, level["x"]);
		stats.add_value(EquipStat::Id::MAGIC, level["y"]);
		stats.add_value(EquipStat::Id::ACC, level["z"]);
		stats.add_value(EquipStat::Id::AVOID, level["z"]);
	}

	template<Weapon::Type W1, Weapon::Type W2>
	bool f_is_applicable(CharStats& stats, nl::node level)
	{
		return f_is_applicable<W1>(stats, level) || f_is_applicable<W2>(stats, level);
	}

	template<Weapon::Type W1>
	bool f_is_applicable(CharStats& stats, nl::node)
	{
		return stats.get_weapontype() == W1;
	}

	template <Weapon::Type...W>
	bool WeaponMasteryBuff<W...>::is_applicable(CharStats& stats, nl::node level) const
	{
		return f_is_applicable<W...>(stats, level);
	}

	template <Weapon::Type...W>
	void WeaponMasteryBuff<W...>::apply_to(CharStats& stats, nl::node level) const
	{
		float mastery = static_cast<float>(level["mastery"]) / 100;
		stats.set_mastery(mastery);
		stats.add_value(EquipStat::Id::ACC, level["x"]);
	}

	void AchillesBuff::apply_to(CharStats& stats, nl::node level) const
	{
		float reducedamage = static_cast<float>(level["x"]) / 1000;
		stats.set_reducedamage(reducedamage);
	}

	bool BerserkBuff::is_applicable(CharStats& stats, nl::node level) const
	{
		float hp_percent = static_cast<float>(level["x"]) / 100;
		int32_t hp_threshold = static_cast<int32_t>(stats.get_total(EquipStat::Id::HP) * hp_percent);
		int32_t hp_current = stats.get_stat(MapleStat::Id::HP);

		return hp_current <= hp_threshold;
	}

	void BerserkBuff::apply_to(CharStats& stats, nl::node level) const
	{
		float damagepercent = static_cast<float>(level["damage"]) / 100;
		stats.set_damagepercent(damagepercent);
	}

	PassiveBuffs::PassiveBuffs()
	{
		// Beginner
		buffs[SkillId::Id::ANGEL_BLESSING] = std::make_unique<AngelBlessingBuff>();

		// Fighter
		buffs[SkillId::Id::SWORD_MASTERY_FIGHTER] = std::make_unique<WeaponMasteryBuff<Weapon::Type::SWORD_1H, Weapon::Type::SWORD_2H>>();
		buffs[SkillId::Id::AXE_MASTERY] = std::make_unique<WeaponMasteryBuff<Weapon::Type::AXE_1H, Weapon::Type::AXE_2H>>();

		// Crusader

		// Hero
		buffs[SkillId::Id::ACHILLES_HERO] = std::make_unique<AchillesBuff>();

		// Page
		buffs[SkillId::Id::SWORD_MASTERY_FIGHTER] = std::make_unique<WeaponMasteryBuff<Weapon::Type::SWORD_1H, Weapon::Type::SWORD_2H>>();
		buffs[SkillId::Id::BW_MASTERY] = std::make_unique<WeaponMasteryBuff<Weapon::Type::MACE_1H, Weapon::Type::MACE_2H>>();

		// White Knight

		// Paladin
		buffs[SkillId::Id::ACHILLES_PALADIN] = std::make_unique<AchillesBuff>();

		// Spearman
		buffs[SkillId::Id::SPEAR_MASTERY] = std::make_unique<WeaponMasteryBuff<Weapon::Type::SPEAR>>();
		buffs[SkillId::Id::PA_MASTERY] = std::make_unique<WeaponMasteryBuff<Weapon::Type::POLEARM>>();

		// Dragon Knight

		// Dark Knight
		buffs[SkillId::Id::ACHILLES_DK] = std::make_unique<AchillesBuff>();
		buffs[SkillId::Id::BERSERK] = std::make_unique<BerserkBuff>();
	}

	void PassiveBuffs::apply_buff(CharStats& stats, int32_t skill_id, int32_t skill_level) const
	{
		auto iter = buffs.find(skill_id);

		if (iter == buffs.end())
			return;

		bool wrong_job = !stats.get_job().can_use(skill_id);

		if (wrong_job)
			return;

		std::string strid;

		if (skill_id < 10000000)
			strid = string_format::extend_id(skill_id, 7);
		else
			strid = std::to_string(skill_id);

		nl::node src = nl::nx::Skill[strid.substr(0, 3) + ".img"]["skill"][strid]["level"][skill_level];

		const PassiveBuff* buff = iter->second.get();

		if (buff && buff->is_applicable(stats, src))
			buff->apply_to(stats, src);
	}
}

================
File: Character/PassiveBuffs.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "CharStats.h"

#include <memory>
#include <unordered_map>

namespace ms
{
	// Interface for passive buffs
	class PassiveBuff
	{
	public:
		virtual ~PassiveBuff() {}

		virtual bool is_applicable(CharStats& stats, nl::node level) const = 0;
		virtual void apply_to(CharStats& stats, nl::node level) const = 0;
	};

	// Abstract base for passives without conditions
	class ConditionlessBuff : public PassiveBuff
	{
	public:
		bool is_applicable(CharStats& stats, nl::node level) const final override;
	};

	// Buff for angel blessing/blessing of the spirit
	class AngelBlessingBuff : public ConditionlessBuff
	{
	public:
		void apply_to(CharStats& stats, nl::node level) const override;
	};

	template <Weapon::Type...W>
	// Buff for Mastery skills
	class WeaponMasteryBuff : public PassiveBuff
	{
	public:
		bool is_applicable(CharStats& stats, nl::node level) const override;
		void apply_to(CharStats& stats, nl::node level) const override;
	};

	// Buff for Achilles
	class AchillesBuff : public ConditionlessBuff
	{
	public:
		void apply_to(CharStats& stats, nl::node level) const override;
	};

	// Buff for Berserk
	class BerserkBuff : public PassiveBuff
	{
	public:
		bool is_applicable(CharStats& stats, nl::node level) const override;
		void apply_to(CharStats& stats, nl::node level) const override;
	};

	// Collection of passive buffs
	class PassiveBuffs
	{
	public:
		// Register all effects
		PassiveBuffs();

		// Apply a passive skill effect to the character stats
		void apply_buff(CharStats& stats, int32_t skill_id, int32_t skill_level) const;

	private:
		std::unordered_map<int32_t, std::unique_ptr<PassiveBuff>> buffs;
	};
}

================
File: Character/Player.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Player.h"

#include "PlayerStates.h"

#include "../Data/WeaponData.h"
#include "../IO/UI.h"

#include "../IO/UITypes/UIStatsInfo.h"
#include "../Net/Packets/GameplayPackets.h"
#include "../Net/Packets/InventoryPackets.h"

namespace ms
{
	const PlayerNullState nullstate;

	const PlayerState* get_state(Char::State state)
	{
		static PlayerStandState standing;
		static PlayerWalkState walking;
		static PlayerFallState falling;
		static PlayerProneState lying;
		static PlayerClimbState climbing;
		static PlayerSitState sitting;
		static PlayerFlyState flying;

		switch (state)
		{
			case Char::State::STAND:
				return &standing;
			case Char::State::WALK:
				return &walking;
			case Char::State::FALL:
				return &falling;
			case Char::State::PRONE:
				return &lying;
			case Char::State::LADDER:
			case Char::State::ROPE:
				return &climbing;
			case Char::State::SIT:
				return &sitting;
			case Char::State::SWIM:
				return &flying;
			default:
				return nullptr;
		}
	}

	Player::Player(const CharEntry& entry) : Char(entry.id, entry.look, entry.stats.name), stats(entry.stats)
	{
		attacking = false;
		underwater = false;

		set_state(Char::State::STAND);
		set_direction(true);
	}

	Player::Player() : Char(0, {}, "") {}

	void Player::respawn(Point<int16_t> pos, bool uw)
	{
		set_position(pos.x(), pos.y());
		underwater = uw;
		keysdown.clear();
		attacking = false;
		ladder = nullptr;
		nullstate.update_state(*this);
	}

	void Player::send_action(KeyAction::Id action, bool down)
	{
		const PlayerState* pst = get_state(state);

		if (pst)
			pst->send_action(*this, action, down);

		keysdown[action] = down;
	}

	void Player::recalc_stats(bool equipchanged)
	{
		Weapon::Type weapontype = get_weapontype();

		stats.set_weapontype(weapontype);
		stats.init_totalstats();

		if (equipchanged)
			inventory.recalc_stats(weapontype);

		for (auto stat : EquipStat::values)
		{
			int32_t inventory_total = inventory.get_stat(stat);
			stats.add_value(stat, inventory_total);
		}

		auto passive_skills = skillbook.collect_passives();

		for (auto& passive : passive_skills)
		{
			int32_t skill_id = passive.first;
			int32_t skill_level = passive.second;

			passive_buffs.apply_buff(stats, skill_id, skill_level);
		}

		for (const Buff& buff : buffs.values())
			active_buffs.apply_buff(stats, buff.stat, buff.value);

		stats.close_totalstats();

		if (auto statsinfo = UI::get().get_element<UIStatsInfo>())
			statsinfo->update_all_stats();
	}

	void Player::change_equip(int16_t slot)
	{
		if (int32_t itemid = inventory.get_item_id(InventoryType::Id::EQUIPPED, slot))
			look.add_equip(itemid);
		else
			look.remove_equip(EquipSlot::by_id(slot));
	}

	void Player::use_item(int32_t itemid)
	{
		InventoryType::Id type = InventoryType::by_item_id(itemid);

		if (int16_t slot = inventory.find_item(type, itemid))
			if (type == InventoryType::Id::USE)
				UseItemPacket(slot, itemid).dispatch();
	}

	void Player::draw(Layer::Id layer, double viewx, double viewy, float alpha) const
	{
		if (layer == get_layer())
			Char::draw(viewx, viewy, alpha);
	}

	int8_t Player::update(const Physics& physics)
	{
		const PlayerState* pst = get_state(state);

		if (pst)
		{
			pst->update(*this);
			physics.move_object(phobj);

			bool aniend = Char::update(physics, get_stancespeed());

			if (aniend && attacking)
			{
				attacking = false;
				nullstate.update_state(*this);
			}
			else
			{
				pst->update_state(*this);
			}
		}

		uint8_t stancebyte = facing_right ? state : state + 1;
		Movement newmove(phobj, stancebyte);
		bool needupdate = lastmove.hasmoved(newmove);

		if (needupdate)
		{
			MovePlayerPacket(newmove).dispatch();
			lastmove = newmove;
		}

		climb_cooldown.update();

		return get_layer();
	}

	int8_t Player::get_integer_attackspeed() const
	{
		int32_t weapon_id = look.get_equips().get_weapon();

		if (weapon_id <= 0)
			return 0;

		const WeaponData& weapon = WeaponData::get(weapon_id);

		int8_t base_speed = stats.get_attackspeed();
		int8_t weapon_speed = weapon.get_speed();

		return base_speed + weapon_speed;
	}

	void Player::set_direction(bool flipped)
	{
		if (!attacking)
			Char::set_direction(flipped);
	}

	void Player::set_state(State st)
	{
		if (!attacking)
		{
			Char::set_state(st);

			const PlayerState* pst = get_state(st);

			if (pst)
				pst->initialize(*this);
		}
	}

	bool Player::is_attacking() const
	{
		return attacking;
	}

	bool Player::can_attack() const
	{
		return !attacking && !is_climbing() && !is_sitting() && look.get_equips().has_weapon();
	}

	SpecialMove::ForbidReason Player::can_use(const SpecialMove& move) const
	{
		if (move.is_skill() && state == Char::State::PRONE)
			return SpecialMove::ForbidReason::FBR_OTHER;

		if (move.is_attack() && (state == Char::State::LADDER || state == Char::State::ROPE))
			return SpecialMove::ForbidReason::FBR_OTHER;

		if (has_cooldown(move.get_id()))
			return SpecialMove::ForbidReason::FBR_COOLDOWN;

		int32_t level = skillbook.get_level(move.get_id());
		Weapon::Type weapon = get_weapontype();
		const Job& job = stats.get_job();
		uint16_t hp = stats.get_stat(MapleStat::Id::HP);
		uint16_t mp = stats.get_stat(MapleStat::Id::MP);
		uint16_t bullets = inventory.get_bulletcount();

		return move.can_use(level, weapon, job, hp, mp, bullets);
	}

	Attack Player::prepare_attack(bool skill) const
	{
		Attack::Type attacktype;
		bool degenerate;

		if (state == Char::State::PRONE)
		{
			degenerate = true;
			attacktype = Attack::Type::CLOSE;
		}
		else
		{
			Weapon::Type weapontype;
			weapontype = get_weapontype();

			switch (weapontype)
			{
				case Weapon::Type::BOW:
				case Weapon::Type::CROSSBOW:
				case Weapon::Type::CLAW:
				case Weapon::Type::GUN:
				{
					degenerate = !inventory.has_projectile();
					attacktype = degenerate ? Attack::Type::CLOSE : Attack::Type::RANGED;
					break;
				}
				case Weapon::Type::WAND:
				case Weapon::Type::STAFF:
				{
					degenerate = !skill;
					attacktype = degenerate ? Attack::Type::CLOSE : Attack::Type::MAGIC;
					break;
				}
				default:
				{
					attacktype = Attack::Type::CLOSE;
					degenerate = false;
					break;
				}
			}
		}

		Attack attack;
		attack.type = attacktype;
		attack.mindamage = stats.get_mindamage();
		attack.maxdamage = stats.get_maxdamage();

		if (degenerate)
		{
			attack.mindamage /= 10;
			attack.maxdamage /= 10;
		}

		attack.critical = stats.get_critical();
		attack.ignoredef = stats.get_ignoredef();
		attack.accuracy = stats.get_total(EquipStat::Id::ACC);
		attack.playerlevel = stats.get_stat(MapleStat::Id::LEVEL);
		attack.range = stats.get_range();
		attack.bullet = inventory.get_bulletid();
		attack.origin = get_position();
		attack.toleft = !facing_right;
		attack.speed = get_integer_attackspeed();

		return attack;
	}

	void Player::rush(double targetx)
	{
		if (phobj.onground)
		{
			uint16_t delay = get_attackdelay(1);
			phobj.movexuntil(targetx, delay);
			phobj.set_flag(PhysicsObject::Flag::TURNATEDGES);
		}
	}

	bool Player::is_invincible() const
	{
		if (state == Char::State::DIED)
			return true;

		if (has_buff(Buffstat::Id::DARKSIGHT))
			return true;

		return Char::is_invincible();
	}

	MobAttackResult Player::damage(const MobAttack& attack)
	{
		int32_t damage = stats.calculate_damage(attack.watk);
		show_damage(damage);

		bool fromleft = attack.origin.x() > phobj.get_x();

		bool missed = damage <= 0;
		bool immovable = ladder || state == Char::State::DIED;
		bool knockback = !missed && !immovable;

		if (knockback && randomizer.above(stats.get_stance()))
		{
			phobj.hspeed = fromleft ? -1.5 : 1.5;
			phobj.vforce -= 3.5;
		}

		uint8_t direction = fromleft ? 0 : 1;

		return { attack, damage, direction };
	}

	void Player::give_buff(Buff buff)
	{
		buffs[buff.stat] = buff;
	}

	void Player::cancel_buff(Buffstat::Id stat)
	{
		buffs[stat] = {};
	}

	bool Player::has_buff(Buffstat::Id stat) const
	{
		return buffs[stat].value > 0;
	}

	void Player::change_skill(int32_t skill_id, int32_t skill_level, int32_t masterlevel, int64_t expiration)
	{
		int32_t old_level = skillbook.get_level(skill_id);
		skillbook.set_skill(skill_id, skill_level, masterlevel, expiration);

		if (old_level != skill_level)
			recalc_stats(false);
	}

	void Player::add_cooldown(int32_t skill_id, int32_t cooltime)
	{
		cooldowns[skill_id] = cooltime;
	}

	bool Player::has_cooldown(int32_t skill_id) const
	{
		auto iter = cooldowns.find(skill_id);

		if (iter == cooldowns.end())
			return false;

		return iter->second > 0;
	}

	void Player::change_level(uint16_t level)
	{
		uint16_t oldlevel = get_level();

		if (level > oldlevel)
			show_effect_id(CharEffect::Id::LEVELUP);

		stats.set_stat(MapleStat::Id::LEVEL, level);
	}

	uint16_t Player::get_level() const
	{
		return stats.get_stat(MapleStat::Id::LEVEL);
	}

	int32_t Player::get_skilllevel(int32_t skillid) const
	{
		return skillbook.get_level(skillid);
	}

	void Player::change_job(uint16_t jobid)
	{
		show_effect_id(CharEffect::Id::JOBCHANGE);
		stats.change_job(jobid);
	}

	void Player::set_seat(Optional<const Seat> seat)
	{
		if (seat)
		{
			set_position(seat->getpos());
			set_state(Char::State::SIT);
		}
	}

	void Player::set_ladder(Optional<const Ladder> ldr)
	{
		ladder = ldr;

		if (ladder)
		{
			phobj.set_x(ldr->get_x());

			phobj.hspeed = 0.0;
			phobj.vspeed = 0.0;
			phobj.fhlayer = 7;

			set_state(ldr->is_ladder() ? Char::State::LADDER : Char::State::ROPE);
		}
	}

	void Player::set_climb_cooldown()
	{
		climb_cooldown.set_for(1000);
	}

	bool Player::can_climb()
	{
		return !climb_cooldown;
	}

	float Player::get_walkforce() const
	{
		return 0.05f + 0.11f * static_cast<float>(stats.get_total(EquipStat::Id::SPEED)) / 100;
	}

	float Player::get_jumpforce() const
	{
		return 1.0f + 3.5f * static_cast<float>(stats.get_total(EquipStat::Id::JUMP)) / 100;
	}

	float Player::get_climbforce() const
	{
		return static_cast<float>(stats.get_total(EquipStat::Id::SPEED)) / 100;
	}

	float Player::get_flyforce() const
	{
		return 0.25f;
	}

	bool Player::is_underwater() const
	{
		return underwater;
	}

	bool Player::is_key_down(KeyAction::Id action) const
	{
		return keysdown.count(action) ? keysdown.at(action) : false;
	}

	CharStats& Player::get_stats()
	{
		return stats;
	}

	const CharStats& Player::get_stats() const
	{
		return stats;
	}

	Inventory& Player::get_inventory()
	{
		return inventory;
	}

	const Inventory& Player::get_inventory() const
	{
		return inventory;
	}

	SkillBook& Player::get_skills()
	{
		return skillbook;
	}

	QuestLog& Player::get_quests()
	{
		return questlog;
	}

	TeleportRock& Player::get_teleportrock()
	{
		return teleportrock;
	}

	MonsterBook& Player::get_monsterbook()
	{
		return monsterbook;
	}

	Optional<const Ladder> Player::get_ladder() const
	{
		return ladder;
	}
}

================
File: Character/Player.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "ActiveBuffs.h"
#include "MonsterBook.h"
#include "PassiveBuffs.h"
#include "QuestLog.h"
#include "SkillBook.h"
#include "TeleportRock.h"

#include "Inventory/Inventory.h"

#include "../Gameplay/Playable.h"

#include "../Gameplay/Combat/Skill.h"
#include "../Gameplay/MapleMap/Layer.h"
#include "../Gameplay/MapleMap/MapInfo.h"

namespace ms
{
	class Player : public Playable, public Char
	{
	public:
		// Construct a player object from the given character entry
		Player(const CharEntry& entry);
		Player();

		// Draw the player
		void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
		// Update the player's animation, physics and states.
		int8_t update(const Physics& physics) override;
		// Set flipped ignore if attacking
		void set_direction(bool flipped) override;
		// Set state ignore if attacking
		void set_state(State stance) override;

		// Respawn the player at the given position
		void respawn(Point<int16_t> position, bool underwater);
		// Sends a Keyaction to the player's state, to apply forces, change the state and other behavior.
		void send_action(KeyAction::Id action, bool pressed);
		// Recalculates the total stats from base stats, inventories and skills.
		void recalc_stats(bool equipchanged);
		// Change the equipment at the specified slot and recalculate stats
		void change_equip(int16_t slot);
		// Use the item from the player's inventory with the given id
		void use_item(int32_t itemid);

		// Return if the player is attacking
		bool is_attacking() const;
		// Return whether the player can attack or not
		bool can_attack() const;
		// Return whether the player can use a skill or not
		SpecialMove::ForbidReason can_use(const SpecialMove& move) const;
		// Create an attack struct using the player's stats
		Attack prepare_attack(bool skill) const;

		// Execute a rush movement
		void rush(double targetx);

		// Check whether the player is invincible
		bool is_invincible() const override;
		// Handle an attack to the player
		MobAttackResult damage(const MobAttack& attack);

		// Apply a buff to the player
		void give_buff(Buff buff);
		// Cancel a buff
		void cancel_buff(Buffstat::Id stat);
		// Return whether the buff is active
		bool has_buff(Buffstat::Id stat) const;

		// Change a skill
		void change_skill(int32_t skill_id, int32_t level, int32_t masterlevel, int64_t expiration);
		// Put a skill on cooldown
		void add_cooldown(int32_t skill_id, int32_t time);
		// Check if a skill is on cooldown
		bool has_cooldown(int32_t skill_id) const;

		// Change the player's level, display the "level up" effect.
		void change_level(uint16_t level);
		// Change the player's job, display the job change effect.
		void change_job(uint16_t jobid);

		// Return the character's level
		uint16_t get_level() const override;
		// Return the character's level of a skill
		int32_t get_skilllevel(int32_t skillid) const override;
		// Return the character's attacking speed
		int8_t get_integer_attackspeed() const override;

		// Returns the current walking force, calculated from the total ES_SPEED stat.
		float get_walkforce() const;
		// Returns the current jumping force, calculated from the total ES_JUMP stat.
		float get_jumpforce() const;
		// Returns the climbing force, calculated from the total ES_SPEED stat.
		float get_climbforce() const;
		// Returns the flying force
		float get_flyforce() const;

		// Return whether the player is underwater
		bool is_underwater() const;
		// Returns if a Keyaction is currently active 
		bool is_key_down(KeyAction::Id action) const;
		// Return a pointer to the ladder the player is on
		Optional<const Ladder> get_ladder() const;

		// Change players position to the seat's position and stance to Char::State::SIT
		void set_seat(Optional<const Seat> seat);
		// Change players x-position to the ladder x and change stance to Char::State::LADDER or Char::State::ROPE
		void set_ladder(Optional<const Ladder> ladder);
		// Sets a quick cooldown on climbing so when jumping off a ladder or rope, it doesn't start climb again.
		void set_climb_cooldown();
		// Checks if the player can climb
		bool can_climb();

		// Obtain a reference to the player's stats
		CharStats& get_stats();
		// Obtain a reference to the player's stats
		const CharStats& get_stats() const;
		// Obtain a reference to the player's inventory
		Inventory& get_inventory();
		// Obtain a reference to the player's inventory
		const Inventory& get_inventory() const;
		// Obtain a reference to the player's skills
		SkillBook& get_skills();
		// Obtain a reference to the player's QuestLog
		QuestLog& get_quests();
		// Obtain a reference to the player's TeleportRock locations
		TeleportRock& get_teleportrock();
		// Obtain a reference to the player's MonsterBook
		MonsterBook& get_monsterbook();

	private:
		CharStats stats;
		Inventory inventory;
		SkillBook skillbook;
		QuestLog questlog;
		TeleportRock teleportrock;
		MonsterBook monsterbook;

		EnumMap<Buffstat::Id, Buff> buffs;
		ActiveBuffs active_buffs;
		PassiveBuffs passive_buffs;

		std::unordered_map<int32_t, int32_t> cooldowns;

		std::map<KeyAction::Id, bool> keysdown;

		Movement lastmove;

		Randomizer randomizer;

		Optional<const Ladder> ladder;
		TimedBool climb_cooldown;

		bool underwater;
	};
}

================
File: Character/PlayerStates.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "PlayerStates.h"

namespace ms
{
#pragma region Base
	void PlayerState::play_jumpsound() const
	{
		Sound(Sound::Name::JUMP).play();
	}

	bool PlayerState::haswalkinput(const Player& player) const
	{
		return player.is_key_down(KeyAction::Id::LEFT) || player.is_key_down(KeyAction::Id::RIGHT);
	}

	bool PlayerState::hasleftinput(const Player& player) const
	{
		return player.is_key_down(KeyAction::Id::LEFT) && !player.is_key_down(KeyAction::Id::RIGHT);
	}

	bool PlayerState::hasrightinput(const Player& player) const
	{
		return player.is_key_down(KeyAction::Id::RIGHT) && !player.is_key_down(KeyAction::Id::LEFT);
	}
#pragma endregion

#pragma region Null
	void PlayerNullState::update_state(Player& player) const
	{
		Char::State state;

		if (player.get_phobj().onground)
		{
			if (player.is_key_down(KeyAction::Id::LEFT))
			{
				state = Char::State::WALK;

				player.set_direction(false);
			}
			else if (player.is_key_down(KeyAction::Id::RIGHT))
			{
				state = Char::State::WALK;

				player.set_direction(true);
			}
			else if (player.is_key_down(KeyAction::Id::DOWN))
			{
				state = Char::State::PRONE;
			}
			else
			{
				state = Char::State::STAND;
			}
		}
		else
		{
			Optional<const Ladder> ladder = player.get_ladder();

			if (ladder)
				state = ladder->is_ladder() ? Char::State::LADDER : Char::State::ROPE;
			else
				state = Char::State::FALL;
		}

		player.get_phobj().clear_flags();
		player.set_state(state);
	}
#pragma endregion

#pragma region Standing
	void PlayerStandState::initialize(Player& player) const
	{
		player.get_phobj().type = PhysicsObject::Type::NORMAL;
	}

	void PlayerStandState::send_action(Player& player, KeyAction::Id ka, bool down) const
	{
		if (player.is_attacking())
			return;

		if (down && ka == KeyAction::Id::JUMP)
		{
			play_jumpsound();

			player.get_phobj().vforce = -player.get_jumpforce();
		}
	}

	void PlayerStandState::update(Player& player) const
	{
		if (player.get_phobj().enablejd == false)
			player.get_phobj().set_flag(PhysicsObject::Flag::CHECKBELOW);

		if (player.is_attacking())
			return;

		if (hasrightinput(player))
		{
			player.set_direction(true);
			player.set_state(Char::State::WALK);
		}
		else if (hasleftinput(player))
		{
			player.set_direction(false);
			player.set_state(Char::State::WALK);
		}

		if (player.is_key_down(KeyAction::Id::DOWN) && !player.is_key_down(KeyAction::Id::UP) && !haswalkinput(player))
			player.set_state(Char::State::PRONE);
	}

	void PlayerStandState::update_state(Player& player) const
	{
		if (!player.get_phobj().onground)
			player.set_state(Char::State::FALL);
	}
#pragma endregion

#pragma region Walking
	void PlayerWalkState::initialize(Player& player) const
	{
		player.get_phobj().type = PhysicsObject::Type::NORMAL;
	}

	void PlayerWalkState::send_action(Player& player, KeyAction::Id ka, bool down) const
	{
		if (player.is_attacking())
			return;

		if (down && ka == KeyAction::Id::JUMP)
		{
			play_jumpsound();

			player.get_phobj().vforce = -player.get_jumpforce();
		}

		if (down && ka == KeyAction::Id::JUMP && player.is_key_down(KeyAction::Id::DOWN) && player.get_phobj().enablejd)
		{
			play_jumpsound();

			player.get_phobj().y = player.get_phobj().groundbelow;
			player.set_state(Char::State::FALL);
		}
	}

	void PlayerWalkState::update(Player& player) const
	{
		if (player.get_phobj().enablejd == false)
			player.get_phobj().set_flag(PhysicsObject::Flag::CHECKBELOW);

		if (player.is_attacking())
			return;

		if (haswalkinput(player))
		{
			if (hasrightinput(player))
			{
				player.set_direction(true);
				player.get_phobj().hforce += player.get_walkforce();
			}
			else if (hasleftinput(player))
			{
				player.set_direction(false);
				player.get_phobj().hforce += -player.get_walkforce();
			}
		}
		else
		{
			if (player.is_key_down(KeyAction::Id::DOWN))
				player.set_state(Char::State::PRONE);
		}
	}

	void PlayerWalkState::update_state(Player& player) const
	{
		if (player.get_phobj().onground)
		{
			if (!haswalkinput(player) || player.get_phobj().hspeed == 0.0f)
				player.set_state(Char::State::STAND);
		}
		else
		{
			player.set_state(Char::State::FALL);
		}
	}
#pragma endregion

#pragma region Falling
	void PlayerFallState::initialize(Player& player) const
	{
		player.get_phobj().type = PhysicsObject::Type::NORMAL;
	}

	void PlayerFallState::update(Player& player) const
	{
		if (player.is_attacking())
			return;

		auto& hspeed = player.get_phobj().hspeed;

		if (hasleftinput(player) && hspeed > 0.0)
			hspeed -= 0.025;
		else if (hasrightinput(player) && hspeed < 0.0)
			hspeed += 0.025;

		if (hasleftinput(player))
			player.set_direction(false);
		else if (hasrightinput(player))
			player.set_direction(true);
	}

	void PlayerFallState::update_state(Player& player) const
	{
		if (player.get_phobj().onground)
		{
			if (player.is_key_down(KeyAction::Id::DOWN) && !haswalkinput(player))
				player.set_state(Char::State::PRONE);
			else
				player.set_state(Char::State::STAND);
		}
		else if (player.is_underwater())
		{
			player.set_state(Char::State::SWIM);
		}
	}
#pragma endregion

#pragma region Prone
	void PlayerProneState::send_action(Player& player, KeyAction::Id ka, bool down) const
	{
		if (down && ka == KeyAction::Id::JUMP)
		{
			if (player.get_phobj().enablejd && player.is_key_down(KeyAction::Id::DOWN))
			{
				play_jumpsound();

				player.get_phobj().y = player.get_phobj().groundbelow;
				player.set_state(Char::State::FALL);
			}
		}
	}

	void PlayerProneState::update(Player& player) const
	{
		if (player.get_phobj().enablejd == false)
			player.get_phobj().set_flag(PhysicsObject::Flag::CHECKBELOW);

		if (player.is_key_down(KeyAction::Id::UP) || !player.is_key_down(KeyAction::Id::DOWN))
			player.set_state(Char::State::STAND);

		if (player.is_key_down(KeyAction::Id::LEFT))
		{
			player.set_direction(false);
			player.set_state(Char::State::WALK);
		}

		if (player.is_key_down(KeyAction::Id::RIGHT))
		{
			player.set_direction(true);
			player.set_state(Char::State::WALK);
		}
	}
#pragma endregion

#pragma region Sitting
	void PlayerSitState::send_action(Player& player, KeyAction::Id ka, bool down) const
	{
		if (down)
		{
			switch (ka)
			{
				case KeyAction::Id::LEFT:
					player.set_direction(false);
					player.set_state(Char::State::WALK);
					break;
				case KeyAction::Id::RIGHT:
					player.set_direction(true);
					player.set_state(Char::State::WALK);
					break;
				case KeyAction::Id::JUMP:
					player.set_state(Char::State::STAND);
					break;
			}
		}
	}
#pragma endregion

#pragma region Flying
	void PlayerFlyState::initialize(Player& player) const
	{
		player.get_phobj().type = player.is_underwater() ? PhysicsObject::Type::SWIMMING : PhysicsObject::Type::FLYING;
	}

	void PlayerFlyState::send_action(Player& player, KeyAction::Id ka, bool down) const
	{
		if (down)
		{
			switch (ka)
			{
				case KeyAction::Id::LEFT:
					player.set_direction(false);
					break;
				case KeyAction::Id::RIGHT:
					player.set_direction(true);
					break;
			}
		}
	}

	void PlayerFlyState::update(Player& player) const
	{
		if (player.is_attacking())
			return;

		if (player.is_key_down(KeyAction::Id::LEFT))
			player.get_phobj().hforce = -player.get_flyforce();
		else if (player.is_key_down(KeyAction::Id::RIGHT))
			player.get_phobj().hforce = player.get_flyforce();

		if (player.is_key_down(KeyAction::Id::UP))
			player.get_phobj().vforce = -player.get_flyforce();
		else if (player.is_key_down(KeyAction::Id::DOWN))
			player.get_phobj().vforce = player.get_flyforce();
	}

	void PlayerFlyState::update_state(Player& player) const
	{
		if (player.get_phobj().onground && player.is_underwater())
		{
			Char::State state;

			if (player.is_key_down(KeyAction::Id::LEFT))
			{
				state = Char::State::WALK;

				player.set_direction(false);
			}
			else if (player.is_key_down(KeyAction::Id::RIGHT))
			{
				state = Char::State::WALK;

				player.set_direction(true);
			}
			else if (player.is_key_down(KeyAction::Id::DOWN))
			{
				state = Char::State::PRONE;
			}
			else
			{
				state = Char::State::STAND;
			}

			player.set_state(state);
		}
	}
#pragma endregion

#pragma region Climbing
	void PlayerClimbState::initialize(Player& player) const
	{
		player.get_phobj().type = PhysicsObject::Type::FIXATED;
	}

	void PlayerClimbState::update(Player& player) const
	{
		if (player.is_key_down(KeyAction::Id::UP) && !player.is_key_down(KeyAction::Id::DOWN))
		{
			player.get_phobj().vspeed = -player.get_climbforce();
		}
		else if (player.is_key_down(KeyAction::Id::DOWN) && !player.is_key_down(KeyAction::Id::UP))
		{
			player.get_phobj().vspeed = player.get_climbforce();
		}
		else
		{
			player.get_phobj().vspeed = 0.0;
		}

		if (player.is_key_down(KeyAction::Id::JUMP) && haswalkinput(player))
		{
			play_jumpsound();

			const auto& walkforce = player.get_walkforce() * 8.0;

			player.set_direction(player.is_key_down(KeyAction::Id::RIGHT));

			player.get_phobj().hspeed = player.is_key_down(KeyAction::Id::LEFT) ? -walkforce : walkforce;
			player.get_phobj().vspeed = -player.get_jumpforce() / 1.5;

			cancel_ladder(player);
		}
	}

	void PlayerClimbState::update_state(Player& player) const
	{
		int16_t y = player.get_phobj().get_y();
		bool downwards = player.is_key_down(KeyAction::Id::DOWN);
		auto ladder = player.get_ladder();

		if (ladder && ladder->felloff(y, downwards))
			cancel_ladder(player);
	}

	void PlayerClimbState::cancel_ladder(Player& player) const
	{
		player.set_state(Char::State::FALL);
		player.set_ladder(nullptr);
		player.set_climb_cooldown();
	}
#pragma endregion
}

================
File: Character/PlayerStates.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Player.h"

namespace ms
{
	// Base class for player states
	class PlayerState
	{
	public:
		virtual ~PlayerState() {}

		// Actions taken when transitioning into the state
		virtual void initialize(Player& player) const = 0;
		// How to handle inputs while in the state
		virtual void send_action(Player& player, KeyAction::Id action, bool pressed) const = 0;
		// Actions taken in the player's update method, before physics are applied.
		virtual void update(Player& player) const = 0;
		// Transition into a new state after physics have been applied
		virtual void update_state(Player& player) const = 0;

	protected:
		// Play the jumping sound
		void play_jumpsound() const;
		// Check if the left or right key is pressed
		bool haswalkinput(const Player& player) const;
		// Check if only the left key is pressed and not the right key
		bool hasleftinput(const Player& player) const;
		// Check if only the right key is pressed and not the left key
		bool hasrightinput(const Player& player) const;
	};

	// The initial state, determines which state the player should be in.
	class PlayerNullState : public PlayerState
	{
	public:
		void initialize(Player&) const override {}
		void send_action(Player&, KeyAction::Id, bool) const override {}
		void update(Player&) const override {}

		void update_state(Player& player) const override;
	};

	// The standing state
	class PlayerStandState : public PlayerState
	{
	public:
		void initialize(Player& player) const override;
		void send_action(Player& player, KeyAction::Id ka, bool down) const override;
		void update(Player&) const override;
		void update_state(Player& player) const override;
	};

	// The walking state
	class PlayerWalkState : public PlayerState
	{
		void initialize(Player& player) const override;
		void send_action(Player& player, KeyAction::Id ka, bool down) const override;
		void update(Player& player) const override;
		void update_state(Player& player) const override;
	};

	// The falling state
	class PlayerFallState : public PlayerState
	{
	public:
		void initialize(Player& player) const override;

		void send_action(Player& player, KeyAction::Id ka, bool down) const override {}
		void update(Player& player) const override;

		void update_state(Player& player) const override;
	};

	// The prone state (Lying down)
	class PlayerProneState : public PlayerState
	{
	public:
		void initialize(Player&) const override {}

		void send_action(Player& player, KeyAction::Id ka, bool down) const override;
		void update(Player&) const override;

		void update_state(Player&) const override {}
	};

	// The sitting state
	class PlayerSitState : public PlayerState
	{
	public:
		void initialize(Player&) const override {}

		void send_action(Player& player, KeyAction::Id ka, bool down) const override;

		void update(Player&) const override {}
		void update_state(Player&) const override {}
	};

	// The flying or swimming state
	class PlayerFlyState : public PlayerState
	{
		void initialize(Player& player) const override;
		void send_action(Player& player, KeyAction::Id ka, bool down) const override;
		void update(Player& player) const override;
		void update_state(Player& player) const override;
	};

	// The climbing state
	class PlayerClimbState : public PlayerState
	{
	public:
		void initialize(Player& player) const override;
		void send_action(Player&, KeyAction::Id, bool) const override {}
		void update(Player& player) const override;
		void update_state(Player& player) const override;

	private:
		void cancel_ladder(Player& player) const;
	};
}

================
File: Character/QuestLog.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "QuestLog.h"

namespace ms
{
	void QuestLog::add_started(int16_t qid, const std::string& qdata)
	{
		started[qid] = qdata;
	}

	void QuestLog::add_in_progress(int16_t qid, int16_t qidl, const std::string& qdata)
	{
		in_progress[qid] = make_pair(qidl, qdata);
	}

	void QuestLog::add_completed(int16_t qid, int64_t time)
	{
		completed[qid] = time;
	}

	bool QuestLog::is_started(int16_t qid)
	{
		return started.count(qid) > 0;
	}

	int16_t QuestLog::get_last_started()
	{
		auto qend = started.end();
		qend--;

		return qend->first;
	}
}

================
File: Character/QuestLog.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <map>

namespace ms
{
	// Class that stores information on the quest log of an individual character
	class QuestLog
	{
	public:
		void add_started(int16_t, const std::string& quest_data);
		void add_in_progress(int16_t, int16_t, const std::string& quest_data);
		void add_completed(int16_t, int64_t);
		bool is_started(int16_t);
		int16_t get_last_started();

	private:
		std::map<int16_t, std::string> started;
		std::map<int16_t, std::pair<int16_t, std::string>> in_progress;
		std::map<int16_t, int64_t> completed;
	};
}

================
File: Character/SkillBook.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "SkillBook.h"

#include "../Data/SkillData.h"

namespace ms
{
	void SkillBook::set_skill(int32_t id, int32_t level, int32_t mlevel, int64_t expire)
	{
		skillentries[id] = { level, mlevel, expire };
	}

	bool SkillBook::has_skill(int32_t id) const
	{
		return skillentries.count(id) > 0;
	}

	int32_t SkillBook::get_level(int32_t id) const
	{
		auto iter = skillentries.find(id);

		if (iter == skillentries.end())
			return 0;

		return iter->second.level;
	}

	int32_t SkillBook::get_masterlevel(int32_t id) const
	{
		auto iter = skillentries.find(id);

		if (iter == skillentries.end())
			return 0;

		return iter->second.masterlevel;
	}

	int64_t SkillBook::get_expiration(int32_t id) const
	{
		auto iter = skillentries.find(id);

		if (iter == skillentries.end())
			return 0;

		return iter->second.expiration;
	}

	std::map<int32_t, int32_t> SkillBook::collect_passives() const
	{
		std::map<int32_t, int32_t> passives;

		for (auto& iter : skillentries)
			if (SkillData::get(iter.first).is_passive())
				passives.emplace(iter.first, iter.second.level);

		return passives;
	}

	std::unordered_map<int32_t, int32_t> SkillBook::collect_required(int32_t id) const
	{
		auto iter = skillentries.find(id);

		if (iter == skillentries.end())
			return {};

		return SkillData::get(iter->first).get_reqskills();
	}
}

================
File: Character/SkillBook.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <map>
#include <unordered_map>

namespace ms
{
	// Class that stores all information about the skills of an individual character
	class SkillBook
	{
	public:
		void set_skill(int32_t id, int32_t level, int32_t masterlevel, int64_t expiration);

		bool has_skill(int32_t id) const;
		int32_t get_level(int32_t id) const;
		int32_t get_masterlevel(int32_t id) const;
		int64_t get_expiration(int32_t id) const;

		// Return id and level of all passive skills
		// An ordered map is used so that lower passive skills don't override higher ones
		std::map<int32_t, int32_t> collect_passives() const;

		// Return id and level of all required skills
		std::unordered_map<int32_t, int32_t> collect_required(int32_t id) const;

	private:
		struct SkillEntry
		{
			int32_t level;
			int32_t masterlevel;
			int64_t expiration;
		};

		std::unordered_map<int32_t, SkillEntry> skillentries;
	};
}

================
File: Character/SkillId.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

namespace ms
{
	namespace SkillId
	{
		enum Id : uint32_t
		{
			// Beginner
			FOLLOW_THE_LEAD = 8,
			ANGEL_BLESSING = 12,
			THREE_SNAILS = 1000,
			HEAL = 1001,
			FEATHER = 1002,
			LEGENDARY_SPIRIT = 1003,
			MONSTER_RIDER = 1004,
			ECHO_OF_THE_HERO = 1005,

			// Swordman
			IMPROVED_HP_RECOVERY = 1000000,
			IMPROVED_MAX_HP = 1000001,
			IMPROVED_LADDER_RECOVERY = 1000002,
			IRON_BODY = 1001003,
			POWER_STRIKE = 1001004,
			SLASH_BLAST = 1001005,

			// Fighter
			SWORD_MASTERY_FIGHTER = 1100000,
			AXE_MASTERY = 1100001,
			SWORD_FA_FIGHTER = 1100002,
			AXE_FA = 1100003,
			SWORD_BOOSTER_FIGHTER = 1101004,
			AXE_BOOSTER = 1101005,
			RAGE = 1101006,
			POWER_GUARD_FIGHTER = 1101007,

			// Crusader
			IMPROVED_MP_RECOVERY_CRUSADER = 1110000,
			SHIELD_MASTERY = 1110001,
			SWORD_PANIC = 1111003,
			AXE_PANIC = 1111004,
			SWORD_COMA = 1111005,
			AXE_COMA = 1111005,
			SHOUT = 1111008,

			// Hero
			ADVANCED_COMBO_ATTACK = 1120003,
			ACHILLES_HERO = 1120004,
			GUARDIAN_HERO = 1120005,
			RUSH_HERO = 1121006,
			BRANDISH = 1121008,

			// Page
			SWORD_MASTERY_PAGE = 1200000,
			BW_MASTERY = 1200001,
			SWORD_FA_PAGE = 1200002,
			BW_FA = 1200003,
			SWORD_BOOSTER_PAGE = 1201004,
			BW_BOOSTER = 1201005,
			THREATEN = 1201006,
			POWER_GUARD_PAGE = 1201007,

			// White Knight
			CHARGE = 1211002,

			// Paladin
			ACHILLES_PALADIN = 1220005,
			GUARDIAN_PALADIN = 1220006,
			ADVANCED_CHARGE = 1220010,
			RUSH_PALADIN = 1221007,
			BLAST = 1221009,
			HEAVENS_HAMMER = 1221011,

			// Spearman
			SPEAR_MASTERY = 1300000,
			PA_MASTERY = 1300001,
			SPEAR_FA = 1300002,
			PA_FA = 1300003,
			SPEAR_BOOSTER = 1301004,
			PA_BOOSTER = 1301005,
			IRON_WILL = 1301006,
			HYPER_BODY = 1301007,

			// Dragon Knight
			DRAGON_BUSTER = 1311001,
			DRAGON_FURY = 1311002,
			PA_BUSTER = 1311003,
			PA_FURY = 1311004,
			SACRIFICE = 1311005,
			DRAGONS_ROAR = 1311006,

			// Dark Knight
			ACHILLES_DK = 1320005,
			BERSERK = 1320006,
			BEHOLDER_HEAL = 1320008,
			BEHOLDER_BUFF = 1320009,
			RUSH_DK = 1321003,
			BEHOLDER = 1321007,

			// Magician
			IMPROVE_HP_RECOVERY = 2000000,
			IMPROVE_MAX_HP = 2000001,
			MAGIC_GUARD = 2001002,
			MAGIC_ARMOR = 2001003,
			ENERGY_BOLT = 2001004,
			MAGIC_CLAW = 2001005,

			// F/P Mage
			MP_EATER_FP = 2100000,
			MEDITATION_FP = 2101001,
			TELEPORT_FP = 2101002,
			SLOW_FP = 2101003,
			FIRE_ARROW = 2101004,
			POISON_BREATH = 2101005,

			// F/P Archmage
			PARTIAL_RESISTANCE_FP = 2110000,
			ELEMENT_AMPLIFICATION_FP = 2110001,
			EXPLOSION = 2111002,
			POISON_MIST = 2111003,
			SEAL_FP = 2111004,
			SPELL_BOOSTER_FP = 2111005,
			ELEMENT_COMPOSITION_FP = 2111006,

			// TODO: ?
			FIRE_DEMON = 2121003,
			ELQUINES = 2121005,
			PARALYZE = 2121006,
			METEOR_SHOWER = 2121007,

			// I/L Mage
			IL_TELEPORT = 2201002,

			// Priest
			PRIEST_TELEPORT = 2301001,

			// Hermit
			AVENGER = 4111005,
			FLASH_JUMP = 4111006,

			// Night Lord
			TRIPLE_THROW = 4121007,

			// Bandit
			MESO_EXPLOSION = 4211006
		};
	}
}

================
File: Character/StatCaps.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <unordered_map>

namespace ms
{
	// Externalizing this for easier configurability
	const std::unordered_map<EquipStat::Id, int32_t> EQSTAT_CAPS =
	{
		{ EquipStat::Id::STR,	999		},
		{ EquipStat::Id::DEX,	999		},
		{ EquipStat::Id::INT,	999		},
		{ EquipStat::Id::LUK,	999		},
		{ EquipStat::Id::HP,	30000	},
		{ EquipStat::Id::MP,	30000	},
		{ EquipStat::Id::WATK,	999		},
		{ EquipStat::Id::MAGIC,	2000	},
		{ EquipStat::Id::WDEF,	999		},
		{ EquipStat::Id::MDEF,	999		},
		{ EquipStat::Id::ACC,	999		},
		{ EquipStat::Id::AVOID,	999		},
		{ EquipStat::Id::HANDS,	999		},
		{ EquipStat::Id::SPEED,	140		},
		{ EquipStat::Id::JUMP,	123		},
	};
}

================
File: Character/TeleportRock.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "TeleportRock.h"

namespace ms
{
	void TeleportRock::addlocation(int32_t mapid)
	{
		locations.push_back(mapid);
	}

	void TeleportRock::addviplocation(int32_t mapid)
	{
		viplocations.push_back(mapid);
	}
}

================
File: Character/TeleportRock.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <vector>

namespace ms
{
	// Saved locations for the 'teleport rock' and 'VIP teleport rock' cash items
	class TeleportRock
	{
	public:
		void addlocation(int32_t);
		void addviplocation(int32_t);

	private:
		std::vector<int32_t> locations;
		std::vector<int32_t> viplocations;
	};
}

================
File: Configuration.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Configuration.h"

#include "Util/Misc.h"

#include <fstream>

namespace ms
{
	Configuration::Configuration()
	{
		settings.emplace<ServerIP>();
		settings.emplace<ServerPort>();
		settings.emplace<Fullscreen>();
		settings.emplace<Width>();
		settings.emplace<Height>();
		settings.emplace<VSync>();
		settings.emplace<FontPathNormal>();
		settings.emplace<FontPathBold>();
		settings.emplace<BGMVolume>();
		settings.emplace<SFXVolume>();
		settings.emplace<SaveLogin>();
		settings.emplace<DefaultAccount>();
		settings.emplace<DefaultWorld>();
		settings.emplace<DefaultChannel>();
		settings.emplace<DefaultRegion>();
		settings.emplace<DefaultCharacter>();
		settings.emplace<ChatViewMax>();
		settings.emplace<ChatViewX>();
		settings.emplace<ChatViewY>();
		settings.emplace<PosSTATS>();
		settings.emplace<PosEQINV>();
		settings.emplace<PosINV>();
		settings.emplace<PosSKILL>();
		settings.emplace<PosQUEST>();
		settings.emplace<PosMAP>();
		settings.emplace<PosUSERLIST>();
		settings.emplace<PosCHAT>();
		settings.emplace<PosMINIMAP>();
		settings.emplace<PosSHOP>();
		settings.emplace<PosNOTICE>();
		settings.emplace<PosMAPLECHAT>();
		settings.emplace<PosCHANNEL>();
		settings.emplace<PosJOYPAD>();
		settings.emplace<PosEVENT>();
		settings.emplace<PosKEYCONFIG>();
		settings.emplace<PosOPTIONMENU>();
		settings.emplace<PosCHARINFO>();
		settings.emplace<MiniMapType>();
		settings.emplace<MiniMapSimpleMode>();
		settings.emplace<MiniMapDefaultHelpers>();

		load();
	}

	Configuration::~Configuration()
	{
#ifndef _DEBUG
		save();
#endif
	}

	void Configuration::load()
	{
		std::unordered_map<std::string, std::string> rawsettings;
		std::ifstream file(FILENAME);

		if (file.is_open())
		{
			// Go through the file line by line
			std::string line;

			while (getline(file, line))
			{
				// If the setting is not empty, load the value.
				size_t split = line.find('=');

				if (split != std::string::npos && split + 2 < line.size())
				{
					rawsettings.emplace(
						line.substr(0, split - 1),
						line.substr(split + 2)
					);
				}
			}
		}

		// Replace default values with loaded values
		for (auto& setting : settings)
		{
			auto rsiter = rawsettings.find(setting.second->name);

			if (rsiter != rawsettings.end())
				setting.second->value = rsiter->second;
		}
	}

	void Configuration::save() const
	{
		// Open the settings file
		std::ofstream config(FILENAME);

		if (config.is_open())
		{
			// Save settings line by line
			for (auto& setting : settings)
				config << setting.second->to_string() << std::endl;
		}
	}

	void Configuration::BoolEntry::save(bool b)
	{
		value = b ? "true" : "false";
	}

	bool Configuration::BoolEntry::load() const
	{
		return value == "true";
	}

	void Configuration::StringEntry::save(std::string str)
	{
		value = str;
	}

	std::string Configuration::StringEntry::load() const
	{
		return value;
	}

	void Configuration::PointEntry::save(Point<int16_t> vec)
	{
		value = vec.to_string();
	}

	Point<int16_t> Configuration::PointEntry::load() const
	{
		std::string xstr = value.substr(1, value.find(",") - 1);
		std::string ystr = value.substr(value.find(",") + 1, value.find(")") - value.find(",") - 1);

		auto x = string_conversion::or_zero<int16_t>(xstr);
		auto y = string_conversion::or_zero<int16_t>(ystr);

		return { x, y };
	}

	bool Configuration::get_show_fps() const
	{
		return SHOW_FPS;
	}

	bool Configuration::get_show_packets() const
	{
		return SHOW_PACKETS;
	}

	bool Configuration::get_auto_login() const
	{
#ifdef NDEBUG
		return false;
#endif

		return AUTO_LOGIN;
	}

	uint8_t Configuration::get_auto_world()
	{
		return auto_world;
	}

	uint8_t Configuration::get_auto_channel()
	{
		return auto_channel;
	}

	std::string Configuration::get_auto_acc()
	{
		return auto_acc;
	}

	std::string Configuration::get_auto_pass()
	{
		return auto_pass;
	}

	std::string Configuration::get_auto_pic()
	{
		return auto_pic;
	}

	int32_t Configuration::get_auto_cid()
	{
		return auto_cid;
	}

	std::string Configuration::get_title() const
	{
		return TITLE;
	}

	std::string Configuration::get_version() const
	{
		return VERSION;
	}

	std::string Configuration::get_login_music() const
	{
		return LoginMusic;
	}

	std::string Configuration::get_login_music_sea() const
	{
		return LoginMusicSEA;
	}

	std::string Configuration::get_login_music_newtro() const
	{
		return LoginMusicNewtro;
	}

	std::string Configuration::get_joinlink() const
	{
		return JOINLINK;
	}

	std::string Configuration::get_website() const
	{
		return WEBSITE;
	}

	std::string Configuration::get_findid() const
	{
		return FINDID;
	}

	std::string Configuration::get_findpass() const
	{
		return FINDPASS;
	}

	std::string Configuration::get_resetpic() const
	{
		return RESETPIC;
	}

	std::string Configuration::get_chargenx() const
	{
		return CHARGENX;
	}

	void Configuration::set_macs(char* macs)
	{
		MACS = macs;
	}

	void Configuration::set_hwid(char* hwid, char* volumeSerialNumber)
	{
		VolumeSerialNumber = volumeSerialNumber;

		std::string newHWID;

		newHWID.append(hwid);
		newHWID.append("_");

		std::string part1 = VolumeSerialNumber.substr(0, 2);
		std::string part2 = VolumeSerialNumber.substr(2, 2);
		std::string part3 = VolumeSerialNumber.substr(4, 2);
		std::string part4 = VolumeSerialNumber.substr(6, 2);

		// TODO: VolumeSerialNumber was not eight characters long, added fix for last part.
		// TODO: Need to look into why the VolumeSerialNumber was seven characters long
		part4 = string_format::pad_string(part4, 2);

		newHWID.append(part4);
		newHWID.append(part3);
		newHWID.append(part2);
		newHWID.append(part1);

		HWID = newHWID;
	}

	void Configuration::set_max_width(int16_t max_width)
	{
		MAXWIDTH = max_width;
	}

	void Configuration::set_max_height(int16_t max_height)
	{
		MAXHEIGHT = max_height;
	}

	std::string Configuration::get_macs()
	{
		return MACS;
	}

	std::string Configuration::get_hwid()
	{
		return HWID;
	}

	std::string Configuration::get_vol_serial_num()
	{
		return VolumeSerialNumber;
	}

	int16_t Configuration::get_max_width()
	{
		return MAXWIDTH;
	}

	int16_t Configuration::get_max_height()
	{
		return MAXHEIGHT;
	}

	bool Configuration::get_rightclicksell()
	{
		return rightclicksell;
	}

	void Configuration::set_rightclicksell(bool value)
	{
		rightclicksell = value;
	}

	bool Configuration::get_show_weekly()
	{
		return show_weekly;
	}

	void Configuration::set_show_weekly(bool value)
	{
		show_weekly = value;
	}

	bool Configuration::get_start_shown()
	{
		return start_shown;
	}

	void Configuration::set_start_shown(bool value)
	{
		start_shown = value;
	}

	uint8_t Configuration::get_worldid()
	{
		return worldid;
	}

	void Configuration::set_worldid(uint8_t id)
	{
		worldid = id;
	}

	uint8_t Configuration::get_channelid()
	{
		return channelid;
	}

	void Configuration::set_channelid(uint8_t id)
	{
		channelid = id;
	}

	bool Configuration::get_admin()
	{
		return admin;
	}

	void Configuration::set_admin(bool value)
	{
		admin = value;
	}

	bool Configuration::get_caps_lock_enabled()
	{
		return caps_lock_enabled;
	}

	void Configuration::set_caps_lock_enabled(int value)
	{
		caps_lock_enabled = value;
	}
}

================
File: Configuration.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Template/Singleton.h"
#include "Template/TypeMap.h"
#include "Util/Misc.h"

namespace ms
{
	// Manages the 'Settings' file which contains configurations set by user behavior
	class Configuration : public Singleton<Configuration>
	{
	public:
		// Add the settings which will be used and load them
		Configuration();
		// Save
		~Configuration();

		// Load all settings
		// If something is missing, set the default value.
		// Can be used for reloading
		void load();
		// Save the current settings 
		void save() const;
		// Get private member SHOW_FPS
		bool get_show_fps() const;
		// Get private member SHOW_PACKETS
		bool get_show_packets() const;
		// Get private member AUTO_LOGIN
		bool get_auto_login() const;
		// Get the world to login with
		uint8_t get_auto_world();
		// Get the channel to login with
		uint8_t get_auto_channel();
		// Get the account to login with
		std::string get_auto_acc();
		// Get the password to login with
		std::string get_auto_pass();
		// Get the pic to login with
		std::string get_auto_pic();
		// Get the character id to login with
		int32_t get_auto_cid();
		// Get private member TITLE
		std::string get_title() const;
		// Get private member VERSION
		std::string get_version() const;
		// Get private member LoginMusic
		std::string get_login_music() const;
		// Get private member LoginMusicSEA
		std::string get_login_music_sea() const;
		// Get private member LoginMusicNewtro
		std::string get_login_music_newtro() const;
		// Get private member JOINLINK
		std::string get_joinlink() const;
		// Get private member WEBSITE
		std::string get_website() const;
		// Get private member FINDID
		std::string get_findid() const;
		// Get private member FINDPASS
		std::string get_findpass() const;
		// Get private member RESETPIC
		std::string get_resetpic() const;
		// Get private member CHARGENX
		std::string get_chargenx() const;
		// Set private member MACS
		void set_macs(char* macs);
		// Set private member HWID
		void set_hwid(char* hwid, char* volumeSerialNumber);
		// Set private member MAXWIDTH
		void set_max_width(int16_t max_width);
		// Set private member MAXHEIGHT
		void set_max_height(int16_t max_height);
		// Get private member MACS
		std::string get_macs();
		// Get private member HWID
		std::string get_hwid();
		// Get the Hard Drive Volume Serial Number
		std::string get_vol_serial_num();
		// Get the max width allowed
		int16_t get_max_width();
		// Get the max height allowed
		int16_t get_max_height();
		// Get the shop's "Right-click to sell item" boolean
		bool get_rightclicksell();
		// Set the shop's "Right-click to sell item" boolean
		void set_rightclicksell(bool value);
		// Whether to show the weekly maple star in Maple Chat
		bool get_show_weekly();
		// Set whether to show the weekly maple star in Maple Chat
		void set_show_weekly(bool value);
		// Whether to show the start screen
		bool get_start_shown();
		// Set whether to show the start screen
		void set_start_shown(bool value);
		// Get the character's selected world
		uint8_t get_worldid();
		// Set the character's selected world
		void set_worldid(uint8_t id);
		// Get the character's selected channel
		uint8_t get_channelid();
		// Set the character's selected channel
		void set_channelid(uint8_t id);
		// Check if the current account is an admin account
		bool get_admin();
		// Set whether the current account is an admin account
		void set_admin(bool value);
		// Check if the Caps Lock key is enabled
		bool get_caps_lock_enabled();
		// Set if the Caps Lock key is enabled
		void set_caps_lock_enabled(int value);

		// Base class for an entry in the settings file
		class Entry
		{
		protected:
			Entry(const char* n, const char* v) : name(n), value(v) {}

			std::string name;
			std::string value;

		private:
			friend class Configuration;

			std::string to_string() const
			{
				return name + " = " + value;
			}
		};

		// Setting which converts to a boolean
		class BoolEntry : public Entry
		{
		public:
			void save(bool b);
			bool load() const;

		protected:
			using Entry::Entry;
		};

		// Setting which uses the raw string
		class StringEntry : public Entry
		{
		public:
			void save(std::string str);
			std::string load() const;

		protected:
			using Entry::Entry;
		};

		// Setting which converts to a Point<int16_t>
		class PointEntry : public Entry
		{
		public:
			void save(Point<int16_t> p);
			Point<int16_t> load() const;

		protected:
			using Entry::Entry;
		};

		// Setting which converts to an integer type
		template <class T>
		class IntegerEntry : public Entry
		{
		public:
			void save(T num)
			{
				value = std::to_string(num);
			}

			T load() const
			{
				return string_conversion::or_zero<T>(value);
			}

		protected:
			using Entry::Entry;
		};

		// Setting which converts to a byte
		class ByteEntry : public IntegerEntry<uint8_t>
		{
		protected:
			using IntegerEntry::IntegerEntry;
		};

		// Setting which converts to a short
		class ShortEntry : public IntegerEntry<uint16_t>
		{
		protected:
			using IntegerEntry::IntegerEntry;
		};

		// Setting which converts to an int
		class IntEntry : public IntegerEntry<uint32_t>
		{
		protected:
			using IntegerEntry::IntegerEntry;
		};

		// Setting which converts to a long
		class LongEntry : public IntegerEntry<uint64_t>
		{
		protected:
			using IntegerEntry::IntegerEntry;
		};

	private:
		template <typename T>
		friend struct Setting;

		const char* FILENAME = "Settings";
		const char* TITLE = "MapleStory";
		const char* VERSION = "228.3";
		const char* LoginMusic = "BgmUI.img/Title";
		const char* LoginMusicSEA = "BgmGL.img/OldMaple";
		const char* LoginMusicNewtro = "BgmEvent2.img/Newtro_Login";
		const char* JOINLINK = "https://www.nexon.com/account/en/create";
		const char* WEBSITE = "http://maplestory.nexon.net/";
		const char* FINDID = "https://www.nexon.com/account/en/login";
		const char* FINDPASS = "https://www.nexon.com/account/en/reset-password";
		const char* RESETPIC = "https://www.nexon.com/account/en/login";
		const char* CHARGENX = "https://billing.nexon.net/PurchaseNX";
		const bool SHOW_FPS = false;
		const bool SHOW_PACKETS = false;
		const bool AUTO_LOGIN = false;
		const uint8_t auto_world = 0;
		const uint8_t auto_channel = 0;
		const std::string auto_acc = "";
		const std::string auto_pass = "";
		const std::string auto_pic = "";
		const int32_t auto_cid = 0;
		bool rightclicksell = false;
		bool show_weekly = true;
		bool start_shown = false;
		std::string MACS;
		std::string HWID;
		int16_t MAXWIDTH;
		int16_t MAXHEIGHT;
		std::string VolumeSerialNumber;
		uint8_t worldid;
		uint8_t channelid;
		bool admin;
		bool caps_lock_enabled;
		TypeMap<Entry> settings;
	};

	// IP Address which the client will connect to
	struct ServerIP : public Configuration::StringEntry
	{
		ServerIP() : StringEntry("ServerIP", "127.0.0.1") {}
	};

	// Port which the client will connect to
	struct ServerPort : public Configuration::StringEntry
	{
		ServerPort() : StringEntry("ServerPort", "8484") {}
	};

	// Whether to start in full screen mode
	struct Fullscreen : public Configuration::BoolEntry
	{
		Fullscreen() : BoolEntry("Fullscreen", "false") {}
	};

	// The width of the screen
	struct Width : public Configuration::ShortEntry
	{
		Width() : ShortEntry("Width", "800") {}
	};

	// The height of the screen
	struct Height : public Configuration::ShortEntry
	{
		Height() : ShortEntry("Height", "600") {}
	};

	// Whether to use VSync
	struct VSync : public Configuration::BoolEntry
	{
		VSync() : BoolEntry("VSync", "true") {}
	};

	// The normal font which will be used
	struct FontPathNormal : public Configuration::StringEntry
	{
		FontPathNormal() : StringEntry("FontPathNormal", "fonts/Arial/Arial.ttf") {}
	};

	// The bold font which will be used
	struct FontPathBold : public Configuration::StringEntry
	{
		FontPathBold() : StringEntry("FontPathBold", "fonts/Arial/Arial-Bold.ttf") {}
	};

	// Music Volume
	// Number from 0 to 100
	struct BGMVolume : public Configuration::ByteEntry
	{
		BGMVolume() : ByteEntry("BGMVolume", "50") {}
	};

	// Sound Volume
	// Number from 0 to 100
	struct SFXVolume : public Configuration::ByteEntry
	{
		SFXVolume() : ByteEntry("SFXVolume", "50") {}
	};

	// Whether to save the last used account name
	struct SaveLogin : public Configuration::BoolEntry
	{
		SaveLogin() : BoolEntry("SaveLogin", "false") {}
	};

	// The last used account name
	struct DefaultAccount : public Configuration::StringEntry
	{
		DefaultAccount() : StringEntry("Account", "") {}
	};

	// The last used world
	struct DefaultWorld : public Configuration::ByteEntry
	{
		DefaultWorld() : ByteEntry("World", "0") {}
	};

	// The last used channel
	struct DefaultChannel : public Configuration::ByteEntry
	{
		DefaultChannel() : ByteEntry("Channel", "0") {}
	};

	// The last used region
	struct DefaultRegion : public Configuration::ByteEntry
	{
		DefaultRegion() : ByteEntry("Region", "5") {}
	};

	// The last used character
	struct DefaultCharacter : public Configuration::ByteEntry
	{
		DefaultCharacter() : ByteEntry("Character", "0") {}
	};

	// Whether the UIChatBar is expanded or not
	struct ChatViewMax : public Configuration::BoolEntry
	{
		ChatViewMax() : BoolEntry("ChatViewMax", "false") {}
	};

	// The user defined width for UIChatBar
	struct ChatViewX : public Configuration::ShortEntry
	{
		ChatViewX() : ShortEntry("ChatViewX", "0") {}
	};

	// The user defined height for UIChatBar
	struct ChatViewY : public Configuration::ShortEntry
	{
		ChatViewY() : ShortEntry("ChatViewY", "0") {}
	};

	// The default position of UIStatsInfo
	struct PosSTATS : public Configuration::PointEntry
	{
		PosSTATS() : PointEntry("PosSTATS", "(72,72)") {}
	};

	// The default position of UIEquipInventory
	struct PosEQINV : public Configuration::PointEntry
	{
		PosEQINV() : PointEntry("PosEQINV", "(250,160)") {}
	};

	// The default position of UIItemInventory
	struct PosINV : public Configuration::PointEntry
	{
		PosINV() : PointEntry("PosINV", "(24,24)") {}
	};

	// The default position of UISkillBook
	struct PosSKILL : public Configuration::PointEntry
	{
		PosSKILL() : PointEntry("PosSKILL", "(96,96)") {}
	};

	// The default position of UIQuestLog
	struct PosQUEST : public Configuration::PointEntry
	{
		PosQUEST() : PointEntry("PosQUEST", "(300,160)") {}
	};

	// The default position of UIWorldMap
	struct PosMAP : public Configuration::PointEntry
	{
		PosMAP() : PointEntry("PosMAP", "(100,35)") {}
	};

	// The default position of UIUserList
	struct PosUSERLIST : public Configuration::PointEntry
	{
		PosUSERLIST() : PointEntry("PosUSERLIST", "(104, 104)") {}
	};

	// The default position of UIChatBar
	struct PosCHAT : public Configuration::PointEntry
	{
		PosCHAT() : PointEntry("PosCHAT", "(0, 572)") {}
	};

	// The default position of UIMiniMap
	struct PosMINIMAP : public Configuration::PointEntry
	{
		PosMINIMAP() : PointEntry("PosMINIMAP", "(0, 0)") {}
	};

	// The default position of UIShop
	struct PosSHOP : public Configuration::PointEntry
	{
		PosSHOP() : PointEntry("PosSHOP", "(146, 48)") {}
	};

	// The default position of UINotice
	struct PosNOTICE : public Configuration::PointEntry
	{
		PosNOTICE() : PointEntry("PosNOTICE", "(400, 285)") {}
	};

	// The default position of UIChat and UIRank
	struct PosMAPLECHAT : public Configuration::PointEntry
	{
		PosMAPLECHAT() : PointEntry("PosMAPLECHAT", "(50, 46)") {}
	};

	// The default position of UIChannel
	struct PosCHANNEL : public Configuration::PointEntry
	{
		PosCHANNEL() : PointEntry("PosCHANNEL", "(215, 100)") {}
	};

	// The default position of UIJoypad
	struct PosJOYPAD : public Configuration::PointEntry
	{
		PosJOYPAD() : PointEntry("PosJOYPAD", "(312, 134)") {}
	};

	// The default position of UIEvent
	struct PosEVENT : public Configuration::PointEntry
	{
		PosEVENT() : PointEntry("PosEVENT", "(99, 100)") {}
	};

	// The default position of UIKeyConfig
	struct PosKEYCONFIG : public Configuration::PointEntry
	{
		PosKEYCONFIG() : PointEntry("PosKEYCONFIG", "(144, 144)") {}
	};

	// The default position of UIOptionMenu
	struct PosOPTIONMENU : public Configuration::PointEntry
	{
		PosOPTIONMENU() : PointEntry("PosUSERLIST", "(170, -1)") {}
	};

	// The default position of UICharInfo
	struct PosCHARINFO : public Configuration::PointEntry
	{
		PosCHARINFO() : PointEntry("PosCHARINFO", "(264, 264)") {}
	};

	// The default type of UIMiniMap
	struct MiniMapType : public Configuration::ByteEntry
	{
		MiniMapType() : ByteEntry("MiniMapType", "2") {}
	};

	// Whether to use a simple version of UIMiniMap
	struct MiniMapSimpleMode : public Configuration::BoolEntry
	{
		MiniMapSimpleMode() : BoolEntry("MiniMapSimpleMode", "false") {}
	};

	// Whether to use default helpers for UIMiniMap
	struct MiniMapDefaultHelpers : public Configuration::BoolEntry
	{
		MiniMapDefaultHelpers() : BoolEntry("MiniMapDefaultHelpers", "false") {}
	};

	template <typename T>
	// Can be used to access settings
	struct Setting
	{
		// Access a setting
		static T& get()
		{
			static_assert(std::is_base_of<Configuration::Entry, T>::value, "template parameter T for Setting must inherit from Configuration::Entry.");

			auto* entry = Configuration::get().settings.get<T>();

			if (entry)
			{
				return *entry;
			}
			else
			{
				static T defaultentry;
				return defaultentry;
			}
		}
	};
}

================
File: Constants.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Template/Singleton.h"

#include <cstdint>

namespace ms
{
	namespace Constants
	{
		// Timestep, i.e., the granularity in which the game advances.
		constexpr uint16_t TIMESTEP = 8;

		class Constants : public Singleton<Constants>
		{
		public:
			Constants()
			{
				VIEWWIDTH = 1024;
				VIEWHEIGHT = 768;
			};

			~Constants() {}

			// Get the window and screen width
			int16_t get_viewwidth()
			{
				return VIEWWIDTH;
			}

			// Set the window and screen width
			void set_viewwidth(int16_t width)
			{
				VIEWWIDTH = width;
			}

			// Get the window and screen height
			int16_t get_viewheight()
			{
				return VIEWHEIGHT;
			}

			// Set the window and screen height
			void set_viewheight(int16_t height)
			{
				VIEWHEIGHT = height;
			}

		private:
			// Window and screen width
			int16_t VIEWWIDTH;
			// Window and screen height
			int16_t VIEWHEIGHT;
		};
	}
}

================
File: Data/BulletData.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "BulletData.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	BulletData::BulletData(int32_t itemid) : itemdata(ItemData::get(itemid))
	{
		std::string prefix = "0" + std::to_string(itemid / 10000);
		std::string strid = "0" + std::to_string(itemid);
		nl::node src = src = nl::nx::Item["Consume"][prefix + ".img"][strid];

		bullet = src["bullet"];
		watk = src["info"]["incPAD"];
	}

	bool BulletData::is_valid() const
	{
		return itemdata.is_valid();
	}

	BulletData::operator bool() const
	{
		return is_valid();
	}

	int16_t BulletData::get_watk() const
	{
		return watk;
	}

	const Animation& BulletData::get_animation() const
	{
		return bullet;
	}

	const ItemData& BulletData::get_itemdata() const
	{
		return itemdata;
	}
}

================
File: Data/BulletData.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "ItemData.h"

#include "../Graphics/Animation.h"

namespace ms
{
	// Information about a bullet type item.
	class BulletData : public Cache<BulletData>
	{
	public:
		// Returns whether the bullet was loaded correctly.
		bool is_valid() const;
		// Returns whether the bullet was loaded correctly.
		explicit operator bool() const;

		// Returns the weapon attack increase when using this bullet.
		int16_t get_watk() const;
		// Returns the bullet animation.
		const Animation& get_animation() const;
		// Returns the general item data.
		const ItemData& get_itemdata() const;

	private:
		// Allow the cache to use the constructor.
		friend Cache<BulletData>;
		// Load a bullet from the game files.
		BulletData(int32_t id);

		const ItemData& itemdata;

		Animation bullet;
		int16_t watk;
	};
}

================
File: Data/EquipData.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "EquipData.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	EquipData::EquipData(int32_t id) : itemdata(ItemData::get(id))
	{
		std::string strid = "0" + std::to_string(id);
		std::string category = itemdata.get_category();
		nl::node src = nl::nx::Character[category][strid + ".img"]["info"];

		cash = src["cash"].get_bool();
		tradeblock = src["tradeBlock"].get_bool();
		slots = src["tuc"];

		reqstats[MapleStat::Id::LEVEL] = src["reqLevel"];
		reqstats[MapleStat::Id::JOB] = src["reqJob"];
		reqstats[MapleStat::Id::STR] = src["reqSTR"];
		reqstats[MapleStat::Id::DEX] = src["reqDEX"];
		reqstats[MapleStat::Id::INT] = src["reqINT"];
		reqstats[MapleStat::Id::LUK] = src["reqLUK"];
		defstats[EquipStat::Id::STR] = src["incSTR"];
		defstats[EquipStat::Id::DEX] = src["incDEX"];
		defstats[EquipStat::Id::INT] = src["incINT"];
		defstats[EquipStat::Id::LUK] = src["incLUK"];
		defstats[EquipStat::Id::WATK] = src["incPAD"];
		defstats[EquipStat::Id::WDEF] = src["incPDD"];
		defstats[EquipStat::Id::MAGIC] = src["incMAD"];
		defstats[EquipStat::Id::MDEF] = src["incMDD"];
		defstats[EquipStat::Id::HP] = src["incMHP"];
		defstats[EquipStat::Id::MP] = src["incMMP"];
		defstats[EquipStat::Id::ACC] = src["incACC"];
		defstats[EquipStat::Id::AVOID] = src["incEVA"];
		defstats[EquipStat::Id::HANDS] = src["incHANDS"];
		defstats[EquipStat::Id::SPEED] = src["incSPEED"];
		defstats[EquipStat::Id::JUMP] = src["incJUMP"];

		constexpr size_t NON_WEAPON_TYPES = 15;
		constexpr size_t WEAPON_OFFSET = NON_WEAPON_TYPES + 15;
		constexpr size_t WEAPON_TYPES = 20;
		size_t index = (id / 10000) - 100;

		if (index < NON_WEAPON_TYPES)
		{
			constexpr const char* types[NON_WEAPON_TYPES] =
			{
				"HAT",
				"FACE ACCESSORY",
				"EYE ACCESSORY",
				"EARRINGS",
				"TOP",
				"OVERALL",
				"BOTTOM",
				"SHOES",
				"GLOVES",
				"SHIELD",
				"CAPE",
				"RING",
				"PENDANT",
				"BELT",
				"MEDAL"
			};

			constexpr EquipSlot::Id equipslots[NON_WEAPON_TYPES] =
			{
				EquipSlot::Id::HAT,
				EquipSlot::Id::FACE,
				EquipSlot::Id::EYEACC,
				EquipSlot::Id::EARACC,
				EquipSlot::Id::TOP,
				EquipSlot::Id::TOP,
				EquipSlot::Id::BOTTOM,
				EquipSlot::Id::SHOES,
				EquipSlot::Id::GLOVES,
				EquipSlot::Id::SHIELD,
				EquipSlot::Id::CAPE,
				EquipSlot::Id::RING1,
				EquipSlot::Id::PENDANT1,
				EquipSlot::Id::BELT,
				EquipSlot::Id::MEDAL
			};

			type = types[index];
			eqslot = equipslots[index];
		}
		else if (index >= WEAPON_OFFSET && index < WEAPON_OFFSET + WEAPON_TYPES)
		{
			constexpr const char* types[WEAPON_TYPES] =
			{
				"ONE-HANDED SWORD",
				"ONE-HANDED AXE",
				"ONE-HANDED MACE",
				"DAGGER",
				"", "", "",
				"WAND",
				"STAFF",
				"",
				"TWO-HANDED SWORD",
				"TWO-HANDED AXE",
				"TWO-HANDED MACE",
				"SPEAR",
				"POLEARM",
				"BOW",
				"CROSSBOW",
				"CLAW",
				"KNUCKLE",
				"GUN"
			};

			size_t weaponindex = index - WEAPON_OFFSET;
			type = types[weaponindex];
			eqslot = EquipSlot::Id::WEAPON;
		}
		else
		{
			type = "CASH";
			eqslot = EquipSlot::Id::NONE;
		}
	}

	bool EquipData::is_valid() const
	{
		return itemdata.is_valid();
	}

	EquipData::operator bool() const
	{
		return is_valid();
	}

	bool EquipData::is_weapon() const
	{
		return eqslot == EquipSlot::Id::WEAPON;
	}

	int16_t EquipData::get_reqstat(MapleStat::Id stat) const
	{
		return reqstats[stat];
	}

	int16_t EquipData::get_defstat(EquipStat::Id stat) const
	{
		return defstats[stat];
	}

	EquipSlot::Id EquipData::get_eqslot() const
	{
		return eqslot;
	}

	const std::string& EquipData::get_type() const
	{
		return type;
	}

	const ItemData& EquipData::get_itemdata() const
	{
		return itemdata;
	}
}

================
File: Data/EquipData.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "ItemData.h"

#include "../Character/EquipStat.h"
#include "../Character/MapleStat.h"

#include "../Character/Look/EquipSlot.h"

namespace ms
{
	// Contains information about an equip
	class EquipData : public Cache<EquipData>
	{
	public:
		// Returns whether the equip was loaded correctly
		bool is_valid() const;
		// Returns whether the equip was loaded correctly
		explicit operator bool() const;

		// Returns whether this equip has equipslot WEAPON
		bool is_weapon() const;
		// Returns a required base stat
		int16_t get_reqstat(MapleStat::Id stat) const;
		// Returns a default stat
		int16_t get_defstat(EquipStat::Id stat) const;
		// Returns the equip slot
		EquipSlot::Id get_eqslot() const;
		// Returns the category name
		const std::string& get_type() const;
		// Returns the general item data (name, price, etc.)
		const ItemData& get_itemdata() const;

	private:
		// Allow the cache to use the constructor
		friend Cache<EquipData>;
		// Load an equip from the game files
		EquipData(int32_t id);

		const ItemData& itemdata;

		EnumMap<MapleStat::Id, int16_t> reqstats;
		EnumMap<EquipStat::Id, int16_t> defstats;
		std::string type;
		EquipSlot::Id eqslot;
		uint8_t slots;
		bool cash;
		bool tradeblock;
	};
}

================
File: Data/ItemData.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "ItemData.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	ItemData::ItemData(int32_t id) : itemid(id)
	{
		untradable = false;
		unique = false;
		unsellable = false;
		cashitem = false;
		gender = 0;

		nl::node src;
		nl::node strsrc;

		std::string strprefix = "0" + std::to_string(get_item_prefix(itemid));
		std::string strid = "0" + std::to_string(itemid);
		int32_t prefix = get_prefix(itemid);

		switch (prefix)
		{
			case 1:
				category = get_eqcategory(itemid);
				src = nl::nx::Character[category][strid + ".img"]["info"];
				strsrc = nl::nx::String["Eqp.img"]["Eqp"][category][std::to_string(itemid)];
				break;
			case 2:
				category = "Consume";
				src = nl::nx::Item["Consume"][strprefix + ".img"][strid]["info"];
				strsrc = nl::nx::String["Consume.img"][std::to_string(itemid)];
				break;
			case 3:
				category = "Install";
				src = nl::nx::Item["Install"][strprefix + ".img"][strid]["info"];
				strsrc = nl::nx::String["Ins.img"][std::to_string(itemid)];
				break;
			case 4:
				category = "Etc";
				src = nl::nx::Item["Etc"][strprefix + ".img"][strid]["info"];
				strsrc = nl::nx::String["Etc.img"]["Etc"][std::to_string(itemid)];
				break;
			case 5:
				category = "Cash";
				src = nl::nx::Item["Cash"][strprefix + ".img"][strid]["info"];
				strsrc = nl::nx::String["Cash.img"][std::to_string(itemid)];
				break;
		}

		if (src)
		{
			icons[false] = src["icon"];
			icons[true] = src["iconRaw"];
			price = src["price"];
			untradable = src["tradeBlock"].get_bool();
			unique = src["only"].get_bool();
			unsellable = src["notSale"].get_bool();
			cashitem = src["cash"].get_bool();
			gender = get_item_gender(itemid);

			name = strsrc["name"];
			desc = strsrc["desc"];

			valid = true;
		}
		else
		{
			valid = false;
		}
	}

	std::string ItemData::get_eqcategory(int32_t id) const
	{
		constexpr const char* categorynames[15] =
		{
			"Cap",
			"Accessory",
			"Accessory",
			"Accessory",
			"Coat",
			"Longcoat",
			"Pants",
			"Shoes",
			"Glove",
			"Shield",
			"Cape",
			"Ring",
			"Accessory",
			"Accessory",
			"Accessory"
		};

		int32_t index = get_item_prefix(id) - 100;

		if (index < 15)
			return categorynames[index];
		else if (index >= 30 && index <= 70)
			return "Weapon";
		else
			return "";
	}

	int32_t ItemData::get_prefix(int32_t id) const
	{
		return id / 1000000;
	}

	int32_t ItemData::get_item_prefix(int32_t id) const
	{
		return id / 10000;
	}

	int8_t ItemData::get_item_gender(int32_t id) const
	{
		const int32_t item_prefix = get_item_prefix(id);

		if ((get_prefix(id) != 1 && item_prefix != 254) || item_prefix == 119 || item_prefix == 168)
			return 2;

		const int32_t gender_digit = id / 1000 % 10;

		return (gender_digit > 1) ? 2 : gender_digit;
	}

	bool ItemData::is_valid() const
	{
		return valid;
	}

	bool ItemData::is_untradable() const
	{
		return untradable;
	}

	bool ItemData::is_unique() const
	{
		return unique;
	}

	bool ItemData::is_unsellable() const
	{
		return unsellable;
	}

	bool ItemData::is_cashitem() const
	{
		return cashitem;
	}

	ItemData::operator bool() const
	{
		return is_valid();
	}

	int32_t ItemData::get_id() const
	{
		return itemid;
	}

	int32_t ItemData::get_price() const
	{
		return price;
	}

	int8_t ItemData::get_gender() const
	{
		return gender;
	}

	const std::string& ItemData::get_name() const
	{
		return name;
	}

	const std::string& ItemData::get_desc() const
	{
		return desc;
	}

	const std::string& ItemData::get_category() const
	{
		return category;
	}

	const Texture& ItemData::get_icon(bool raw) const
	{
		return icons[raw];
	}
}

================
File: Data/ItemData.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Graphics/Texture.h"
#include "../Template/BoolPair.h"
#include "../Template/Cache.h"

namespace ms
{
	// Class that represents an item loaded from the game's files
	// Contains all shared data between concrete items
	class ItemData : public Cache<ItemData>
	{
	public:
		// Returns whether the item was loaded correctly
		bool is_valid() const;
		// Returns whether the item is tradable or not
		bool is_untradable() const;
		// Returns whether the item is a one-of-a-kind item or not
		bool is_unique() const;
		// Returns whether the item is able to be sold or not
		bool is_unsellable() const;
		// Returns whether the item is a cash item or not
		bool is_cashitem() const;
		// Returns whether the item was loaded correctly
		explicit operator bool() const;

		// Returns the item id
		int32_t get_id() const;
		// Returns the item price
		int32_t get_price() const;
		// Returns the item's gender based on item id
		int8_t get_gender() const;
		// Returns the item's name loaded from the String file
		const std::string& get_name() const;
		// Returns the item's description loaded from the String file
		const std::string& get_desc() const;
		// Return the item category (Also the node name)
		const std::string& get_category() const;
		// Returns one of the item's icons
		// For each item there is a 'raw' icon and an icon with a drop shadow
		const Texture& get_icon(bool raw) const;

	private:
		// Allow the cache to use the constructor
		friend Cache<ItemData>;
		// Creates an item from the game's Item file with the specified id
		ItemData(int32_t itemid);

		std::string get_eqcategory(int32_t itemid) const;
		int32_t get_prefix(int32_t itemid) const;
		int32_t get_item_prefix(int32_t itemid) const;
		int8_t get_item_gender(int32_t itemid) const;

		BoolPair<Texture> icons;
		int32_t itemid;
		int32_t price;
		int8_t gender;
		std::string name;
		std::string desc;
		std::string category;

		bool valid;
		bool untradable;
		bool unique;
		bool unsellable;
		bool cashitem;
	};
}

================
File: Data/JobData.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "JobData.h"

#include "../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	JobData::JobData(int32_t id)
	{
		std::string strid = string_format::extend_id(id, 3);
		nl::node src = nl::nx::Skill[strid + ".img"];
		nl::node strsrc = nl::nx::String["Skill.img"][strid];

		icon = src["info"]["icon"];

		name = strsrc["bookName"];

		for (nl::node sub : src["skill"])
		{
			int32_t skill_id = string_conversion::or_zero<int32_t>(sub.name());

			if (skill_id == 0)
				continue;

			skills.push_back(skill_id);
		}
	}

	const std::vector<std::int32_t>& JobData::get_skills() const
	{
		return skills;
	}

	const std::string& JobData::get_name() const
	{
		return name;
	}

	const Texture& JobData::get_icon() const
	{
		return icon;
	}
}

================
File: Data/JobData.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Graphics/Texture.h"
#include "../Template/Cache.h"

namespace ms
{
	// Contains information about a job
	class JobData : public Cache<JobData>
	{
	public:
		// Return the ids of the skills for this job
		const std::vector<std::int32_t>& get_skills() const;
		// Return the name of the skill book
		const std::string& get_name() const;
		// Return the book cover icon
		const Texture& get_icon() const;

	private:
		friend Cache<JobData>;
		JobData(int32_t id);

		Texture icon;
		std::vector<std::int32_t> skills;
		std::string name;
	};
}

================
File: Data/SkillData.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "SkillData.h"

#include "../Character/SkillId.h"
#include "../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	SkillData::SkillData(int32_t id)
	{
		/// Locate sources
		std::string strid = string_format::extend_id(id, 7);
		std::string jobid = strid.substr(0, 3);
		nl::node src = nl::nx::Skill[jobid + ".img"]["skill"][strid];
		nl::node strsrc = nl::nx::String["Skill.img"][strid];

		/// Load icons
		icons = { src["icon"], src["iconDisabled"], src["iconMouseOver"] };

		/// Load strings
		name = strsrc["name"];
		desc = strsrc["desc"];

		for (int32_t level = 1; nl::node sub = strsrc["h" + std::to_string(level)]; level++)
			levels.emplace(level, sub);

		/// Load stats
		nl::node levelsrc = src["level"];

		for (auto sub : levelsrc)
		{
			float damage = (float)sub["damage"] / 100;
			int32_t matk = sub["mad"];
			int32_t fixdamage = sub["fixdamage"];
			int32_t mastery = sub["mastery"];
			uint8_t attackcount = (uint8_t)sub["attackCount"].get_integer(1);
			uint8_t mobcount = (uint8_t)sub["mobCount"].get_integer(1);
			uint8_t bulletcount = (uint8_t)sub["bulletCount"].get_integer(1);
			int16_t bulletcost = (int16_t)sub["bulletConsume"].get_integer(bulletcount);
			int32_t hpcost = sub["hpCon"];
			int32_t mpcost = sub["mpCon"];
			float chance = (float)sub["prop"].get_real(100.0) / 100;
			float critical = 0.0f;
			float ignoredef = 0.0f;
			float hrange = (float)sub["range"].get_real(100.0) / 100;
			Rectangle<int16_t> range = sub;
			int32_t level = string_conversion::or_default<int32_t>(sub.name(), -1);

			stats.emplace(
				std::piecewise_construct,
				std::forward_as_tuple(level),
				std::forward_as_tuple(damage, matk, fixdamage, mastery, attackcount, mobcount, bulletcount, bulletcost, hpcost, mpcost, chance, critical, ignoredef, hrange, range)
			);
		}

		element = src["elemAttr"];

		if (jobid == "900" || jobid == "910")
			reqweapon = Weapon::Type::NONE;
		else
			reqweapon = Weapon::by_value(100 + (int32_t)src["weapon"]);

		masterlevel = static_cast<int32_t>(stats.size());
		passive = (id % 10000) / 1000 == 0;
		flags = flags_of(id);
		invisible = src["invisible"].get_bool();

		/// Load required skills
		nl::node reqsrc = src["req"];

		for (auto sub : reqsrc)
		{
			int32_t skillid = string_conversion::or_default<int32_t>(sub.name(), -1);
			int32_t reqlv = sub.get_integer();

			reqskills.emplace(skillid, reqlv);
		}
	}

	int32_t SkillData::flags_of(int32_t id) const
	{
		static const std::unordered_map<int32_t, int32_t> skill_flags =
		{
			// Beginner
			{ SkillId::THREE_SNAILS, ATTACK },
			// Warrior
			{ SkillId::POWER_STRIKE, ATTACK },
			{ SkillId::SLASH_BLAST, ATTACK },
			// Fighter
			// Page
			// Crusader
			{ SkillId::SWORD_PANIC, ATTACK },
			{ SkillId::AXE_PANIC, ATTACK },
			{ SkillId::SWORD_COMA, ATTACK },
			{ SkillId::AXE_COMA, ATTACK },
			// Hero
			{ SkillId::RUSH_HERO, ATTACK },
			{ SkillId::BRANDISH, ATTACK },
			// Page
			// White Knight
			{ SkillId::CHARGE, ATTACK },
			// Paladin
			{ SkillId::RUSH_PALADIN, ATTACK },
			{ SkillId::BLAST, ATTACK },
			{ SkillId::HEAVENS_HAMMER, ATTACK },
			// Spearman
			// Dragon Knight
			{ SkillId::DRAGON_BUSTER, ATTACK },
			{ SkillId::DRAGON_FURY, ATTACK },
			{ SkillId::PA_BUSTER, ATTACK },
			{ SkillId::PA_FURY, ATTACK },
			{ SkillId::SACRIFICE, ATTACK },
			{ SkillId::DRAGONS_ROAR, ATTACK },
			// Dark Knight
			{ SkillId::RUSH_DK, ATTACK },
			// Mage
			{ SkillId::ENERGY_BOLT, ATTACK | RANGED },
			{ SkillId::MAGIC_CLAW, ATTACK | RANGED },
			// F/P Mage
			{ SkillId::SLOW_FP, ATTACK },
			{ SkillId::FIRE_ARROW, ATTACK | RANGED },
			{ SkillId::POISON_BREATH, ATTACK | RANGED },
			// F/P ArchMage
			{ SkillId::EXPLOSION, ATTACK },
			{ SkillId::POISON_BREATH, ATTACK },
			{ SkillId::SEAL_FP, ATTACK },
			{ SkillId::ELEMENT_COMPOSITION_FP, ATTACK | RANGED },
			// TODO: Blank?
			{ SkillId::FIRE_DEMON, ATTACK },
			{ SkillId::PARALYZE, ATTACK | RANGED },
			{ SkillId::METEOR_SHOWER, ATTACK }
		};

		auto iter = skill_flags.find(id);

		if (iter == skill_flags.end())
			return NONE;

		return iter->second;
	}

	bool SkillData::is_passive() const
	{
		return passive;
	}

	bool SkillData::is_attack() const
	{
		return !passive && (flags & ATTACK);
	}

	bool SkillData::is_invisible() const
	{
		return invisible;
	}

	int32_t SkillData::get_masterlevel() const
	{
		return masterlevel;
	}

	Weapon::Type SkillData::get_required_weapon() const
	{
		return reqweapon;
	}

	const SkillData::Stats& SkillData::get_stats(int32_t level) const
	{
		auto iter = stats.find(level);

		if (iter == stats.end())
		{
			static constexpr Stats null_stats = Stats(0.0f, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0f, 0.0f, 0.0f, 0.0f, Rectangle<int16_t>());

			return null_stats;
		}

		return iter->second;
	}

	const std::string& SkillData::get_name() const
	{
		return name;
	}

	const std::string& SkillData::get_desc() const
	{
		return desc;
	}

	const std::string& SkillData::get_level_desc(int32_t level) const
	{
		auto iter = levels.find(level);

		if (iter == levels.end())
		{
			static const std::string null_level = "Missing level description.";

			return null_level;
		}
		else
		{
			return iter->second;
		}
	}

	const Texture& SkillData::get_icon(Icon icon) const
	{
		return icons[icon];
	}

	const std::unordered_map<int32_t, int32_t>& SkillData::get_reqskills() const
	{
		return reqskills;
	}
}

================
File: Data/SkillData.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Graphics/Texture.h"
#include "../Template/Cache.h"

#include "../Character/Inventory/Weapon.h"

namespace ms
{
	// Contains information about a skill
	class SkillData : public Cache<SkillData>
	{
	public:
		// The stats of one level
		struct Stats
		{
			float damage;
			int32_t matk;
			int32_t fixdamage;
			int32_t mastery;
			uint8_t attackcount;
			uint8_t mobcount;
			uint8_t bulletcount;
			int16_t bulletcost;
			int32_t hpcost;
			int32_t mpcost;
			float chance;
			float critical;
			float ignoredef;
			float hrange;
			Rectangle<int16_t> range;

			constexpr Stats(float damage, int32_t matk, int32_t fixdamage, int32_t mastery, uint8_t attackcount, uint8_t mobcount, uint8_t bulletcount, int16_t bulletcost, int32_t hpcost, int32_t mpcost, float chance, float critical, float ignoredef, float hrange, Rectangle<int16_t> range) : damage(damage), matk(matk), fixdamage(fixdamage), mastery(mastery), attackcount(attackcount), mobcount(mobcount), bulletcount(bulletcount), bulletcost(bulletcost), hpcost(hpcost), mpcost(mpcost), chance(chance), critical(critical), ignoredef(ignoredef), hrange(hrange), range(range) {}
		};

		// Skill flags, unfortunately these just have to be hard-coded
		enum Flags
		{
			NONE = 0x0000,
			ATTACK = 0x0001,
			RANGED = 0x0002
		};

		// Icon types
		enum Icon
		{
			NORMAL,
			DISABLED,
			MOUSEOVER,
			NUM_ICONS
		};

		// Return whether the skill is passive
		bool is_passive() const;
		// Return whether the skill is an attack skill
		bool is_attack() const;
		// Return whether this skill is invisible in the skill book UI
		bool is_invisible() const;
		// Return the default masterlevel
		int32_t get_masterlevel() const;
		// Return the required weapon
		Weapon::Type get_required_weapon() const;
		// Return the stats of one level
		// If there are no stats for that level, a default object is returned.
		const Stats& get_stats(int32_t level) const;

		// Return the name of the skill
		const std::string& get_name() const;
		// Return the description of the skill
		const std::string& get_desc() const;
		// Return the description of a level
		// If there is no description for this level, a warning message is returned.
		const std::string& get_level_desc(int32_t level) const;

		// Return one of the skill icons
		// Cannot fail if type is a valid enumeration
		const Texture& get_icon(Icon icon) const;

		// Return id and level of all required skills
		const std::unordered_map<int32_t, int32_t>& get_reqskills() const;

	private:
		// Allow the cache to use the constructor
		friend Cache<SkillData>;
		// Load a skill from the game files
		SkillData(int32_t id);

		// Get some hard-coded information
		int32_t flags_of(int32_t id) const;

		std::unordered_map<int32_t, Stats> stats;
		std::string element;
		Weapon::Type reqweapon;
		int32_t masterlevel;
		int32_t flags;
		bool passive;
		bool invisible;

		std::string name;
		std::string desc;
		std::unordered_map<int32_t, std::string> levels;
		std::unordered_map<int32_t, int32_t> reqskills;

		std::array<Texture, Icon::NUM_ICONS> icons;
	};
}

================
File: Data/WeaponData.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "WeaponData.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	WeaponData::WeaponData(int32_t equipid) : equipdata(EquipData::get(equipid))
	{
		int32_t prefix = equipid / 10000;
		type = Weapon::by_value(prefix);
		twohanded = prefix == Weapon::Type::STAFF || (prefix >= Weapon::Type::SWORD_2H && prefix <= Weapon::Type::POLEARM) || prefix == Weapon::Type::CROSSBOW;

		nl::node src = nl::nx::Character["Weapon"]["0" + std::to_string(equipid) + ".img"]["info"];

		attackspeed = static_cast<uint8_t>(src["attackSpeed"]);
		attack = static_cast<uint8_t>(src["attack"]);

		nl::node soundsrc = nl::nx::Sound["Weapon.img"][src["sfx"]];

		bool twosounds = soundsrc["Attack2"].data_type() == nl::node::type::audio;

		if (twosounds)
		{
			usesounds[false] = soundsrc["Attack"];
			usesounds[true] = soundsrc["Attack2"];
		}
		else
		{
			usesounds[false] = soundsrc["Attack"];
			usesounds[true] = soundsrc["Attack"];
		}

		afterimage = src["afterImage"];
	}

	bool WeaponData::is_valid() const
	{
		return equipdata.is_valid();
	}

	WeaponData::operator bool() const
	{
		return is_valid();
	}

	bool WeaponData::is_twohanded() const
	{
		return twohanded;
	}

	uint8_t WeaponData::get_speed() const
	{
		return attackspeed;
	}

	uint8_t WeaponData::get_attack() const
	{
		return attack;
	}

	std::string WeaponData::getspeedstring() const
	{
		switch (attackspeed)
		{
		case 1:
			return "FAST (1)";
		case 2:
			return "FAST (2)";
		case 3:
			return "FAST (3)";
		case 4:
			return "FAST (4)";
		case 5:
			return "NORMAL (5)";
		case 6:
			return "NORMAL (6)";
		case 7:
			return "SLOW (7)";
		case 8:
			return "SLOW (8)";
		case 9:
			return "SLOW (9)";
		default:
			return "";
		}
	}

	uint8_t WeaponData::get_attackdelay() const
	{
		if (type == Weapon::NONE)
			return 0;
		else
			return 50 - 25 / attackspeed;
	}

	Weapon::Type WeaponData::get_type() const
	{
		return type;
	}

	Sound WeaponData::get_usesound(bool degenerate) const
	{
		return usesounds[degenerate];
	}

	const std::string& WeaponData::get_afterimage() const
	{
		return afterimage;
	}

	const EquipData& WeaponData::get_equipdata() const
	{
		return equipdata;
	}
}

================
File: Data/WeaponData.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "EquipData.h"

#include "../Audio/Audio.h"

#include "../Character/Inventory/Weapon.h"

namespace ms
{
	// Contains information about a weapon
	class WeaponData : public Cache<WeaponData>
	{
	public:
		// Returns whether the weapon was loaded correctly
		bool is_valid() const;
		// Returns whether the weapon was loaded correctly
		explicit operator bool() const;

		// Return whether this weapon uses two-handed stances
		bool is_twohanded() const;
		// Return the attack speed
		uint8_t get_speed() const;
		// Return the attack type
		uint8_t get_attack() const;
		// Return the speed as displayed in a Tooltip
		std::string getspeedstring() const;
		// Return the attack delay
		uint8_t get_attackdelay() const;
		// Return the weapon type
		Weapon::Type get_type() const;
		// Return the sound to play when attacking
		Sound get_usesound(bool degenerate) const;
		// Return the name of the afterimage
		const std::string& get_afterimage() const;
		// Return the general equip data
		const EquipData& get_equipdata() const;

	private:
		// Allow the cache to use the constructor
		friend Cache<WeaponData>;
		// Load a weapon from the game files
		WeaponData(int32_t id);

		const EquipData& equipdata;

		Weapon::Type type;
		bool twohanded;
		uint8_t attackspeed;
		uint8_t attack;
		BoolPair<Sound> usesounds;
		std::string afterimage;
	};
}

================
File: debug_nx.cpp
================
#include "includes/NoLifeNx/nlnx/nx.hpp"
#include <iostream>

int main() {
    try {
        nl::nx::load_all();
        
        std::cout << "=== NX FILES LOADED ===" << std::endl;
        std::cout << "Map.name(): " << nl::nx::Map.name() << std::endl;
        std::cout << "Map001.name(): " << nl::nx::Map001.name() << std::endl;
        std::cout << "Map002.name(): " << nl::nx::Map002.name() << std::endl;
        
        std::cout << "\n=== CHECKING LOGIN ASSETS ===" << std::endl;
        
        // Check if Map has Back directory
        auto back_node = nl::nx::Map["Back"];
        std::cout << "Map[\"Back\"] exists: " << (back_node.name().empty() ? "NO" : "YES") << std::endl;
        
        if (!back_node.name().empty()) {
            auto ui_login = back_node["UI_login.img"];
            std::cout << "Map[\"Back\"][\"UI_login.img\"] exists: " << (ui_login.name().empty() ? "NO" : "YES") << std::endl;
            
            if (!ui_login.name().empty()) {
                auto back_img = ui_login["back"];
                std::cout << "UI_login.img[\"back\"] exists: " << (back_img.name().empty() ? "NO" : "YES") << std::endl;
                
                if (!back_img.name().empty()) {
                    auto back_0 = back_img["0"];
                    std::cout << "back[\"0\"] exists: " << (back_0.name().empty() ? "NO" : "YES") << std::endl;
                }
            }
        }
        
        // Check Map001 fallback
        std::cout << "\n=== CHECKING MAP001 FALLBACK ===" << std::endl;
        auto map001_back = nl::nx::Map001["Back"];
        std::cout << "Map001[\"Back\"] exists: " << (map001_back.name().empty() ? "NO" : "YES") << std::endl;
        
        if (!map001_back.name().empty()) {
            auto ui_login = map001_back["UI_login.img"];
            std::cout << "Map001[\"Back\"][\"UI_login.img\"] exists: " << (ui_login.name().empty() ? "NO" : "YES") << std::endl;
        }
        
    } catch (const std::exception& e) {
        std::cout << "Error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}

================
File: Error.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

namespace ms
{
	// Error codes to be checked after initialization
	class Error
	{
	public:
		enum Code
		{
			NONE,
			CONNECTION,
			NLNX,
			WZ,
			MISSING_FILE,
			WRONG_UI_FILE,
			GLFW,
			GLEW,
			FREETYPE,
			VERTEX_SHADER,
			FRAGMENT_SHADER,
			SHADER_PROGRAM_LINK,
			SHADER_PROGRAM_VALID,
			SHADER_VARS,
			WINDOW,
			AUDIO,
			MISSING_ICON,
			FONT_PATH,
			LENGTH
		};

		constexpr Error(Code c) : Error(c, "") {}
		constexpr Error(Code c, const char* args) : code(c), args(args) {}

		constexpr operator bool() const
		{
			return code != Code::NONE;
		}

		constexpr bool can_retry() const
		{
			return code == Code::CONNECTION || code == Code::MISSING_FILE || code == Code::WRONG_UI_FILE || code == Code::MISSING_ICON || code == Code::FONT_PATH;
		}

		constexpr const char* get_message() const
		{
			return messages[code];
		}

		constexpr const char* get_args() const
		{
			return args;
		}

	private:
		Code code;
		const char* args;

		static constexpr const char* messages[Code::LENGTH] =
		{
			"",
			"Cannot connect to server.",
			"Could not initialize NLNX.",
			"Could not initialize WZ.",
			"Missing a game file: ",
			"UI.nx has wrong version.",
			"Could not initialize GLFW.",
			"Could not initialize GLEW.",
			"Could not initialize FreeType.",
			"Failed to compile vertex shader.",
			"Failed to compile fragment shader.",
			"Failed to link shader program.",
			"Failed to validate shader program.",
			"Failed to locate shader variables.",
			"Failed to create window.",
			"Failed to initialize audio.",
			"Could not load icon.",
			"Could not load fonts."
		};
	};
}

================
File: extract_all_nx_structures.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	NX Structure Extraction Tool - Complete Documentation
//	Extracts all nx file structures to detailed text files
//////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>

#ifdef USE_NX
#include <nlnx/nx.hpp>
#include <nlnx/node.hpp>
#endif

void explore_node_to_file(std::ofstream& file, const nl::node& node, const std::string& path, int depth, int& total_nodes) {
    if (depth > 6) return; // Limit depth to prevent excessive output
    
    std::string indent(depth * 2, ' ');
    std::string node_type;
    total_nodes++;
    
    // Determine node type
    if (node.data_type() == nl::node::type::bitmap) node_type = "[Bitmap]";
    else if (node.data_type() == nl::node::type::audio) node_type = "[Audio]";
    else if (node.data_type() == nl::node::type::string) node_type = "[String]";
    else if (node.data_type() == nl::node::type::integer) node_type = "[Int]";
    else if (node.data_type() == nl::node::type::real) node_type = "[Real]";
    else if (node.data_type() == nl::node::type::vector) node_type = "[Vector]";
    else if (node.size() > 0) node_type = "[Node]";
    else node_type = "[Data]";
    
    // Write node info
    file << indent << "- " << node.name() << " " << node_type;
    if (node.size() > 0) {
        file << " (" << node.size() << " children)";
    }
    
    // Add data info for leaf nodes
    if (node.size() == 0) {
        try {
            if (node.data_type() == nl::node::type::string) {
                std::string str_val = node.get_string();
                if (str_val.length() < 50) {
                    file << " = \"" << str_val << "\"";
                } else {
                    file << " = \"" << str_val.substr(0, 47) << "...\"";
                }
            } else if (node.data_type() == nl::node::type::integer) {
                file << " = " << node.get_integer();
            } else if (node.data_type() == nl::node::type::real) {
                file << " = " << node.get_real();
            } else if (node.data_type() == nl::node::type::vector) {
                auto vec = node.get_vector();
                file << " = (" << vec.x << ", " << vec.y << ")";
            }
        } catch (...) {
            // Ignore data extraction errors
        }
    }
    
    file << std::endl;
    
    // Recursively explore children
    int child_count = 0;
    for (const auto& child : node) {
        if (child_count++ >= 50 && depth > 2) {
            file << indent << "  ... (" << (node.size() - 50) << " more children)" << std::endl;
            break;
        }
        explore_node_to_file(file, child, path + "/" + node.name(), depth + 1, total_nodes);
    }
}

void extract_nx_file(const std::string& nx_name, const nl::node& nx_node, const std::string& output_dir) {
    std::string filename = output_dir + "/" + nx_name + "_structure.txt";
    std::ofstream file(filename);
    
    if (!file.is_open()) {
        std::cout << "Failed to create file: " << filename << std::endl;
        return;
    }
    
    file << "================================================================================" << std::endl;
    file << "NX STRUCTURE DOCUMENTATION: " << nx_name << std::endl;
    file << "Generated by HeavenMS Client Asset Registry System" << std::endl;
    file << "================================================================================" << std::endl;
    file << std::endl;
    
    if (nx_node.name().empty()) {
        file << "ERROR: " << nx_name << " is not loaded or is empty!" << std::endl;
        file.close();
        std::cout << "WARNING: " << nx_name << " appears to be empty or not loaded" << std::endl;
        return;
    }
    
    file << "File: " << nx_name << std::endl;
    file << "Root node size: " << nx_node.size() << " children" << std::endl;
    file << std::endl;
    
    int total_nodes = 0;
    explore_node_to_file(file, nx_node, nx_name, 0, total_nodes);
    
    file << std::endl;
    file << "================================================================================" << std::endl;
    file << "SUMMARY" << std::endl;
    file << "Total nodes explored: " << total_nodes << std::endl;
    file << "File: " << nx_name << std::endl;
    file << "================================================================================" << std::endl;
    
    file.close();
    std::cout << "Extracted " << nx_name << " structure (" << total_nodes << " nodes) -> " << filename << std::endl;
}

int main() {
    std::cout << "=== NX STRUCTURE EXTRACTION TOOL ===" << std::endl;
    std::cout << "Loading nx files..." << std::endl;
    
#ifdef USE_NX
    try {
        // Load all nx files
        nl::nx::load_all();
        std::cout << "NX files loaded successfully!" << std::endl;
        
        // Create output directory
        std::string output_dir = "nx_structures";
        system(("mkdir " + output_dir + " 2>nul").c_str()); // Windows mkdir, ignore errors
        
        std::cout << "Extracting structures to " << output_dir << "/ directory..." << std::endl;
        std::cout << std::endl;
        
        // Extract all major nx files
        std::vector<std::pair<std::string, const nl::node*>> nx_files = {
            {"UI", &nl::nx::UI},
            {"Map", &nl::nx::Map},
            {"Character", &nl::nx::Character},
            {"Item", &nl::nx::Item},
            {"Skill", &nl::nx::Skill},
            {"Effect", &nl::nx::Effect},
            {"Sound", &nl::nx::Sound},
            {"String", &nl::nx::String},
            {"Etc", &nl::nx::Etc},
            {"Base", &nl::nx::Base},
            {"Mob", &nl::nx::Mob},
            {"Npc", &nl::nx::Npc},
            {"Quest", &nl::nx::Quest},
            {"Reactor", &nl::nx::Reactor},
            {"TamingMob", &nl::nx::TamingMob},
            {"Morph", &nl::nx::Morph}
        };
        
        // Also check split files
        if (!nl::nx::Map001.name().empty()) {
            nx_files.push_back({"Map001", &nl::nx::Map001});
        }
        if (!nl::nx::Map002.name().empty()) {
            nx_files.push_back({"Map002", &nl::nx::Map002});
        }
        if (!nl::nx::Sound2.name().empty()) {
            nx_files.push_back({"Sound2", &nl::nx::Sound2});
        }
        
        // Extract each nx file
        for (const auto& nx_pair : nx_files) {
            extract_nx_file(nx_pair.first, *nx_pair.second, output_dir);
        }
        
        // Create master summary file
        std::ofstream summary(output_dir + "/nx_summary.txt");
        summary << "================================================================================" << std::endl;
        summary << "NX FILES SUMMARY - HeavenMS Client v83 Asset Analysis" << std::endl;
        summary << "================================================================================" << std::endl;
        summary << std::endl;
        
        summary << "Available NX Files:" << std::endl;
        for (const auto& nx_pair : nx_files) {
            const nl::node& node = *nx_pair.second;
            if (!node.name().empty()) {
                summary << "  ✅ " << nx_pair.first << ".nx - " << node.size() << " top-level children" << std::endl;
            } else {
                summary << "  ❌ " << nx_pair.first << ".nx - NOT AVAILABLE" << std::endl;
            }
        }
        
        summary << std::endl;
        summary << "Key Asset Locations (for AssetRegistry mapping):" << std::endl;
        summary << "  UI Login Assets: UI.nx/Login.img/Title/* and UI.nx/Login.img/Notice/Loading/*" << std::endl;
        summary << "  Login Backgrounds: UI.nx/Login.img/Notice/Loading/backgrnd" << std::endl;
        summary << "  Login Buttons: UI.nx/Login.img/Title/Bt*" << std::endl;
        summary << "  Character Select: UI.nx/Login.img/CharSelect/*" << std::endl;
        summary << "  World Select: UI.nx/Login.img/WorldSelect/*" << std::endl;
        summary << std::endl;
        
        summary << "File Structure Notes:" << std::endl;
        summary << "  - This is a v83 consolidated nx setup (no Map001/Map002 split files)" << std::endl;
        summary << "  - Map backgrounds are in Map.nx/Back/* but no UI_login.img" << std::endl;
        summary << "  - All UI assets consolidated in UI.nx" << std::endl;
        summary << "  - Login assets use Title/* hierarchy, not Title_new/*" << std::endl;
        
        summary.close();
        
        std::cout << std::endl;
        std::cout << "=== EXTRACTION COMPLETE ===" << std::endl;
        std::cout << "All nx structures have been extracted to the " << output_dir << "/ directory." << std::endl;
        std::cout << "Check " << output_dir << "/nx_summary.txt for an overview." << std::endl;
        std::cout << "Individual structure files: *_structure.txt" << std::endl;
        
    } catch (const std::exception& e) {
        std::cout << "ERROR: Failed to load nx files: " << e.what() << std::endl;
        return 1;
    }
#else
    std::cout << "ERROR: USE_NX not defined. This tool requires NX support." << std::endl;
    return 1;
#endif
    
    return 0;
}

================
File: Gameplay/Camera.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Camera.h"

#include "../Constants.h"

namespace ms
{
	Camera::Camera()
	{
		x.set(0.0);
		y.set(0.0);

		VWIDTH = Constants::Constants::get().get_viewwidth();
		VHEIGHT = Constants::Constants::get().get_viewheight();
	}

	void Camera::update(Point<int16_t> position)
	{
		int32_t new_width = Constants::Constants::get().get_viewwidth();
		int32_t new_height = Constants::Constants::get().get_viewheight();

		if (VWIDTH != new_width || VHEIGHT != new_height)
		{
			VWIDTH = new_width;
			VHEIGHT = new_height;
		}

		double next_x = x.get();
		double hdelta = VWIDTH / 2 - position.x() - next_x;

		if (std::abs(hdelta) >= 5.0)
			next_x += hdelta * (12.0 / VWIDTH);

		double next_y = y.get();
		double vdelta = VHEIGHT / 2 - position.y() - next_y;

		if (std::abs(vdelta) >= 5.0)
			next_y += vdelta * (12.0 / VHEIGHT);

		if (next_x > hbounds.first() || hbounds.length() < VWIDTH)
			next_x = hbounds.first();
		else if (next_x < hbounds.second() + VWIDTH)
			next_x = hbounds.second() + VWIDTH;

		if (next_y > vbounds.first() || vbounds.length() < VHEIGHT)
			next_y = vbounds.first();
		else if (next_y < vbounds.second() + VHEIGHT)
			next_y = vbounds.second() + VHEIGHT;

		x = next_x;
		y = next_y;
	}

	void Camera::set_position(Point<int16_t> position)
	{
		int32_t new_width = Constants::Constants::get().get_viewwidth();
		int32_t new_height = Constants::Constants::get().get_viewheight();

		if (VWIDTH != new_width || VHEIGHT != new_height)
		{
			VWIDTH = new_width;
			VHEIGHT = new_height;
		}

		x.set(VWIDTH / 2 - position.x());
		y.set(VHEIGHT / 2 - position.y());
	}

	void Camera::set_view(Range<int16_t> mapwalls, Range<int16_t> mapborders)
	{
		hbounds = -mapwalls;
		vbounds = -mapborders;
	}

	Point<int16_t> Camera::position() const
	{
		auto shortx = static_cast<int16_t>(std::round(x.get()));
		auto shorty = static_cast<int16_t>(std::round(y.get()));

		return { shortx, shorty };
	}

	Point<int16_t> Camera::position(float alpha) const
	{
		auto interx = static_cast<int16_t>(std::round(x.get(alpha)));
		auto intery = static_cast<int16_t>(std::round(y.get(alpha)));

		return { interx, intery };
	}

	Point<double> Camera::realposition(float alpha) const
	{
		return { x.get(alpha), y.get(alpha) };
	}
}

================
File: Gameplay/Camera.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Template/Interpolated.h"
#include "../Template/Point.h"
#include "../Template/Range.h"

#include <cstdint>

namespace ms
{
	// View on stage which follows the player object.
	class Camera
	{
	public:
		// Initialize everything to 0, we need the player's spawnpoint first to properly set the position.
		Camera();

		// Update the view with the current player position. (Or any other target)
		void update(Point<int16_t> position);
		// Set the position, changing the view immediately.
		void set_position(Point<int16_t> position);
		// Updates the view's boundaries. Determined by mapinfo or footholds.
		void set_view(Range<int16_t> hborders, Range<int16_t> vborders);
		// Return the current position.
		Point<int16_t> position() const;
		// Return the interpolated position.
		Point<int16_t> position(float alpha) const;
		// Return the interpolated position.
		Point<double> realposition(float alpha) const;

	private:
		// Movement variables.
		Linear<double> x;
		Linear<double> y;

		// View limits.
		Range<int16_t> hbounds;
		Range<int16_t> vbounds;

		int16_t VWIDTH;
		int16_t VHEIGHT;
	};
}

================
File: Gameplay/Combat/Attack.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Template/Rectangle.h"

#include <unordered_map>
#include <vector>

namespace ms
{
	struct Attack
	{
		enum Type
		{
			CLOSE,
			RANGED,
			MAGIC
		};

		enum DamageType
		{
			DMG_WEAPON,
			DMG_MAGIC,
			DMG_FIXED
		};

		Type type = Type::CLOSE;
		DamageType damagetype = DamageType::DMG_WEAPON;

		double mindamage = 1.0;
		double maxdamage = 1.0;
		float critical = 0.0f;
		float ignoredef = 0.0f;
		int32_t matk = 0;
		int32_t accuracy = 0;
		int32_t fixdamage = 0;
		int16_t playerlevel = 1;

		uint8_t hitcount = 0;
		uint8_t mobcount = 0;
		uint8_t speed = 0;
		uint8_t stance = 0;
		int32_t skill = 0;
		int32_t bullet = 0;

		Point<int16_t> origin;
		Rectangle<int16_t> range;
		float hrange = 1.0f;
		bool toleft = false;
	};

	struct MobAttack
	{
		Attack::Type type = Attack::Type::CLOSE;
		int32_t watk = 0;
		int32_t matk = 0;
		int32_t mobid = 0;
		int32_t oid = 0;
		Point<int16_t> origin;
		bool valid = false;

		// Create a mob attack for touch damage
		MobAttack() : valid(false) {}
		MobAttack(int32_t watk, Point<int16_t> origin, int32_t mobid, int32_t oid) : type(Attack::Type::CLOSE), watk(watk), origin(origin), mobid(mobid), oid(oid), valid(true) {}

		explicit operator bool() const
		{
			return valid;
		}
	};

	struct MobAttackResult
	{
		int32_t damage;
		int32_t mobid;
		int32_t oid;
		uint8_t direction;

		MobAttackResult(const MobAttack& attack, int32_t damage, uint8_t direction) : damage(damage), direction(direction), mobid(attack.mobid), oid(attack.oid) {}
	};

	struct AttackResult
	{
		AttackResult() {}

		AttackResult(const Attack& attack)
		{
			type = attack.type;
			hitcount = attack.hitcount;
			skill = attack.skill;
			speed = attack.speed;
			stance = attack.stance;
			bullet = attack.bullet;
			toleft = attack.toleft;
		}

		Attack::Type type;
		int32_t attacker = 0;
		uint8_t mobcount = 0;
		uint8_t hitcount = 1;
		int32_t skill = 0;
		int32_t charge = 0;
		int32_t bullet = 0;
		uint8_t level = 0;
		uint8_t display = 0;
		uint8_t stance = 0;
		uint8_t speed = 0;
		bool toleft = false;
		std::unordered_map<int32_t, std::vector<std::pair<int32_t, bool>>> damagelines;
		int32_t first_oid;
		int32_t last_oid;
	};

	struct AttackUser
	{
		int32_t skilllevel;
		uint16_t level;
		bool secondweapon;
		bool flip;
	};
}

================
File: Gameplay/Combat/Bullet.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Bullet.h"

namespace ms
{
	Bullet::Bullet(Animation a, Point<int16_t> origin, bool toleft)
	{
		animation = a;

		moveobj.set_x(origin.x() + (toleft ? -30.0 : 30.0));
		moveobj.set_y(origin.y() - 26.0);
	}

	void Bullet::draw(double viewx, double viewy, float alpha) const
	{
		Point<int16_t> bulletpos = moveobj.get_absolute(viewx, viewy, alpha);
		DrawArgument args(bulletpos, flip);
		animation.draw(args, alpha);
	}

	bool Bullet::settarget(Point<int16_t> target)
	{
		double xdelta = target.x() - moveobj.crnt_x();
		double ydelta = target.y() - moveobj.crnt_y();

		if (std::abs(xdelta) < 10.0)
			return true;

		flip = xdelta > 0.0;

		moveobj.hspeed = xdelta / 32;

		if (xdelta > 0.0)
		{
			if (moveobj.hspeed < 3.0)
				moveobj.hspeed = 3.0;
			else if (moveobj.hspeed > 6.0)
				moveobj.hspeed = 6.0;
		}
		else if (xdelta < 0.0)
		{
			if (moveobj.hspeed > -3.0)
				moveobj.hspeed = -3.0;
			else if (moveobj.hspeed < -6.0)
				moveobj.hspeed = -6.0;
		}

		moveobj.vspeed = moveobj.hspeed * ydelta / xdelta;

		return false;
	}

	bool Bullet::update(Point<int16_t> target)
	{
		animation.update();
		moveobj.move();

		int16_t xdelta = target.x() - moveobj.get_x();
		return moveobj.hspeed > 0.0 ? xdelta < 10 : xdelta > 10;
	}
}

================
File: Gameplay/Combat/Bullet.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Physics/PhysicsObject.h"

#include "../../Graphics/Animation.h"

namespace ms
{
	// Represents a projectile on a map
	class Bullet
	{
	public:
		Bullet(Animation animation, Point<int16_t> origin, bool toleft);

		void draw(double viewx, double viewy, float alpha) const;
		bool settarget(Point<int16_t> target);
		bool update(Point<int16_t> target);

	private:
		Animation animation;
		MovingObject moveobj;
		bool flip;
	};
}

================
File: Gameplay/Combat/Combat.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Combat.h"

#include "../../Character/SkillId.h"
#include "../../IO/Messages.h"

#include "../../Net/Packets/AttackAndSkillPackets.h"
#include "../../Net/Packets/GameplayPackets.h"

namespace ms
{
	Combat::Combat(Player& in_player, MapChars& in_chars, MapMobs& in_mobs, MapReactors& in_reactors) : player(in_player), chars(in_chars), mobs(in_mobs), reactors(in_reactors),
		attackresults([&](const AttackResult& attack) { apply_attack(attack); }),
		bulleteffects([&](const BulletEffect& effect) { apply_bullet_effect(effect); }),
		damageeffects([&](const DamageEffect& effect) { apply_damage_effect(effect); }) {}

	void Combat::draw(double viewx, double viewy, float alpha) const
	{
		for (auto& be : bullets)
			be.bullet.draw(viewx, viewy, alpha);

		for (auto& dn : damagenumbers)
			dn.draw(viewx, viewy, alpha);
	}

	void Combat::update()
	{
		attackresults.update();
		bulleteffects.update();
		damageeffects.update();

		bullets.remove_if(
			[&](BulletEffect& mb)
			{
				int32_t target_oid = mb.damageeffect.target_oid;

				if (mobs.contains(target_oid))
				{
					mb.target = mobs.get_mob_head_position(target_oid);
					bool apply = mb.bullet.update(mb.target);

					if (apply)
						apply_damage_effect(mb.damageeffect);

					return apply;
				}
				else
				{
					return mb.bullet.update(mb.target);
				}
			}
		);

		damagenumbers.remove_if(
			[](DamageNumber& dn)
			{
				return dn.update();
			}
		);
	}

	void Combat::use_move(int32_t move_id)
	{
		if (!player.can_attack())
			return;

		const SpecialMove& move = get_move(move_id);
		SpecialMove::ForbidReason reason = player.can_use(move);
		Weapon::Type weapontype = player.get_stats().get_weapontype();

		switch (reason)
		{
		case SpecialMove::ForbidReason::FBR_NONE:
			apply_move(move);
			break;
		default:
			ForbidSkillMessage(reason, weapontype).drop();
			break;
		}
	}

	void Combat::apply_move(const SpecialMove& move)
	{
		if (move.is_attack())
		{
			Attack attack = player.prepare_attack(move.is_skill());

			move.apply_useeffects(player);
			move.apply_actions(player, attack.type);

			player.set_afterimage(move.get_id());

			move.apply_stats(player, attack);

			Point<int16_t> origin = attack.origin;
			Rectangle<int16_t> range = attack.range;
			int16_t hrange = static_cast<int16_t>(range.left() * attack.hrange);

			if (attack.toleft)
			{
				range = {
					origin.x() + hrange,
					origin.x() + range.right(),
					origin.y() + range.top(),
					origin.y() + range.bottom()
				};
			}
			else
			{
				range = {
					origin.x() - range.right(),
					origin.x() - hrange,
					origin.y() + range.top(),
					origin.y() + range.bottom()
				};
			}

			// This approach should also make it easier to implement PvP
			uint8_t mobcount = attack.mobcount;
			AttackResult result = attack;

			MapObjects* mob_objs = mobs.get_mobs();
			MapObjects* reactor_objs = reactors.get_reactors();

			std::vector<int32_t> mob_targets = find_closest(mob_objs, range, origin, mobcount, true);
			std::vector<int32_t> reactor_targets = find_closest(reactor_objs, range, origin, mobcount, false);

			mobs.send_attack(result, attack, mob_targets, mobcount);
			result.attacker = player.get_oid();
			extract_effects(player, move, result);

			apply_use_movement(move);
			apply_result_movement(move, result);

			AttackPacket(result).dispatch();

			if (reactor_targets.size())
				if (Optional<Reactor> reactor = reactor_objs->get(reactor_targets.at(0)))
					DamageReactorPacket(reactor->get_oid(), player.get_position(), 0, 0).dispatch();
		}
		else
		{
			move.apply_useeffects(player);
			move.apply_actions(player, Attack::Type::MAGIC);

			int32_t moveid = move.get_id();
			int32_t level = player.get_skills().get_level(moveid);
			UseSkillPacket(moveid, level).dispatch();
		}
	}

	std::vector<int32_t> Combat::find_closest(MapObjects* objs, Rectangle<int16_t> range, Point<int16_t> origin, uint8_t objcount, bool use_mobs) const
	{
		std::multimap<uint16_t, int32_t> distances;

		for (auto& mmo : *objs)
		{
			if (use_mobs)
			{
				const Mob* mob = static_cast<const Mob*>(mmo.second.get());

				if (mob && mob->is_alive() && mob->is_in_range(range))
				{
					int32_t oid = mob->get_oid();
					uint16_t distance = mob->get_position().distance(origin);
					distances.emplace(distance, oid);
				}
			}
			else
			{
				// Assume Reactor
				const Reactor* reactor = static_cast<const Reactor*>(mmo.second.get());

				if (reactor && reactor->is_hittable() && reactor->is_in_range(range))
				{
					int32_t oid = reactor->get_oid();
					uint16_t distance = reactor->get_position().distance(origin);
					distances.emplace(distance, oid);
				}
			}
		}

		std::vector<int32_t> targets;

		for (auto& iter : distances)
		{
			if (targets.size() >= objcount)
				break;

			targets.push_back(iter.second);
		}

		return targets;
	}

	void Combat::apply_use_movement(const SpecialMove& move)
	{
		switch (move.get_id())
		{
		case SkillId::Id::TELEPORT_FP:
		case SkillId::Id::IL_TELEPORT:
		case SkillId::Id::PRIEST_TELEPORT:
		case SkillId::Id::FLASH_JUMP:
		default:
			break;
		}
	}

	void Combat::apply_result_movement(const SpecialMove& move, const AttackResult& result)
	{
		switch (move.get_id())
		{
		case SkillId::Id::RUSH_HERO:
		case SkillId::Id::RUSH_PALADIN:
		case SkillId::Id::RUSH_DK:
			apply_rush(result);
			break;
		default:
			break;
		}
	}

	void Combat::apply_rush(const AttackResult& result)
	{
		if (result.mobcount == 0)
			return;

		Point<int16_t> mob_position = mobs.get_mob_position(result.last_oid);
		int16_t targetx = mob_position.x();
		player.rush(targetx);
	}

	void Combat::apply_bullet_effect(const BulletEffect& effect)
	{
		bullets.push_back(effect);

		if (bullets.back().bullet.settarget(effect.target))
		{
			apply_damage_effect(effect.damageeffect);
			bullets.pop_back();
		}
	}

	void Combat::apply_damage_effect(const DamageEffect& effect)
	{
		Point<int16_t> head_position = mobs.get_mob_head_position(effect.target_oid);
		damagenumbers.push_back(effect.number);
		damagenumbers.back().set_x(head_position.x());

		const SpecialMove& move = get_move(effect.move_id);
		mobs.apply_damage(effect.target_oid, effect.damage, effect.toleft, effect.user, move);
	}

	void Combat::push_attack(const AttackResult& attack)
	{
		attackresults.push(400, attack);
	}

	void Combat::apply_attack(const AttackResult& attack)
	{
		if (Optional<OtherChar> ouser = chars.get_char(attack.attacker))
		{
			OtherChar& user = *ouser;
			user.update_skill(attack.skill, attack.level);
			user.update_speed(attack.speed);

			const SpecialMove& move = get_move(attack.skill);
			move.apply_useeffects(user);

			if (Stance::Id stance = Stance::by_id(attack.stance))
				user.attack(stance);
			else
				move.apply_actions(user, attack.type);

			user.set_afterimage(attack.skill);

			extract_effects(user, move, attack);
		}
	}

	void Combat::extract_effects(const Char& user, const SpecialMove& move, const AttackResult& result)
	{
		AttackUser attackuser = {
			user.get_skilllevel(move.get_id()),
			user.get_level(),
			user.is_twohanded(),
			!result.toleft
		};

		if (result.bullet)
		{
			Bullet bullet{
				move.get_bullet(user, result.bullet),
				user.get_position(),
				result.toleft
			};

			for (auto& line : result.damagelines)
			{
				int32_t oid = line.first;

				if (mobs.contains(oid))
				{
					std::vector<DamageNumber> numbers = place_numbers(oid, line.second);
					Point<int16_t> head = mobs.get_mob_head_position(oid);

					size_t i = 0;

					for (auto& number : numbers)
					{
						DamageEffect effect{
							attackuser,
							number,
							line.second[i].first,
							result.toleft,
							oid,
							move.get_id()
						};

						bulleteffects.emplace(user.get_attackdelay(i), std::move(effect), bullet, head);
						i++;
					}
				}
			}

			if (result.damagelines.empty())
			{
				int16_t xshift = result.toleft ? -400 : 400;
				Point<int16_t> target = user.get_position() + Point<int16_t>(xshift, -26);

				for (uint8_t i = 0; i < result.hitcount; i++)
				{
					DamageEffect effect{ attackuser, {}, 0, false, 0, 0 };
					bulleteffects.emplace(user.get_attackdelay(i), std::move(effect), bullet, target);
				}
			}
		}
		else
		{
			for (auto& line : result.damagelines)
			{
				int32_t oid = line.first;

				if (mobs.contains(oid))
				{
					std::vector<DamageNumber> numbers = place_numbers(oid, line.second);

					size_t i = 0;

					for (auto& number : numbers)
					{
						damageeffects.emplace(
							user.get_attackdelay(i),
							attackuser,
							number,
							line.second[i].first,
							result.toleft,
							oid,
							move.get_id()
							);

						i++;
					}
				}
			}
		}
	}

	std::vector<DamageNumber> Combat::place_numbers(int32_t oid, const std::vector<std::pair<int32_t, bool>>& damagelines)
	{
		std::vector<DamageNumber> numbers;
		int16_t head = mobs.get_mob_head_position(oid).y();

		for (auto& line : damagelines)
		{
			int32_t amount = line.first;
			bool critical = line.second;
			DamageNumber::Type type = critical ? DamageNumber::Type::CRITICAL : DamageNumber::Type::NORMAL;
			numbers.emplace_back(type, amount, head);

			head -= DamageNumber::rowheight(critical);
		}

		return numbers;
	}

	void Combat::show_buff(int32_t cid, int32_t skillid, int8_t level)
	{
		if (Optional<OtherChar> ouser = chars.get_char(cid))
		{
			OtherChar& user = *ouser;
			user.update_skill(skillid, level);

			const SpecialMove& move = get_move(skillid);
			move.apply_useeffects(user);
			move.apply_actions(user, Attack::Type::MAGIC);
		}
	}

	void Combat::show_player_buff(int32_t skillid)
	{
		get_move(skillid).apply_useeffects(player);
	}

	const SpecialMove& Combat::get_move(int32_t move_id)
	{
		if (move_id == 0)
			return regularattack;

		auto iter = skills.find(move_id);

		if (iter == skills.end())
			iter = skills.emplace(move_id, move_id).first;

		return iter->second;
	}
}

================
File: Gameplay/Combat/Combat.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "RegularAttack.h"

#include "../MapleMap/MapChars.h"
#include "../MapleMap/MapMobs.h"
#include "../MapleMap/MapReactors.h"

#include "../../Character/Player.h"
#include "../../Template/TimedQueue.h"

namespace ms
{
	class Combat
	{
	public:
		Combat(Player& player, MapChars& chars, MapMobs& mobs, MapReactors& reactors);

		// Draw bullets, damage numbers etc.
		void draw(double viewx, double viewy, float alpha) const;
		// Poll attacks, damage effects, etc.
		void update();

		// Make the player use a special move
		void use_move(int32_t move_id);

		// Add an attack to the attack queue
		void push_attack(const AttackResult& attack);
		// Show a buff effect
		void show_buff(int32_t cid, int32_t skillid, int8_t level);
		// Show a buff effect
		void show_player_buff(int32_t skillid);

	private:
		struct DamageEffect
		{
			AttackUser user;
			DamageNumber number;
			int32_t damage;
			bool toleft;
			int32_t target_oid;
			int32_t move_id;
		};

		struct BulletEffect
		{
			DamageEffect damageeffect;
			Bullet bullet;
			Point<int16_t> target;
		};

		void apply_attack(const AttackResult& attack);
		void apply_move(const SpecialMove& move);
		std::vector<int32_t> find_closest(MapObjects* objs, Rectangle<int16_t> range, Point<int16_t> origin, uint8_t objcount, bool use_mobs) const;
		void apply_use_movement(const SpecialMove& move);
		void apply_result_movement(const SpecialMove& move, const AttackResult& result);
		void apply_rush(const AttackResult& result);
		void apply_bullet_effect(const BulletEffect& effect);
		void apply_damage_effect(const DamageEffect& effect);
		void extract_effects(const Char& user, const SpecialMove& move, const AttackResult& result);
		std::vector<DamageNumber> place_numbers(int32_t oid, const std::vector<std::pair<int32_t, bool>>& damagelines);
		const SpecialMove& get_move(int32_t move_id);

		Player& player;
		MapChars& chars;
		MapMobs& mobs;
		MapReactors& reactors;

		std::unordered_map<int32_t, Skill> skills;
		RegularAttack regularattack;

		TimedQueue<AttackResult> attackresults;
		TimedQueue<BulletEffect> bulleteffects;
		TimedQueue<DamageEffect> damageeffects;

		std::list<BulletEffect> bullets;
		std::list<DamageNumber> damagenumbers;
	};
}

================
File: Gameplay/Combat/DamageNumber.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "DamageNumber.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	DamageNumber::DamageNumber(Type t, int32_t damage, int16_t starty, int16_t x)
	{
		type = t;

		if (damage > 0)
		{
			miss = false;

			std::string number = std::to_string(damage);
			firstnum = number[0];

			if (number.size() > 1)
			{
				restnum = number.substr(1);
				multiple = true;
			}
			else
			{
				restnum = "";
				multiple = false;
			}

			int16_t total = getadvance(firstnum, true);

			for (size_t i = 0; i < restnum.length(); i++)
			{
				char c = restnum[i];
				int16_t advance;

				if (i < restnum.length() - 1)
				{
					char n = restnum[i + 1];
					advance = (getadvance(c, false) + getadvance(n, false)) / 2;
				}
				else
				{
					advance = getadvance(c, false);
				}

				total += advance;
			}

			shift = total / 2;
		}
		else
		{
			shift = charsets[type][true].getw('M') / 2;
			miss = true;
		}

		moveobj.set_x(x);
		moveobj.set_y(starty);
		moveobj.vspeed = -0.25;
		opacity.set(1.5f);
	}

	DamageNumber::DamageNumber() {}

	void DamageNumber::draw(double viewx, double viewy, float alpha) const
	{
		Point<int16_t> absolute = moveobj.get_absolute(viewx, viewy, alpha);
		Point<int16_t> position = absolute - Point<int16_t>(0, shift);
		float interopc = opacity.get(alpha);

		if (miss)
		{
			charsets[type][true].draw('M', { position, interopc });
		}
		else
		{
			charsets[type][false].draw(firstnum, { position, interopc });

			if (multiple)
			{
				int16_t first_advance = getadvance(firstnum, true);
				position.shift_x(first_advance);

				for (size_t i = 0; i < restnum.length(); i++)
				{
					char c = restnum[i];
					Point<int16_t> yshift = { 0, (i % 2) ? -2 : 2 };
					charsets[type][true].draw(c, { position + yshift, interopc });

					int16_t advance;

					if (i < restnum.length() - 1)
					{
						char n = restnum[i + 1];
						int16_t c_advance = getadvance(c, false);
						int16_t n_advance = getadvance(n, false);
						advance = (c_advance + n_advance) / 2;
					}
					else
					{
						advance = getadvance(c, false);
					}

					position.shift_x(advance);
				}
			}
		}
	}

	int16_t DamageNumber::getadvance(char c, bool first) const
	{
		constexpr size_t LENGTH = 10;

		constexpr int16_t advances[LENGTH] =
		{
			24, 20, 22, 22, 24, 23, 24, 22, 24, 24
		};

		size_t index = c - 48;

		if (index < LENGTH)
		{
			int16_t advance = advances[index];

			switch (type)
			{
				case DamageNumber::Type::CRITICAL:
				{
					if (first)
						advance += 8;
					else
						advance += 4;

					break;
				}
				default:
				{
					if (first)
						advance += 2;

					break;
				}
			}

			return advance;
		}
		else
		{
			return 0;
		}
	}

	void DamageNumber::set_x(int16_t headx)
	{
		moveobj.set_x(headx);
	}

	bool DamageNumber::update()
	{
		moveobj.move();

		constexpr float FADE_STEP = Constants::TIMESTEP * 1.0f / FADE_TIME;
		opacity -= FADE_STEP;

		return opacity.last() <= 0.0f;
	}

	int16_t DamageNumber::rowheight(bool critical)
	{
		return critical ? 36 : 30;
	}

	void DamageNumber::init()
	{
		nl::node BasicEff = nl::nx::Effect["BasicEff.img"];

		charsets[DamageNumber::Type::NORMAL].set(false, BasicEff["NoRed1"], Charset::Alignment::LEFT);
		charsets[DamageNumber::Type::NORMAL].set(true, BasicEff["NoRed0"], Charset::Alignment::LEFT);
		charsets[DamageNumber::Type::CRITICAL].set(false, BasicEff["NoCri1"], Charset::Alignment::LEFT);
		charsets[DamageNumber::Type::CRITICAL].set(true, BasicEff["NoCri0"], Charset::Alignment::LEFT);
		charsets[DamageNumber::Type::TOPLAYER].set(false, BasicEff["NoViolet1"], Charset::Alignment::LEFT);
		charsets[DamageNumber::Type::TOPLAYER].set(true, BasicEff["NoViolet0"], Charset::Alignment::LEFT);
	}

	BoolPair<Charset> DamageNumber::charsets[NUM_TYPES];
}

================
File: Gameplay/Combat/DamageNumber.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Physics/PhysicsObject.h"

#include "../../Template/BoolPair.h"

#include "../../IO/Components/Charset.h"

namespace ms
{
	class DamageNumber
	{
	public:
		static const size_t NUM_TYPES = 3;

		enum Type
		{
			NORMAL,
			CRITICAL,
			TOPLAYER
		};

		DamageNumber(Type type, int32_t damage, int16_t starty, int16_t x = 0);
		DamageNumber();

		void draw(double viewx, double viewy, float alpha) const;
		void set_x(int16_t headx);
		bool update();

		static int16_t rowheight(bool critical);
		static void init();

	private:
		int16_t getadvance(char c, bool first) const;

		static constexpr uint16_t FADE_TIME = 500;

		Type type;
		bool miss;
		bool multiple;
		int8_t firstnum;
		std::string restnum;
		int16_t shift;
		MovingObject moveobj;
		Linear<float> opacity;

		static BoolPair<Charset> charsets[NUM_TYPES];
	};
}

================
File: Gameplay/Combat/RegularAttack.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "RegularAttack.h"

namespace ms
{
	void RegularAttack::apply_useeffects(Char&) const {}

	void RegularAttack::apply_actions(Char& user, Attack::Type type) const
	{
		action.apply(user, type);
	}

	void RegularAttack::apply_stats(const Char& user, Attack& attack) const
	{
		attack.damagetype = Attack::DMG_WEAPON;
		attack.skill = 0;
		attack.mobcount = 1;
		attack.hitcount = 1;
		attack.stance = user.get_look().get_stance();

		if (attack.type == Attack::CLOSE)
			attack.range = user.get_afterimage().get_range();
	}

	void RegularAttack::apply_hiteffects(const AttackUser&, Mob&) const {}

	Animation RegularAttack::get_bullet(const Char& user, int32_t bulletid) const
	{
		return bullet.get(user, bulletid);
	}

	bool RegularAttack::is_attack() const
	{
		return true;
	}

	bool RegularAttack::is_skill() const
	{
		return false;
	}

	int32_t RegularAttack::get_id() const
	{
		return 0;
	}

	SpecialMove::ForbidReason RegularAttack::can_use(int32_t, Weapon::Type weapon, const Job&, uint16_t, uint16_t, uint16_t bullets) const
	{
		switch (weapon)
		{
		case Weapon::BOW:
		case Weapon::CROSSBOW:
		case Weapon::CLAW:
		case Weapon::GUN:
			return bullets ? FBR_NONE : FBR_BULLETCOST;
		default:
			return FBR_NONE;
		}
	}
}

================
File: Gameplay/Combat/RegularAttack.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "SpecialMove.h"
#include "SkillAction.h"
#include "SkillBullet.h"

namespace ms
{
	class RegularAttack : public SpecialMove
	{
	public:
		void apply_useeffects(Char& user) const override;
		void apply_actions(Char& user, Attack::Type type) const override;
		void apply_stats(const Char& user, Attack& attack) const override;
		void apply_hiteffects(const AttackUser& user, Mob& target) const override;
		Animation get_bullet(const Char& user, int32_t bulletid) const override;

		bool is_attack() const override;
		bool is_skill() const override;
		int32_t get_id() const override;

		ForbidReason can_use(int32_t level, Weapon::Type weapon, const Job& job, uint16_t hp, uint16_t mp, uint16_t bullets) const override;

	private:
		RegularAction action;
		RegularBullet bullet;
	};
}

================
File: Gameplay/Combat/Skill.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Skill.h"

#include "../../Character/SkillId.h"
#include "../../Data/SkillData.h"
#include "../../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Skill::Skill(int32_t id) : skillid(id)
	{
		const SkillData& data = SkillData::get(skillid);

		std::string strid;

		if (skillid < 10000000)
			strid = string_format::extend_id(skillid, 7);
		else
			strid = std::to_string(skillid);

		nl::node src = nl::nx::Skill[strid.substr(0, 3) + ".img"]["skill"][strid];

		projectile = true;
		overregular = false;

		sound = std::make_unique<SingleSkillSound>(strid);

		bool byleveleffect = src["CharLevel"]["10"]["effect"].size() > 0;
		bool multieffect = src["effect0"].size() > 0;

		if (byleveleffect)
		{
			useeffect = std::make_unique<ByLevelUseEffect>(src);
		}
		else if (multieffect)
		{
			useeffect = std::make_unique<MultiUseEffect>(src);
		}
		else
		{
			bool isanimation = src["effect"]["0"].data_type() == nl::node::type::bitmap;
			bool haseffect1 = src["effect"]["1"].size() > 0;

			if (isanimation)
			{
				useeffect = std::make_unique<SingleUseEffect>(src);
			}
			else if (haseffect1)
			{
				useeffect = std::make_unique<TwoHandedUseEffect>(src);
			}
			else
			{
				switch (skillid)
				{
				case SkillId::IRON_BODY:
				case SkillId::MAGIC_ARMOR:
					useeffect = std::make_unique<IronBodyUseEffect>();
					break;
				default:
					useeffect = std::make_unique<NoUseEffect>();
					break;
				}
			}
		}

		bool bylevelhit = src["CharLevel"]["10"]["hit"].size() > 0;
		bool byskilllevelhit = src["level"]["1"]["hit"].size() > 0;
		bool hashit0 = src["hit"]["0"].size() > 0;
		bool hashit1 = src["hit"]["1"].size() > 0;

		if (bylevelhit)
		{
			if (hashit0 && hashit1)
				hiteffect = std::make_unique<ByLevelTwoHHitEffect>(src);
			else
				hiteffect = std::make_unique<ByLevelHitEffect>(src);
		}
		else if (byskilllevelhit)
		{
			hiteffect = std::make_unique<BySkillLevelHitEffect>(src);
		}
		else if (hashit0 && hashit1)
		{
			hiteffect = std::make_unique<TwoHandedHitEffect>(src);
		}
		else if (hashit0)
		{
			hiteffect = std::make_unique<SingleHitEffect>(src);
		}
		else
		{
			hiteffect = std::make_unique<NoHitEffect>();
		}

		bool hasaction0 = src["action"]["0"].data_type() == nl::node::type::string;
		bool hasaction1 = src["action"]["1"].data_type() == nl::node::type::string;

		if (hasaction0 && hasaction1)
		{
			action = std::make_unique<TwoHandedAction>(src);
		}
		else if (hasaction0)
		{
			action = std::make_unique<SingleAction>(src);
		}
		else if (data.is_attack())
		{
			bool bylevel = src["level"]["1"]["action"].data_type() == nl::node::type::string;

			if (bylevel)
			{
				action = std::make_unique<ByLevelAction>(src, skillid);
			}
			else
			{
				action = std::make_unique<RegularAction>();
				overregular = true;
			}
		}
		else
		{
			action = std::make_unique<NoAction>();
		}

		bool hasball = src["ball"].size() > 0;
		bool bylevelball = src["level"]["1"]["ball"].size() > 0;

		if (bylevelball)
		{
			bullet = std::make_unique<BySkillLevelBullet>(src, skillid);
		}
		else if (hasball)
		{
			bullet = std::make_unique<SingleBullet>(src);
		}
		else
		{
			bullet = std::make_unique<RegularBullet>();
			projectile = false;
		}
	}

	void Skill::apply_useeffects(Char& user) const
	{
		useeffect->apply(user);

		sound->play_use();
	}

	void Skill::apply_actions(Char& user, Attack::Type type) const
	{
		action->apply(user, type);
	}

	void Skill::apply_stats(const Char& user, Attack& attack) const
	{
		attack.skill = skillid;

		int32_t level = user.get_skilllevel(skillid);
		const SkillData::Stats stats = SkillData::get(skillid).get_stats(level);

		if (stats.fixdamage)
		{
			attack.fixdamage = stats.fixdamage;
			attack.damagetype = Attack::DMG_FIXED;
		}
		else if (stats.matk)
		{
			attack.matk += stats.matk;
			attack.damagetype = Attack::DMG_MAGIC;
		}
		else
		{
			attack.mindamage *= stats.damage;
			attack.maxdamage *= stats.damage;
			attack.damagetype = Attack::DMG_WEAPON;
		}

		attack.critical += stats.critical;
		attack.ignoredef += stats.ignoredef;
		attack.mobcount = stats.mobcount;
		attack.hrange = stats.hrange;

		switch (attack.type)
		{
		case Attack::RANGED:
			attack.hitcount = stats.bulletcount;
			break;
		default:
			attack.hitcount = stats.attackcount;
			break;
		}

		if (!stats.range.empty())
			attack.range = stats.range;

		if (projectile && !attack.bullet)
		{
			switch (skillid)
			{
			case SkillId::THREE_SNAILS:
				switch (level)
				{
				case 1:
					attack.bullet = 4000019;
					break;
				case 2:
					attack.bullet = 4000000;
					break;
				case 3:
					attack.bullet = 4000016;
					break;
				}
				break;
			default:
				attack.bullet = skillid;
				break;
			}
		}

		if (overregular)
		{
			attack.stance = user.get_look().get_stance();

			if (attack.type == Attack::CLOSE && !projectile)
				attack.range = user.get_afterimage().get_range();
		}
	}

	void Skill::apply_hiteffects(const AttackUser& user, Mob& target) const
	{
		hiteffect->apply(user, target);

		sound->play_hit();
	}

	Animation Skill::get_bullet(const Char& user, int32_t bulletid) const
	{
		return bullet->get(user, bulletid);
	}

	bool Skill::is_attack() const
	{
		return SkillData::get(skillid).is_attack();
	}

	bool Skill::is_skill() const
	{
		return true;
	}

	int32_t Skill::get_id() const
	{
		return skillid;
	}

	SpecialMove::ForbidReason Skill::can_use(int32_t level, Weapon::Type weapon, const Job& job, uint16_t hp, uint16_t mp, uint16_t bullets) const
	{
		if (level <= 0 || level > SkillData::get(skillid).get_masterlevel())
			return FBR_OTHER;

		if (job.can_use(skillid) == false)
			return FBR_OTHER;

		const SkillData::Stats stats = SkillData::get(skillid).get_stats(level);

		if (hp <= stats.hpcost)
			return FBR_HPCOST;

		if (mp < stats.mpcost)
			return FBR_MPCOST;

		Weapon::Type reqweapon = SkillData::get(skillid).get_required_weapon();

		if (weapon != reqweapon && reqweapon != Weapon::NONE)
			return FBR_WEAPONTYPE;

		switch (weapon)
		{
		case Weapon::BOW:
		case Weapon::CROSSBOW:
		case Weapon::CLAW:
		case Weapon::GUN:
			return (bullets >= stats.bulletcost) ? FBR_NONE : FBR_BULLETCOST;
		default:
			return FBR_NONE;
		}
	}
}

================
File: Gameplay/Combat/Skill.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "SkillAction.h"
#include "SkillBullet.h"
#include "SkillHitEffect.h"
#include "SkillSound.h"
#include "SkillUseEffect.h"
#include "SpecialMove.h"

#include <memory>

namespace ms
{
	// The skill implementation of special move
	class Skill : public SpecialMove
	{
	public:
		Skill(int32_t skillid);

		void apply_useeffects(Char& user) const override;
		void apply_actions(Char& user, Attack::Type type) const override;
		void apply_stats(const Char& user, Attack& attack) const override;
		void apply_hiteffects(const AttackUser& user, Mob& target) const override;
		Animation get_bullet(const Char& user, int32_t bulletid) const override;

		bool is_attack() const override;
		bool is_skill() const override;
		int32_t get_id() const override;

		ForbidReason can_use(int32_t level, Weapon::Type weapon, const Job& job, uint16_t hp, uint16_t mp, uint16_t bullets) const override;

	private:
		std::unique_ptr<SkillAction> action;
		std::unique_ptr<SkillBullet> bullet;
		std::unique_ptr<SkillSound> sound;
		std::unique_ptr<SkillUseEffect> useeffect;
		std::unique_ptr<SkillHitEffect> hiteffect;

		int32_t skillid;
		bool overregular;
		bool projectile;
	};
}

================
File: Gameplay/Combat/SkillAction.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "SkillAction.h"

#include "../../Util/Misc.h"

namespace ms
{
	void RegularAction::apply(Char& target, Attack::Type atype) const
	{
		Weapon::Type weapontype = target.get_weapontype();
		bool degenerate;

		switch (weapontype)
		{
		case Weapon::BOW:
		case Weapon::CROSSBOW:
		case Weapon::CLAW:
		case Weapon::GUN:
			degenerate = atype != Attack::RANGED;
			break;
		default:
			degenerate = false;
			break;
		}

		target.attack(degenerate);
	}

	SingleAction::SingleAction(nl::node src)
	{
		action = src["action"]["0"];
	}

	void SingleAction::apply(Char& target, Attack::Type) const
	{
		target.attack(action);
	}

	TwoHandedAction::TwoHandedAction(nl::node src)
	{
		actions[false] = src["action"]["0"];
		actions[true] = src["action"]["1"];
	}

	void TwoHandedAction::apply(Char& target, Attack::Type) const
	{
		bool twohanded = target.is_twohanded();
		std::string action = actions[twohanded];

		target.attack(action);
	}

	ByLevelAction::ByLevelAction(nl::node src, int32_t id)
	{
		for (auto sub : src["level"])
		{
			int32_t level = string_conversion::or_zero<int32_t>(sub.name());
			actions[level] = sub["action"];
		}

		skillid = id;
	}

	void ByLevelAction::apply(Char& target, Attack::Type) const
	{
		int32_t level = target.get_skilllevel(skillid);
		auto iter = actions.find(level);

		if (iter != actions.end())
			target.attack(iter->second);
	}
}

================
File: Gameplay/Combat/SkillAction.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Attack.h"

#include "../../Character/Char.h"

namespace ms
{
	class SkillAction
	{
	public:
		virtual ~SkillAction() {}

		virtual void apply(Char& target, Attack::Type atype) const = 0;
	};

	class NoAction : public SkillAction
	{
	public:
		void apply(Char&, Attack::Type) const override {}
	};

	class RegularAction : public SkillAction
	{
	public:
		void apply(Char& target, Attack::Type atype) const override;
	};

	class SingleAction : public SkillAction
	{
	public:
		SingleAction(nl::node src);

		void apply(Char& target, Attack::Type atype) const override;

	private:
		std::string action;
	};

	class TwoHandedAction : public SkillAction
	{
	public:
		TwoHandedAction(nl::node src);

		void apply(Char& target, Attack::Type atype) const override;

	private:
		BoolPair<std::string> actions;
	};

	class ByLevelAction : public SkillAction
	{
	public:
		ByLevelAction(nl::node src, int32_t skillid);

		void apply(Char& target, Attack::Type atype) const override;

	private:
		std::map<int32_t, std::string> actions;
		int32_t skillid;
	};
}

================
File: Gameplay/Combat/SkillBullet.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "SkillBullet.h"

#include "../../Data/BulletData.h"
#include "../../Util/Misc.h"

namespace ms
{
	Animation RegularBullet::get(const Char&, int32_t bulletid) const
	{
		return BulletData::get(bulletid).get_animation();
	}

	SingleBullet::SingleBullet(nl::node src)
	{
		ball = src["ball"];
	}

	Animation SingleBullet::get(const Char&, int32_t) const
	{
		return ball.animation;
	}

	BySkillLevelBullet::BySkillLevelBullet(nl::node src, int32_t id)
	{
		skillid = id;

		for (auto sub : src["level"])
		{
			auto level = string_conversion::or_zero<int32_t>(sub.name());
			bullets[level] = sub["ball"];
		}
	}

	Animation BySkillLevelBullet::get(const Char& user, int32_t) const
	{
		int32_t level = user.get_skilllevel(skillid);
		auto iter = bullets.find(level);

		if (iter != bullets.end())
			return iter->second.animation;
		else
			return {};
	}
}

================
File: Gameplay/Combat/SkillBullet.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Character/Char.h"

namespace ms
{
	class SkillBullet
	{
	public:
		virtual ~SkillBullet() {}

		virtual Animation get(const Char& user, int32_t bulletid) const = 0;

	protected:
		struct Ball
		{
			Animation animation;

			Ball(nl::node src)
			{
				animation = src;
			}

			Ball() {}
		};
	};

	class RegularBullet : public SkillBullet
	{
	public:
		Animation get(const Char& user, int32_t bulletid) const override;
	};

	class SingleBullet : public SkillBullet
	{
	public:
		SingleBullet(nl::node src);

		Animation get(const Char& user, int32_t bulletid) const override;

	private:
		Ball ball;
	};

	class BySkillLevelBullet : public SkillBullet
	{
	public:
		BySkillLevelBullet(nl::node src, int32_t skillid);

		Animation get(const Char& user, int32_t bulletid) const override;

	private:
		std::unordered_map<int32_t, Ball> bullets;
		int32_t skillid;
	};
}

================
File: Gameplay/Combat/SkillHitEffect.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "SkillHitEffect.h"

#include "../../Util/Misc.h"

namespace ms
{
	SingleHitEffect::SingleHitEffect(nl::node src) : effect(src["hit"]["0"]) {}

	void SingleHitEffect::apply(const AttackUser& user, Mob& target) const
	{
		effect.apply(target, user.flip);
	}

	TwoHandedHitEffect::TwoHandedHitEffect(nl::node src) : effects(src["hit"]["0"], src["hit"]["1"]) {}

	void TwoHandedHitEffect::apply(const AttackUser& user, Mob& target) const
	{
		effects[user.secondweapon].apply(target, user.flip);
	}

	ByLevelHitEffect::ByLevelHitEffect(nl::node src)
	{
		for (auto sub : src["CharLevel"])
		{
			uint16_t level = string_conversion::or_zero<uint16_t>(sub.name());
			effects.emplace(level, sub["hit"]["0"]);
		}
	}

	void ByLevelHitEffect::apply(const AttackUser& user, Mob& target) const
	{
		if (effects.empty())
			return;

		auto iter = effects.begin();
		for (; iter != effects.end() && user.level > iter->first; ++iter) {}

		if (iter != effects.begin())
			iter--;

		iter->second.apply(target, user.flip);
	}

	ByLevelTwoHHitEffect::ByLevelTwoHHitEffect(nl::node src)
	{
		for (auto sub : src["CharLevel"])
		{
			auto level = string_conversion::or_zero<uint16_t>(sub.name());

			effects.emplace(std::piecewise_construct,
				std::forward_as_tuple(level),
				std::forward_as_tuple(sub["hit"]["0"], sub["hit"]["1"])
				);
		}
	}

	void ByLevelTwoHHitEffect::apply(const AttackUser& user, Mob& target) const
	{
		if (effects.empty())
			return;

		auto iter = effects.begin();
		for (; iter != effects.end() && user.level > iter->first; ++iter) {}

		if (iter != effects.begin())
			iter--;

		iter->second[user.secondweapon].apply(target, user.flip);
	}

	BySkillLevelHitEffect::BySkillLevelHitEffect(nl::node src)
	{
		for (auto sub : src["level"])
		{
			auto level = string_conversion::or_zero<int32_t>(sub.name());
			effects.emplace(level, sub["hit"]["0"]);
		}
	}

	void BySkillLevelHitEffect::apply(const AttackUser& user, Mob& target) const
	{
		auto iter = effects.find(user.skilllevel);

		if (iter != effects.end())
			iter->second.apply(target, user.flip);
	}
}

================
File: Gameplay/Combat/SkillHitEffect.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../MapleMap/Mob.h"

#include "../../Template/BoolPair.h"

namespace ms
{
	// Interface for hit effects, animations applied to a mob for each hit.
	class SkillHitEffect
	{
	public:
		virtual ~SkillHitEffect() {}

		virtual void apply(const AttackUser& user, Mob& target) const = 0;

	protected:
		class Effect
		{
		public:
			Effect(nl::node src)
			{
				animation = src;
				pos = src["pos"];
				z = src["z"];
			}

			void apply(Mob& target, bool flip) const
			{
				target.show_effect(animation, pos, z, flip);
			}

		private:
			Animation animation;
			int8_t pos;
			int8_t z;
		};
	};

	// No animation
	class NoHitEffect : public SkillHitEffect
	{
	public:
		void apply(const AttackUser&, Mob&) const override {}
	};

	// A single animation
	class SingleHitEffect : public SkillHitEffect
	{
	public:
		SingleHitEffect(nl::node src);

		void apply(const AttackUser& user, Mob& target) const override;

	private:
		Effect effect;
	};

	// The animation changes depending on the weapon used
	class TwoHandedHitEffect : public SkillHitEffect
	{
	public:
		TwoHandedHitEffect(nl::node src);

		void apply(const AttackUser& user, Mob& target) const override;

	private:
		BoolPair<Effect> effects;
	};

	// The animation changes with the character level
	class ByLevelHitEffect : public SkillHitEffect
	{
	public:
		ByLevelHitEffect(nl::node src);

		void apply(const AttackUser& user, Mob& target) const override;

	private:
		std::map<uint16_t, Effect> effects;
	};

	// The animation changes with the character level and weapon used
	class ByLevelTwoHHitEffect : public SkillHitEffect
	{
	public:
		ByLevelTwoHHitEffect(nl::node src);

		void apply(const AttackUser& user, Mob& target) const override;

	private:
		std::map<uint16_t, BoolPair<Effect>> effects;
	};

	// The animation changes with the skill level
	class BySkillLevelHitEffect : public SkillHitEffect
	{
	public:
		BySkillLevelHitEffect(nl::node src);

		void apply(const AttackUser& user, Mob& target) const override;

	private:
		std::map<int32_t, Effect> effects;
	};
}

================
File: Gameplay/Combat/SkillSound.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "SkillSound.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	SingleSkillSound::SingleSkillSound(std::string strid)
	{
		nl::node soundsrc = nl::nx::Sound["Skill.img"][strid];

		usesound = soundsrc["Use"];
		hitsound = soundsrc["Hit"];
	}

	void SingleSkillSound::play_use() const
	{
		usesound.play();
	}

	void SingleSkillSound::play_hit() const
	{
		hitsound.play();
	}
}

================
File: Gameplay/Combat/SkillSound.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Audio/Audio.h"

namespace ms
{
	// Interface for skill sound
	class SkillSound
	{
	public:
		virtual ~SkillSound() {}

		virtual void play_use() const = 0;
		virtual void play_hit() const = 0;
	};

	// No sound
	class NoSkillSound : public SkillSound
	{
	public:
		void play_use() const override {}
		void play_hit() const override {}
	};

	// Plays one use and one hit sound
	class SingleSkillSound : public SkillSound
	{
	public:
		SingleSkillSound(std::string strid);

		void play_use() const override;
		void play_hit() const override;

	private:
		Sound usesound;
		Sound hitsound;
	};
}

================
File: Gameplay/Combat/SkillUseEffect.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "SkillUseEffect.h"

#include "../../Util/Misc.h"

namespace ms
{
	SingleUseEffect::SingleUseEffect(nl::node src) : effect(src["effect"]) {}

	void SingleUseEffect::apply(Char& target) const
	{
		effect.apply(target);
	}

	TwoHandedUseEffect::TwoHandedUseEffect(nl::node src) : effects(src["effect"]["0"], src["effect"]["1"]) {}

	void TwoHandedUseEffect::apply(Char& target) const
	{
		bool twohanded = target.is_twohanded();
		effects[twohanded].apply(target);
	}

	MultiUseEffect::MultiUseEffect(nl::node src)
	{
		int8_t no = -1;
		nl::node sub = src["effect"];

		while (sub)
		{
			effects.push_back(sub);

			no++;
			sub = src["effect" + std::to_string(no)];
		}
	}

	void MultiUseEffect::apply(Char& target) const
	{
		for (auto& effect : effects)
			effect.apply(target);
	}

	ByLevelUseEffect::ByLevelUseEffect(nl::node src)
	{
		for (auto sub : src["CharLevel"])
		{
			auto level = string_conversion::or_zero<uint16_t>(sub.name());
			effects.emplace(level, sub["effect"]);
		}
	}

	void ByLevelUseEffect::apply(Char& target) const
	{
		if (effects.empty())
			return;

		uint16_t level = target.get_level();
		auto iter = effects.begin();
		for (; iter != effects.end() && level > iter->first; ++iter) {}

		if (iter != effects.begin())
			iter--;

		iter->second.apply(target);
	}

	void IronBodyUseEffect::apply(Char& target) const
	{
		target.show_iron_body();
	}
}

================
File: Gameplay/Combat/SkillUseEffect.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Character/Char.h"

namespace ms
{
	// Interface for skill effects
	class SkillUseEffect
	{
	public:
		virtual ~SkillUseEffect() {}

		virtual void apply(Char& target) const = 0;

	protected:
		class Effect
		{
		public:
			Effect(nl::node src)
			{
				animation = src;
				z = src["z"];
			}

			void apply(Char& target) const
			{
				target.show_attack_effect(animation, z);
			}

		private:
			Animation animation;
			int8_t z;
		};
	};

	// No animation
	class NoUseEffect : public SkillUseEffect
	{
	public:
		void apply(Char&) const override {}
	};

	// An effect which displays an animation over the character's position
	class SingleUseEffect : public SkillUseEffect
	{
	public:
		SingleUseEffect(nl::node src);

		void apply(Char& target) const override;

	private:
		Effect effect;
	};

	// An effect which displays an animation over the character's position
	// The effect changes based on whether the character uses a two-handed weapon
	class TwoHandedUseEffect : public SkillUseEffect
	{
	public:
		TwoHandedUseEffect(nl::node src);

		void apply(Char& target) const override;

	private:
		BoolPair<Effect> effects;
	};

	// An effect which displays multiple animations over the character's position
	class MultiUseEffect : public SkillUseEffect
	{
	public:
		MultiUseEffect(nl::node src);

		void apply(Char& target) const override;

	private:
		std::vector<Effect> effects;
	};

	// The animation changes with the character level
	class ByLevelUseEffect : public SkillUseEffect
	{
	public:
		ByLevelUseEffect(nl::node src);

		void apply(Char& target) const override;

	private:
		std::map<uint16_t, Effect> effects;
	};

	// Use effect for Iron Body
	class IronBodyUseEffect : public SkillUseEffect
	{
	public:
		void apply(Char& target) const override;
	};
}

================
File: Gameplay/Combat/SpecialMove.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../MapleMap/Mob.h"

#include "../../Character/Char.h"
#include "../../Character/Job.h"

namespace ms
{
	// Base class for attacks and buffs
	class SpecialMove
	{
	public:
		enum ForbidReason
		{
			FBR_NONE,
			FBR_WEAPONTYPE,
			FBR_HPCOST,
			FBR_MPCOST,
			FBR_BULLETCOST,
			FBR_COOLDOWN,
			FBR_OTHER
		};

		virtual ~SpecialMove() {}

		virtual void apply_useeffects(Char& user) const = 0;
		virtual void apply_actions(Char& user, Attack::Type type) const = 0;
		virtual void apply_stats(const Char& user, Attack& attack) const = 0;
		virtual void apply_hiteffects(const AttackUser& user, Mob& target) const = 0;
		virtual Animation get_bullet(const Char& user, int32_t bulletid) const = 0;

		virtual bool is_attack() const = 0;
		virtual bool is_skill() const = 0;
		virtual int32_t get_id() const = 0;

		virtual ForbidReason can_use(int32_t level, Weapon::Type weapon, const Job& job, uint16_t hp, uint16_t mp, uint16_t bullets) const = 0;
	};
}

================
File: Gameplay/MapleMap/Drop.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Drop.h"

namespace ms
{
	Drop::Drop(int32_t id, int32_t own, Point<int16_t> start, Point<int16_t> dst, int8_t type, int8_t mode, bool pldrp) : MapObject(id)
	{
		owner = own;
		set_position(start.x(), start.y() - 4);
		dest = dst;
		pickuptype = type;
		playerdrop = pldrp;

		angle.set(0.0f);
		opacity.set(1.0f);
		moved = 0.0f;
		looter = nullptr;

		switch (mode)
		{
		case 0:
		case 1:
			state = Drop::State::DROPPED;
			basey = static_cast<double>(dest.y() - 4);
			phobj.vspeed = -5.0f;
			phobj.hspeed = static_cast<double>(dest.x() - start.x()) / 48;
			break;
		case 2:
			state = Drop::State::FLOATING;
			basey = phobj.crnt_y();
			phobj.type = PhysicsObject::Type::FIXATED;
			break;
		case 3:
			state = Drop::State::PICKEDUP;
			phobj.vspeed = -5.0f;
			break;
		}
	}

	int8_t Drop::update(const Physics& physics)
	{
		physics.move_object(phobj);

		if (state == Drop::State::DROPPED)
		{
			if (phobj.onground)
			{
				phobj.hspeed = 0.0;
				phobj.type = PhysicsObject::Type::FIXATED;
				state = Drop::State::FLOATING;
				angle.set(0.0f);
				set_position(dest.x(), dest.y() - 4);
			}
			else
			{
				static const float SPINSTEP = 0.2f;
				angle += SPINSTEP;
			}
		}

		if (state == Drop::State::FLOATING)
		{
			phobj.y = basey + 5.0f + (cos(moved) - 1.0f) * 2.5f;
			moved = (moved < 360.0f) ? moved + 0.025f : 0.0f;
		}

		if (state == Drop::State::PICKEDUP)
		{
			static const uint16_t PICKUPTIME = 48;
			static const float OPCSTEP = 1.0f / PICKUPTIME;

			if (looter)
			{
				double hdelta = looter->x - phobj.x;
				phobj.hspeed = looter->hspeed / 2.0 + (hdelta - 16.0) / PICKUPTIME;
			}

			opacity -= OPCSTEP;

			if (opacity.last() <= OPCSTEP)
			{
				opacity.set(1.0f);

				MapObject::deactivate();
				return -1;
			}
		}

		return phobj.fhlayer;
	}

	void Drop::expire(int8_t type, const PhysicsObject* lt)
	{
		switch (type)
		{
		case 0:
			state = Drop::State::PICKEDUP;
			break;
		case 1:
			deactivate();
			break;
		case 2:
			angle.set(0.0f);
			state = Drop::State::PICKEDUP;
			looter = lt;
			phobj.vspeed = -4.5f;
			phobj.type = PhysicsObject::Type::NORMAL;
			break;
		}
	}

	Rectangle<int16_t> Drop::bounds() const
	{
		auto lt = get_position();
		auto rb = lt + Point<int16_t>(32, 32);

		return Rectangle<int16_t>(lt, rb);
	}
}

================
File: Gameplay/MapleMap/Drop.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "MapObject.h"

#include "../../Template/Rectangle.h"

namespace ms
{
	class Drop : public MapObject
	{
	public:
		virtual int8_t update(const Physics& physics) override;

		void expire(int8_t, const PhysicsObject*);

		Rectangle<int16_t> bounds() const;

	protected:
		Drop(int32_t oid, int32_t owner, Point<int16_t> start,
			Point<int16_t> dest, int8_t type, int8_t mode, bool playerdrop);

		Linear<float> opacity;
		Linear<float> angle;

	private:
		enum State
		{
			DROPPED,
			FLOATING,
			PICKEDUP
		};

		int32_t owner;
		int8_t pickuptype;
		bool playerdrop;

		const PhysicsObject* looter;
		State state;

		Point<int16_t> dest;
		double basey;
		double moved;
	};
}

================
File: Gameplay/MapleMap/ItemDrop.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "ItemDrop.h"

namespace ms
{
	ItemDrop::ItemDrop(int32_t oid, int32_t owner, Point<int16_t> start, Point<int16_t> dest, int8_t type, int8_t mode, int32_t iid, bool pd, const Texture& icn) : Drop(oid, owner, start, dest, type, mode, pd), icon(icn), itemid(iid) {}

	void ItemDrop::draw(double viewx, double viewy, float alpha) const
	{
		if (!active)
			return;

		Point<int16_t> absp = phobj.get_absolute(viewx, viewy, alpha);
		icon.draw({ angle.get(alpha), absp, opacity.get(alpha) });
	}
}

================
File: Gameplay/MapleMap/ItemDrop.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Drop.h"

#include "../../Graphics/Texture.h"

namespace ms
{
	class ItemDrop : public Drop
	{
	public:
		ItemDrop(int32_t oid, int32_t owner, Point<int16_t> start, Point<int16_t> dest, int8_t type, int8_t mode, int32_t iid, bool playerdrop, const Texture& icon);

		void draw(double viewx, double viewy, float alpha) const override;

	private:
		const Texture& icon;
		int32_t itemid;
	};
}

================
File: Gameplay/MapleMap/Layer.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Template/Enumeration.h"

namespace ms
{
	namespace Layer
	{
		enum Id
		{
			ZERO,
			ONE,
			TWO,
			THREE,
			FOUR,
			FIVE,
			SIX,
			SEVEN,
			LENGTH
		};

		constexpr Enumeration<Id> IDs;
	}
}

================
File: Gameplay/MapleMap/MapBackgrounds.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapBackgrounds.h"

#include "../../Graphics/GraphicsGL.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Background::Background(nl::node src)
	{
		VWIDTH = Constants::Constants::get().get_viewwidth();
		VHEIGHT = Constants::Constants::get().get_viewheight();
		WOFFSET = VWIDTH / 2;
		HOFFSET = VHEIGHT / 2;

		// Try multiple paths for v83 compatibility
		nl::node backsrc = nl::nx::Map001["Back"];
		if (backsrc.name().empty()) {
			// Try direct Map path (v83)
			backsrc = nl::nx::Map["Back"];
		}

		animated = src["ani"].get_bool();
		animation = backsrc[src["bS"] + ".img"][animated ? "ani" : "back"][src["no"]];
		opacity = src["a"];
		flipped = src["f"].get_bool();
		cx = src["cx"];
		cy = src["cy"];
		rx = src["rx"];
		ry = src["ry"];

		moveobj.set_x(src["x"]);
		moveobj.set_y(src["y"]);

		Type type = typebyid(src["type"]);

		settype(type);
	}

	void Background::settype(Type type)
	{
		int16_t dim_x = animation.get_dimensions().x();
		int16_t dim_y = animation.get_dimensions().y();

		// TODO: Double check for zero. Is this a WZ reading issue?
		if (cx == 0)
			cx = (dim_x > 0) ? dim_x : 1;

		if (cy == 0)
			cy = (dim_y > 0) ? dim_y : 1;

		htile = 1;
		vtile = 1;

		switch (type)
		{
		case Type::HTILED:
		case Type::HMOVEA:
			htile = VWIDTH / cx + 3;
			break;
		case Type::VTILED:
		case Type::VMOVEA:
			vtile = VHEIGHT / cy + 3;
			break;
		case Type::TILED:
		case Type::HMOVEB:
		case Type::VMOVEB:
			htile = VWIDTH / cx + 3;
			vtile = VHEIGHT / cy + 3;
			break;
		}

		switch (type)
		{
		case Type::HMOVEA:
		case Type::HMOVEB:
			moveobj.hspeed = rx / 16;
			break;
		case Type::VMOVEA:
		case Type::VMOVEB:
			moveobj.vspeed = ry / 16;
			break;
		}
	}

	void Background::draw(double viewx, double viewy, float alpha) const
	{
		double x;

		if (moveobj.hmobile())
		{
			x = moveobj.get_absolute_x(viewx, alpha);
		}
		else
		{
			double shift_x = rx * (WOFFSET - viewx) / 100 + WOFFSET;
			x = moveobj.get_absolute_x(shift_x, alpha);
		}

		double y;

		if (moveobj.vmobile())
		{
			y = moveobj.get_absolute_y(viewy, alpha);
		}
		else
		{
			double shift_y = ry * (HOFFSET - viewy) / 100 + HOFFSET;
			y = moveobj.get_absolute_y(shift_y, alpha);
		}

		if (htile > 1)
		{
			while (x > 0)
				x -= cx;

			while (x < -cx)
				x += cx;
		}

		if (vtile > 1)
		{
			while (y > 0)
				y -= cy;

			while (y < -cy)
				y += cy;
		}

		int16_t ix = static_cast<int16_t>(std::round(x));
		int16_t iy = static_cast<int16_t>(std::round(y));

		int16_t tw = cx * htile;
		int16_t th = cy * vtile;

		for (int16_t tx = 0; tx < tw; tx += cx)
			for (int16_t ty = 0; ty < th; ty += cy)
				animation.draw(DrawArgument(Point<int16_t>(ix + tx, iy + ty), flipped, opacity / 255), alpha);
	}

	void Background::update()
	{
		moveobj.move();
		animation.update();
	}

	MapBackgrounds::MapBackgrounds(nl::node src)
	{
		int16_t no = 0;
		nl::node back = src[std::to_string(no)];

		while (back.size() > 0)
		{
			bool front = back["front"].get_bool();

			if (front)
				foregrounds.push_back(back);
			else
				backgrounds.push_back(back);

			no++;
			back = src[std::to_string(no)];
		}

		black = src["0"]["bS"].get_string() == "";
	}

	MapBackgrounds::MapBackgrounds() {}

	void MapBackgrounds::drawbackgrounds(double viewx, double viewy, float alpha) const
	{
		if (black)
			GraphicsGL::get().drawscreenfill(0.0f, 0.0f, 0.0f, 1.0f);

		for (auto& background : backgrounds)
			background.draw(viewx, viewy, alpha);
	}

	void MapBackgrounds::drawforegrounds(double viewx, double viewy, float alpha) const
	{
		for (auto& foreground : foregrounds)
			foreground.draw(viewx, viewy, alpha);
	}

	void MapBackgrounds::update()
	{
		for (auto& background : backgrounds)
			background.update();

		for (auto& foreground : foregrounds)
			foreground.update();
	}
}

================
File: Gameplay/MapleMap/MapBackgrounds.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Physics/PhysicsObject.h"

#include "../../Graphics/Animation.h"

#include <iostream>

namespace ms
{
	class Background
	{
	public:
		Background(nl::node src);

		void draw(double viewx, double viewy, float alpha) const;
		void update();

	private:
		enum Type
		{
			NORMAL,
			HTILED,
			VTILED,
			TILED,
			HMOVEA,
			VMOVEA,
			HMOVEB,
			VMOVEB
		};

		static Type typebyid(int32_t id)
		{
			if (id >= NORMAL && id <= VMOVEB)
				return static_cast<Type>(id);

			LOG(LOG_DEBUG, "Unknown Background::Type id: [" << id << "]");

			return NORMAL;
		}

		void settype(Type type);

		int16_t VWIDTH;
		int16_t VHEIGHT;
		int16_t WOFFSET;
		int16_t HOFFSET;

		Animation animation;
		bool animated;
		int16_t cx;
		int16_t cy;
		double rx;
		double ry;
		int16_t htile;
		int16_t vtile;
		float opacity;
		bool flipped;

		MovingObject moveobj;
	};

	class MapBackgrounds
	{
	public:
		MapBackgrounds(nl::node src);
		MapBackgrounds();

		void drawbackgrounds(double viewx, double viewy, float alpha) const;
		void drawforegrounds(double viewx, double viewy, float alpha) const;
		void update();

	private:
		std::vector<Background> backgrounds;
		std::vector<Background> foregrounds;
		bool black;
	};
}

================
File: Gameplay/MapleMap/MapChars.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapChars.h"

namespace ms
{
	void MapChars::draw(Layer::Id layer, double viewx, double viewy, float alpha) const
	{
		chars.draw(layer, viewx, viewy, alpha);
	}

	void MapChars::update(const Physics& physics)
	{
		for (; !spawns.empty(); spawns.pop())
		{
			const CharSpawn& spawn = spawns.front();

			int32_t cid = spawn.get_cid();
			Optional<OtherChar> ochar = get_char(cid);

			if (ochar)
			{
				// TODO: Blank
			}
			else
			{
				chars.add(spawn.instantiate());
			}
		}

		chars.update(physics);
	}

	void MapChars::spawn(CharSpawn&& spawn)
	{
		spawns.emplace(std::move(spawn));
	}

	void MapChars::remove(int32_t cid)
	{
		chars.remove(cid);
	}

	void MapChars::clear()
	{
		chars.clear();
	}

	MapObjects * MapChars::get_chars()
	{
		return &chars;
	}

	void MapChars::send_movement(int32_t cid, const std::vector<Movement>& movements)
	{
		if (Optional<OtherChar> otherchar = get_char(cid))
			otherchar->send_movement(movements);
	}

	void MapChars::update_look(int32_t cid, const LookEntry& look)
	{
		if (Optional<OtherChar> otherchar = get_char(cid))
			otherchar->update_look(look);
	}

	Optional<OtherChar> MapChars::get_char(int32_t cid)
	{
		return chars.get(cid);
	}
}

================
File: Gameplay/MapleMap/MapChars.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "MapObjects.h"

#include "../Spawn.h"

#include "../../Character/OtherChar.h"

namespace ms
{
	// A collection of remote controlled characters on a map
	class MapChars
	{
	public:
		// Draw all characters on a layer
		void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
		// Update all characters
		void update(const Physics& physics);

		// Spawn a new character, if it has not been spawned yet.
		void spawn(CharSpawn&& spawn);
		// Remove a character
		void remove(int32_t cid);
		// Remove all characters
		void clear();

		// Returns a reference to the MapObjects` object
		MapObjects* get_chars();

		// Update a character's movement
		void send_movement(int32_t cid, const std::vector<Movement>& movements);
		// Update a character's look
		void update_look(int32_t cid, const LookEntry& look);

		Optional<OtherChar> get_char(int32_t cid);

	private:
		MapObjects chars;

		std::queue<CharSpawn> spawns;
	};
}

================
File: Gameplay/MapleMap/MapDrops.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapDrops.h"

#include "Drop.h"

#include "../../Data/ItemData.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	MapDrops::MapDrops()
	{
		lootenabled = false;
	}

	void MapDrops::init()
	{
		nl::node src = nl::nx::Item["Special"]["0900.img"];

		mesoicons[MesoIcon::BRONZE] = src["09000000"]["iconRaw"];
		mesoicons[MesoIcon::GOLD] = src["09000001"]["iconRaw"];
		mesoicons[MesoIcon::BUNDLE] = src["09000002"]["iconRaw"];
		mesoicons[MesoIcon::BAG] = src["09000003"]["iconRaw"];
	}

	void MapDrops::draw(Layer::Id layer, double viewx, double viewy, float alpha) const
	{
		drops.draw(layer, viewx, viewy, alpha);
	}

	void MapDrops::update(const Physics& physics)
	{
		for (; !spawns.empty(); spawns.pop())
		{
			const DropSpawn& spawn = spawns.front();

			int32_t oid = spawn.get_oid();

			if (Optional<MapObject> drop = drops.get(oid))
			{
				drop->makeactive();
			}
			else
			{
				int32_t itemid = spawn.get_itemid();
				bool meso = spawn.is_meso();

				if (meso)
				{
					MesoIcon mesotype = (itemid > 999)
						? BAG : (itemid > 99)
						? BUNDLE : (itemid > 49)
						? GOLD : BRONZE;

					const Animation& icon = mesoicons[mesotype];
					drops.add(spawn.instantiate(icon));
				}
				else if (const ItemData& itemdata = ItemData::get(itemid))
				{
					const Texture& icon = itemdata.get_icon(true);
					drops.add(spawn.instantiate(icon));
				}
			}
		}

		for (auto& mesoicon : mesoicons)
			mesoicon.update();

		drops.update(physics);

		lootenabled = true;
	}

	void MapDrops::spawn(DropSpawn&& spawn)
	{
		spawns.emplace(std::move(spawn));
	}

	void MapDrops::remove(int32_t oid, int8_t mode, const PhysicsObject* looter)
	{
		if (Optional<Drop> drop = drops.get(oid))
			drop->expire(mode, looter);
	}

	void MapDrops::clear()
	{
		drops.clear();
	}

	MapDrops::Loot MapDrops::find_loot_at(Point<int16_t> playerpos)
	{
		if (!lootenabled)
			return { 0, {} };

		for (auto& mmo : drops)
		{
			Optional<const Drop> drop = mmo.second.get();

			if (drop && drop->bounds().contains(playerpos))
			{
				lootenabled = false;

				int32_t oid = mmo.first;
				Point<int16_t> position = drop->get_position();

				return { oid, position };
			}
		}

		return { 0, {} };
	}
}

================
File: Gameplay/MapleMap/MapDrops.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "MapObjects.h"

#include "../Spawn.h"

#include <queue>

namespace ms
{
	class MapDrops
	{
	public:
		MapDrops();

		// Initialize the meso icons
		void init();

		// Draw all drops on a layer
		void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
		// Update all drops
		void update(const Physics& physics);

		// Spawn a new drop
		void spawn(DropSpawn&& spawn);
		// Remove a drop
		void remove(int32_t oid, int8_t mode, const PhysicsObject* looter);
		// Remove all drops
		void clear();

		// Find a drop which can be picked up at the specified position
		using Loot = std::pair<int32_t, Point<int16_t>>;
		Loot find_loot_at(Point<int16_t> playerpos);

	private:
		MapObjects drops;

		enum MesoIcon
		{
			BRONZE,
			GOLD,
			BUNDLE,
			BAG,
			NUM_ICONS
		};

		std::array<Animation, MesoIcon::NUM_ICONS> mesoicons;
		bool lootenabled;

		std::queue<DropSpawn> spawns;
	};
}

================
File: Gameplay/MapleMap/MapEffect.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapEffect.h"

#include "../../Constants.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	MapEffect::MapEffect(std::string path) : active(false)
	{
		// Try Map002 fallback, then direct Map (v83)
		nl::node Effect = nl::nx::Map002["Effect.img"];
		if (Effect.name().empty()) {
			Effect = nl::nx::Map["Effect.img"];
		}

		effect = Effect.resolve(path);

		int16_t width = Constants::Constants::get().get_viewwidth();

		position = Point<int16_t>(width / 2, 250);
	}

	MapEffect::MapEffect() {}

	void MapEffect::draw() const
	{
		if (!active)
			effect.draw(position, 1.0f);
	}

	void MapEffect::update()
	{
		if (!active)
			active = effect.update(6);
	}
}

================
File: Gameplay/MapleMap/MapEffect.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Graphics/Animation.h"

namespace ms
{
	class MapEffect
	{
	public:
		MapEffect(std::string path);
		MapEffect();

		void draw() const;
		void update();

	private:
		bool active;
		Animation effect;
		Point<int16_t> position;
	};
}

================
File: Gameplay/MapleMap/MapInfo.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapInfo.h"

namespace ms
{
	MapInfo::MapInfo(nl::node src, Range<int16_t> walls, Range<int16_t> borders)
	{
		nl::node info = src["info"];

		if (info["VRLeft"].data_type() == nl::node::type::integer)
		{
			mapwalls = Range<int16_t>(info["VRLeft"], info["VRRight"]);
			mapborders = Range<int16_t>(info["VRTop"], info["VRBottom"]);
		}
		else
		{
			mapwalls = walls;
			mapborders = borders;
		}

		std::string bgmpath = info["bgm"];
		size_t split = bgmpath.find('/');
		bgm = bgmpath.substr(0, split) + ".img/" + bgmpath.substr(split + 1);

		cloud = info["cloud"].get_bool();
		fieldlimit = info["fieldLimit"];
		hideminimap = info["hideMinimap"].get_bool();
		mapmark = info["mapMark"];
		swim = info["swim"].get_bool();
		town = info["town"].get_bool();

		for (auto seat : src["seat"])
			seats.push_back(seat);

		for (auto ladder : src["ladderRope"])
			ladders.push_back(ladder);
	}

	MapInfo::MapInfo() {}

	bool MapInfo::is_underwater() const
	{
		return swim;
	}

	std::string MapInfo::get_bgm() const
	{
		return bgm;
	}

	Range<int16_t> MapInfo::get_walls() const
	{
		return mapwalls;
	}

	Range<int16_t> MapInfo::get_borders() const
	{
		return mapborders;
	}

	Optional<const Seat> MapInfo::findseat(Point<int16_t> position) const
	{
		for (auto& seat : seats)
			if (seat.inrange(position))
				return seat;

		return nullptr;
	}

	Optional<const Ladder> MapInfo::findladder(Point<int16_t> position, bool upwards) const
	{
		for (auto& ladder : ladders)
			if (ladder.inrange(position, upwards))
				return ladder;

		return nullptr;
	}

	Seat::Seat(nl::node src)
	{
		pos = src;
	}

	bool Seat::inrange(Point<int16_t> position) const
	{
		auto hor = Range<int16_t>::symmetric(position.x(), 10);
		auto ver = Range<int16_t>::symmetric(position.y(), 10);

		return hor.contains(pos.x()) && ver.contains(pos.y());
	}

	Point<int16_t> Seat::getpos() const
	{
		return pos;
	}

	Ladder::Ladder(nl::node src)
	{
		x = src["x"];
		y1 = src["y1"];
		y2 = src["y2"];
		ladder = src["l"].get_bool();
	}

	bool Ladder::is_ladder() const
	{
		return ladder;
	}

	bool Ladder::inrange(Point<int16_t> position, bool upwards) const
	{
		auto hor = Range<int16_t>::symmetric(position.x(), 10);
		auto ver = Range<int16_t>(y1, y2);

		int16_t y = upwards ?
			position.y() - 5 :
			position.y() + 5;

		return hor.contains(x) && ver.contains(y);
	}

	bool Ladder::felloff(int16_t y, bool downwards) const
	{
		int16_t dy = downwards ? y + 5 : y - 5;

		return dy > y2 || y + 5 < y1;
	}

	int16_t Ladder::get_x() const
	{
		return x;
	}
}

================
File: Gameplay/MapleMap/MapInfo.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Template/Optional.h"
#include "../../Template/Point.h"
#include "../../Template/Range.h"

#include <vector>

namespace ms
{
	class Seat
	{
	public:
		Seat(nl::node source);

		bool inrange(Point<int16_t> position) const;
		Point<int16_t> getpos() const;

	private:
		Point<int16_t> pos;
	};

	class Ladder
	{
	public:
		Ladder(nl::node source);

		bool is_ladder() const;
		bool inrange(Point<int16_t> position, bool upwards) const;
		bool felloff(int16_t y, bool downwards) const;
		int16_t get_x() const;

	private:
		int16_t x;
		int16_t y1;
		int16_t y2;
		bool ladder;
	};

	class MapInfo
	{
	public:
		MapInfo(nl::node src, Range<int16_t> walls, Range<int16_t> borders);
		MapInfo();

		bool is_underwater() const;
		std::string get_bgm() const;
		Range<int16_t> get_walls() const;
		Range<int16_t> get_borders() const;

		// Find a seat the player's position
		Optional<const Seat> findseat(Point<int16_t> position) const;
		// Find a ladder at the player's position
		// !upwards - implies downwards
		Optional<const Ladder> findladder(Point<int16_t> position, bool upwards) const;

	private:
		int32_t fieldlimit;
		bool cloud;
		std::string bgm;
		std::string mapdesc;
		std::string mapname;
		std::string streetname;
		std::string mapmark;
		bool swim;
		bool town;
		bool hideminimap;
		Range<int16_t> mapwalls;
		Range<int16_t> mapborders;
		std::vector<Seat> seats;
		std::vector<Ladder> ladders;
	};
}

================
File: Gameplay/MapleMap/MapMobs.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapMobs.h"
#include "Mob.h"

#include <algorithm>
#include <iostream>
#include <map>

namespace ms
{
	void MapMobs::draw(Layer::Id layer, double viewx, double viewy, float alpha) const
	{
		mobs.draw(layer, viewx, viewy, alpha);
	}

	void MapMobs::update(const Physics& physics)
	{
		for (; !spawns.empty(); spawns.pop())
		{
			const MobSpawn& spawn = spawns.front();

			if (Optional<Mob> mob = mobs.get(spawn.get_oid()))
			{
				int8_t mode = spawn.get_mode();

				if (mode > 0)
					mob->set_control(mode);

				mob->makeactive();
			}
			else
			{
				mobs.add(spawn.instantiate());
			}
		}

		mobs.update(physics);
	}

	void MapMobs::spawn(MobSpawn&& spawn)
	{
		spawns.emplace(std::move(spawn));
	}

	void MapMobs::remove(int32_t oid, int8_t animation)
	{
		if (Optional<Mob> mob = mobs.get(oid))
			mob->kill(animation);
	}

	void MapMobs::clear()
	{
		mobs.clear();
	}

	void MapMobs::set_control(int32_t oid, bool control)
	{
		int8_t mode = control ? 1 : 0;

		if (Optional<Mob> mob = mobs.get(oid))
			mob->set_control(mode);
	}

	void MapMobs::send_mobhp(int32_t oid, int8_t percent, uint16_t playerlevel)
	{
		if (Optional<Mob> mob = mobs.get(oid))
			mob->show_hp(percent, playerlevel);
	}

	void MapMobs::send_movement(int32_t oid, Point<int16_t> start, std::vector<Movement>&& movements)
	{
		if (Optional<Mob> mob = mobs.get(oid))
			mob->send_movement(start, std::move(movements));
	}

	void MapMobs::send_attack(AttackResult& result, const Attack& attack, const std::vector<int32_t>& targets, uint8_t mobcount)
	{
		for (auto& target : targets)
		{
			if (Optional<Mob> mob = mobs.get(target))
			{
				result.damagelines[target] = mob->calculate_damage(attack);
				result.mobcount++;

				if (result.mobcount == 1)
					result.first_oid = target;

				if (result.mobcount == mobcount)
					result.last_oid = target;
			}
		}
	}

	void MapMobs::apply_damage(int32_t oid, int32_t damage, bool toleft, const AttackUser& user, const SpecialMove& move)
	{
		if (Optional<Mob> mob = mobs.get(oid))
		{
			mob->apply_damage(damage, toleft);

			// TODO: Maybe move this into the method above too?
			move.apply_hiteffects(user, *mob);
		}
	}

	bool MapMobs::contains(int32_t oid) const
	{
		return mobs.contains(oid);
	}

	int32_t MapMobs::find_colliding(const MovingObject& moveobj) const
	{
		Range<int16_t> horizontal = Range<int16_t>(moveobj.get_last_x(), moveobj.get_x());
		Range<int16_t> vertical = Range<int16_t>(moveobj.get_last_y(), moveobj.get_y());

		Rectangle<int16_t> player_rect = {
			horizontal.smaller(),
			horizontal.greater(),
			vertical.smaller() - 50,
			vertical.greater()
		};

		auto iter = std::find_if(
			mobs.begin(),
			mobs.end(),
			[&player_rect](auto& mmo)
			{
				Optional<Mob> mob = mmo.second.get();
				return mob && mob->is_alive() && mob->is_in_range(player_rect);
			}
		);

		if (iter == mobs.end())
			return 0;

		return iter->second->get_oid();
	}

	MobAttack MapMobs::create_attack(int32_t oid) const
	{
		if (Optional<const Mob> mob = mobs.get(oid))
			return mob->create_touch_attack();
		else
			return {};
	}

	Point<int16_t> MapMobs::get_mob_position(int32_t oid) const
	{
		if (auto mob = mobs.get(oid))
			return mob->get_position();
		else
			return Point<int16_t>(0, 0);
	}

	Point<int16_t> MapMobs::get_mob_head_position(int32_t oid) const
	{
		if (Optional<const Mob> mob = mobs.get(oid))
			return mob->get_head_position();
		else
			return Point<int16_t>(0, 0);
	}

	MapObjects* MapMobs::get_mobs()
	{
		return &mobs;
	}
}

================
File: Gameplay/MapleMap/MapMobs.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "MapObjects.h"

#include "../Spawn.h"

#include "../Combat/Attack.h"
#include "../Combat/SpecialMove.h"

#include <queue>

namespace ms
{
	// A collection of mobs on a map.
	class MapMobs
	{
	public:
		// Draw all mobs on a layer.
		void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
		// Update all mobs.
		void update(const Physics& physics);

		// Spawn a new mob.
		void spawn(MobSpawn&& spawn);
		// Kill a mob.
		void remove(int32_t oid, int8_t effect);
		// Remove all mobs.
		void clear();

		// Update who a mob is controlled by.
		void set_control(int32_t oid, bool control);
		// Update a mob's hp display.
		void send_mobhp(int32_t oid, int8_t percent, uint16_t playerlevel);
		// Update a mob's movements.
		void send_movement(int32_t oid, Point<int16_t> start, std::vector<Movement>&& movements);

		// Calculate the results of an attack.
		void send_attack(AttackResult& result, const Attack& attack, const std::vector<int32_t>& targets, uint8_t mobcount);
		// Applies damage to a mob.
		void apply_damage(int32_t oid, int32_t damage, bool toleft, const AttackUser& user, const SpecialMove& move);

		// Check if the mob with the specified oid exists.
		bool contains(int32_t oid) const;
		// Return the id of the first mob who collides with the object.
		int32_t find_colliding(const MovingObject& moveobj) const;
		// Create an attack by the specified mob.
		MobAttack create_attack(int32_t oid) const;
		// Return the position of a mob.
		Point<int16_t> get_mob_position(int32_t oid) const;
		// Return the head position of a mob.
		Point<int16_t> get_mob_head_position(int32_t oid) const;
		// Return all mob map objects
		MapObjects* get_mobs();

	private:
		MapObjects mobs;

		std::queue<MobSpawn> spawns;
	};
}

================
File: Gameplay/MapleMap/MapNpcs.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapNpcs.h"

#include "Npc.h"

#include "../../Net/Packets/NpcInteractionPackets.h"

namespace ms
{
	void MapNpcs::draw(Layer::Id layer, double viewx, double viewy, float alpha) const
	{
		npcs.draw(layer, viewx, viewy, alpha);
	}

	void MapNpcs::update(const Physics& physics)
	{
		for (; !spawns.empty(); spawns.pop())
		{
			const NpcSpawn& spawn = spawns.front();

			int32_t oid = spawn.get_oid();
			Optional<MapObject> npc = npcs.get(oid);

			if (npc)
				npc->makeactive();
			else
				npcs.add(spawn.instantiate(physics));
		}

		npcs.update(physics);
	}

	void MapNpcs::spawn(NpcSpawn&& spawn)
	{
		spawns.emplace(std::move(spawn));
	}

	void MapNpcs::remove(int32_t oid)
	{
		if (auto npc = npcs.get(oid))
			npc->deactivate();
	}

	void MapNpcs::clear()
	{
		npcs.clear();
	}

	MapObjects * MapNpcs::get_npcs()
	{
		return &npcs;
	}

	Cursor::State MapNpcs::send_cursor(bool pressed, Point<int16_t> position, Point<int16_t> viewpos)
	{
		for (auto& map_object : npcs)
		{
			Npc* npc = static_cast<Npc*>(map_object.second.get());

			if (npc && npc->is_active() && npc->inrange(position, viewpos))
			{
				if (pressed)
				{
					// TODO: Try finding dialog first
					TalkToNPCPacket(npc->get_oid()).dispatch();

					return Cursor::State::IDLE;
				}
				else
				{
					return Cursor::State::CANCLICK;
				}
			}
		}

		return Cursor::State::IDLE;
	}
}

================
File: Gameplay/MapleMap/MapNpcs.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "MapObjects.h"

#include "../Spawn.h"

#include "../../IO/Cursor.h"

#include <queue>

namespace ms
{
	class MapNpcs
	{
	public:
		// Draw all NPCs on a layer
		void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
		// Update all NPCs
		void update(const Physics& physics);

		// Add an NPC to the spawn queue
		void spawn(NpcSpawn&& spawn);
		// Remove the NPC with the specified oid
		void remove(int32_t oid);
		// Remove all NPCs
		void clear();

		// Returns a reference to the MapObject's object
		MapObjects* get_npcs();

		// Send mouse input to clickable NPCs
		Cursor::State send_cursor(bool pressed, Point<int16_t> position, Point<int16_t> viewpos);

	private:
		MapObjects npcs;

		std::queue<NpcSpawn> spawns;
	};
}

================
File: Gameplay/MapleMap/MapObject.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapObject.h"

namespace ms
{
	MapObject::MapObject(int32_t o, Point<int16_t> p) : oid(o)
	{
		set_position(p);
		active = true;
	}

	int8_t MapObject::update(const Physics& physics)
	{
		physics.move_object(phobj);

		return phobj.fhlayer;
	}

	void MapObject::set_position(int16_t x, int16_t y)
	{
		phobj.set_x(x);
		phobj.set_y(y);
	}

	void MapObject::set_position(Point<int16_t> position)
	{
		int16_t x = position.x();
		int16_t y = position.y();
		set_position(x, y);
	}

	void MapObject::makeactive()
	{
		active = true;
	}

	void MapObject::deactivate()
	{
		active = false;
	}

	bool MapObject::is_active() const
	{
		return active;
	}

	int8_t MapObject::get_layer() const
	{
		return phobj.fhlayer;
	}

	int32_t MapObject::get_oid() const
	{
		return oid;
	}

	Point<int16_t> MapObject::get_position() const
	{
		return phobj.get_position();
	}
}

================
File: Gameplay/MapleMap/MapObject.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Camera.h"

#include "../Physics/Physics.h"

namespace ms
{
	// Base for objects on a map, e.g., Mobs, NPCs, Characters, etc.
	class MapObject
	{
	public:
		virtual ~MapObject() {}

		// Draws the object at the given position and with the specified interpolation.
		virtual void draw(double viewx, double viewy, float alpha) const = 0;

		// Updates the object and returns the updated layer.
		virtual int8_t update(const Physics& physics);
		// Reactivates the object.
		virtual void makeactive();
		// Deactivates the object.
		virtual void deactivate();
		// Checks whether this object is active.
		virtual bool is_active() const;
		// Obtains the layer used to determine the drawing order on the map.
		virtual int8_t get_layer() const;

		// Changes the objects position.
		void set_position(int16_t x, int16_t y);
		// Changes the objects position.
		void set_position(Point<int16_t> position);

		// Returns the object id unique to every object on one map.
		int32_t get_oid() const;
		// Returns the current position.
		Point<int16_t> get_position() const;

	protected:
		MapObject(int32_t oid, Point<int16_t> position = {});

		PhysicsObject phobj;
		int32_t oid;
		bool active;
	};
}

================
File: Gameplay/MapleMap/MapObjects.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapObjects.h"

namespace ms
{
	void MapObjects::draw(Layer::Id layer, double viewx, double viewy, float alpha) const
	{
		for (auto& oid : layers[layer])
		{
			auto mmo = get(oid);

			if (mmo && mmo->is_active())
				mmo->draw(viewx, viewy, alpha);
		}
	}

	void MapObjects::update(const Physics& physics)
	{
		for (auto iter = objects.begin(); iter != objects.end();)
		{
			bool remove_mob = false;

			if (auto& mmo = iter->second)
			{
				int8_t oldlayer = mmo->get_layer();
				int8_t newlayer = mmo->update(physics);

				if (newlayer == -1)
				{
					remove_mob = true;
				}
				else if (newlayer != oldlayer)
				{
					int32_t oid = iter->first;
					layers[oldlayer].erase(oid);
					layers[newlayer].insert(oid);
				}
			}
			else
			{
				remove_mob = true;
			}

			if (remove_mob)
				iter = objects.erase(iter);
			else
				iter++;
		}
	}

	void MapObjects::clear()
	{
		objects.clear();

		for (auto& layer : layers)
			layer.clear();
	}

	bool MapObjects::contains(int32_t oid) const
	{
		return objects.count(oid) > 0;
	}

	void MapObjects::add(std::unique_ptr<MapObject> toadd)
	{
		int32_t oid = toadd->get_oid();
		int8_t layer = toadd->get_layer();
		objects[oid] = std::move(toadd);
		layers[layer].insert(oid);
	}

	void MapObjects::remove(int32_t oid)
	{
		auto iter = objects.find(oid);

		if (iter != objects.end() && iter->second)
		{
			int8_t layer = iter->second->get_layer();
			objects.erase(iter);

			layers[layer].erase(oid);
		}
	}

	Optional<MapObject> MapObjects::get(int32_t oid)
	{
		auto iter = objects.find(oid);

		return iter != objects.end() ? iter->second.get() : nullptr;
	}

	Optional<const MapObject> MapObjects::get(int32_t oid) const
	{
		auto iter = objects.find(oid);

		return iter != objects.end() ? iter->second.get() : nullptr;
	}

	MapObjects::underlying_t::iterator MapObjects::begin()
	{
		return objects.begin();
	}

	MapObjects::underlying_t::iterator MapObjects::end()
	{
		return objects.end();
	}

	MapObjects::underlying_t::const_iterator MapObjects::begin() const
	{
		return objects.begin();
	}

	MapObjects::underlying_t::const_iterator MapObjects::end() const
	{
		return objects.end();
	}

	MapObjects::underlying_t::size_type MapObjects::size() const
	{
		return objects.size();
	}
}

================
File: Gameplay/MapleMap/MapObjects.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Layer.h"
#include "MapObject.h"

#include "../../Template/Optional.h"

#include <memory>
#include <unordered_set>

namespace ms
{
	// A collection of generic MapObjects
	class MapObjects
	{
	public:
		// Draw all MapObjects that are on the specified layer
		void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
		// Update all MapObjects of this type
		// Also updates layers (E.g. drawing order)
		void update(const Physics& physics);

		// Adds a MapObjects of this type
		void add(std::unique_ptr<MapObject> mapobject);
		// Removes the MapObjects with the given oid
		void remove(int32_t oid);
		// Removes all MapObjects of this type
		void clear();

		// Check if a map object with the specified id exists on the map
		bool contains(int32_t oid) const;
		// Obtains a pointer to the MapObject with the given oid
		Optional<MapObject> get(int32_t oid);
		// Obtains a constant pointer to the MapObject with the given oid
		Optional<const MapObject> get(int32_t oid) const;

		using underlying_t = typename std::unordered_map<int32_t, std::unique_ptr<MapObject>>;
		// Return a begin iterator
		underlying_t::iterator begin();
		// Return an end iterator
		underlying_t::iterator end();
		// Return a begin iterator
		underlying_t::const_iterator begin() const;
		// Return an end iterator
		underlying_t::const_iterator end() const;
		// Return the size of the iterator
		underlying_t::size_type size() const;

	private:
		std::unordered_map<int32_t, std::unique_ptr<MapObject>> objects;
		std::array<std::unordered_set<int32_t>, Layer::Id::LENGTH> layers;
	};
}

================
File: Gameplay/MapleMap/MapPortals.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapPortals.h"

#include "../../Constants.h"

#include "../../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	MapPortals::MapPortals(nl::node src, int32_t mapid)
	{
		for (auto sub : src)
		{
			int8_t portal_id = string_conversion::or_default<int8_t>(sub.name(), -1);

			if (portal_id < 0)
				continue;

			Portal::Type type = Portal::typebyid(sub["pt"]);
			std::string name = sub["pn"];
			std::string target_name = sub["tn"];
			int32_t target_id = sub["tm"];
			Point<int16_t> position = { sub["x"], sub["y"] };

			const Animation* animation = &animations[type];
			bool intramap = target_id == mapid;

			portals_by_id.emplace(
				std::piecewise_construct,
				std::forward_as_tuple(portal_id),
				std::forward_as_tuple(animation, type, name, intramap, position, target_id, target_name)
			);

			portal_ids_by_name.emplace(name, portal_id);
		}

		cooldown = WARPCD;
	}

	MapPortals::MapPortals()
	{
		cooldown = WARPCD;
	}

	void MapPortals::update(Point<int16_t> playerpos)
	{
		animations[Portal::REGULAR].update(Constants::TIMESTEP);
		animations[Portal::HIDDEN].update(Constants::TIMESTEP);

		for (auto& iter : portals_by_id)
		{
			Portal& portal = iter.second;
			switch (portal.get_type())
			{
			case Portal::HIDDEN:
			case Portal::TOUCH:
				portal.update(playerpos);
				break;
			}
		}

		if (cooldown > 0)
			cooldown--;
	}

	void MapPortals::draw(Point<int16_t> viewpos, float inter) const
	{
		for (auto& ptit : portals_by_id)
			ptit.second.draw(viewpos, inter);
	}

	Point<int16_t> MapPortals::get_portal_by_id(uint8_t portal_id) const
	{
		auto iter = portals_by_id.find(portal_id);

		if (iter != portals_by_id.end())
		{
			constexpr Point<int16_t> ABOVE(0, 30);

			return iter->second.get_position() - ABOVE;
		}
		else
		{
			return {};
		}
	}

	Point<int16_t> MapPortals::get_portal_by_name(const std::string& portal_name) const
	{
		auto iter = portal_ids_by_name.find(portal_name);

		if (iter != portal_ids_by_name.end())
			return get_portal_by_id(iter->second);
		else
			return {};
	}

	Portal::WarpInfo MapPortals::find_warp_at(Point<int16_t> playerpos)
	{
		if (cooldown == 0)
		{
			cooldown = WARPCD;

			for (auto& iter : portals_by_id)
			{
				const Portal& portal = iter.second;

				if (portal.bounds().contains(playerpos))
					return portal.getwarpinfo();
			}
		}

		return {};
	}

	void MapPortals::init()
	{
		nl::node src = nl::nx::Map["MapHelper.img"]["portal"]["game"];

		animations[Portal::HIDDEN] = src["ph"]["default"]["portalContinue"];
		animations[Portal::REGULAR] = src["pv"]["default"];
	}

	std::unordered_map<Portal::Type, Animation> MapPortals::animations;
}

================
File: Gameplay/MapleMap/MapPortals.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Portal.h"

#include <unordered_map>

namespace ms
{
	// Collection of portals on a map
	// Draws and updates portals
	// Also contains methods for using portals and obtaining spawn points
	class MapPortals
	{
	public:
		static void init();

		MapPortals(nl::node source, int32_t mapid);
		MapPortals();

		void update(Point<int16_t> playerpos);
		void draw(Point<int16_t> viewpos, float inter) const;

		Portal::WarpInfo find_warp_at(Point<int16_t> playerpos);

		Point<int16_t> get_portal_by_id(uint8_t id) const;
		Point<int16_t> get_portal_by_name(const std::string& name) const;

	private:
		static std::unordered_map<Portal::Type, Animation> animations;

		std::unordered_map<uint8_t, Portal> portals_by_id;
		std::unordered_map<std::string, uint8_t> portal_ids_by_name;

		static const int16_t WARPCD = 48;
		int16_t cooldown;
	};
}

================
File: Gameplay/MapleMap/MapReactors.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapReactors.h"

namespace ms
{
	void MapReactors::draw(Layer::Id layer, double viewx, double viewy, float alpha) const
	{
		reactors.draw(layer, viewx, viewy, alpha);
	}

	// Spawns all reactors to map with proper footholds
	void MapReactors::update(const Physics& physics)
	{
		for (; !spawns.empty(); spawns.pop())
		{
			const ReactorSpawn& spawn = spawns.front();

			int32_t oid = spawn.get_oid();

			if (auto reactor = reactors.get(oid))
				reactor->makeactive();
			else
				reactors.add(spawn.instantiate(physics));
		}

		reactors.update(physics);
	}

	void MapReactors::trigger(int32_t oid, int8_t state)
	{
		if (Optional<Reactor> reactor = reactors.get(oid))
			reactor->set_state(state);
	}

	void MapReactors::spawn(ReactorSpawn&& spawn)
	{
		spawns.emplace(std::move(spawn));
	}

	void MapReactors::remove(int32_t oid, int8_t state, Point<int16_t> position)
	{
		if (Optional<Reactor> reactor = reactors.get(oid))
			reactor->destroy(state, position);
	}

	void MapReactors::clear()
	{
		reactors.clear();
	}

	MapObjects* MapReactors::get_reactors()
	{
		return &reactors;
	}
}

================
File: Gameplay/MapleMap/MapReactors.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "MapObjects.h"
#include "Reactor.h"

#include "../Spawn.h"

#include <queue>

namespace ms
{
	// Collection of reactors on a map
	class MapReactors
	{
	public:
		// Draw all reactors on a layer
		void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
		// Update all reactors
		void update(const Physics& physics);

		// Trigger a reactor
		void trigger(int32_t oid, int8_t state);
		// Spawn a new reactor
		void spawn(ReactorSpawn&& spawn);
		// Remove a reactor
		void remove(int32_t oid, int8_t state, Point<int16_t> position);
		// Remove all reactors
		void clear();
		MapObjects* get_reactors();

	private:
		MapObjects reactors;

		std::queue<ReactorSpawn> spawns;
	};
}

================
File: Gameplay/MapleMap/MapTilesObjs.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapTilesObjs.h"

namespace ms
{
	TilesObjs::TilesObjs(nl::node src)
	{
		auto tileset = src["info"]["tS"] + ".img";

		for (auto tilenode : src["tile"])
		{
			Tile tile{ tilenode, tileset };
			int8_t z = tile.getz();
			tiles.emplace(z, std::move(tile));
		}

		for (auto objnode : src["obj"])
		{
			Obj obj{ objnode };
			int8_t z = obj.getz();
			objs.emplace(z, std::move(obj));
		}
	}

	void TilesObjs::update()
	{
		for (auto& iter : objs)
			iter.second.update();
	}

	void TilesObjs::draw(Point<int16_t> viewpos, float alpha) const
	{
		for (auto& iter : objs)
			iter.second.draw(viewpos, alpha);

		for (auto& iter : tiles)
			iter.second.draw(viewpos);
	}

	MapTilesObjs::MapTilesObjs(nl::node src)
	{
		for (auto iter : layers)
			iter.second = src[iter.first];
	}

	void MapTilesObjs::draw(Layer::Id layer, Point<int16_t> viewpos, float alpha) const
	{
		layers[layer].draw(viewpos, alpha);
	}

	void MapTilesObjs::update()
	{
		for (auto iter : layers)
			iter.second.update();
	}
}

================
File: Gameplay/MapleMap/MapTilesObjs.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Layer.h"
#include "Obj.h"
#include "Tile.h"

#include "../../Template/EnumMap.h"

#include <map>

namespace ms
{
	// A tile and object layer
	class TilesObjs
	{
	public:
		TilesObjs() {}
		TilesObjs(nl::node src);

		void draw(Point<int16_t> viewpos, float alpha) const;
		void update();

	private:
		std::multimap<uint8_t, Tile> tiles;
		std::multimap<uint8_t, Obj> objs;
	};

	// The collection of tile and object layers on a map
	class MapTilesObjs
	{
	public:
		MapTilesObjs() {}
		MapTilesObjs(nl::node src);

		void draw(Layer::Id layer, Point<int16_t> viewpos, float alpha) const;
		void update();

	private:
		EnumMap<Layer::Id, TilesObjs> layers;
	};
}

================
File: Gameplay/MapleMap/MesoDrop.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MesoDrop.h"

namespace ms
{
	MesoDrop::MesoDrop(int32_t oid, int32_t owner, Point<int16_t> start, Point<int16_t> dest, int8_t type, int8_t mode, bool pd, const Animation& icn) : Drop(oid, owner, start, dest, type, mode, pd), icon(icn) {}

	void MesoDrop::draw(double viewx, double viewy, float alpha) const
	{
		if (!active)
			return;

		Point<int16_t> absp = phobj.get_absolute(viewx, viewy, alpha);
		icon.draw({ angle.get(alpha), absp, opacity.get(alpha) }, alpha);
	}
}

================
File: Gameplay/MapleMap/MesoDrop.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Drop.h"

#include "../../Graphics/Animation.h"

namespace ms
{
	class MesoDrop : public Drop
	{
	public:
		MesoDrop(int32_t oid, int32_t owner, Point<int16_t> start, Point<int16_t> dest, int8_t type, int8_t mode, bool playerdrop, const Animation& icon);

		void draw(double viewx, double viewy, float alpha) const override;

	private:
		const Animation& icon;
	};
}

================
File: Gameplay/MapleMap/Mob.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Mob.h"

#include "../../Util/Misc.h"

#include "../../Net/Packets/GameplayPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Mob::Mob(int32_t oi, int32_t mid, int8_t mode, int8_t st, uint16_t fh, bool newspawn, int8_t tm, Point<int16_t> position) : MapObject(oi)
	{
		std::string strid = string_format::extend_id(mid, 7);
		nl::node src = nl::nx::Mob[strid + ".img"];

		nl::node info = src["info"];

		level = info["level"];
		watk = info["PADamage"];
		matk = info["MADamage"];
		wdef = info["PDDamage"];
		mdef = info["MDDamage"];
		accuracy = info["acc"];
		avoid = info["eva"];
		knockback = info["pushed"];
		speed = info["speed"];
		flyspeed = info["flySpeed"];
		touchdamage = info["bodyAttack"].get_bool();
		undead = info["undead"].get_bool();
		noflip = info["noFlip"].get_bool();
		notattack = info["notAttack"].get_bool();
		canjump = src["jump"].size() > 0;
		canfly = src["fly"].size() > 0;
		canmove = src["move"].size() > 0 || canfly;
		
		std::string linkid = info["link"];
		nl::node link_src = nl::nx::Mob[linkid + ".img"];
		nl::node link = link_src ? link_src : src;
		nl::node fly = link["fly"];

		if (canfly)
		{
			animations[Stance::STAND] = fly;
			animations[Stance::MOVE] = fly;
		}
		else
		{
			animations[Stance::STAND] = link["stand"];
			animations[Stance::MOVE] = link["move"];
		}

		animations[Stance::JUMP] = link["jump"];
		animations[Stance::HIT] = link["hit1"];
		animations[Stance::DIE] = link["die1"];

		name = nl::nx::String["Mob.img"][std::to_string(mid)]["name"];

		nl::node sndsrc = nl::nx::Sound["Mob.img"][strid];

		hitsound = sndsrc["Damage"];
		diesound = sndsrc["Die"];

		speed += 100;
		speed *= 0.001f;

		flyspeed += 100;
		flyspeed *= 0.0005f;

		if (canfly)
			phobj.type = PhysicsObject::Type::FLYING;

		id = mid;
		team = tm;
		set_position(position);
		set_control(mode);
		phobj.fhid = fh;
		phobj.set_flag(PhysicsObject::Flag::TURNATEDGES);

		hppercent = 0;
		dying = false;
		dead = false;
		fading = false;
		set_stance(st);
		flydirection = STRAIGHT;
		counter = 0;

		namelabel = Text(Text::Font::A13M, Text::Alignment::CENTER, Color::Name::WHITE, Text::Background::NAMETAG, name);

		if (newspawn)
		{
			fadein = true;
			opacity.set(0.0f);
		}
		else
		{
			fadein = false;
			opacity.set(1.0f);
		}

		if (control && stance == Stance::STAND)
			next_move();
	}

	void Mob::set_stance(uint8_t stancebyte)
	{
		flip = (stancebyte % 2) == 0;

		if (!flip)
			stancebyte -= 1;

		if (stancebyte < Stance::MOVE)
			stancebyte = Stance::MOVE;

		set_stance(static_cast<Stance>(stancebyte));
	}

	void Mob::set_stance(Stance newstance)
	{
		if (stance != newstance)
		{
			stance = newstance;

			animations.at(stance).reset();
		}
	}

	int8_t Mob::update(const Physics& physics)
	{
		if (!active)
			return phobj.fhlayer;

		bool aniend = animations.at(stance).update();

		if (aniend && stance == Stance::DIE)
			dead = true;

		if (fading)
		{
			opacity -= 0.025f;

			if (opacity.last() < 0.025f)
			{
				opacity.set(0.0f);
				fading = false;
				dead = true;
			}
		}
		else if (fadein)
		{
			opacity += 0.025f;

			if (opacity.last() > 0.975f)
			{
				opacity.set(1.0f);
				fadein = false;
			}
		}

		if (dead)
		{
			deactivate();

			return -1;
		}

		effects.update();
		showhp.update();

		if (!dying)
		{
			if (!canfly)
			{
				if (phobj.is_flag_not_set(PhysicsObject::Flag::TURNATEDGES))
				{
					flip = !flip;
					phobj.set_flag(PhysicsObject::Flag::TURNATEDGES);

					if (stance == Stance::HIT)
						set_stance(Stance::STAND);
				}
			}

			switch (stance)
			{
			case Stance::MOVE:
				if (canfly)
				{
					phobj.hforce = flip ? flyspeed : -flyspeed;

					switch (flydirection)
					{
					case FlyDirection::UPWARDS:
						phobj.vforce = -flyspeed;
						break;
					case FlyDirection::DOWNWARDS:
						phobj.vforce = flyspeed;
						break;
					}
				}
				else
				{
					phobj.hforce = flip ? speed : -speed;
				}

				break;
			case Stance::HIT:
				if (canmove)
				{
					double KBFORCE = phobj.onground ? 0.2 : 0.1;
					phobj.hforce = flip ? -KBFORCE : KBFORCE;
				}

				break;
			case Stance::JUMP:
				phobj.vforce = -5.0;
				break;
			}

			physics.move_object(phobj);

			if (control)
			{
				counter++;

				bool next;

				switch (stance)
				{
				case Stance::HIT:
					next = counter > 200;
					break;
				case Stance::JUMP:
					next = phobj.onground;
					break;
				default:
					next = aniend && counter > 200;
					break;
				}

				if (next)
				{
					next_move();
					update_movement();
					counter = 0;
				}
			}
		}
		else
		{
			phobj.normalize();
			physics.get_fht().update_fh(phobj);
		}

		return phobj.fhlayer;
	}

	void Mob::next_move()
	{
		if (canmove)
		{
			switch (stance)
			{
			case Stance::HIT:
			case Stance::STAND:
				set_stance(Stance::MOVE);
				flip = randomizer.next_bool();
				break;
			case Stance::MOVE:
			case Stance::JUMP:
				if (canjump && phobj.onground && randomizer.below(0.25f))
				{
					set_stance(Stance::JUMP);
				}
				else
				{
					switch (randomizer.next_int(3))
					{
					case 0:
						set_stance(Stance::STAND);
						break;
					case 1:
						set_stance(Stance::MOVE);
						flip = false;
						break;
					case 2:
						set_stance(Stance::MOVE);
						flip = true;
						break;
					}
				}

				break;
			}

			if (stance == Stance::MOVE && canfly)
				flydirection = randomizer.next_enum(FlyDirection::NUM_DIRECTIONS);
		}
		else
		{
			set_stance(Stance::STAND);
		}
	}

	void Mob::update_movement()
	{
		MoveMobPacket(
			oid, 1, 0, 0, 0, 0, 0, 0,
			get_position(),
			Movement(phobj, value_of(stance, flip))
		).dispatch();
	}

	void Mob::draw(double viewx, double viewy, float alpha) const
	{
		Point<int16_t> absp = phobj.get_absolute(viewx, viewy, alpha);
		Point<int16_t> headpos = get_head_position(absp);

		effects.drawbelow(absp, alpha);

		if (!dead)
		{
			float interopc = opacity.get(alpha);

			animations.at(stance).draw(DrawArgument(absp, flip && !noflip, interopc), alpha);

			if (showhp)
			{
				namelabel.draw(absp);

				if (!dying && hppercent > 0)
					hpbar.draw(headpos, hppercent);
			}
		}

		effects.drawabove(absp, alpha);
	}

	void Mob::set_control(int8_t mode)
	{
		control = mode > 0;
		aggro = mode == 2;
	}

	void Mob::send_movement(Point<int16_t> start, std::vector<Movement>&& in_movements)
	{
		if (control)
			return;

		set_position(start);

		movements = std::forward<decltype(in_movements)>(in_movements);

		if (movements.empty())
			return;

		const Movement& lastmove = movements.front();

		uint8_t laststance = lastmove.newstate;
		set_stance(laststance);

		phobj.fhid = lastmove.fh;
	}

	Point<int16_t> Mob::get_head_position(Point<int16_t> position) const
	{
		Point<int16_t> head = animations.at(stance).get_head();

		position.shift_x((flip && !noflip) ? -head.x() : head.x());
		position.shift_y(head.y());

		return position;
	}

	void Mob::kill(int8_t animation)
	{
		switch (animation)
		{
		case 0:
			deactivate();
			break;
		case 1:
			dying = true;

			apply_death();
			break;
		case 2:
			fading = true;
			dying = true;
			break;
		}
	}

	void Mob::show_hp(int8_t percent, uint16_t playerlevel)
	{
		if (hppercent == 0)
		{
			int16_t delta = playerlevel - level;

			if (delta > 9)
				namelabel.change_color(Color::Name::YELLOW);
			else if (delta < -9)
				namelabel.change_color(Color::Name::RED);
		}

		if (percent > 100)
			percent = 100;
		else if (percent < 0)
			percent = 0;

		hppercent = percent;
		showhp.set_for(2000);
	}

	void Mob::show_effect(const Animation& animation, int8_t pos, int8_t z, bool f)
	{
		if (!active)
			return;

		Point<int16_t> shift;

		switch (pos)
		{
		case 0:
			shift = get_head_position(Point<int16_t>());
			break;
		case 1:
			break;
		case 2:
			break;
		case 3:
			break;
		case 4:
			break;
		}

		effects.add(animation, DrawArgument(shift, f), z);
	}

	float Mob::calculate_hitchance(int16_t leveldelta, int32_t player_accuracy) const
	{
		float faccuracy = static_cast<float>(player_accuracy);
		float hitchance = faccuracy / (((1.84f + 0.07f * leveldelta) * avoid) + 1.0f);

		if (hitchance < 0.01f)
			hitchance = 0.01f;

		return hitchance;
	}

	double Mob::calculate_mindamage(int16_t leveldelta, double damage, bool magic) const
	{
		double mindamage =
			magic ?
			damage - (1 + 0.01 * leveldelta) * mdef * 0.6 :
			damage * (1 - 0.01 * leveldelta) - wdef * 0.6;

		return mindamage < 1.0 ? 1.0 : mindamage;
	}

	double Mob::calculate_maxdamage(int16_t leveldelta, double damage, bool magic) const
	{
		double maxdamage =
			magic ?
			damage - (1 + 0.01 * leveldelta) * mdef * 0.5 :
			damage * (1 - 0.01 * leveldelta) - wdef * 0.5;

		return maxdamage < 1.0 ? 1.0 : maxdamage;
	}

	std::vector<std::pair<int32_t, bool>> Mob::calculate_damage(const Attack& attack)
	{
		double mindamage;
		double maxdamage;
		float hitchance;
		float critical;
		int16_t leveldelta = level - attack.playerlevel;

		if (leveldelta < 0)
			leveldelta = 0;

		Attack::DamageType damagetype = attack.damagetype;

		switch (damagetype)
		{
		case Attack::DamageType::DMG_WEAPON:
		case Attack::DamageType::DMG_MAGIC:
			mindamage = calculate_mindamage(leveldelta, attack.mindamage, damagetype == Attack::DamageType::DMG_MAGIC);
			maxdamage = calculate_maxdamage(leveldelta, attack.maxdamage, damagetype == Attack::DamageType::DMG_MAGIC);
			hitchance = calculate_hitchance(leveldelta, attack.accuracy);
			critical = attack.critical;
			break;
		case Attack::DamageType::DMG_FIXED:
			mindamage = attack.fixdamage;
			maxdamage = attack.fixdamage;
			hitchance = 1.0f;
			critical = 0.0f;
			break;
		}

		std::vector<std::pair<int32_t, bool>> result(attack.hitcount);

		std::generate(
			result.begin(), result.end(),
			[&]()
			{
				return next_damage(mindamage, maxdamage, hitchance, critical);
			}
		);

		update_movement();

		return result;
	}

	std::pair<int32_t, bool> Mob::next_damage(double mindamage, double maxdamage, float hitchance, float critical) const
	{
		bool hit = randomizer.below(hitchance);

		if (!hit)
			return std::pair<int32_t, bool>(0, false);

		constexpr double DAMAGECAP = 999999.0;

		double damage = randomizer.next_real(mindamage, maxdamage);
		bool iscritical = randomizer.below(critical);

		if (iscritical)
			damage *= 1.5;

		if (damage < 1)
			damage = 1;
		else if (damage > DAMAGECAP)
			damage = DAMAGECAP;

		auto intdamage = static_cast<int32_t>(damage);

		return std::pair<int32_t, bool>(intdamage, iscritical);
	}

	void Mob::apply_damage(int32_t damage, bool toleft)
	{
		hitsound.play();

		if (dying && stance != Stance::DIE)
		{
			apply_death();
		}
		else if (control && is_alive() && damage >= knockback)
		{
			flip = toleft;
			counter = 170;
			set_stance(Stance::HIT);

			update_movement();
		}
	}

	MobAttack Mob::create_touch_attack() const
	{
		if (!touchdamage)
			return MobAttack();

		int32_t minattack = static_cast<int32_t>(watk * 0.8f);
		int32_t maxattack = watk;
		int32_t attack = randomizer.next_int(minattack, maxattack);

		return MobAttack(attack, get_position(), id, oid);
	}

	void Mob::apply_death()
	{
		set_stance(Stance::DIE);
		diesound.play();
		dying = true;
	}

	bool Mob::is_alive() const
	{
		return active && !dying;
	}

	bool Mob::is_in_range(const Rectangle<int16_t>& range) const
	{
		if (!active)
			return false;

		Rectangle<int16_t> bounds = animations.at(stance).get_bounds();
		bounds.shift(get_position());

		return range.overlaps(bounds);
	}

	Point<int16_t> Mob::get_head_position() const
	{
		Point<int16_t> position = get_position();

		return get_head_position(position);
	}
}

================
File: Gameplay/MapleMap/Mob.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "MapObject.h"

#include "../Movement.h"

#include "../Combat/Attack.h"
#include "../Combat/Bullet.h"

#include "../../Audio/Audio.h"
#include "../../Graphics/EffectLayer.h"
#include "../../Graphics/Geometry.h"
#include "../../Util/Randomizer.h"
#include "../../Util/TimedBool.h"

namespace ms
{
	class Mob : public MapObject
	{
	public:
		static const size_t NUM_STANCES = 6;

		enum Stance : uint8_t
		{
			MOVE = 2,
			STAND = 4,
			JUMP = 6,
			HIT = 8,
			DIE = 10
		};

		static std::string nameof(Stance stance)
		{
			static const std::string stancenames[NUM_STANCES] =
			{
				"move",
				"stand",
				"jump",
				"hit1",
				"die1",
				"fly"
			};

			size_t index = (stance - 1) / 2;

			return stancenames[index];
		}

		static uint8_t value_of(Stance stance, bool flip)
		{
			return flip ? stance : stance + 1;
		}

		// Construct a mob by combining data from game files with data sent by the server
		Mob(int32_t oid, int32_t mobid, int8_t mode, int8_t stance, uint16_t fhid, bool newspawn, int8_t team, Point<int16_t> position);

		// Draw the mob
		void draw(double viewx, double viewy, float alpha) const override;
		// Update movement and animations
		int8_t update(const Physics& physics) override;

		// Change this mob's control mode:
		// 0 - no control, 1 - control, 2 - aggro
		void set_control(int8_t mode);
		// Send movement to the mob
		void send_movement(Point<int16_t> start, std::vector<Movement>&& movements);
		// Kill the mob with the appropriate type:
		// 0 - make inactive 1 - death animation 2 - fade out
		void kill(int8_t killtype);
		// Display the hp percentage above the mob
		// Use the playerlevel to determine color of NameTag
		void show_hp(int8_t percentage, uint16_t playerlevel);
		// Show an effect at the mob's position
		void show_effect(const Animation& animation, int8_t pos, int8_t z, bool flip);

		// Calculate the damage to this mob with the specified attack
		std::vector<std::pair<int32_t, bool>> calculate_damage(const Attack& attack);
		// Apply damage to the mob
		void apply_damage(int32_t damage, bool toleft);

		// Create a touch damage attack to the player
		MobAttack create_touch_attack() const;

		// Check if this mob collides with the specified rectangle
		bool is_in_range(const Rectangle<int16_t>& range) const;
		// Check if this mob is still alive
		bool is_alive() const;
		// Return the head position
		Point<int16_t> get_head_position() const;

	private:
		enum FlyDirection
		{
			STRAIGHT,
			UPWARDS,
			DOWNWARDS,
			NUM_DIRECTIONS
		};

		// Set the stance by byte value
		void set_stance(uint8_t stancebyte);
		// Set the stance by enumeration value
		void set_stance(Stance newstance);
		// Start the death animation
		void apply_death();
		// Decide on the next state
		void next_move();
		// Send the current position and state to the server
		void update_movement();

		// Calculate the hit chance
		float calculate_hitchance(int16_t leveldelta, int32_t accuracy) const;
		// Calculate the minimum damage
		double calculate_mindamage(int16_t leveldelta, double mindamage, bool magic) const;
		// Calculate the maximum damage
		double calculate_maxdamage(int16_t leveldelta, double maxdamage, bool magic) const;
		// Calculate a random damage line based on the specified values
		std::pair<int32_t, bool> next_damage(double mindamage, double maxdamage, float hitchance, float critical) const;

		// Return the current 'head' position
		Point<int16_t> get_head_position(Point<int16_t> position) const;

		std::map<Stance, Animation> animations;
		std::string name;
		Sound hitsound;
		Sound diesound;
		uint16_t level;
		float speed;
		float flyspeed;
		uint16_t watk;
		uint16_t matk;
		uint16_t wdef;
		uint16_t mdef;
		uint16_t accuracy;
		uint16_t avoid;
		uint16_t knockback;
		bool undead;
		bool touchdamage;
		bool noflip;
		bool notattack;
		bool canmove;
		bool canjump;
		bool canfly;

		EffectLayer effects;
		Text namelabel;
		MobHpBar hpbar;
		Randomizer randomizer;

		TimedBool showhp;

		std::vector<Movement> movements;
		uint16_t counter;

		int32_t id;
		int8_t effect;
		int8_t team;
		bool dying;
		bool dead;
		bool control;
		bool aggro;
		Stance stance;
		bool flip;
		FlyDirection flydirection;
		float walkforce;
		int8_t hppercent;
		bool fading;
		bool fadein;
		Linear<float> opacity;
	};
}

================
File: Gameplay/MapleMap/Npc.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Npc.h"

#include <codecvt>

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Npc::Npc(int32_t id, int32_t o, bool fl, uint16_t f, bool cnt, Point<int16_t> position) : MapObject(o)
	{
		std::string strid = std::to_string(id);
		strid.insert(0, 7 - strid.size(), '0');
		strid.append(".img");

		nl::node src = nl::nx::Npc[strid];
		nl::node strsrc = nl::nx::String["Npc.img"][std::to_string(id)];

		std::string link = src["info"]["link"];

		if (link.size() > 0)
		{
			link.append(".img");
			src = nl::nx::Npc[link];
		}

		nl::node info = src["info"];

		hidename = info["hideName"].get_bool();
		mouseonly = info["talkMouseOnly"].get_bool();
		scripted = info["script"].size() > 0 || info["shop"].get_bool();

		for (auto npcnode : src)
		{
			std::string state = npcnode.name();

			if (state != "info")
			{
				animations[state] = npcnode;
				states.push_back(state);
			}

			for (auto speaknode : npcnode["speak"])
				lines[state].push_back(strsrc[speaknode.get_string()]);
		}

		name = strsrc["name"];
		func = strsrc["func"];

		std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
		std::wstring wide = converter.from_bytes(func);

		for (size_t i = 0; i < wide.size(); i++)
		{
			wchar_t c = wide[i];

			// Korean
			if (c >= 0x1100 && c <= 0x11FF)
			{
				func = "";
				break;
			}
		}

		namelabel = Text(Text::Font::A13B, Text::Alignment::CENTER, Color::Name::YELLOW, Text::Background::NAMETAG, name);
		funclabel = Text(Text::Font::A13B, Text::Alignment::CENTER, Color::Name::YELLOW, Text::Background::NAMETAG, func);

		npcid = id;
		flip = !fl;
		control = cnt;
		stance = "stand";

		phobj.fhid = f;
		set_position(position);
	}

	void Npc::draw(double viewx, double viewy, float alpha) const
	{
		Point<int16_t> absp = phobj.get_absolute(viewx, viewy, alpha);

		if (animations.count(stance))
			animations.at(stance).draw(DrawArgument(absp, flip), alpha);

		if (!hidename)
		{
			// If ever changing code for namelabel confirm placements with map 10000
			namelabel.draw(absp + Point<int16_t>(0, -4));
			funclabel.draw(absp + Point<int16_t>(0, 18));
		}
	}

	int8_t Npc::update(const Physics& physics)
	{
		if (!active)
			return phobj.fhlayer;

		physics.move_object(phobj);

		if (animations.count(stance))
		{
			bool aniend = animations.at(stance).update();

			if (aniend && states.size() > 0)
			{
				size_t next_stance = random.next_int(states.size());
				std::string new_stance = states[next_stance];
				set_stance(new_stance);
			}
		}

		return phobj.fhlayer;
	}

	void Npc::set_stance(const std::string& st)
	{
		if (stance != st)
		{
			stance = st;

			auto iter = animations.find(stance);

			if (iter == animations.end())
				return;

			iter->second.reset();
		}
	}

	bool Npc::isscripted() const
	{
		return scripted;
	}

	bool Npc::inrange(Point<int16_t> cursorpos, Point<int16_t> viewpos) const
	{
		if (!active)
			return false;

		Point<int16_t> absp = get_position() + viewpos;

		Point<int16_t> dim =
			animations.count(stance) ?
			animations.at(stance).get_dimensions() :
			Point<int16_t>();

		return Rectangle<int16_t>(
			absp.x() - dim.x() / 2,
			absp.x() + dim.x() / 2,
			absp.y() - dim.y(),
			absp.y()
			).contains(cursorpos);
	}

	std::string Npc::get_name()
	{
		return name;
	}

	std::string Npc::get_func()
	{
		return func;
	}
}

================
File: Gameplay/MapleMap/Npc.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "MapObject.h"

#include "../../Graphics/Animation.h"
#include "../../Graphics/Text.h"
#include "../../Util/Randomizer.h"

namespace ms
{
	// Represents a NPC on the current map
	// Implements the 'MapObject' interface to be used in a 'MapObjects' template
	class Npc : public MapObject
	{
	public:
		// Constructs an NPC by combining data from game files with data sent by the server
		Npc(int32_t npcid, int32_t oid, bool mirrored, uint16_t fhid, bool control, Point<int16_t> position);

		// Draws the current animation and name/function tags
		void draw(double viewx, double viewy, float alpha) const override;
		// Updates the current animation and physics
		int8_t update(const Physics& physics) override;

		// Changes stance and resets animation
		void set_stance(const std::string& stance);

		// Check whether this is a server-sided NPC
		bool isscripted() const;
		// Check if the NPC is in range of the cursor
		bool inrange(Point<int16_t> cursorpos, Point<int16_t> viewpos) const;

		// Returns the NPC name
		std::string get_name();
		// Returns the NPC's function description or title
		std::string get_func();

	private:
		std::map<std::string, Animation> animations;
		std::map<std::string, std::vector<std::string>> lines;
		std::vector<std::string> states;
		std::string name;
		std::string func;
		bool hidename;
		bool scripted;
		bool mouseonly;

		int32_t npcid;
		bool flip;
		std::string stance;
		bool control;

		Randomizer random;
		Text namelabel;
		Text funclabel;
	};
}

================
File: Gameplay/MapleMap/Obj.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Obj.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Obj::Obj(nl::node src)
	{
		animation = Animation(nl::nx::Map["Obj"][src["oS"] + ".img"][src["l0"]][src["l1"]][src["l2"]]);
		pos = Point<int16_t>(src["x"], src["y"]);
		flip = src["f"].get_bool();
		z = src["z"];
	}

	void Obj::update()
	{
		animation.update();
	}

	void Obj::draw(Point<int16_t> viewpos, float inter) const
	{
		animation.draw(DrawArgument(pos + viewpos, flip), inter);
	}

	uint8_t Obj::getz() const
	{
		return z;
	}
}

================
File: Gameplay/MapleMap/Obj.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Graphics/Animation.h"

namespace ms
{
	// Represents a map decoration (object) on a map
	class Obj
	{
	public:
		Obj(nl::node source);

		// Update animation
		void update();
		// Draw the object at the specified position
		void draw(Point<int16_t> viewpos, float inter) const;
		// Return the depth of the object
		uint8_t getz() const;

	private:
		Animation animation;
		Point<int16_t> pos;
		uint8_t z;
		bool flip;
	};
}

================
File: Gameplay/MapleMap/Portal.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Portal.h"

namespace ms
{
	Portal::Portal(const Animation* a, Type t, std::string nm, bool intramap, Point<int16_t> p, int32_t tid, std::string tnm) : animation(a), type(t), name(nm), position(p), warpinfo(tid, intramap, tnm, nm)
	{
		touched = false;
	}

	Portal::Portal() : Portal(nullptr, SPAWN, "", false, Point<int16_t>(), 0, "") {}

	void Portal::update(Point<int16_t> playerpos)
	{
		touched = bounds().contains(playerpos);
	}

	void Portal::draw(Point<int16_t> viewpos, float inter) const
	{
		if (!animation || (type == HIDDEN && !touched))
			return;

		animation->draw(position + viewpos, inter);
	}

	std::string Portal::get_name() const
	{
		return name;
	}

	Portal::Type Portal::get_type() const
	{
		return type;
	}

	Point<int16_t> Portal::get_position() const
	{
		return position;
	}

	Rectangle<int16_t> Portal::bounds() const
	{
		auto lt = position + Point<int16_t>(-25, -100);
		auto rb = position + Point<int16_t>(25, 25);

		return Rectangle<int16_t>(lt, rb);
	}

	Portal::WarpInfo Portal::getwarpinfo() const
	{
		return warpinfo;
	}
}

================
File: Gameplay/MapleMap/Portal.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Graphics/Animation.h"

namespace ms
{
	class Portal
	{
	public:
		enum Type
		{
			SPAWN,
			INVISIBLE,
			REGULAR,
			TOUCH,
			TYPE4,
			TYPE5,
			WARP,
			SCRIPTED,
			SCRIPTED_INVISIBLE,
			SCRIPTED_TOUCH,
			HIDDEN,
			SCRIPTED_HIDDEN,
			SPRING1,
			SPRING2,
			TYPE14
		};

		static Type typebyid(int32_t id)
		{
			return static_cast<Type>(id);
		}

		struct WarpInfo
		{
			int32_t mapid;
			std::string toname;
			std::string name;
			bool intramap;
			bool valid;

			WarpInfo(int32_t m, bool i, std::string tn, std::string n) : mapid(m), intramap(i), toname(tn), name(n)
			{
				valid = mapid < 999999999;
			}

			WarpInfo() : WarpInfo(999999999, false, {}, {}) {}
		};

		Portal(const Animation* animation, Type type, std::string name, bool intramap, Point<int16_t> position, int32_t tomap, std::string toname);
		Portal();

		void update(Point<int16_t> playerpos);
		void draw(Point<int16_t> viewpos, float alpha) const;

		std::string get_name() const;
		Type get_type() const;
		Point<int16_t> get_position() const;
		Rectangle<int16_t> bounds() const;

		WarpInfo getwarpinfo() const;

	private:
		const Animation* animation;
		Type type;
		std::string name;
		Point<int16_t> position;
		WarpInfo warpinfo;
		bool touched;
	};
}

================
File: Gameplay/MapleMap/Reactor.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Reactor.h"

#include "../../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Reactor::Reactor(int32_t o, int32_t r, int8_t s, Point<int16_t> p) : MapObject(o, p), rid(r), state(s)
	{
		std::string strid = string_format::extend_id(rid, 7);
		src = nl::nx::Reactor[strid + ".img"];

		normal = src[0];
		animation_ended = true;
		dead = false;
		hittable = false;

		for (auto sub : src[0])
			if (sub.name() == "event")
				if (sub["0"]["type"].get_integer() == 0)
					hittable = true;
	}

	void Reactor::draw(double viewx, double viewy, float alpha) const
	{
		Point<int16_t> absp = phobj.get_absolute(viewx, viewy, alpha);
		Point<int16_t> shift = Point<int16_t>(0, normal.get_origin().y());

		if (animation_ended)
		{
			// TODO: Handle 'default' animations (horntail reactor floating)
			normal.draw(absp - shift, alpha);
		}
		else
		{
			animations.at(state - 1).draw(DrawArgument(absp - shift), 1.0);
		}
	}

	int8_t Reactor::update(const Physics& physics)
	{
		physics.move_object(phobj);

		if (!animation_ended)
			animation_ended = animations.at(state - 1).update();

		if (animation_ended && dead)
			deactivate();

		return phobj.fhlayer;
	}

	void Reactor::set_state(int8_t state)
	{
		// TODO: hit/break sounds
		if (hittable)
		{
			animations[this->state] = src[this->state]["hit"];
			animation_ended = false;
		}

		this->state = state;
	}

	void Reactor::destroy(int8_t, Point<int16_t>)
	{
		animations[this->state] = src[this->state]["hit"];
		state++;
		dead = true;
		animation_ended = false;
	}

	bool Reactor::is_hittable() const
	{
		return hittable;
	}

	bool Reactor::is_in_range(const Rectangle<int16_t>& range) const
	{
		if (!active)
			return false;

		Rectangle<int16_t> bounds(Point<int16_t>(-30, -normal.get_dimensions().y()), Point<int16_t>(normal.get_dimensions().x() - 10, 0)); //normal.get_bounds(); //animations.at(stance).get_bounds();
		bounds.shift(get_position());

		return range.overlaps(bounds);
	}
}

================
File: Gameplay/MapleMap/Reactor.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "MapObject.h"

#include "../../Graphics/Animation.h"

#include <map>

namespace ms
{
	class Reactor : public MapObject
	{
	public:
		Reactor(int32_t oid, int32_t rid, int8_t state, Point<int16_t> position);

		void draw(double viewx, double viewy, float alpha) const override;
		int8_t update(const Physics& physics);

		void set_state(int8_t state);
		void destroy(int8_t state, Point<int16_t> position);

		bool is_hittable() const;

		// Check if this mob collides with the specified rectangle
		bool is_in_range(const Rectangle<int16_t>& range) const;

	private:
		int32_t oid;
		int32_t rid;
		int8_t state;
		// TODO: Below
		//int8_t stance; // ??
		// TODO: These are in the GMS client
		//bool movable; // Snowball?
		//int32_t questid;
		//bool activates_by_touch;

		nl::node src;
		std::map<int8_t, Animation> animations;
		bool animation_ended;

		bool active;
		bool hittable;
		bool dead;

		Animation normal;
	};
}

================
File: Gameplay/MapleMap/Tile.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Tile.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

#include <iostream>

namespace ms
{
	Tile::Tile(nl::node src, const std::string& ts)
	{
		nl::node dsrc = nl::nx::Map["Tile"][ts][src["u"]][src["no"]];
		nl::node _outlink = dsrc["_outlink"];

		// TODO: Should this be done during the NX conversion?
		if (_outlink)
		{
			size_t pos = 0;
			std::string path = _outlink;
			std::string delimiter = "/";

			std::string file;

			if ((pos = path.find(delimiter)) != std::string::npos)
			{
				file = path.substr(0, pos);
				path.erase(0, pos + delimiter.length());
			}

			if (file == "Map")
				dsrc = nl::nx::Map.resolve(path);
			else
				LOG(LOG_WARN, "Tile::Tile file not handled: " << file);
		}

		texture = Texture(dsrc);
		pos = Point<int16_t>(src["x"], src["y"]);
		z = dsrc["z"];

		if (z == 0)
			z = dsrc["zM"];
	}

	void Tile::draw(Point<int16_t> viewpos) const
	{
		texture.draw(pos + viewpos);
	}

	uint8_t Tile::getz() const
	{
		return z;
	}
}

================
File: Gameplay/MapleMap/Tile.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Graphics/Texture.h"

#ifdef USE_NX
#include <nlnx/node.hpp>
#endif

namespace ms
{
	// Represents a tile on a map
	class Tile
	{
	public:
		Tile(nl::node src, const std::string& tileset);

		// Draw the tile
		void draw(Point<int16_t> viewpos) const;
		// Returns the depth of the tile
		uint8_t getz() const;

	private:
		Texture texture;
		Point<int16_t> pos;
		uint8_t z;
	};
}

================
File: Gameplay/Movement.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Physics/PhysicsObject.h"

namespace ms
{
	struct Movement
	{
		enum Type
		{
			NONE,
			ABSOLUTE,
			RELATIVE,
			CHAIR,
			JUMPDOWN
		};

		Movement(Type t, uint8_t c, int16_t x, int16_t y, int16_t lx, int16_t ly, uint16_t f, uint8_t s, int16_t d) : type(t), command(c), xpos(x), ypos(y), lastx(lx), lasty(ly), fh(f), newstate(s), duration(d) {}
		Movement(int16_t x, int16_t y, int16_t lx, int16_t ly, uint8_t s, int16_t d) : Movement(Type::ABSOLUTE, 0, x, y, lx, ly, 0, s, d) {}
		Movement(const PhysicsObject& phobj, uint8_t s) : Movement(Type::ABSOLUTE, 0, phobj.get_x(), phobj.get_y(), phobj.get_last_x(), phobj.get_last_y(), phobj.fhid, s, 1) {}
		Movement() : Movement(Type::NONE, 0, 0, 0, 0, 0) {}

		bool hasmoved(const Movement& newmove) const
		{
			return newmove.newstate != newstate || newmove.xpos != xpos || newmove.ypos != ypos || newmove.lastx != lastx || newmove.lasty != lasty;
		}

		Type type;
		uint8_t command;
		int16_t xpos;
		int16_t ypos;
		int16_t lastx;
		int16_t lasty;
		uint16_t fh;
		uint8_t newstate;
		int16_t duration;
	};
}

================
File: Gameplay/Physics/Foothold.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Foothold.h"

namespace ms
{
	Foothold::Foothold() : m_id(0), m_layer(0), m_next(0), m_prev(0) {}
	Foothold::Foothold(nl::node src, uint16_t id, uint8_t ly) : m_prev(src["prev"]), m_next(src["next"]), m_horizontal(src["x1"], src["x2"]), m_vertical(src["y1"], src["y2"]), m_id(id), m_layer(ly) {}

	uint16_t Foothold::id() const
	{
		return m_id;
	}

	uint16_t Foothold::prev() const
	{
		return m_prev;
	}

	uint16_t Foothold::next() const
	{
		return m_next;
	}

	uint8_t Foothold::layer() const
	{
		return m_layer;
	}

	const Range<int16_t>& Foothold::horizontal() const
	{
		return m_horizontal;
	}

	const Range<int16_t>& Foothold::vertical() const
	{
		return m_vertical;
	}

	int16_t Foothold::l() const
	{
		return m_horizontal.smaller();
	}

	int16_t Foothold::r() const
	{
		return m_horizontal.greater();
	}

	int16_t Foothold::t() const
	{
		return m_vertical.smaller();
	}

	int16_t Foothold::b() const
	{
		return m_vertical.greater();
	}

	int16_t Foothold::x1() const
	{
		return m_horizontal.first();
	}

	int16_t Foothold::x2() const
	{
		return m_horizontal.second();
	}

	int16_t Foothold::y1() const
	{
		return m_vertical.first();
	}

	int16_t Foothold::y2() const
	{
		return m_vertical.second();
	}

	bool Foothold::is_wall() const
	{
		return m_id && m_horizontal.empty();
	}

	bool Foothold::is_floor() const
	{
		return m_id && m_vertical.empty();
	}

	bool Foothold::is_left_edge() const
	{
		return m_id && m_prev == 0;
	}

	bool Foothold::is_right_edge() const
	{
		return m_id && m_next == 0;
	}

	bool Foothold::hcontains(int16_t x) const
	{
		return m_id && m_horizontal.contains(x);
	}

	bool Foothold::vcontains(int16_t y) const
	{
		return m_id && m_vertical.contains(y);
	}

	bool Foothold::is_blocking(const Range<int16_t>& vertical) const
	{
		return is_wall() && m_vertical.overlaps(vertical);
	}

	int16_t Foothold::hdelta() const
	{
		return m_horizontal.delta();
	}

	int16_t Foothold::vdelta() const
	{
		return m_vertical.delta();
	}

	double Foothold::slope() const
	{
		return is_wall() ? 0.0f : static_cast<double>(vdelta()) / hdelta();
	}

	double Foothold::ground_below(double x) const
	{
		return is_floor() ? y1() : slope() * (x - x1()) + y1();
	}
}

================
File: Gameplay/Physics/Foothold.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../MapleStory.h"

#include "../../Template/Range.h"

#ifdef USE_NX
#include <nlnx/node.hpp>
#else
#include "../../Util/WzFiles.h"
#endif

namespace ms
{
	// Represents a platform part on a maple map
	class Foothold
	{
	public:
		Foothold();
		Foothold(nl::node src, uint16_t id, uint8_t layer);

		// Returns the foothold id aka the identifier in game data of this platform
		uint16_t id() const;
		// Returns the platform left to this
		uint16_t prev() const;
		// Returns the platform right to this
		uint16_t next() const;
		// Returns the platform's layer
		uint8_t layer() const;
		// Returns the horizontal component
		const Range<int16_t>& horizontal() const;
		// Returns the vertical component
		const Range<int16_t>& vertical() const;

		// Return the left edge
		int16_t l() const;
		// Return the right edge
		int16_t r() const;
		// Return the top edge
		int16_t t() const;
		// Return the bottom edge
		int16_t b() const;
		// Return the first horizontal component
		int16_t x1() const;
		// Return the second horizontal component
		int16_t x2() const;
		// Return the first vertical component
		int16_t y1() const;
		// Return the second vertical component
		int16_t y2() const;
		// Return if the platform is a wall (x1 == x2)
		bool is_wall() const;
		// Return if the platform is a floor (y1 == y2)
		bool is_floor() const;
		// Return if this platform is a left edge
		bool is_left_edge() const;
		// Return if this platform is a right edge
		bool is_right_edge() const;
		// Returns if a x-coordinate is above or below this platform
		bool hcontains(int16_t x) const;
		// Returns if a y-coordinate is right or left of this platform
		bool vcontains(int16_t y) const;
		// Check whether this foothold blocks an object
		bool is_blocking(const Range<int16_t>& vertical) const;
		// Returns the width
		int16_t hdelta() const;
		// Returns the height
		int16_t vdelta() const;
		// Returns the slope as a ratio of vertical/horizontal
		double slope() const;
		// Returns a y-coordinate right below the given x-coordinate
		double ground_below(double x) const;

	private:
		uint16_t m_id;
		uint16_t m_prev;
		uint16_t m_next;
		uint8_t m_layer;
		Range<int16_t> m_horizontal;
		Range<int16_t> m_vertical;
	};
}

================
File: Gameplay/Physics/FootholdTree.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "FootholdTree.h"

#include <iostream>

namespace ms
{
	FootholdTree::FootholdTree(nl::node src)
	{
		int16_t leftw = 30000;
		int16_t rightw = -30000;
		int16_t botb = -30000;
		int16_t topb = 30000;

		for (auto basef : src)
		{
			uint8_t layer;

			try
			{
				layer = static_cast<uint8_t>(std::stoi(basef.name()));
			}
			catch (const std::exception& ex)
			{
				LOG(LOG_ERROR, __func__ << ": " << ex.what());
				continue;
			}

			for (auto midf : basef)
			{
				for (auto lastf : midf)
				{
					uint16_t id;

					try
					{
						id = static_cast<uint16_t>(std::stoi(lastf.name()));
					}
					catch (const std::exception& ex)
					{
						LOG(LOG_ERROR, __func__ << ": " << ex.what());
						continue;
					}

					const Foothold& foothold = footholds.emplace(
						std::piecewise_construct,
						std::forward_as_tuple(id),
						std::forward_as_tuple(lastf, id, layer)
					).first->second;

					if (foothold.l() < leftw)
						leftw = foothold.l();

					if (foothold.r() > rightw)
						rightw = foothold.r();

					if (foothold.b() > botb)
						botb = foothold.b();

					if (foothold.t() < topb)
						topb = foothold.t();

					if (foothold.is_wall())
						continue;

					int16_t start = foothold.l();
					int16_t end = foothold.r();

					for (int16_t i = start; i <= end; i++)
						footholdsbyx.emplace(i, id);
				}
			}
		}

		walls = { leftw + 25, rightw - 25 };
		borders = { topb - 300, botb + 100 };
	}

	FootholdTree::FootholdTree() {}

	void FootholdTree::limit_movement(PhysicsObject& phobj) const
	{
		if (phobj.hmobile())
		{
			double crnt_x = phobj.crnt_x();
			double next_x = phobj.next_x();

			bool left = phobj.hspeed < 0.0f;
			double wall = get_wall(phobj.fhid, left, phobj.next_y());
			bool collision = left ? crnt_x >= wall && next_x <= wall : crnt_x <= wall && next_x >= wall;

			if (!collision && phobj.is_flag_set(PhysicsObject::Flag::TURNATEDGES))
			{
				wall = get_edge(phobj.fhid, left);
				collision = left ? crnt_x >= wall && next_x <= wall : crnt_x <= wall && next_x >= wall;
			}

			if (collision)
			{
				phobj.limitx(wall);
				phobj.clear_flag(PhysicsObject::Flag::TURNATEDGES);
			}
		}

		if (phobj.vmobile())
		{
			double crnt_y = phobj.crnt_y();
			double next_y = phobj.next_y();

			auto ground = Range<double>(
				get_fh(phobj.fhid).ground_below(phobj.crnt_x()),
				get_fh(phobj.fhid).ground_below(phobj.next_x())
				);

			bool collision = crnt_y <= ground.first() && next_y >= ground.second();

			if (collision)
			{
				phobj.limity(ground.second());

				limit_movement(phobj);
			}
			else
			{
				if (next_y < borders.first())
					phobj.limity(borders.first());
				else if (next_y > borders.second())
					phobj.limity(borders.second());
			}
		}
	}

	void FootholdTree::update_fh(PhysicsObject& phobj) const
	{
		if (phobj.type == PhysicsObject::Type::FIXATED && phobj.fhid > 0)
			return;

		const Foothold& curfh = get_fh(phobj.fhid);
		bool checkslope = false;

		double x = phobj.crnt_x();
		double y = phobj.crnt_y();

		if (phobj.onground)
		{
			if (std::floor(x) > curfh.r())
				phobj.fhid = curfh.next();
			else if (std::ceil(x) < curfh.l())
				phobj.fhid = curfh.prev();

			if (phobj.fhid == 0)
				phobj.fhid = get_fhid_below(x, y);
			else
				checkslope = true;
		}
		else
		{
			phobj.fhid = get_fhid_below(x, y);

			if (phobj.fhid == 0)
				return;
		}

		const Foothold& nextfh = get_fh(phobj.fhid);
		phobj.fhslope = nextfh.slope();

		double ground = nextfh.ground_below(x);

		if (phobj.vspeed == 0.0 && checkslope)
		{
			double vdelta = abs(phobj.fhslope);

			if (phobj.fhslope < 0.0)
				vdelta *= (ground - y);
			else if (phobj.fhslope > 0.0)
				vdelta *= (y - ground);

			if (curfh.slope() != 0.0 || nextfh.slope() != 0.0)
			{
				if (phobj.hspeed > 0.0 && vdelta <= phobj.hspeed)
					phobj.y = ground;
				else if (phobj.hspeed < 0.0 && vdelta >= phobj.hspeed)
					phobj.y = ground;
			}
		}

		phobj.onground = phobj.y == ground;

		if (phobj.enablejd || phobj.is_flag_set(PhysicsObject::Flag::CHECKBELOW))
		{
			uint16_t belowid = get_fhid_below(x, nextfh.ground_below(x) + 1.0);

			if (belowid > 0)
			{
				double nextground = get_fh(belowid).ground_below(x);
				phobj.enablejd = (nextground - ground) < 600.0;
				phobj.groundbelow = ground + 1.0;
			}
			else
			{
				phobj.enablejd = false;
			}

			phobj.clear_flag(PhysicsObject::Flag::CHECKBELOW);
		}

		if (phobj.fhlayer == 0 || phobj.onground)
			phobj.fhlayer = nextfh.layer();

		if (phobj.fhid == 0)
		{
			phobj.fhid = curfh.id();
			phobj.limitx(curfh.x1());
		}
	}

	const Foothold& FootholdTree::get_fh(uint16_t fhid) const
	{
		auto iter = footholds.find(fhid);

		if (iter == footholds.end())
			return nullfh;

		return iter->second;
	}

	double FootholdTree::get_wall(uint16_t curid, bool left, double fy) const
	{
		auto shorty = static_cast<int16_t>(fy);
		Range<int16_t> vertical(shorty - 50, shorty - 1);
		const Foothold& cur = get_fh(curid);

		if (left)
		{
			const Foothold& prev = get_fh(cur.prev());

			if (prev.is_blocking(vertical))
				return cur.l();

			const Foothold& prev_prev = get_fh(prev.prev());

			if (prev_prev.is_blocking(vertical))
				return prev.l();

			return walls.first();
		}
		else
		{
			const Foothold& next = get_fh(cur.next());

			if (next.is_blocking(vertical))
				return cur.r();

			const Foothold& next_next = get_fh(next.next());

			if (next_next.is_blocking(vertical))
				return next.r();

			return walls.second();
		}
	}

	double FootholdTree::get_edge(uint16_t curid, bool left) const
	{
		const Foothold& fh = get_fh(curid);

		if (left)
		{
			uint16_t previd = fh.prev();

			if (!previd)
				return fh.l();

			const Foothold& prev = get_fh(previd);
			uint16_t prev_previd = prev.prev();

			if (!prev_previd)
				return prev.l();

			return walls.first();
		}
		else
		{
			uint16_t nextid = fh.next();

			if (!nextid)
				return fh.r();

			const Foothold& next = get_fh(nextid);
			uint16_t next_nextid = next.next();

			if (!next_nextid)
				return next.r();

			return walls.second();
		}
	}

	uint16_t FootholdTree::get_fhid_below(double fx, double fy) const
	{
		uint16_t ret = 0;
		double comp = borders.second();

		int16_t x = static_cast<int16_t>(fx);
		auto range = footholdsbyx.equal_range(x);

		for (auto iter = range.first; iter != range.second; ++iter)
		{
			const Foothold& fh = footholds.at(iter->second);
			double ycomp = fh.ground_below(fx);

			if (comp >= ycomp && ycomp >= fy)
			{
				comp = ycomp;
				ret = fh.id();
			}
		}

		return ret;
	}

	int16_t FootholdTree::get_y_below(Point<int16_t> position) const
	{
		if (uint16_t fhid = get_fhid_below(position.x(), position.y()))
		{
			const Foothold& fh = get_fh(fhid);

			return static_cast<int16_t>(fh.ground_below(position.x()));
		}
		else
		{
			return borders.second();
		}
	}

	Range<int16_t> FootholdTree::get_walls() const
	{
		return walls;
	}

	Range<int16_t> FootholdTree::get_borders() const
	{
		return borders;
	}
}

================
File: Gameplay/Physics/FootholdTree.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Foothold.h"
#include "PhysicsObject.h"

#include <unordered_map>

namespace ms
{
	// The collection of platforms in a maple map
	// Used for collision-detection
	class FootholdTree
	{
	public:
		FootholdTree(nl::node source);
		FootholdTree();

		// Takes an accelerated PhysicsObject and limits its movement based on the platforms in this tree
		void limit_movement(PhysicsObject& touse) const;
		// Updates a PhysicsObject's fhid based on it's position
		void update_fh(PhysicsObject& touse) const;
		// Determine the point on the ground below the specified position
		int16_t get_y_below(Point<int16_t> position) const;
		// Returns the leftmost and rightmost platform positions of the map
		Range<int16_t> get_walls() const;
		// Returns the topmost and bottommost platform positions of the map
		Range<int16_t> get_borders() const;

	private:
		uint16_t get_fhid_below(double fx, double fy) const;
		double get_wall(uint16_t fhid, bool left, double fy) const;
		double get_edge(uint16_t fhid, bool left) const;
		const Foothold& get_fh(uint16_t fhid) const;

		std::unordered_map<uint16_t, Foothold> footholds;
		std::unordered_multimap<int16_t, uint16_t> footholdsbyx;

		Foothold nullfh;
		Range<int16_t> walls;
		Range<int16_t> borders;
	};
}

================
File: Gameplay/Physics/Physics.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Physics.h"

namespace ms
{
	const double GRAVFORCE = 0.14;
	const double SWIMGRAVFORCE = 0.03;
	const double FRICTION = 0.5;
	const double SLOPEFACTOR = 0.1;
	const double GROUNDSLIP = 3.0;
	const double FLYFRICTION = 0.05;
	const double SWIMFRICTION = 0.08;

	Physics::Physics(nl::node src)
	{
		fht = src;
	}

	Physics::Physics() {}

	void Physics::move_object(PhysicsObject& phobj) const
	{
		// Determine which platform the object is currently on
		fht.update_fh(phobj);

		// Use the appropriate physics for the terrain the object is on
		switch (phobj.type)
		{
		case PhysicsObject::Type::NORMAL:
			move_normal(phobj);
			fht.limit_movement(phobj);
			break;
		case PhysicsObject::Type::FLYING:
			move_flying(phobj);
			fht.limit_movement(phobj);
			break;
		case PhysicsObject::Type::SWIMMING:
			move_swimming(phobj);
			fht.limit_movement(phobj);
			break;
		case PhysicsObject::Type::FIXATED:
		default:
			break;
		}

		// Move the object forward
		phobj.move();
	}

	void Physics::move_normal(PhysicsObject& phobj) const
	{
		phobj.vacc = 0.0;
		phobj.hacc = 0.0;

		if (phobj.onground)
		{
			phobj.vacc += phobj.vforce;
			phobj.hacc += phobj.hforce;

			if (phobj.hacc == 0.0 && phobj.hspeed < 0.1 && phobj.hspeed > -0.1)
			{
				phobj.hspeed = 0.0;
			}
			else
			{
				double inertia = phobj.hspeed / GROUNDSLIP;
				double slopef = phobj.fhslope;

				if (slopef > 0.5)
					slopef = 0.5;
				else if (slopef < -0.5)
					slopef = -0.5;

				phobj.hacc -= (FRICTION + SLOPEFACTOR * (1.0 + slopef * -inertia)) * inertia;
			}
		}
		else if (phobj.is_flag_not_set(PhysicsObject::Flag::NOGRAVITY))
		{
			phobj.vacc += GRAVFORCE;
		}

		phobj.hforce = 0.0;
		phobj.vforce = 0.0;

		phobj.hspeed += phobj.hacc;
		phobj.vspeed += phobj.vacc;
	}

	void Physics::move_flying(PhysicsObject& phobj) const
	{
		phobj.hacc = phobj.hforce;
		phobj.vacc = phobj.vforce;
		phobj.hforce = 0.0;
		phobj.vforce = 0.0;

		phobj.hacc -= FLYFRICTION * phobj.hspeed;
		phobj.vacc -= FLYFRICTION * phobj.vspeed;

		phobj.hspeed += phobj.hacc;
		phobj.vspeed += phobj.vacc;

		if (phobj.hacc == 0.0 && phobj.hspeed < 0.1 && phobj.hspeed > -0.1)
			phobj.hspeed = 0.0;

		if (phobj.vacc == 0.0 && phobj.vspeed < 0.1 && phobj.vspeed > -0.1)
			phobj.vspeed = 0.0;
	}

	void Physics::move_swimming(PhysicsObject& phobj) const
	{
		phobj.hacc = phobj.hforce;
		phobj.vacc = phobj.vforce;
		phobj.hforce = 0.0;
		phobj.vforce = 0.0;

		phobj.hacc -= SWIMFRICTION * phobj.hspeed;
		phobj.vacc -= SWIMFRICTION * phobj.vspeed;

		if (phobj.is_flag_not_set(PhysicsObject::Flag::NOGRAVITY))
			phobj.vacc += SWIMGRAVFORCE;

		phobj.hspeed += phobj.hacc;
		phobj.vspeed += phobj.vacc;

		if (phobj.hacc == 0.0 && phobj.hspeed < 0.1 && phobj.hspeed > -0.1)
			phobj.hspeed = 0.0;

		if (phobj.vacc == 0.0 && phobj.vspeed < 0.1 && phobj.vspeed > -0.1)
			phobj.vspeed = 0.0f;
	}

	Point<int16_t> Physics::get_y_below(Point<int16_t> position) const
	{
		int16_t ground = fht.get_y_below(position);

		return Point<int16_t>(position.x(), ground - 1);
	}

	const FootholdTree& Physics::get_fht() const
	{
		return fht;
	}
}

================
File: Gameplay/Physics/Physics.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "FootholdTree.h"

namespace ms
{
	// Class that uses physics engines and the collection of platforms to determine object movement
	class Physics
	{
	public:
		Physics(nl::node src);
		Physics();

		// Move the specified object over the specified game-time
		void move_object(PhysicsObject& tomove) const;
		// Determine the point on the ground below the specified position
		Point<int16_t> get_y_below(Point<int16_t> position) const;
		// Return a reference to the collection of platforms
		const FootholdTree& get_fht() const;

	private:
		void move_normal(PhysicsObject&) const;
		void move_flying(PhysicsObject&) const;
		void move_swimming(PhysicsObject&) const;

		FootholdTree fht;
	};
}

================
File: Gameplay/Physics/PhysicsObject.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Constants.h"

#include "../../Template/Interpolated.h"
#include "../../Template/Point.h"

namespace ms
{
	// Structure that contains all properties for movement calculations
	struct MovingObject
	{
		Linear<double> x;
		Linear<double> y;
		double hspeed = 0.0;
		double vspeed = 0.0;

		void normalize()
		{
			x.normalize();
			y.normalize();
		}

		void move()
		{
			x += hspeed;
			y += vspeed;
		}

		void set_x(double d)
		{
			x.set(d);
		}

		void set_y(double d)
		{
			y.set(d);
		}

		void limitx(double d)
		{
			x = d;
			hspeed = 0.0;
		}

		void limity(double d)
		{
			y = d;
			vspeed = 0.0;
		}

		void movexuntil(double d, uint16_t delay)
		{
			if (delay)
			{
				double hdelta = d - x.get();
				hspeed = Constants::TIMESTEP * hdelta / delay;
			}
		}

		void moveyuntil(double d, uint16_t delay)
		{
			if (delay)
			{
				double vdelta = d - y.get();
				vspeed = Constants::TIMESTEP * vdelta / delay;
			}
		}

		bool hmobile() const
		{
			return hspeed != 0.0;
		}

		bool vmobile() const
		{
			return vspeed != 0.0;
		}

		bool mobile() const
		{
			return hmobile() || vmobile();
		}

		double crnt_x() const
		{
			return x.get();
		}

		double crnt_y() const
		{
			return y.get();
		}

		double next_x() const
		{
			return x + hspeed;
		}

		double next_y() const
		{
			return y + vspeed;
		}

		int16_t get_x() const
		{
			double rounded = std::round(x.get());
			return static_cast<int16_t>(rounded);
		}

		int16_t get_y() const
		{
			double rounded = std::round(y.get());
			return static_cast<int16_t>(rounded);
		}

		int16_t get_last_x() const
		{
			double rounded = std::round(x.last());
			return static_cast<int16_t>(rounded);
		}

		int16_t get_last_y() const
		{
			double rounded = std::round(y.last());
			return static_cast<int16_t>(rounded);
		}

		Point<int16_t> get_position() const
		{
			return { get_x(), get_y() };
		}

		int16_t get_absolute_x(double viewx, float alpha) const
		{
			double interx = x.normalized() ? std::round(x.get()) : x.get(alpha);

			return static_cast<int16_t>(
				std::round(interx + viewx)
				);
		}

		int16_t get_absolute_y(double viewy, float alpha) const
		{
			double intery = y.normalized() ? std::round(y.get()) : y.get(alpha);

			return static_cast<int16_t>(
				std::round(intery + viewy)
				);
		}

		Point<int16_t> get_absolute(double viewx, double viewy, float alpha) const
		{
			return { get_absolute_x(viewx, alpha), get_absolute_y(viewy, alpha) };
		}
	};

	// Structure that contains all properties necessary for physics calculations
	struct PhysicsObject : public MovingObject
	{
		// Determines which physics engine to use
		enum Type
		{
			NORMAL,
			ICE,
			SWIMMING,
			FLYING,
			FIXATED
		};

		enum Flag
		{
			NOGRAVITY = 0x0001,
			TURNATEDGES = 0x0002,
			CHECKBELOW = 0x0004
		};

		Type type = Type::NORMAL;
		int32_t flags = 0;
		uint16_t fhid = 0;
		double fhslope = 0.0;
		int8_t fhlayer = 0;
		double groundbelow = 0.0;
		bool onground = true;
		bool enablejd = false;

		double hforce = 0.0;
		double vforce = 0.0;
		double hacc = 0.0;
		double vacc = 0.0;

		bool is_flag_set(Flag f)
		{
			return (flags & f) != 0;
		}

		bool is_flag_not_set(Flag f)
		{
			return !is_flag_set(f);
		}

		void set_flag(Flag f)
		{
			flags |= f;
		}

		void clear_flag(Flag f)
		{
			flags &= ~f;
		}

		void clear_flags()
		{
			flags = 0;
		}
	};
}

================
File: Gameplay/Playable.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../IO/KeyAction.h"

namespace ms
{
	// Interface for classes which can be controlled through key inputs.
	class Playable
	{
	public:
		virtual ~Playable() {}

		// Sends a keystate to the object.
		virtual void send_action(KeyAction::Id action, bool pressed) = 0;
	};
}

================
File: Gameplay/Spawn.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Spawn.h"

#include "MapleMap/ItemDrop.h"
#include "MapleMap/MesoDrop.h"
#include "MapleMap/Mob.h"
#include "MapleMap/Npc.h"
#include "MapleMap/Reactor.h"

#include "../Character/OtherChar.h"

namespace ms
{
	NpcSpawn::NpcSpawn(int32_t o, int32_t i, Point<int16_t> p, bool fl, uint16_t f) : oid(o), id(i), position(p), flip(fl), fh(f) {}

	int32_t NpcSpawn::get_oid() const
	{
		return oid;
	}

	std::unique_ptr<MapObject> NpcSpawn::instantiate(const Physics& physics) const
	{
		auto spawnposition = physics.get_y_below(position);
		return std::make_unique<Npc>(id, oid, flip, fh, false, spawnposition);
	}

	MobSpawn::MobSpawn(int32_t o, int32_t i, int8_t m, int8_t st, uint16_t f, bool ns, int8_t t, Point<int16_t> p) : oid(o), id(i), mode(m), stance(st), fh(f), newspawn(ns), team(t), position(p) {}

	int8_t MobSpawn::get_mode() const
	{
		return mode;
	}

	int32_t MobSpawn::get_oid() const
	{
		return oid;
	}

	std::unique_ptr<MapObject> MobSpawn::instantiate() const
	{
		return std::make_unique<Mob>(oid, id, mode, stance, fh, newspawn, team, position);
	}

	ReactorSpawn::ReactorSpawn(int32_t o, int32_t r, int8_t s, Point<int16_t> p) : oid(o), rid(r), state(s), position(p) {}

	int32_t ReactorSpawn::get_oid() const
	{
		return oid;
	}

	std::unique_ptr<MapObject> ReactorSpawn::instantiate(const Physics& physics) const
	{
		auto spawnposition = physics.get_y_below(position);
		return std::make_unique<Reactor>(oid, rid, state, spawnposition);
	}

	DropSpawn::DropSpawn(int32_t o, int32_t i, bool ms, int32_t ow, Point<int16_t> p, Point<int16_t> d, int8_t t, int8_t m, bool pd) : oid(o), id(i), meso(ms), owner(ow), start(p), dest(d), droptype(t), mode(m), playerdrop(pd) {}

	bool DropSpawn::is_meso() const
	{
		return meso;
	}

	int32_t DropSpawn::get_itemid() const
	{
		return id;
	}

	int32_t DropSpawn::get_oid() const
	{
		return oid;
	}

	std::unique_ptr<MapObject> DropSpawn::instantiate(const Animation& icon) const
	{
		return std::make_unique<MesoDrop>(oid, owner, start, dest, droptype, mode, playerdrop, icon);
	}

	std::unique_ptr<MapObject> DropSpawn::instantiate(const Texture& icon) const
	{
		return std::make_unique<ItemDrop>(oid, owner, start, dest, droptype, mode, id, playerdrop, icon);
	}

	CharSpawn::CharSpawn(int32_t cid, const LookEntry& look, uint16_t level, int16_t job, const std::string& name, int8_t stance, Point<int16_t> position) : cid(cid), look(look), level(level), job(job), name(name), stance(stance), position(position) {}

	int32_t CharSpawn::get_cid() const
	{
		return cid;
	}

	std::unique_ptr<MapObject> CharSpawn::instantiate() const
	{
		return std::make_unique<OtherChar>(cid, look, level, job, name, stance, position);
	}
}

================
File: Gameplay/Spawn.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "MapleMap/MapObject.h"

#include "../Graphics/Animation.h"
#include "../Net/Login.h"

#include <memory>

namespace ms
{
	class NpcSpawn
	{
	public:
		NpcSpawn(int32_t oid, int32_t npcid, Point<int16_t> position, bool mirrored, uint16_t fh);

		int32_t get_oid() const;
		std::unique_ptr<MapObject> instantiate(const Physics& physics) const;

	private:
		int32_t oid;
		int32_t id;
		Point<int16_t> position;
		bool flip;
		uint16_t fh;
	};

	class MobSpawn
	{
	public:
		MobSpawn(int32_t oid, int32_t id, int8_t mode, int8_t stance, uint16_t fh, bool newspawn, int8_t team, Point<int16_t> position);

		int8_t get_mode() const;
		int32_t get_oid() const;
		std::unique_ptr<MapObject> instantiate() const;

	private:
		int32_t oid;
		int32_t id;
		int8_t mode;
		int8_t stance;
		uint16_t fh;
		bool newspawn;
		int8_t team;
		Point<int16_t> position;
	};

	class ReactorSpawn
	{
	public:
		ReactorSpawn(int32_t oid, int32_t rid, int8_t state, Point<int16_t> position);

		int32_t get_oid() const;
		std::unique_ptr<MapObject> instantiate(const Physics& physics) const;

	private:
		int32_t oid;
		int32_t rid;
		int8_t state;
		Point<int16_t> position;
	};

	class DropSpawn
	{
	public:
		DropSpawn(int32_t oid, int32_t id, bool meso, int32_t owner, Point<int16_t> position, Point<int16_t> destination, int8_t droptype, int8_t mode, bool playerdrop);

		bool is_meso() const;
		int32_t get_itemid() const;
		int32_t get_oid() const;
		std::unique_ptr<MapObject> instantiate(const Animation& icon) const;
		std::unique_ptr<MapObject> instantiate(const Texture& icon) const;

	private:
		int32_t oid;
		int32_t id;
		bool meso;
		int32_t owner;
		Point<int16_t> start;
		Point<int16_t> dest;
		int8_t droptype;
		int8_t mode;
		bool playerdrop;
	};

	class CharSpawn
	{
	public:
		CharSpawn(int32_t cid, const LookEntry& look, uint16_t level, int16_t job, const std::string& name, int8_t stance, Point<int16_t> position);

		int32_t get_cid() const;
		std::unique_ptr<MapObject> instantiate() const;

	private:
		int32_t cid;
		uint16_t level;
		int16_t job;
		std::string name;
		int8_t stance;
		Point<int16_t> position;
		LookEntry look;
	};
}

================
File: Gameplay/Stage.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Stage.h"

#include "../Configuration.h"

#include "../IO/UI.h"

#include "../IO/UITypes/UIStatusBar.h"
#include "../Net/Packets/AttackAndSkillPackets.h"
#include "../Net/Packets/GameplayPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Stage::Stage() : combat(player, chars, mobs, reactors)
	{
		state = State::INACTIVE;
	}

	void Stage::init()
	{
		drops.init();
	}

	void Stage::load(int32_t mapid, int8_t portalid)
	{
		switch (state)
		{
			case State::INACTIVE:
				load_map(mapid);
				respawn(portalid);
				break;
			case State::TRANSITION:
				respawn(portalid);
				break;
		}

		state = State::ACTIVE;
	}

	void Stage::loadplayer(const CharEntry& entry)
	{
		player = entry;
		playable = player;

		start = ContinuousTimer::get().start();

		CharStats stats = player.get_stats();
		levelBefore = stats.get_stat(MapleStat::Id::LEVEL);
		expBefore = stats.get_exp();
	}

	void Stage::clear()
	{
		state = State::INACTIVE;

		chars.clear();
		npcs.clear();
		mobs.clear();
		drops.clear();
		reactors.clear();
	}

	void Stage::load_map(int32_t mapid)
	{
		Stage::mapid = mapid;

		std::string strid = string_format::extend_id(mapid, 9);
		std::string prefix = std::to_string(mapid / 100000000);

		// Try Map002 fallback, then direct Map (v83)
		nl::node src;
		if (mapid == -1) {
			src = nl::nx::UI["CashShopPreview.img"];
		} else {
			src = nl::nx::Map002["Map"]["Map" + prefix][strid + ".img"];
			if (src.name().empty()) {
				src = nl::nx::Map["Map"]["Map" + prefix][strid + ".img"];
			}
		}

		tilesobjs = MapTilesObjs(src);
		backgrounds = MapBackgrounds(src["back"]);
		physics = Physics(src["foothold"]);
		mapinfo = MapInfo(src, physics.get_fht().get_walls(), physics.get_fht().get_borders());
		portals = MapPortals(src["portal"], mapid);
	}

	void Stage::respawn(int8_t portalid)
	{
		Music(mapinfo.get_bgm()).play();

		Point<int16_t> spawnpoint = portals.get_portal_by_id(portalid);
		Point<int16_t> startpos = physics.get_y_below(spawnpoint);
		player.respawn(startpos, mapinfo.is_underwater());
		camera.set_position(startpos);
		camera.set_view(mapinfo.get_walls(), mapinfo.get_borders());
	}

	void Stage::draw(float alpha) const
	{
		if (state != State::ACTIVE)
			return;

		Point<int16_t> viewpos = camera.position(alpha);
		Point<double> viewrpos = camera.realposition(alpha);
		double viewx = viewrpos.x();
		double viewy = viewrpos.y();

		backgrounds.drawbackgrounds(viewx, viewy, alpha);

		for (auto id : Layer::IDs)
		{
			tilesobjs.draw(id, viewpos, alpha);
			reactors.draw(id, viewx, viewy, alpha);
			npcs.draw(id, viewx, viewy, alpha);
			mobs.draw(id, viewx, viewy, alpha);
			chars.draw(id, viewx, viewy, alpha);
			player.draw(id, viewx, viewy, alpha);
			drops.draw(id, viewx, viewy, alpha);
		}

		combat.draw(viewx, viewy, alpha);
		portals.draw(viewpos, alpha);
		backgrounds.drawforegrounds(viewx, viewy, alpha);
		effect.draw();
	}

	void Stage::update()
	{
		if (state != State::ACTIVE)
			return;

		combat.update();
		backgrounds.update();
		effect.update();
		tilesobjs.update();

		reactors.update(physics);
		npcs.update(physics);
		mobs.update(physics);
		chars.update(physics);
		drops.update(physics);
		player.update(physics);

		portals.update(player.get_position());
		camera.update(player.get_position());

		if (!player.is_climbing() && !player.is_sitting() && !player.is_attacking())
		{
			if (player.is_key_down(KeyAction::Id::UP) && !player.is_key_down(KeyAction::Id::DOWN))
				check_ladders(true);

			if (player.is_key_down(KeyAction::Id::UP))
				check_portals();

			if (player.is_key_down(KeyAction::Id::DOWN))
				check_ladders(false);

			if (player.is_key_down(KeyAction::Id::SIT))
				check_seats();

			if (player.is_key_down(KeyAction::Id::ATTACK))
				combat.use_move(0);

			if (player.is_key_down(KeyAction::Id::PICKUP))
				check_drops();
		}

		if (player.is_invincible())
			return;

		if (int32_t oid_id = mobs.find_colliding(player.get_phobj()))
		{
			if (MobAttack attack = mobs.create_attack(oid_id))
			{
				MobAttackResult result = player.damage(attack);
				TakeDamagePacket(result, TakeDamagePacket::From::TOUCH).dispatch();
			}
		}
	}

	void Stage::show_character_effect(int32_t cid, CharEffect::Id effect)
	{
		if (auto character = get_character(cid))
			character->show_effect_id(effect);
	}

	void Stage::check_portals()
	{
		if (player.is_attacking())
			return;

		Point<int16_t> playerpos = player.get_position();
		Portal::WarpInfo warpinfo = portals.find_warp_at(playerpos);

		if (warpinfo.intramap)
		{
			Point<int16_t> spawnpoint = portals.get_portal_by_name(warpinfo.toname);
			Point<int16_t> startpos = physics.get_y_below(spawnpoint);

			player.respawn(startpos, mapinfo.is_underwater());
		}
		else if (warpinfo.valid)
		{
			ChangeMapPacket(false, -1, warpinfo.name, false).dispatch();

			CharStats& stats = Stage::get().get_player().get_stats();

			stats.set_mapid(warpinfo.mapid);

			Sound(Sound::Name::PORTAL).play();
		}
	}

	void Stage::check_seats()
	{
		if (player.is_sitting() || player.is_attacking())
			return;

		Optional<const Seat> seat = mapinfo.findseat(player.get_position());
		player.set_seat(seat);
	}

	void Stage::check_ladders(bool up)
	{
		if (!player.can_climb() || player.is_climbing() || player.is_attacking())
			return;

		Optional<const Ladder> ladder = mapinfo.findladder(player.get_position(), up);
		player.set_ladder(ladder);
	}

	void Stage::check_drops()
	{
		Point<int16_t> playerpos = player.get_position();
		MapDrops::Loot loot = drops.find_loot_at(playerpos);

		if (loot.first)
			PickupItemPacket(loot.first, loot.second).dispatch();
	}

	void Stage::send_key(KeyType::Id type, int32_t action, bool down)
	{
		if (state != State::ACTIVE || !playable)
			return;

		switch (type)
		{
			case KeyType::Id::ACTION:
				playable->send_action(KeyAction::actionbyid(action), down);
				break;
			case KeyType::Id::SKILL:
				combat.use_move(action);
				break;
			case KeyType::Id::ITEM:
				player.use_item(action);
				break;
			case KeyType::Id::FACE:
				player.set_expression(action);
				break;
		}
	}

	Cursor::State Stage::send_cursor(bool clicked, Point<int16_t> cursor_position)
	{
		auto statusbar = UI::get().get_element<UIStatusBar>();

		if (statusbar && statusbar->is_menu_active())
		{
			if (clicked)
				statusbar->remove_menus();

			if (statusbar->is_in_range(cursor_position))
				return statusbar->send_cursor(clicked, cursor_position);
		}

		return npcs.send_cursor(clicked, cursor_position, camera.position());
	}

	bool Stage::is_player(int32_t cid) const
	{
		return cid == player.get_oid();
	}

	MapNpcs& Stage::get_npcs()
	{
		return npcs;
	}

	MapChars& Stage::get_chars()
	{
		return chars;
	}

	MapMobs& Stage::get_mobs()
	{
		return mobs;
	}

	MapReactors& Stage::get_reactors()
	{
		return reactors;
	}

	MapDrops& Stage::get_drops()
	{
		return drops;
	}

	Player& Stage::get_player()
	{
		return player;
	}

	Combat& Stage::get_combat()
	{
		return combat;
	}

	Optional<Char> Stage::get_character(int32_t cid)
	{
		if (is_player(cid))
			return player;
		else
			return chars.get_char(cid);
	}

	int Stage::get_mapid()
	{
		return mapid;
	}

	void Stage::add_effect(std::string path)
	{
		effect = MapEffect(path);
	}

	int64_t Stage::get_uptime()
	{
		return ContinuousTimer::get().stop(start);
	}

	uint16_t Stage::get_uplevel()
	{
		return levelBefore;
	}

	int64_t Stage::get_upexp()
	{
		return expBefore;
	}

	void Stage::transfer_player()
	{
		PlayerMapTransferPacket().dispatch();

		if (Configuration::get().get_admin())
			AdminEnterMapPacket(AdminEnterMapPacket::Operation::ALERT_ADMINS).dispatch();
	}
}

================
File: Gameplay/Stage.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Combat/Combat.h"
#include "MapleMap/MapBackgrounds.h"
#include "MapleMap/MapDrops.h"
#include "MapleMap/MapEffect.h"
#include "MapleMap/MapNpcs.h"
#include "MapleMap/MapPortals.h"
#include "MapleMap/MapTilesObjs.h"

#include "../Timer.h"

#include "../IO/KeyType.h"

namespace ms
{
	class Stage : public Singleton<Stage>
	{
	public:
		Stage();

		void init();

		// Loads the map to display
		void load(int32_t mapid, int8_t portalid);
		// Remove all map objects and graphics
		void clear();

		// Construct the player from a character entry
		void loadplayer(const CharEntry& entry);

		// Call 'draw()' of all objects on stage
		void draw(float alpha) const;
		// Calls 'update()' of all objects on stage
		void update();

		// Show a character effect
		void show_character_effect(int32_t cid, CharEffect::Id effect);

		// Send key input to the stage
		void send_key(KeyType::Id keytype, int32_t keycode, bool pressed);
		// Send mouse input to the stage
		Cursor::State send_cursor(bool clicked, Point<int16_t> cursor_position);

		// Check if the specified id is the player's id
		bool is_player(int32_t cid) const;

		// Returns a reference to the NPCs on the current map
		MapNpcs& get_npcs();
		// Returns a reference to the other characters on the current map
		MapChars& get_chars();
		// Returns a reference to the mobs on the current map
		MapMobs& get_mobs();
		// Returns a reference to the reactors on the current map
		MapReactors& get_reactors();
		// Returns a reference to the drops on the current map
		MapDrops& get_drops();
		// Returns a reference to the Player
		Player& get_player();
		// Return a reference to the attack and buff component
		Combat& get_combat();
		// Returns the current map ID
		int32_t get_mapid();

		// Return a pointer to a character, possibly the player.
		Optional<Char> get_character(int32_t cid);

		// Set a map effect
		void add_effect(std::string path);

		// Get the total up time of the client
		int64_t get_uptime();
		// Get the level at the start of the client
		uint16_t get_uplevel();
		// Get the EXP at the start of the client
		int64_t get_upexp();

		// Notify the server that the player has moved maps
		void transfer_player();

	private:
		void load_map(int32_t mapid);
		void respawn(int8_t portalid);
		void check_portals();
		void check_seats();
		void check_ladders(bool up);
		void check_drops();

		enum State
		{
			INACTIVE,
			TRANSITION,
			ACTIVE
		};

		Camera camera;
		Physics physics;
		Player player;

		Optional<Playable> playable;
		State state;
		int32_t mapid;

		MapInfo mapinfo;
		MapTilesObjs tilesobjs;
		MapBackgrounds backgrounds;
		MapPortals portals;
		MapReactors reactors;
		MapNpcs npcs;
		MapChars chars;
		MapMobs mobs;
		MapDrops drops;
		MapEffect effect;

		Combat combat;

		std::chrono::time_point<std::chrono::steady_clock> start;
		uint16_t levelBefore;
		int64_t expBefore;
	};
}

================
File: Graphics/Animation.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Animation.h"

#include "../Constants.h"

#include "../Util/Misc.h"

#include <set>
#include <iostream>

namespace ms
{
	Frame::Frame(nl::node src)
	{
		std::cout << "[DEBUG FRAME] Creating frame from node: '" << src.name() 
		          << "', data type: " << static_cast<int>(src.data_type()) << std::endl;
		texture = src;
		std::cout << "[DEBUG FRAME] Texture created from node" << std::endl;
		bounds = src;
		head = src["head"];
		delay = src["delay"];

		if (delay == 0)
			delay = 100;

		bool hasa0 = src["a0"].data_type() == nl::node::type::integer;
		bool hasa1 = src["a1"].data_type() == nl::node::type::integer;

		if (hasa0 && hasa1)
		{
			opacities = { src["a0"], src["a1"] };
		}
		else if (hasa0)
		{
			uint8_t a0 = src["a0"];
			opacities = { a0, 255 - a0 };
		}
		else if (hasa1)
		{
			uint8_t a1 = src["a1"];
			opacities = { 255 - a1, a1 };
		}
		else
		{
			opacities = { 255, 255 };
		}

		bool hasz0 = src["z0"].data_type() == nl::node::type::integer;
		bool hasz1 = src["z1"].data_type() == nl::node::type::integer;

		if (hasz0 && hasz1)
			scales = { src["z0"], src["z1"] };
		else if (hasz0)
			scales = { src["z0"], 0 };
		else if (hasz1)
			scales = { 100, src["z1"] };
		else
			scales = { 100, 100 };
	}

	Frame::Frame()
	{
		delay = 0;
		opacities = { 0, 0 };
		scales = { 0, 0 };
	}

	void Frame::draw(const DrawArgument& args) const
	{
		texture.draw(args);
	}

	uint8_t Frame::start_opacity() const
	{
		return opacities.first;
	}

	uint16_t Frame::start_scale() const
	{
		return scales.first;
	}

	uint16_t Frame::get_delay() const
	{
		return delay;
	}

	Point<int16_t> Frame::get_origin() const
	{
		return texture.get_origin();
	}

	Point<int16_t> Frame::get_dimensions() const
	{
		return texture.get_dimensions();
	}

	Point<int16_t> Frame::get_head() const
	{
		return head;
	}

	Rectangle<int16_t> Frame::get_bounds() const
	{
		return bounds;
	}

	float Frame::opcstep(uint16_t timestep) const
	{
		return timestep * static_cast<float>(opacities.second - opacities.first) / delay;
	}

	float Frame::scalestep(uint16_t timestep) const
	{
		return timestep * static_cast<float>(scales.second - scales.first) / delay;
	}

	Animation::Animation(nl::node src)
	{
		bool istexture = src.data_type() == nl::node::type::bitmap;

		if (istexture)
		{
			frames.push_back(src);
		}
		else
		{
			std::set<int16_t> frameids;

			for (auto sub : src)
			{
				if (sub.data_type() == nl::node::type::bitmap)
				{
					int16_t fid = string_conversion::or_default<int16_t>(sub.name(), -1);

					if (fid >= 0)
						frameids.insert(fid);
				}
			}

			for (auto& fid : frameids)
			{
				auto sub = src[std::to_string(fid)];
				frames.push_back(sub);
			}

			if (frames.empty())
				frames.push_back(Frame());
		}

		animated = frames.size() > 1;
		zigzag = src["zigzag"].get_bool();

		reset();
	}

	Animation::Animation()
	{
		animated = false;
		zigzag = false;

		frames.push_back(Frame());

		reset();
	}

	void Animation::reset()
	{
		frame.set(0);
		opacity.set(frames[0].start_opacity());
		xyscale.set(frames[0].start_scale());
		delay = frames[0].get_delay();
		framestep = 1;
	}

	void Animation::draw(const DrawArgument& args, float alpha) const
	{
		int16_t interframe = frame.get(alpha);
		float interopc = opacity.get(alpha) / 255;
		float interscale = xyscale.get(alpha) / 100;

		bool modifyopc = interopc != 1.0f;
		bool modifyscale = interscale != 1.0f;

		if (modifyopc || modifyscale)
			frames[interframe].draw(args + DrawArgument(interscale, interscale, interopc));
		else
			frames[interframe].draw(args);
	}

	bool Animation::update()
	{
		return update(Constants::TIMESTEP);
	}

	bool Animation::update(uint16_t timestep)
	{
		const Frame& framedata = get_frame();

		opacity += framedata.opcstep(timestep);

		if (opacity.last() < 0.0f)
			opacity.set(0.0f);
		else if (opacity.last() > 255.0f)
			opacity.set(255.0f);

		xyscale += framedata.scalestep(timestep);

		if (xyscale.last() < 0.0f)
			opacity.set(0.0f);

		if (timestep >= delay)
		{
			int16_t lastframe = static_cast<int16_t>(frames.size() - 1);
			int16_t nextframe;
			bool ended;

			if (zigzag && lastframe > 0)
			{
				if (framestep == 1 && frame == lastframe)
				{
					framestep = -framestep;
					ended = false;
				}
				else if (framestep == -1 && frame == 0)
				{
					framestep = -framestep;
					ended = true;
				}
				else
				{
					ended = false;
				}

				nextframe = frame + framestep;
			}
			else
			{
				if (frame == lastframe)
				{
					nextframe = 0;
					ended = true;
				}
				else
				{
					nextframe = frame + 1;
					ended = false;
				}
			}

			uint16_t delta = timestep - delay;
			float threshold = static_cast<float>(delta) / timestep;
			frame.next(nextframe, threshold);

			delay = frames[nextframe].get_delay();

			if (delay >= delta)
				delay -= delta;

			opacity.set(frames[nextframe].start_opacity());
			xyscale.set(frames[nextframe].start_scale());

			return ended;
		}
		else
		{
			frame.normalize();

			delay -= timestep;

			return false;
		}
	}

	uint16_t Animation::get_delay(int16_t frame_id) const
	{
		return frame_id < frames.size() ? frames[frame_id].get_delay() : 0;
	}

	uint16_t Animation::getdelayuntil(int16_t frame_id) const
	{
		uint16_t total = 0;

		for (int16_t i = 0; i < frame_id; i++)
		{
			if (i >= frames.size())
				break;

			total += frames[frame_id].get_delay();
		}

		return total;
	}

	Point<int16_t> Animation::get_origin() const
	{
		return get_frame().get_origin();
	}

	Point<int16_t> Animation::get_dimensions() const
	{
		return get_frame().get_dimensions();
	}

	Point<int16_t> Animation::get_head() const
	{
		return get_frame().get_head();
	}

	Rectangle<int16_t> Animation::get_bounds() const
	{
		return get_frame().get_bounds();
	}

	const Frame& Animation::get_frame() const
	{
		return frames[frame.get()];
	}
}

================
File: Graphics/Animation.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Texture.h"

#include "../Template/Interpolated.h"
#include "../Template/Rectangle.h"

#include <vector>

namespace ms
{
	// A single frame within an animation.
	class Frame
	{
	public:
		Frame(nl::node src);
		Frame();

		void draw(const DrawArgument& args) const;

		uint8_t start_opacity() const;
		uint16_t start_scale() const;
		uint16_t get_delay() const;
		Point<int16_t> get_origin() const;
		Point<int16_t> get_dimensions() const;
		Point<int16_t> get_head() const;
		Rectangle<int16_t> get_bounds() const;
		float opcstep(uint16_t timestep) const;
		float scalestep(uint16_t timestep) const;

	private:
		Texture texture;
		uint16_t delay;
		std::pair<uint8_t, uint8_t> opacities;
		std::pair<int16_t, int16_t> scales;
		Rectangle<int16_t> bounds;
		Point<int16_t> head;
	};

	// Class which consists of multiple textures to make an Animation.
	class Animation
	{
	public:
		Animation(nl::node source);
		Animation();

		bool update();
		bool update(uint16_t timestep);
		void reset();

		void draw(const DrawArgument& arguments, float alpha) const;

		uint16_t get_delay(int16_t frame) const;
		uint16_t getdelayuntil(int16_t frame) const;
		Point<int16_t> get_origin() const;
		Point<int16_t> get_dimensions() const;
		Point<int16_t> get_head() const;
		Rectangle<int16_t> get_bounds() const;

	private:
		const Frame& get_frame() const;

		std::vector<Frame> frames;
		bool animated;
		bool zigzag;

		Nominal<int16_t> frame;
		Linear<float> opacity;
		Linear<float> xyscale;

		uint16_t delay;
		int16_t framestep;
		float opcstep;
	};
}

================
File: Graphics/Color.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Color.h"

#include "../Util/Lerp.h"

namespace ms
{
	const float* Color::data() const
	{
		return rgba.data();
	}

	Color::underlying_t::const_iterator Color::begin() const
	{
		return rgba.begin();
	}

	Color::underlying_t::const_iterator Color::end() const
	{
		return rgba.end();
	}

	Color Color::blend(const Color& other, float alpha) const
	{
		underlying_t blended;

		std::transform(
			begin(),
			end(),
			other.begin(),
			blended.begin(),
			[alpha](float first, float second)
			{
				return lerp(first, second, alpha);
			}
		);

		return blended;
	}
}

================
File: Graphics/Color.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#define GLEW_STATIC
#include <glew.h>

#include <array>

namespace ms
{
	// Simple color class which stores RGBA components
	class Color
	{
	public:
		static constexpr size_t LENGTH = 4;
		using underlying_t = std::array<float, LENGTH>;

		// Codes of predefined colors
		enum Code : uint32_t
		{
			CNONE = 0x00000000,
			CWHITE = 0xFFFFFFFF,
			CBLACK = 0x000000FF,
			CRED = 0xFF0000FF,
			CGREEN = 0x00FF00FF,
			CBLUE = 0x0000FFFF,
			CYELLOW = 0xFFFF00FF,
			CTURQUOISE = 0x00FFFFFF,
			CPURPLE = 0xFF00FFFF
		};

		// Name of predefined colors
		enum Name : uint32_t
		{
			BLACK,
			WHITE,
			YELLOW,
			BLUE,
			RED,
			DARKRED,
			BROWN,
			JAMBALAYA,
			LIGHTGREY,
			DARKGREY,
			ORANGE,
			MEDIUMBLUE,
			VIOLET,
			TOBACCOBROWN,
			EAGLE,
			LEMONGRASS,
			TUNA,
			GALLERY,
			DUSTYGRAY,
			EMPEROR,
			MINESHAFT,
			HALFANDHALF,
			ENDEAVOUR,
			BROWNDERBY,
			PORCELAIN,
			IRISHCOFFEE,
			BOULDER,
			GREEN,
			LIGHTGREEN,
			JAPANESELAUREL,
			GRAYOLIVE,
			ELECTRICLIME,
			SUPERNOVA,
			CHARTREUSE,
			MALIBU,
			SILVERCHALICE,
			GRAY,
			TORCHRED,
			CREAM,
			PERSIANGREEN,
			SILVER,
			NUM_COLORS
		};

		// Predefined colors by name
		static constexpr GLfloat colors[Name::NUM_COLORS][3] =
		{
			{ 0.00f, 0.00f, 0.00f }, // Black
			{ 1.00f, 1.00f, 1.00f }, // White
			{ 1.00f, 1.00f, 0.00f }, // Yellow
			{ 0.00f, 0.00f, 1.00f }, // Blue
			{ 1.00f, 0.00f, 0.00f }, // Red
			{ 0.80f, 0.30f, 0.30f }, // DarkRed
			{ 0.50f, 0.25f, 0.00f }, // Brown
			{ 0.34f, 0.20f, 0.07f }, // Jambalaya
			{ 0.50f, 0.50f, 0.50f }, // Lightgrey
			{ 0.25f, 0.25f, 0.25f }, // Darkgrey
			{ 1.00f, 0.50f, 0.00f }, // Orange
			{ 0.00f, 0.75f, 1.00f }, // Mediumblue
			{ 0.50f, 0.00f, 0.50f }, // Violet
			{ 0.47f, 0.40f, 0.27f }, // Tobacco Brown
			{ 0.74f, 0.74f, 0.67f }, // Eagle
			{ 0.60f, 0.60f, 0.54f }, // Lemon Grass
			{ 0.20f, 0.20f, 0.27f }, // Tuna
			{ 0.94f, 0.94f, 0.94f }, // Gallery
			{ 0.60f, 0.60f, 0.60f }, // Dusty Gray
			{ 0.34f, 0.34f, 0.34f }, // Emperor
			{ 0.20f, 0.20f, 0.20f }, // Mine Shaft
			{ 1.00f, 1.00f, 0.87f }, // Half and Half
			{ 0.00f, 0.40f, 0.67f }, // Endeavour
			{ 0.30f, 0.20f, 0.10f }, // Brown Derby
			{ 0.94f, 0.95f, 0.95f }, // Porcelain
			{ 0.34f, 0.27f, 0.14f }, // Irish Coffee
			{ 0.47f, 0.47f, 0.47f }, // Boulder
			{ 0.00f, 0.75f, 0.00f }, // Green (Mob HP Bar)
			{ 0.00f, 1.00f, 0.00f }, // Light Green (Mob HP Bar)
			{ 0.00f, 0.50f, 0.00f }, // Japanese Laurel (Mob HP Bar)
			{ 0.67f, 0.67f, 0.60f }, // Gray Olive
			{ 0.80f, 1.00f, 0.00f }, // Electric Lime
			{ 1.00f, 0.80f, 0.00f }, // Supernova
			{ 0.47f, 1.00f, 0.00f }, // Chartreuse
			{ 0.47f, 0.80f, 1.00f }, // Malibu
			{ 0.67f, 0.67f, 0.67f }, // Silver Chalice
			{ 0.54f, 0.54f, 0.54f }, // Gray
			{ 0.94f, 0.00f, 0.20f }, // Torch Red
			{ 1.00f, 1.00f, 0.80f }, // Cream
			{ 0.00f, 0.67f, 0.67f }, // Persian Green
			{ 0.80f, 0.80f, 0.80f }  // Silver
		};

		// Create a color by an array of real numbers [0.0f, 1.0f]
		constexpr Color(underlying_t comps) : rgba(comps) {}
		// Create a color by real numbers [0.0f, 1.0f]
		constexpr Color(float red, float green, float blue, float alpha) : Color(underlying_t{ red, green, blue, alpha }) {}
		// Create a color by an array of natural numbers [0, 255]
		constexpr Color(const std::array<uint8_t, Color::LENGTH> comps) : Color(comps[0], comps[1], comps[2], comps[3]) {}

		// Create a color by natural numbers [0, 255]
		constexpr Color(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha) : Color(
			static_cast<float>(red) / 255,
			static_cast<float>(green) / 255,
			static_cast<float>(blue) / 255,
			static_cast<float>(alpha) / 255
		) {}

		// Create a color by code
		constexpr Color(uint32_t code) : Color(
			static_cast<uint8_t>(code >> 24),
			static_cast<uint8_t>(code >> 16),
			static_cast<uint8_t>(code >> 8),
			static_cast<uint8_t>(code)
		) {}

		// Create a color by named code
		constexpr Color(Code code) : Color((uint32_t)code) {}
		constexpr Color() : Color(Code::CNONE) {}

		// Check whether the color is completely invisible
		constexpr bool invisible() const
		{
			return rgba[3] <= 0.0f;
		}

		// Return the red component
		constexpr float r() const
		{
			return rgba[0];
		}

		// Return the green component
		constexpr float g() const
		{
			return rgba[1];
		}

		// Return the blue component
		constexpr float b() const
		{
			return rgba[2];
		}

		// Return the alpha (opacity) component
		constexpr float a() const
		{
			return rgba[3];
		}

		// Return all components
		const float* data() const;

		// Return a begin iterator
		underlying_t::const_iterator begin() const;

		// Return an end iterator
		underlying_t::const_iterator end() const;

		// Blend the second color into the first
		Color blend(const Color& other, float alpha) const;

		// Combine two colors
		constexpr Color operator*(const Color& o) const
		{
			return Color(
				r() * o.r(),
				g() * o.g(),
				b() * o.b(),
				a() * o.a()
			);
		}

		// Combine two colors
		constexpr Color operator/(const Color& o) const
		{
			return Color(
				r() / o.r(),
				g() / o.g(),
				b() / o.b(),
				a() / o.a()
			);
		}

	private:
		underlying_t rgba;
	};
}

================
File: Graphics/DrawArgument.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Color.h"

#include "../Template/Rectangle.h"

namespace ms
{
	class DrawArgument
	{
	public:
		constexpr DrawArgument() : DrawArgument(0, 0) {}
		constexpr DrawArgument(int16_t x, int16_t y) : DrawArgument(Point<int16_t>(x, y)) {}
		constexpr DrawArgument(Point<int16_t> position) : DrawArgument(position, 1.0f) {}
		constexpr DrawArgument(Point<int16_t> position, float xscale, float yscale) : DrawArgument(position, position, xscale, yscale, 1.0f) {}
		constexpr DrawArgument(Point<int16_t> position, Point<int16_t> stretch) : DrawArgument(position, position, stretch, 1.0f, 1.0f, 1.0f, 0.0f) {}
		constexpr DrawArgument(Point<int16_t> position, bool flip) : DrawArgument(position, flip, 1.0f) {}
		constexpr DrawArgument(float angle, Point<int16_t> position, float opacity) : DrawArgument(angle, position, false, opacity) {}
		constexpr DrawArgument(Point<int16_t> position, float opacity) : DrawArgument(position, false, opacity) {}
		constexpr DrawArgument(Point<int16_t> position, Color color) : DrawArgument(position, position, Point<int16_t>(0, 0), 1.0f, 1.0f, color, 0.0f) {}
		constexpr DrawArgument(Point<int16_t> position, bool flip, Point<int16_t> center) : DrawArgument(position, center, flip ? -1.0f : 1.0f, 1.0f, 1.0f) {}
		constexpr DrawArgument(Point<int16_t> position, Point<int16_t> center, float xscale, float yscale, float opacity) : DrawArgument(position, center, Point<int16_t>(0, 0), xscale, yscale, opacity, 0.0f) {}
		constexpr DrawArgument(bool flip) : DrawArgument(flip ? -1.0f : 1.0f, 1.0f, 1.0f) {}
		constexpr DrawArgument(float xscale, float yscale, float opacity) : DrawArgument(Point<int16_t>(0, 0), xscale, yscale, opacity) {}
		constexpr DrawArgument(Point<int16_t> position, float xscale, float yscale, float opacity) : DrawArgument(position, position, xscale, yscale, opacity) {}
		constexpr DrawArgument(Point<int16_t> position, bool flip, float opacity) : DrawArgument(position, position, flip ? -1.0f : 1.0f, 1.0f, opacity) {}
		constexpr DrawArgument(float angle, Point<int16_t> position, bool flip, float opacity) : DrawArgument(position, position, Point<int16_t>(0, 0), flip ? -1.0f : 1.0f, 1.0f, opacity, angle) {}
		constexpr DrawArgument(Point<int16_t> position, Point<int16_t> center, Point<int16_t> stretch, float xscale, float yscale, float opacity, float angle) : pos(position), center(center), stretch(stretch), xscale(xscale), yscale(yscale), color(1.0f, 1.0f, 1.0f, opacity), angle(angle) {}
		constexpr DrawArgument(Point<int16_t> position, Point<int16_t> center, Point<int16_t> stretch, float xscale, float yscale, Color color, float angle) : pos(position), center(center), stretch(stretch), xscale(xscale), yscale(yscale), color(color), angle(angle) {}

		constexpr Point<int16_t> getpos() const
		{
			return pos;
		}

		constexpr Point<int16_t> getstretch() const
		{
			return stretch;
		}

		constexpr float get_xscale() const
		{
			return xscale;
		}

		constexpr float get_yscale() const
		{
			return yscale;
		}

		constexpr const Color& get_color() const
		{
			return color;
		}

		constexpr float get_angle() const
		{
			return angle;
		}

		constexpr DrawArgument operator + (Point<int16_t> argpos) const
		{
			return {
				pos + argpos,
				center + argpos,
				stretch, xscale, yscale, color, angle
			};
		}

		constexpr DrawArgument operator + (float argopc) const
		{
			return {
				pos, center, stretch, xscale, yscale,
				color.a() * argopc,
				angle
			};
		}

		constexpr DrawArgument operator + (const DrawArgument& o) const
		{
			return {
				pos + o.pos,
				center + o.center,
				stretch + o.stretch,
				xscale * o.xscale,
				yscale * o.yscale,
				color * o.color,
				angle + o.angle
			};
		}

		constexpr DrawArgument operator - (const DrawArgument& o) const
		{
			return {
				pos - o.pos,
				center - o.center,
				stretch - o.stretch,
				xscale / o.xscale,
				yscale / o.yscale,
				color / o.color,
				angle - o.angle
			};
		}

		Rectangle<int16_t> get_rectangle(Point<int16_t> origin, Point<int16_t> dimensions) const
		{
			int16_t w = stretch.x();

			if (w == 0)
				w = dimensions.x();

			int16_t h = stretch.y();

			if (h == 0)
				h = dimensions.y();

			Point<int16_t> rlt = pos - center - origin;
			int16_t rl = rlt.x();
			int16_t rr = rlt.x() + w;
			int16_t rt = rlt.y();
			int16_t rb = rlt.y() + h;
			int16_t cx = center.x();
			int16_t cy = center.y();

			return {
				cx + static_cast<int16_t>(xscale * rl),
				cx + static_cast<int16_t>(xscale * rr),
				cy + static_cast<int16_t>(yscale * rt),
				cy + static_cast<int16_t>(yscale * rb)
			};
		}

	private:
		Point<int16_t> pos;
		Point<int16_t> center;
		Point<int16_t> stretch;
		float xscale;
		float yscale;
		float angle;
		Color color;
	};
}

================
File: Graphics/EffectLayer.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "EffectLayer.h"

namespace ms
{
	void EffectLayer::drawbelow(Point<int16_t> position, float alpha) const
	{
		for (auto iter = effects.begin(); iter != effects.upper_bound(-1); ++iter)
			for (auto& effect : iter->second)
				effect.draw(position, alpha);
	}

	void EffectLayer::drawabove(Point<int16_t> position, float alpha) const
	{
		for (auto iter = effects.upper_bound(-1); iter != effects.end(); ++iter)
			for (auto& effect : iter->second)
				effect.draw(position, alpha);
	}

	void EffectLayer::update()
	{
		for (auto& effectlist : effects)
		{
			effectlist.second.remove_if(
				[](Effect& effect)
				{
					return effect.update();
				}
			);
		}
	}

	void EffectLayer::add(const Animation& animation, const DrawArgument& args, int8_t z, float speed)
	{
		effects[z].emplace_back(animation, args, speed);
	}

	void EffectLayer::add(const Animation& animation, const DrawArgument& args, int8_t z)
	{
		add(animation, args, z, 1.0f);
	}

	void EffectLayer::add(const Animation& animation, const DrawArgument& args)
	{
		add(animation, args, 0, 1.0f);
	}

	void EffectLayer::add(const Animation& animation)
	{
		add(animation, {}, 0, 1.0f);
	}
}

================
File: Graphics/EffectLayer.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Sprite.h"

#include "../Constants.h"

#include <map>
#include <list>

namespace ms
{
	// A list of animations. Animations will be removed after all frames were displayed.
	class EffectLayer
	{
	public:
		void drawbelow(Point<int16_t> position, float alpha) const;
		void drawabove(Point<int16_t> position, float alpha) const;
		void update();
		void add(const Animation& effect, const DrawArgument& args, int8_t z, float speed);
		void add(const Animation& effect, const DrawArgument& args, int8_t z);
		void add(const Animation& effect, const DrawArgument& args);
		void add(const Animation& effect);

	private:
		class Effect
		{
		public:
			Effect(const Animation& a, const DrawArgument& args, float s) : sprite(a, args), speed(s) {}

			void draw(Point<int16_t> position, float alpha) const
			{
				sprite.draw(position, alpha);
			}

			bool update()
			{
				return sprite.update(
					static_cast<uint16_t>(Constants::TIMESTEP * speed)
				);
			}

		private:
			Sprite sprite;
			float speed;
		};

		std::map<int8_t, std::list<Effect>> effects;
	};
}

================
File: Graphics/Geometry.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Geometry.h"

namespace ms
{
	void Geometry::draw(int16_t x, int16_t y, int16_t w, int16_t h, Color::Name cid, float opacity) const
	{
		if (w == 0 || h == 0 || opacity <= 0.0f)
			return;

		const float* color = Color::colors[cid];

		GraphicsGL::get().drawrectangle(x, y, w, h, color[0], color[1], color[2], opacity);
	}

	ColorBox::ColorBox(int16_t w, int16_t h, Color::Name c, float o) : width(w), height(h), color(c), opacity(o) {}
	ColorBox::ColorBox() : ColorBox(0, 0, Color::Name::BLACK, 0.0f) {}

	void ColorBox::setwidth(int16_t w)
	{
		width = w;
	}

	void ColorBox::setheight(int16_t h)
	{
		height = h;
	}

	void ColorBox::set_color(Color::Name c)
	{
		color = c;
	}

	void ColorBox::setopacity(float o)
	{
		opacity = o;
	}

	void ColorBox::draw(const DrawArgument& args) const
	{
		Point<int16_t> absp = args.getpos();
		int16_t absw = args.getstretch().x();

		if (absw == 0)
			absw = width;

		int16_t absh = args.getstretch().y();

		if (absh == 0)
			absh = height;

		absw = static_cast<int16_t>(absw * args.get_xscale());
		absh = static_cast<int16_t>(absh * args.get_yscale());

		float absopc = opacity * args.get_color().a();

		Geometry::draw(absp.x(), absp.y(), absw, absh, color, absopc);
	}

	ColorLine::ColorLine(int16_t size, Color::Name color, float opacity, bool vertical) : size(size), color(color), opacity(opacity), vertical(vertical) {}
	ColorLine::ColorLine() : ColorLine(0, Color::Name::BLACK, 0.0f, false) {}

	void ColorLine::setsize(int16_t s)
	{
		size = s;
	}

	void ColorLine::setcolor(Color::Name c)
	{
		color = c;
	}

	void ColorLine::setopacity(float o)
	{
		opacity = o;
	}

	void ColorLine::draw(const DrawArgument& args) const
	{
		Point<int16_t> absp = args.getpos();

		int16_t absw = args.getstretch().x();
		int16_t absh = args.getstretch().y();

		if (absw == 0)
			absw = vertical ? 1 : size;

		if (absh == 0)
			absh = vertical ? size : 1;

		absw = static_cast<int16_t>(absw * args.get_xscale());
		absh = static_cast<int16_t>(absh * args.get_yscale());

		float absopc = opacity * args.get_color().a();

		Geometry::draw(absp.x(), absp.y(), absw, absh, color, absopc);
	}

	void MobHpBar::draw(Point<int16_t> position, int16_t hppercent) const
	{
		int16_t fillw = static_cast<int16_t>((WIDTH - 6) * static_cast<float>(hppercent) / 100);
		int16_t x = position.x() - WIDTH / 2;
		int16_t y = position.y() - HEIGHT * 3;

		Geometry::draw(x, y, WIDTH, HEIGHT, Color::Name::BLACK, 1.0f);
		Geometry::draw(x + 1, y + 1, WIDTH - 2, 1, Color::Name::WHITE, 1.0f);
		Geometry::draw(x + 1, y + HEIGHT - 2, WIDTH - 2, 1, Color::Name::WHITE, 1.0f);
		Geometry::draw(x + 1, y + 2, 1, HEIGHT - 4, Color::Name::WHITE, 1.0f);
		Geometry::draw(x + WIDTH - 2, y + 2, 1, HEIGHT - 4, Color::Name::WHITE, 1.0f);
		Geometry::draw(x + 3, y + 3, fillw, 3, Color::Name::LIGHTGREEN, 1.0f);
		Geometry::draw(x + 3, y + 6, fillw, 1, Color::Name::JAPANESELAUREL, 1.0f);
	}
}

================
File: Graphics/Geometry.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "DrawArgument.h"
#include "GraphicsGL.h"

namespace ms
{
	class Geometry
	{
	public:
		virtual ~Geometry() {}

	protected:
		void draw(int16_t x, int16_t y, int16_t w, int16_t h, Color::Name color, float opacity) const;
	};

	class ColorBox : public Geometry
	{
	public:
		ColorBox(int16_t width, int16_t height, Color::Name color, float opacity);
		ColorBox();

		void setwidth(int16_t width);
		void setheight(int16_t height);
		void set_color(Color::Name color);
		void setopacity(float opacity);

		void draw(const DrawArgument& args) const;

	private:
		int16_t width;
		int16_t height;
		Color::Name color;
		float opacity;
	};

	class ColorLine : public Geometry
	{
	public:
		ColorLine(int16_t size, Color::Name color, float opacity, bool vertical);
		ColorLine();

		void setsize(int16_t size);
		void setcolor(Color::Name color);
		void setopacity(float opacity);

		void draw(const DrawArgument& args) const;

	private:
		int16_t size;
		Color::Name color;
		float opacity;
		bool vertical;
	};

	class MobHpBar : public Geometry
	{
	public:
		void draw(Point<int16_t> position, int16_t hppercent) const;

	private:
		static const int16_t WIDTH = 50;
		static const int16_t HEIGHT = 10;
	};
}

================
File: Graphics/GraphicsGL.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "GraphicsGL.h"

#include "../Configuration.h"
#include "../Util/Misc.h"
#include <algorithm>

namespace ms
{
	GraphicsGL::GraphicsGL()
	{
		locked = false;

		VWIDTH = Constants::Constants::get().get_viewwidth();
		VHEIGHT = Constants::Constants::get().get_viewheight();
		SCREEN = Rectangle<int16_t>(0, VWIDTH, 0, VHEIGHT);

		// Initialize camera
		camera_x = 0;
		camera_y = 0;
		debug_mode = false;
	}

	Error GraphicsGL::init()
	{
		// Setup parameters
		// ----------------
		const char* vertexShaderSource =
			"#version 120\n"
			"attribute vec4 coord;"
			"attribute vec4 color;"
			"varying vec2 texpos;"
			"varying vec4 colormod;"
			"uniform vec2 screensize;"
			"uniform int yoffset;"

			"void main(void)"
			"{"
			"	float x = -1.0 + coord.x * 2.0 / screensize.x;"
			"	float y = 1.0 - (coord.y + yoffset) * 2.0 / screensize.y;"
			"   gl_Position = vec4(x, y, 0.0, 1.0);"
			"	texpos = coord.zw;"
			"	colormod = color;"
			"}";

		const char* fragmentShaderSource =
			"#version 120\n"
			"varying vec2 texpos;"
			"varying vec4 colormod;"
			"uniform sampler2D texture;"
			"uniform vec2 atlassize;"
			"uniform int fontregion;"

			"void main(void)"
			"{"
			"	if (texpos.y == 0)"
			"	{"
			"		gl_FragColor = colormod;"
			"	}"
			"	else if (texpos.y <= fontregion)"
			"	{"
			"		gl_FragColor = vec4(1, 1, 1, texture2D(texture, texpos / atlassize).r) * colormod;"
			"	}"
			"	else"
			"	{"
			"		gl_FragColor = texture2D(texture, texpos / atlassize) * colormod;"
			"	}"
			"}";

		const GLsizei bufSize = 512;

		GLint success;
		GLchar infoLog[bufSize];

		// Initialize and configure
		// ------------------------
		if (GLenum error = glewInit())
			return Error(Error::Code::GLEW, (const char*)glewGetErrorString(error));

		LOG(LOG_INFO, "Using OpenGL " << glGetString(GL_VERSION));
		LOG(LOG_INFO, "Using GLEW " << glewGetString(GLEW_VERSION));

		if (FT_Init_FreeType(&ftlibrary))
			return Error::Code::FREETYPE;

		FT_Int ftmajor;
		FT_Int ftminor;
		FT_Int ftpatch;

		FT_Library_Version(ftlibrary, &ftmajor, &ftminor, &ftpatch);

		LOG(LOG_INFO, "Using FreeType " << ftmajor << "." << ftminor << "." << ftpatch);

		// Build and compile our shader program
		// ------------------------------------

		// Vertex Shader
		GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
		glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
		glCompileShader(vertexShader);

		// Check for shader compile errors
		glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);

		if (success != GL_TRUE)
		{
			glGetShaderInfoLog(vertexShader, bufSize, NULL, infoLog);

			return Error(Error::Code::VERTEX_SHADER, infoLog);
		}

		// Fragment Shader
		GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
		glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
		glCompileShader(fragmentShader);

		// Check for shader compile errors
		glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);

		if (success != GL_TRUE)
		{
			glGetShaderInfoLog(fragmentShader, bufSize, NULL, infoLog);

			return Error(Error::Code::FRAGMENT_SHADER, infoLog);
		}

		// Link Shaders
		shaderProgram = glCreateProgram();
		glAttachShader(shaderProgram, vertexShader);
		glAttachShader(shaderProgram, fragmentShader);
		glLinkProgram(shaderProgram);

		// Check for linking errors
		glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);

		if (success != GL_TRUE)
		{
			glGetProgramInfoLog(shaderProgram, bufSize, NULL, infoLog);

			return Error(Error::Code::SHADER_PROGRAM_LINK, infoLog);
		}

		// Validate Program
		glValidateProgram(shaderProgram);

		// Check for validation errors
		glGetProgramiv(shaderProgram, GL_VALIDATE_STATUS, &success);

		if (success != GL_TRUE)
		{
			glGetProgramInfoLog(shaderProgram, bufSize, NULL, infoLog);

			return Error(Error::Code::SHADER_PROGRAM_VALID, infoLog);
		}

		glDeleteShader(vertexShader);
		glDeleteShader(fragmentShader);

		attribute_coord = glGetAttribLocation(shaderProgram, "coord");
		attribute_color = glGetAttribLocation(shaderProgram, "color");
		uniform_texture = glGetUniformLocation(shaderProgram, "texture");
		uniform_atlassize = glGetUniformLocation(shaderProgram, "atlassize");
		uniform_screensize = glGetUniformLocation(shaderProgram, "screensize");
		uniform_yoffset = glGetUniformLocation(shaderProgram, "yoffset");
		uniform_fontregion = glGetUniformLocation(shaderProgram, "fontregion");

		if (attribute_coord == -1 || attribute_color == -1 || uniform_texture == -1 || uniform_atlassize == -1 || uniform_screensize == -1 || uniform_yoffset == -1)
			return Error::Code::SHADER_VARS;

		// Vertex Buffer Object
		glGenBuffers(1, &VBO);

		glGenTextures(1, &atlas);
		glBindTexture(GL_TEXTURE_2D, atlas);
		glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, ATLASW, ATLASH, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);

		fontborder.set_y(1);

		const std::string FONT_NORMAL = Setting<FontPathNormal>().get().load();
		const std::string FONT_BOLD = Setting<FontPathBold>().get().load();

		if (FONT_NORMAL.empty() || FONT_BOLD.empty())
			return Error::Code::FONT_PATH;

		const char* FONT_NORMAL_STR = FONT_NORMAL.c_str();
		const char* FONT_BOLD_STR = FONT_BOLD.c_str();

		addfont(FONT_NORMAL_STR, Text::Font::A11M, 0, 11);
		addfont(FONT_BOLD_STR, Text::Font::A11B, 0, 11);
		addfont(FONT_NORMAL_STR, Text::Font::A12M, 0, 12);
		addfont(FONT_BOLD_STR, Text::Font::A12B, 0, 12);
		addfont(FONT_NORMAL_STR, Text::Font::A13M, 0, 13);
		addfont(FONT_BOLD_STR, Text::Font::A13B, 0, 13);
		addfont(FONT_NORMAL_STR, Text::Font::A14M, 0, 14);
		addfont(FONT_BOLD_STR, Text::Font::A14B, 0, 14);
		addfont(FONT_NORMAL_STR, Text::Font::A15M, 0, 15);
		addfont(FONT_BOLD_STR, Text::Font::A15B, 0, 15);
		addfont(FONT_NORMAL_STR, Text::Font::A18M, 0, 18);
		addfont(FONT_BOLD_STR, Text::Font::A18B, 0, 18);

		fontymax += fontborder.y();

		leftovers = QuadTree<size_t, Leftover>(
			[](const Leftover& first, const Leftover& second)
			{
				bool width_comparison = first.width() >= second.width();
				bool height_comparison = first.height() >= second.height();

				if (width_comparison && height_comparison)
					return QuadTree<size_t, Leftover>::Direction::RIGHT;
				else if (width_comparison)
					return QuadTree<size_t, Leftover>::Direction::DOWN;
				else if (height_comparison)
					return QuadTree<size_t, Leftover>::Direction::UP;
				else
					return QuadTree<size_t, Leftover>::Direction::LEFT;
			}
		);

		return Error::Code::NONE;
	}

	bool GraphicsGL::addfont(const char* name, Text::Font id, FT_UInt pixelw, FT_UInt pixelh)
	{
		FT_Face face;

		if (FT_New_Face(ftlibrary, name, 0, &face))
			return false;

		if (FT_Set_Pixel_Sizes(face, pixelw, pixelh))
			return false;

		FT_GlyphSlot g = face->glyph;

		GLshort width = 0;
		GLshort height = 0;

		for (uint8_t c = 32; c < 128; c++)
		{
			if (FT_Load_Char(face, c, FT_LOAD_RENDER))
				continue;

			GLshort w = static_cast<GLshort>(g->bitmap.width);
			GLshort h = static_cast<GLshort>(g->bitmap.rows);

			width += w;

			if (h > height)
				height = h;
		}

		if (fontborder.x() + width > ATLASW)
		{
			fontborder.set_x(0);
			fontborder.set_y(fontymax);
			fontymax = 0;
		}

		GLshort x = fontborder.x();
		GLshort y = fontborder.y();

		fontborder.shift_x(width);

		if (height > fontymax)
			fontymax = height;

		fonts[id] = Font(width, height);

		GLshort ox = x;
		GLshort oy = y;

		for (uint8_t c = 32; c < 128; c++)
		{
			if (FT_Load_Char(face, c, FT_LOAD_RENDER))
				continue;

			GLshort ax = static_cast<GLshort>(g->advance.x >> 6);
			GLshort ay = static_cast<GLshort>(g->advance.y >> 6);
			GLshort l = static_cast<GLshort>(g->bitmap_left);
			GLshort t = static_cast<GLshort>(g->bitmap_top);
			GLshort w = static_cast<GLshort>(g->bitmap.width);
			GLshort h = static_cast<GLshort>(g->bitmap.rows);

			glTexSubImage2D(GL_TEXTURE_2D, 0, ox, oy, w, h, GL_RED, GL_UNSIGNED_BYTE, g->bitmap.buffer);

			Offset offset = Offset(ox, oy, w, h);
			fonts[id].chars[c] = { ax, ay, w, h, l, t, offset };

			ox += w;
		}

		return true;
	}

	void GraphicsGL::reinit()
	{
		int32_t new_width = Constants::Constants::get().get_viewwidth();
		int32_t new_height = Constants::Constants::get().get_viewheight();

		if (VWIDTH != new_width || VHEIGHT != new_height)
		{
			VWIDTH = new_width;
			VHEIGHT = new_height;
			SCREEN = Rectangle<int16_t>(0, VWIDTH, 0, VHEIGHT);
		}

		glUseProgram(shaderProgram);

		glUniform1i(uniform_fontregion, fontymax);
		glUniform2f(uniform_atlassize, ATLASW, ATLASH);
		glUniform2f(uniform_screensize, VWIDTH, VHEIGHT);

		glBindBuffer(GL_ARRAY_BUFFER, VBO);
		glVertexAttribPointer(attribute_coord, 4, GL_SHORT, GL_FALSE, sizeof(Quad::Vertex), 0);
		glVertexAttribPointer(attribute_color, 4, GL_FLOAT, GL_FALSE, sizeof(Quad::Vertex), (const void*)8);

		glEnable(GL_BLEND);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

		glBindTexture(GL_TEXTURE_2D, atlas);
		glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

		clearinternal();
	}

	void GraphicsGL::clearinternal()
	{
		border = Point<GLshort>(0, fontymax + 1); // Start textures below font region to avoid shader conflict
		GDEBUG("Atlas cleared: border set to (0," << (fontymax + 1) << ") fontregion=" << fontymax);
		yrange = Range<GLshort>();

		offsets.clear();
		leftovers.clear();
		rlid = 1;
		wasted = 0;
	}

	void GraphicsGL::clear()
	{
		size_t used = ATLASW * border.y() + border.x() * yrange.second();
		double usedpercent = static_cast<double>(used) / (ATLASW * ATLASH);

		if (usedpercent > 80.0)
			clearinternal();
	}

	void GraphicsGL::addbitmap(const nl::bitmap& bmp)
	{
		getoffset(bmp);
	}

	const GraphicsGL::Offset& GraphicsGL::getoffset(const nl::bitmap& bmp)
	{
		size_t id = bmp.id();
		GLshort width = bmp.width();
		GLshort height = bmp.height();
		auto offiter = offsets.find(id);

		if (offiter != offsets.end()) {
			if (width > 300 || height > 300) {
				GDEBUG("CACHED: " << width << "x" << height << " using cached atlas position");
			}
			return offiter->second;
		}

		GLshort x = 0;
		GLshort y = 0;

		if (width <= 0 || height <= 0)
			return nulloffset;

		Leftover value = Leftover(x, y, width, height);

		size_t lid = leftovers.findnode(
			value,
			[](const Leftover& val, const Leftover& leaf)
			{
				return val.width() <= leaf.width() && val.height() <= leaf.height();
			}
		);

		if (lid > 0)
		{
			const Leftover& leftover = leftovers[lid];

			x = leftover.left;
			y = leftover.top;

			GLshort width_delta = leftover.width() - width;
			GLshort height_delta = leftover.height() - height;

			leftovers.erase(lid);

			wasted -= width * height;

			if (width_delta >= MINLOSIZE && height_delta >= MINLOSIZE)
			{
				leftovers.add(rlid, Leftover(x + width, y + height, width_delta, height_delta));
				rlid++;

				if (width >= MINLOSIZE)
				{
					leftovers.add(rlid, Leftover(x, y + height, width, height_delta));
					rlid++;
				}

				if (height >= MINLOSIZE)
				{
					leftovers.add(rlid, Leftover(x + width, y, width_delta, height));
					rlid++;
				}
			}
			else if (width_delta >= MINLOSIZE)
			{
				leftovers.add(rlid, Leftover(x + width, y, width_delta, height + height_delta));
				rlid++;
			}
			else if (height_delta >= MINLOSIZE)
			{
				leftovers.add(rlid, Leftover(x, y + height, width + width_delta, height_delta));
				rlid++;
			}
		}
		else
		{
			if (border.x() + width > ATLASW)
			{
				border.set_x(0);
				border.shift_y(yrange.second());

				if (border.y() + height > ATLASH)
					clearinternal();
				else
					yrange = Range<GLshort>();
			}

			x = border.x();
			y = border.y();

			border.shift_x(width);

			if (height > yrange.second())
			{
				if (x >= MINLOSIZE && height - yrange.second() >= MINLOSIZE)
				{
					leftovers.add(rlid, Leftover(0, yrange.first(), x, height - yrange.second()));
					rlid++;
				}

				wasted += x * (height - yrange.second());

				yrange = Range<int16_t>(y + height, height);
			}
			else if (height < yrange.first() - y)
			{
				if (width >= MINLOSIZE && yrange.first() - y - height >= MINLOSIZE)
				{
					leftovers.add(rlid, Leftover(x, y + height, width, yrange.first() - y - height));
					rlid++;
				}

				wasted += width * (yrange.first() - y - height);
			}
		}

#if LOG_LEVEL >= LOG_TRACE
		size_t used = ATLASW * border.y() + border.x() * yrange.second();

		double usedpercent = static_cast<double>(used) / (ATLASW * ATLASH);
		double wastedpercent = static_cast<double>(wasted) / used;

		LOG(LOG_TRACE, "Used: [" << usedpercent << "] Wasted: [" << wastedpercent << "]");
#endif

		// Debug large texture uploads
		if (width > 300 || height > 300) {
			const char* data_ptr = reinterpret_cast<const char*>(bmp.data());
			uint32_t checksum = 0;
			if (data_ptr) {
				// Simple checksum of first 16 pixels (64 bytes)
				for (int i = 0; i < 64 && i < width * height * 4; i++) {
					checksum += data_ptr[i];
				}
			}
			GDEBUG("UPLOAD: " << width << "x" << height << " to atlas (" << x << "," << y << ") fontregion=" << fontymax << " data=" << (bmp.data() ? "valid" : "null") << " checksum=" << checksum);
		}
		
		glTexSubImage2D(GL_TEXTURE_2D, 0, x, y, width, height, GL_BGRA, GL_UNSIGNED_BYTE, bmp.data());
		
		// Check for OpenGL errors after upload
		if (width > 300 || height > 300) {
			GLenum error = glGetError();
			if (error != GL_NO_ERROR) {
				GDEBUG("OpenGL ERROR after upload: " << error);
			}
		}

		return offsets.emplace(
			std::piecewise_construct,
			std::forward_as_tuple(id),
			std::forward_as_tuple(x, y, width, height)
		).first->second;
	}

	void GraphicsGL::draw(const nl::bitmap& bmp, const Rectangle<int16_t>& rect, const Range<int16_t>& vertical, const Range<int16_t>& horizontal, const Color& color, float angle)
	{
		// Only debug large textures (likely backgrounds)
		if (rect.width() > 300 || rect.height() > 300) {
			GDEBUG("LARGE texture: " << rect.width() << "x" << rect.height() << " at (" << rect.left() << "," << rect.top() << ") alpha=" << color.a());
		}
		
		if (locked)
			return;

		if (color.invisible()) {
			if (rect.width() > 300 || rect.height() > 300) {
				GDEBUG("LARGE texture INVISIBLE - alpha=" << color.a());
			}
			return;
		}

		if (!rect.overlaps(SCREEN))
			return;

		Offset offset = getoffset(bmp);

		// Debug atlas placement for all textures
		if (rect.width() > 300 || rect.height() > 300) {
			GDEBUG("LARGE: " << rect.width() << "x" << rect.height() << " at atlas (" << offset.left << "," << offset.top << ")-(" << offset.right << "," << offset.bottom << ") fontregion=" << fontymax);
			
			// In debug mode, draw red rectangles instead of textures
			if (debug_mode) {
				drawrectangle(rect.left() + camera_x, rect.top() + camera_y, rect.width(), rect.height(), 1.0f, 0.0f, 0.0f, 1.0f);
				return;
			}
		} else if (rect.width() > 20) { // Log medium-sized textures too
			GDEBUG("SMALL: " << rect.width() << "x" << rect.height() << " at atlas (" << offset.left << "," << offset.top << ")-(" << offset.right << "," << offset.bottom << ") fontregion=" << fontymax);
		}

		offset.top += vertical.first();
		offset.bottom -= vertical.second();
		offset.left += horizontal.first();
		offset.right -= horizontal.second();

		quads.emplace_back(
			rect.left() + horizontal.first() + camera_x,
			rect.right() - horizontal.second() + camera_x,
			rect.top() + vertical.first() + camera_y,
			rect.bottom() - vertical.second() + camera_y,
			offset, color, angle
		);
	}

	Text::Layout GraphicsGL::createlayout(const std::string& text, Text::Font id, Text::Alignment alignment, Color::Name color, int16_t maxwidth, bool formatted, int16_t line_adj)
	{
		size_t length = text.length();

		if (length == 0)
			return Text::Layout();

		LayoutBuilder builder(id, fonts[id], alignment, color, maxwidth, formatted, line_adj);

		const char* p_text = text.c_str();

		size_t first = 0;
		size_t offset = 0;

		while (offset < length)
		{
			size_t last = text.find_first_of(" \\#\t", offset + 1);

			if (last == std::string::npos)
				last = length;

			first = builder.add(p_text, first, offset, last);
			offset = last;
		}

		return builder.finish(first, offset);
	}

	GraphicsGL::LayoutBuilder::LayoutBuilder(Text::Font id, const Font& f, Text::Alignment a, Color::Name c, int16_t mw, bool fm, int16_t la) : fontid(id), font(f), alignment(a), color(c), maxwidth(mw), formatted(fm), line_adj(la)
	{
		ax = 0;
		ay = font.linespace();
		width = 0;
		endy = 0;

		if (maxwidth == 0)
			maxwidth = 800;
	}

	size_t GraphicsGL::LayoutBuilder::add(const char* text, size_t prev, size_t first, size_t last)
	{
		if (first == last)
			return prev;

		Text::Font last_font = fontid;
		Color::Name last_color = color;
		size_t skip = 0;
		bool linebreak = false;

		if (formatted)
		{
			size_t next_char = first + 1;
			char c = text[next_char];

			switch (text[first])
			{
				case '\\':
				{
					if (next_char < last)
					{
						switch (c)
						{
							// \r\n - Moves down a line
							case 'rn':
							case 'RN':
							{
								// TODO: How is this treated differently than the single versions?
								skip += 4;
								break;
							}
							// \n - New line
							case 'n':
							case 'N':
							{
								linebreak = true;
								skip += 2;
								break;
							}
							// \r - Return carriage
							case 'r':
							case 'R':
							{
								linebreak = ax > 0;
								skip += 2;
								break;
							}
							// \b - Backwards
							case 'b':
							{
								// TODO: What is this?
								skip += 2;
								break;
							}
							default:
							{
								single_console::log_message("[GraphicsGL::LayoutBuilder::add] Unknown format: [" + std::to_string(c) + "]");
								break;
							}
						}
					}

					break;
				}
				case '#':
				{
					if (next_char < last)
					{
						switch (c)
						{
							// #b - Blue text
							case 'b':
							{
								color = Color::Name::PERSIANGREEN;
								skip += 2;
								break;
							}
							// #B[%]# - Shows a progress bar
							case 'B':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							// #c[id]# - Show how many of a given item are in the player's inventory in an orange color
							case 'c':
							{
								// TODO: Show the number of items
								color = Color::Name::ORANGE;
								skip += 2;
								break;
							}
							// #d - Purple text
							case 'd':
							{
								// TODO: Need to get the proper color
								skip += 2;
								break;
							}
							// #e - Bold text
							case 'e':
							case 'E':
							{
								switch (last_font)
								{
									case Text::Font::A11M:
										fontid = Text::Font::A11B;
										break;
									case Text::Font::A12M:
										fontid = Text::Font::A12B;
										break;
									case Text::Font::A13M:
										fontid = Text::Font::A13B;
										break;
									case Text::Font::A18M:
										fontid = Text::Font::A18B;
										break;
									default:
										single_console::log_message("[GraphicsGL::LayoutBuilder::add] Unknown Text::Font: [" + std::to_string(last_font) + "]");
										break;
								}

								skip += 2;
								break;
							}
							// #f[path]# - Shows an image within the WZ file
							case 'f':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							// #g - Green text
							case 'g':
							{
								// TODO: Need to get the proper color
								skip += 2;
								break;
							}
							// TODO: Is there a space between the h and ending # or not?
							// #h # - Shows the name of the player
							case 'h':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							// #i[id]# - Shows a picture of the given item
							case 'i':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							// #k - Black text
							case 'k':
							{
								color = Color::Name::DARKGREY;
								skip += 2;
								break;
							}
							// #l - Ends the list of items in the selection
							case 'l':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							// #L[number]# - Starts a selection for the number of items given
							case 'L':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							// #m[id]# - Shows the name of the given map
							case 'm':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							// #n - Normal text (Removes bold)
							case 'n':
							case 'N':
							{
								switch (last_font)
								{
									case Text::Font::A11B:
										fontid = Text::Font::A11M;
										break;
									case Text::Font::A12B:
										fontid = Text::Font::A12M;
										break;
									case Text::Font::A13B:
										fontid = Text::Font::A13M;
										break;
									case Text::Font::A18B:
										fontid = Text::Font::A18M;
										break;
									default:
										single_console::log_message("[GraphicsGL::LayoutBuilder::add] Unknown Text::Font: [" + std::to_string(last_font) + "]");
										break;
								}

								skip += 2;
								break;
							}
							// #o[id]# - Shows the name of the given monster
							case 'o':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							// #p[id]# - Shows the name of the given NPC
							case 'p':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							// #q[id]# - Shows the name of the given skill
							case 'q':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							// #r - Red text
							case 'r':
							{
								color = Color::Name::RED;
								skip += 2;
								break;
							}
							// #s[id]# - Shows the image of the given skill
							case 's':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							// #t[id]#
							// #z[id]#
							// Shows the name of the given item
							// TODO: Are these the same?
							case 't':
							case 'z':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							// #v[id]# - Shows a picture of the given item
							case 'v':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							// #x - Returns "0%" (Need more information on this)
							case 'x':
							{
								// TODO: Needs implemented
								skip += 2;
								break;
							}
							default:
							{
								single_console::log_message("[GraphicsGL::LayoutBuilder::add] Unknown format: [" + std::to_string(c) + "]");
								break;
							}
						}
					}

					break;
				}
				// \t - Tab (4 spaces)
				case '\t':
				{
					ax = font.chars[' '].ax * 4;
					skip++;
					break;
				}
			}
		}

		int16_t wordwidth = 0;

		if (!linebreak)
		{
			for (size_t i = first; i < last; i++)
			{
				char c = text[i];

				if (c == '\t')
					wordwidth += ax;
				else
					wordwidth += font.chars[c].ax;

				if (wordwidth > maxwidth)
				{
					if (last - first == 1)
					{
						return last;
					}
					else
					{
						prev = add(text, prev, first, i);
						return add(text, prev, i, last);
					}
				}
			}
		}

		bool newword = skip > 0;
		bool newline = linebreak || ax + wordwidth > maxwidth;

		if (newword || newline)
			add_word(prev, first, last_font, last_color);

		if (newline)
		{
			add_line();

			endy = ay;
			ax = 0;
			ay += font.linespace();

			if (lines.size() > 0)
				ay -= line_adj;
		}

		for (size_t pos = first; pos < last; pos++)
		{
			char c = text[pos];
			const Font::Char& ch = font.chars[c];

			advances.push_back(ax);

			if (pos < first + skip || newline && c == ' ')
				continue;

			ax += ch.ax;

			if (width < ax)
				width = ax;
		}

		if (newword || newline)
			return first + skip;
		else
			return prev;
	}

	Text::Layout GraphicsGL::LayoutBuilder::finish(size_t first, size_t last)
	{
		add_word(first, last, fontid, color);
		add_line();

		advances.push_back(ax);

		return Text::Layout(lines, advances, width, ay, ax, endy);
	}

	void GraphicsGL::LayoutBuilder::add_word(size_t word_first, size_t word_last, Text::Font word_font, Color::Name word_color)
	{
		words.push_back({ word_first, word_last, word_font, word_color });
	}

	void GraphicsGL::LayoutBuilder::add_line()
	{
		int16_t line_x = 0;
		int16_t line_y = ay;

		switch (alignment)
		{
			case Text::Alignment::CENTER:
				line_x -= ax / 2;
				break;
			case Text::Alignment::RIGHT:
				line_x -= ax;
				break;
		}

		lines.push_back({ words, { line_x, line_y } });
		words.clear();
	}

	void GraphicsGL::drawtext(const DrawArgument& args, const Range<int16_t>& vertical, const std::string& text, const Text::Layout& layout, Text::Font id, Color::Name colorid, Text::Background background)
	{
		if (locked)
			return;

		const Color& color = args.get_color();

		if (text.empty() || color.invisible())
			return;

		const Font& font = fonts[id];

		GLshort x = args.getpos().x();
		GLshort y = args.getpos().y();
		GLshort w = layout.width();
		GLshort h = layout.height();
		GLshort minheight = vertical.first() > 0 ? vertical.first() : SCREEN.top();
		GLshort maxheight = vertical.second() > 0 ? vertical.second() : SCREEN.bottom();

		switch (background)
		{
			case Text::Background::NAMETAG:
			{
				// If ever changing code in here confirm placements with map 10000
				for (const Text::Layout::Line& line : layout)
				{
					GLshort left = x + line.position.x() - 1;
					GLshort right = left + w + 3;
					GLshort top = y + line.position.y() - font.linespace() + 6;
					GLshort bottom = top + h - 2;
					Color ntcolor = Color(0.0f, 0.0f, 0.0f, 0.6f);

					quads.emplace_back(left, right, top, bottom, nulloffset, ntcolor, 0.0f);
					quads.emplace_back(left - 1, left, top + 1, bottom - 1, nulloffset, ntcolor, 0.0f);
					quads.emplace_back(right, right + 1, top + 1, bottom - 1, nulloffset, ntcolor, 0.0f);
				}

				break;
			}
		}

		for (const Text::Layout::Line& line : layout)
		{
			Point<int16_t> position = line.position;

			for (const Text::Layout::Word& word : line.words)
			{
				GLshort ax = position.x() + layout.advance(word.first);
				GLshort ay = position.y();

				const GLfloat* wordcolor;

				if (word.color < Color::Name::NUM_COLORS)
					wordcolor = Color::colors[word.color];
				else
					wordcolor = Color::colors[colorid];

				Color abscolor = color * Color(wordcolor[0], wordcolor[1], wordcolor[2], 1.0f);

				for (size_t pos = word.first; pos < word.last; ++pos)
				{
					const char c = text[pos];
					const Font& word_font = fonts[word.font];
					const Font::Char& ch = word_font.chars[c];

					GLshort char_x = x + ax + ch.bl;
					GLshort char_y = y + ay - ch.bt;
					GLshort char_width = ch.bw;
					GLshort char_height = ch.bh;
					GLshort char_bottom = char_y + char_height;

					Offset offset = ch.offset;

					if (char_bottom > maxheight)
					{
						GLshort bottom_adjust = char_bottom - maxheight;

						if (bottom_adjust < 10)
						{
							offset.bottom -= bottom_adjust;
							char_bottom -= bottom_adjust;
						}
						else
						{
							continue;
						}
					}

					if (char_y < minheight)
						continue;

					if (ax == 0 && c == ' ')
						continue;

					ax += ch.ax;

					if (char_width <= 0 || char_height <= 0)
						continue;

					quads.emplace_back(char_x, char_x + char_width, char_y, char_bottom, offset, abscolor, 0.0f);
				}
			}
		}
	}

	void GraphicsGL::drawrectangle(int16_t x, int16_t y, int16_t width, int16_t height, float red, float green, float blue, float alpha)
	{
		if (locked)
			return;

		quads.emplace_back(x, x + width, y, y + height, nulloffset, Color(red, green, blue, alpha), 0.0f);
	}

	void GraphicsGL::drawscreenfill(float red, float green, float blue, float alpha)
	{
		drawrectangle(0, 0, VWIDTH, VHEIGHT, red, green, blue, alpha);
	}

	void GraphicsGL::lock()
	{
		locked = true;
	}

	void GraphicsGL::unlock()
	{
		locked = false;
	}

	void GraphicsGL::flush(float opacity)
	{
		bool coverscene = opacity != 1.0f;

		if (coverscene)
		{
			float complement = 1.0f - opacity;
			Color color = Color(0.0f, 0.0f, 0.0f, complement);

			quads.emplace_back(SCREEN.left(), SCREEN.right(), SCREEN.top(), SCREEN.bottom(), nulloffset, color, 0.0f);
		}

		glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT);

		// Z-sorting temporarily disabled due to rendering issues
		// std::stable_sort(quads.begin(), quads.end(), [](const Quad& a, const Quad& b) {
		//     return a.z < b.z;
		// });

		GLsizeiptr csize = quads.size() * sizeof(Quad);
		GLsizeiptr fsize = quads.size() * Quad::LENGTH;

		glEnableVertexAttribArray(attribute_coord);
		glEnableVertexAttribArray(attribute_color);
		glBindBuffer(GL_ARRAY_BUFFER, VBO);
		glBufferData(GL_ARRAY_BUFFER, csize, quads.data(), GL_STREAM_DRAW);

		glDrawArrays(GL_QUADS, 0, fsize);

		glDisableVertexAttribArray(attribute_coord);
		glDisableVertexAttribArray(attribute_color);
		glBindBuffer(GL_ARRAY_BUFFER, 0);

		if (coverscene)
			quads.pop_back();
	}

	void GraphicsGL::move_camera(int16_t dx, int16_t dy)
	{
		camera_x += dx;
		camera_y += dy;
		GDEBUG("Camera moved to (" << camera_x << "," << camera_y << ")");
	}

	void GraphicsGL::reset_camera()
	{
		camera_x = 0;
		camera_y = 0;
		GDEBUG("Camera reset to (0,0)");
	}

	void GraphicsGL::clear_atlas_cache()
	{
		// Clear the actual OpenGL texture data
		GLubyte* black_data = new GLubyte[ATLASW * ATLASH * 4]();  // All zeros (black/transparent)
		glBindTexture(GL_TEXTURE_2D, atlas);
		glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, ATLASW, ATLASH, GL_RGBA, GL_UNSIGNED_BYTE, black_data);
		delete[] black_data;
		
		clearinternal();
		GDEBUG("Atlas cache and texture data cleared - textures will be re-uploaded");
	}

	void GraphicsGL::toggle_debug_mode()
	{
		debug_mode = !debug_mode;
		GDEBUG("Debug mode " << (debug_mode ? "ENABLED - large textures will draw as RED" : "DISABLED"));
	}

	void GraphicsGL::clearscene()
	{
		if (!locked)
			quads.clear();
	}
}

================
File: Graphics/GraphicsGL.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Text.h"

#include "../Constants.h"
#include "../Error.h"

#include "../Util/QuadTree.h"

#include <ft2build.h>
#include FT_FREETYPE_H

#ifdef USE_NX
#include <nlnx/bitmap.hpp>
#endif

namespace ms
{
	// Graphics engine which uses OpenGL
	class GraphicsGL : public Singleton<GraphicsGL>
	{
	public:
		GraphicsGL();

		// Initialize all resources
		Error init();
		// Re-initialize after changing screen modes
		void reinit();

		// Clear all bitmaps if most of the space is used up
		void clear();

		// Add a bitmap to the available resources
		void addbitmap(const nl::bitmap& bmp);
		// Draw the bitmap with the given parameters
		void draw(const nl::bitmap& bmp, const Rectangle<int16_t>& rect, const Range<int16_t>& vertical, const Range<int16_t>& horizontal, const Color& color, float angle);

		// Create a layout for the text with the parameters specified
		Text::Layout createlayout(const std::string& text, Text::Font font, Text::Alignment alignment, Color::Name color, int16_t maxwidth, bool formatted, int16_t line_adj);
		// Draw a text with the given parameters
		void drawtext(const DrawArgument& args, const Range<int16_t>& vertical, const std::string& text, const Text::Layout& layout, Text::Font font, Color::Name color, Text::Background back);

		// Draw a rectangle filled with the specified color
		void drawrectangle(int16_t x, int16_t y, int16_t width, int16_t height, float red, float green, float blue, float alpha);
		// Fill the screen with the specified color
		void drawscreenfill(float red, float green, float blue, float alpha);

		// Camera controls for debugging
		void move_camera(int16_t dx, int16_t dy);
		void reset_camera();
		void clear_atlas_cache();
		void toggle_debug_mode();

		// Lock the current scene
		void lock();
		// Unlock the scene
		void unlock();

		// Draw the buffer contents with the specified scene opacity
		void flush(float opacity);
		// Clear the buffer contents
		void clearscene();

	private:
		void clearinternal();
		bool addfont(const char* name, Text::Font id, FT_UInt width, FT_UInt height);

		struct Offset
		{
			GLshort left;
			GLshort right;
			GLshort top;
			GLshort bottom;

			Offset(GLshort x, GLshort y, GLshort width, GLshort height)
			{
				left = x;
				right = x + width;
				top = y;
				bottom = y + height;
			}

			Offset()
			{
				left = 0;
				right = 0;
				top = 0;
				bottom = 0;
			}
		};

		// Add a bitmap to the available resources
		const Offset& getoffset(const nl::bitmap& bmp);

		struct Leftover
		{
			GLshort left;
			GLshort right;
			GLshort top;
			GLshort bottom;

			Leftover(GLshort x, GLshort y, GLshort width, GLshort height)
			{
				left = x;
				right = x + width;
				top = y;
				bottom = y + height;
			}

			Leftover()
			{
				left = 0;
				right = 0;
				top = 0;
				bottom = 0;
			}

			GLshort width() const
			{
				return right - left;
			}

			GLshort height() const
			{
				return bottom - top;
			}
		};

		struct Quad
		{
			struct Vertex
			{
				// Local Space Position
				GLshort localcoord_x;
				GLshort localcoord_y;

				// Texture Coordinates
				GLshort texcoord_x;
				GLshort texcoord_y;

				Color color;
			};

			static const size_t LENGTH = 4;
			Vertex vertices[LENGTH];

			Quad(GLshort left, GLshort right, GLshort top, GLshort bottom, const Offset& offset, const Color& color, GLfloat rotation)
			{
				vertices[0] = { left, top, offset.left, offset.top, color };
				vertices[1] = { left, bottom, offset.left, offset.bottom, color };
				vertices[2] = { right, bottom, offset.right, offset.bottom, color };
				vertices[3] = { right, top, offset.right, offset.top, color };

				if (rotation != 0.0f)
				{
					GLfloat cos = std::cos(rotation);
					GLfloat sin = std::sin(rotation);
					GLshort center_x = (left + right) / 2;
					GLshort center_y = (top + bottom) / 2;

					for (size_t i = 0; i < LENGTH; i++)
					{
						GLshort vertice_x = vertices[i].localcoord_x - center_x;
						GLshort vertice_y = vertices[i].localcoord_y - center_y;
						GLfloat rounded_x = std::roundf(vertice_x * cos - vertice_y * sin);
						GLfloat rounded_y = std::roundf(vertice_x * sin + vertice_y * cos);
						vertices[i].localcoord_x = static_cast<GLshort>(rounded_x + center_x);
						vertices[i].localcoord_y = static_cast<GLshort>(rounded_y + center_y);
					}
				}
			}
		};

		struct Font
		{
			struct Char
			{
				GLshort ax;
				GLshort ay;
				GLshort bw;
				GLshort bh;
				GLshort bl;
				GLshort bt;
				Offset offset;
			};

			GLshort width;
			GLshort height;
			Char chars[128];

			Font(GLshort w, GLshort h)
			{
				width = w;
				height = h;
			}

			Font()
			{
				width = 0;
				height = 0;
			}

			int16_t linespace() const
			{
				return static_cast<int16_t>(height * 1.35 + 1);
			}
		};

		class LayoutBuilder
		{
		public:
			LayoutBuilder(Text::Font id, const Font& font, Text::Alignment alignment, Color::Name color, int16_t maxwidth, bool formatted, int16_t line_adj);

			size_t add(const char* text, size_t prev, size_t first, size_t last);
			Text::Layout finish(size_t first, size_t last);

		private:
			void add_word(size_t first, size_t last, Text::Font font, Color::Name color);
			void add_line();

			const Font& font;

			Text::Alignment alignment;
			Text::Font fontid;
			Color::Name color;
			int16_t maxwidth;
			bool formatted;

			int16_t ax;
			int16_t ay;

			std::vector<Text::Layout::Line> lines;
			std::vector<Text::Layout::Word> words;
			std::vector<int16_t> advances;
			int16_t width;
			int16_t endy;
			int16_t line_adj;
		};

		int16_t VWIDTH;
		int16_t VHEIGHT;
		Rectangle<int16_t> SCREEN;

		// Camera offset for debugging
		int16_t camera_x;
		int16_t camera_y;
		bool debug_mode;

		static const GLshort ATLASW = 8192;
		static const GLshort ATLASH = 8192;
		static const GLshort MINLOSIZE = 32;

		bool locked;

		std::vector<Quad> quads;
		GLuint VBO;
		GLuint atlas;

		GLint shaderProgram;
		GLint attribute_coord;
		GLint attribute_color;
		GLint uniform_texture;
		GLint uniform_atlassize;
		GLint uniform_screensize;
		GLint uniform_yoffset;
		GLint uniform_fontregion;

		std::unordered_map<size_t, Offset> offsets;
		Offset nulloffset;

		QuadTree<size_t, Leftover> leftovers;
		size_t rlid;
		size_t wasted;
		Point<GLshort> border;
		Range<GLshort> yrange;

		FT_Library ftlibrary;
		Font fonts[Text::Font::NUM_FONTS];
		Point<GLshort> fontborder;
		GLshort fontymax;
	};
}

================
File: Graphics/SpecialText.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Text.h"

namespace ms
{
	struct OutlinedText
	{
		Text inner;
		Text l;
		Text r;
		Text t;
		Text b;

		OutlinedText(Text::Font font, Text::Alignment alignment, Color::Name innerColor, Color::Name outerColor)
		{
			inner = Text(font, alignment, innerColor);
			l = Text(font, alignment, outerColor);
			r = Text(font, alignment, outerColor);
			t = Text(font, alignment, outerColor);
			b = Text(font, alignment, outerColor);
		}

		OutlinedText() {}

		void draw(Point<int16_t> parentpos) const
		{
			l.draw(parentpos + Point<int16_t>(-1, 0));
			r.draw(parentpos + Point<int16_t>(1, 0));
			t.draw(parentpos + Point<int16_t>(0, -1));
			b.draw(parentpos + Point<int16_t>(0, 1));
			inner.draw(parentpos);
		}

		void change_text(const std::string& text)
		{
			inner.change_text(text);
			l.change_text(text);
			r.change_text(text);
			t.change_text(text);
			b.change_text(text);
		}

		void change_color(Color::Name color)
		{
			inner.change_color(color);
		}

		int16_t width() const
		{
			return inner.width();
		}
	};

	struct ShadowText
	{
		Text top;
		Text shadow;

		ShadowText(Text::Font font, Text::Alignment alignment, Color::Name topColor, Color::Name shadowColor)
		{
			top = Text(font, alignment, topColor);
			shadow = Text(font, alignment, shadowColor);
		}

		ShadowText() {}

		void draw(Point<int16_t> parentpos) const
		{
			shadow.draw(parentpos + Point<int16_t>(1, 1));
			top.draw(parentpos);
		}

		void change_text(const std::string& text)
		{
			top.change_text(text);
			shadow.change_text(text);
		}

		void change_color(Color::Name color)
		{
			top.change_color(color);
		}

		int16_t width() const
		{
			return top.width();
		}
	};
}

================
File: Graphics/Sprite.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Sprite.h"

namespace ms
{
	Sprite::Sprite(const Animation& a, const DrawArgument& args) : animation(a), stateargs(args) {}
	Sprite::Sprite(nl::node src, const DrawArgument& args) : animation(src), stateargs(args) {}
	Sprite::Sprite(nl::node src) : Sprite(src, {}) {}
	Sprite::Sprite() {}

	void Sprite::draw(Point<int16_t> parentpos, float alpha) const
	{
		auto absargs = stateargs + parentpos;
		animation.draw(absargs, alpha);
	}

	bool Sprite::update(uint16_t timestep)
	{
		return animation.update(timestep);
	}

	bool Sprite::update()
	{
		return animation.update();
	}

	int16_t Sprite::width() const
	{
		return get_dimensions().x();
	}

	int16_t Sprite::height() const
	{
		return get_dimensions().y();
	}

	Point<int16_t> Sprite::get_origin() const
	{
		return animation.get_origin();
	}

	Point<int16_t> Sprite::get_dimensions() const
	{
		return animation.get_dimensions();
	}
}

================
File: Graphics/Sprite.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Animation.h"

namespace ms
{
	// Combines an Animation with additional state
	class Sprite
	{
	public:
		Sprite(const Animation& animation, const DrawArgument& stateargs);
		Sprite(nl::node src, const DrawArgument& stateargs);
		Sprite(nl::node src);
		Sprite();

		void draw(Point<int16_t> parentpos, float alpha) const;
		bool update(uint16_t timestep);
		bool update();

		int16_t width() const;
		int16_t height() const;
		Point<int16_t> get_origin() const;
		Point<int16_t> get_dimensions() const;

	private:
		Animation animation;
		DrawArgument stateargs;
	};
}

================
File: Graphics/Text.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Text.h"

#include "GraphicsGL.h"

namespace ms
{
	Text::Text(Font f, Alignment a, Color::Name c, Background b, const std::string& t, uint16_t mw, bool fm, int16_t la) : font(f), alignment(a), color(c), background(b), maxwidth(mw), formatted(fm), line_adj(la)
	{
		change_text(t);
	}

	Text::Text(Font f, Alignment a, Color::Name c, const std::string& t, uint16_t mw, bool fm, int16_t la) : Text(f, a, c, Background::NONE, t, mw, fm, la) {}
	Text::Text() : Text(Font::A11M, Alignment::LEFT, Color::BLACK) {}

	void Text::reset_layout()
	{
		if (text.empty())
			return;

		layout = GraphicsGL::get().createlayout(text, font, alignment, color, maxwidth, formatted, line_adj);
	}

	void Text::change_text(const std::string& t)
	{
		if (text == t)
			return;

		text = t;

		reset_layout();
	}

	void Text::change_color(Color::Name c)
	{
		if (color == c)
			return;

		color = c;

		reset_layout();
	}

	void Text::set_background(Background b)
	{
		background = b;
	}

	void Text::draw(const DrawArgument& args) const
	{
		draw(args, Range<int16_t>(0, 0));
	}

	void Text::draw(const DrawArgument& args, const Range<int16_t>& vertical) const
	{
		GraphicsGL::get().drawtext(args, vertical, text, layout, font, color, background);
	}

	uint16_t Text::advance(size_t pos) const
	{
		return layout.advance(pos);
	}

	bool Text::empty() const
	{
		return text.empty();
	}

	size_t Text::length() const
	{
		return text.size();
	}

	int16_t Text::width() const
	{
		return layout.width();
	}

	int16_t Text::height() const
	{
		return layout.height();
	}

	Point<int16_t> Text::dimensions() const
	{
		return layout.get_dimensions();
	}

	Point<int16_t> Text::endoffset() const
	{
		return layout.get_endoffset();
	}

	const std::string& Text::get_text() const
	{
		return text;
	}

	Text::Layout::Layout(const std::vector<Layout::Line>& l, const std::vector<int16_t>& a, int16_t w, int16_t h, int16_t ex, int16_t ey) : lines(l), advances(a), dimensions(w, h), endoffset(ex, ey) {}
	Text::Layout::Layout() : Layout(std::vector<Layout::Line>(), std::vector<int16_t>(), 0, 0, 0, 0) {}

	int16_t Text::Layout::width() const
	{
		return dimensions.x();
	}

	int16_t Text::Layout::height() const
	{
		return dimensions.y();
	}

	int16_t Text::Layout::advance(size_t index) const
	{
		return index < advances.size() ? advances[index] : 0;
	}

	Point<int16_t> Text::Layout::get_dimensions() const
	{
		return dimensions;
	}

	Point<int16_t> Text::Layout::get_endoffset() const
	{
		return endoffset;
	}

	Text::Layout::iterator Text::Layout::begin() const
	{
		return lines.begin();
	}

	Text::Layout::iterator Text::Layout::end() const
	{
		return lines.end();
	}
}

================
File: Graphics/Text.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "DrawArgument.h"

#include <map>
#include <vector>

namespace ms
{
	class Text
	{
	public:
		enum Font
		{
			A11M,
			A11B,
			A12M,
			A12B,
			A13M,
			A13B,
			A14M,
			A14B,
			A15M,
			A15B,
			A18M,
			A18B,
			NUM_FONTS
		};

		enum Alignment
		{
			LEFT,
			CENTER,
			RIGHT
		};

		enum Background
		{
			NONE,
			NAMETAG
		};

		class Layout
		{
		public:
			struct Word
			{
				size_t first;
				size_t last;
				Font font;
				Color::Name color;
			};

			struct Line
			{
				std::vector<Word> words;
				Point<int16_t> position;
			};

			Layout(const std::vector<Line>& lines, const std::vector<int16_t>& advances, int16_t width, int16_t height, int16_t endx, int16_t endy);
			Layout();

			int16_t width() const;
			int16_t height() const;
			int16_t advance(size_t index) const;
			Point<int16_t> get_dimensions() const;
			Point<int16_t> get_endoffset() const;

			using iterator = std::vector<Line>::const_iterator;
			iterator begin() const;
			iterator end() const;

		private:
			std::vector<Line> lines;
			std::vector<int16_t> advances;
			Point<int16_t> dimensions;
			Point<int16_t> endoffset;
		};

		Text(Font font, Alignment alignment, Color::Name color, Background background, const std::string& text = "", uint16_t maxwidth = 0, bool formatted = true, int16_t line_adj = 0);
		Text(Font font, Alignment alignment, Color::Name color, const std::string& text = "", uint16_t maxwidth = 0, bool formatted = true, int16_t line_adj = 0);
		Text();

		void draw(const DrawArgument& args) const;
		void draw(const DrawArgument& args, const Range<int16_t>& vertical) const;

		void change_text(const std::string& text);
		void change_color(Color::Name color);
		void set_background(Background background);

		bool empty() const;
		size_t length() const;
		int16_t width() const;
		int16_t height() const;
		uint16_t advance(size_t pos) const;
		Point<int16_t> dimensions() const;
		Point<int16_t> endoffset() const;
		const std::string& get_text() const;

	private:
		void reset_layout();

		Font font;
		Alignment alignment;
		Color::Name color;
		Background background;
		Layout layout;
		uint16_t maxwidth;
		bool formatted;
		std::string text;
		int16_t line_adj;
	};
}

================
File: Graphics/Texture.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Texture.h"

#include "GraphicsGL.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

#include <iostream>

namespace ms
{
	Texture::Texture(nl::node src)
	{
		z_index = 0; // Default Z-index
		nl::node final_node = src;

		// --- NEW: Defensive Check for Unexpected Containers ---
		if (src && src.data_type() == nl::node::type::none && src.size() > 0) {
			// Container node received, searching for child bitmap 
			
			// Attempt to find a valid bitmap child, prioritizing "0"
			nl::node child_zero = src["0"];
			if (child_zero && child_zero.data_type() == nl::node::type::bitmap) {
				final_node = child_zero;
				// Using fallback child
			} else {
				for (const auto& child : src) {
					if (child.data_type() == nl::node::type::bitmap) {
						final_node = child;
						// Using child bitmap
						break;
					}
				}
			}
		}

		if (final_node && final_node.data_type() == nl::node::type::bitmap)
		{
			origin = final_node["origin"];
			// Read Z-depth for proper layering
			z_index = final_node["z"].get_integer(0);
			if (z_index == 0) {
				z_index = final_node["zM"].get_integer(0);
			}
			// Texture creation from node (debug output removed)

			if (final_node.root() == nl::nx::Map001)
			{
				const std::string& _outlink = final_node["_outlink"];

				if (!_outlink.empty())
				{
					size_t first = _outlink.find_first_of('/');

					if (first != std::string::npos)
					{
						const std::string& first_part = _outlink.substr(0, first);

						if (first_part == "Map")
						{
							const std::string& path = _outlink.substr(first + 1);
							nl::node foundOutlink = nl::nx::Map.resolve(path);

							if (foundOutlink)
								final_node = foundOutlink;
						}
					}
				}
			}

			// This is the critical conversion line, now performed on the correct node
			bitmap = final_node;
			
			// Bitmap assignment complete

			if (bitmap.id() == 0)
			{
				std::cout << "[ERROR] Failed to load bitmap for node: " << final_node.name() << std::endl;
			}

			dimensions = Point<int16_t>(bitmap.width(), bitmap.height());
			// Texture loaded successfully

			GraphicsGL::get().addbitmap(bitmap);
		}
		else
		{
			// Note: Invalid bitmap node (debug output suppressed)
		}
	}

	void Texture::draw(const DrawArgument& args) const
	{
		draw(args, Range<int16_t>(0, 0));
	}

	void Texture::draw(const DrawArgument& args, const Range<int16_t>& vertical) const
	{
		draw(args, vertical, Range<int16_t>(0, 0));
	}

	void Texture::draw(const DrawArgument& args, const Range<int16_t>& vertical, const Range<int16_t>& horizontal) const
	{
		if (!is_valid())
		{
			// Skipping draw: invalid texture
			return;
		}

		// Drawing texture 

		GraphicsGL::get().draw(
			bitmap,
			args.get_rectangle(origin, dimensions),
			vertical,
			horizontal,
			args.get_color(),
			args.get_angle()
		);
	}

	void Texture::shift(Point<int16_t> amount)
	{
		origin -= amount;
	}

	bool Texture::is_valid() const
	{
		return bitmap.id() > 0;
	}

	int16_t Texture::width() const
	{
		return dimensions.x();
	}

	int16_t Texture::height() const
	{
		return dimensions.y();
	}

	Point<int16_t> Texture::get_origin() const
	{
		return origin;
	}

	Point<int16_t> Texture::get_dimensions() const
	{
		return dimensions;
	}

	int Texture::get_z_index() const
	{
		return z_index;
	}
}

================
File: Graphics/Texture.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "DrawArgument.h"

#ifdef USE_NX
#include <nlnx/bitmap.hpp>
#endif

namespace ms
{
	// Represents a single image loaded from a of game data
	class Texture
	{
	public:
		Texture() {}
		Texture(nl::node source);
		~Texture() {}

		void draw(const DrawArgument& args) const;
		void draw(const DrawArgument& args, const Range<int16_t>& vertical) const;
		void draw(const DrawArgument& args, const Range<int16_t>& vertical, const Range<int16_t>& horizontal) const;
		void shift(Point<int16_t> amount);

		bool is_valid() const;
		int16_t width() const;
		int16_t height() const;
		Point<int16_t> get_origin() const;
		Point<int16_t> get_dimensions() const;
		int get_z_index() const;

	private:
		nl::bitmap bitmap;
		Point<int16_t> origin;
		Point<int16_t> dimensions;
		int z_index;
	};
}

================
File: install_dependencies.bat
================
@echo off
echo HeavenClient Dependencies Installer
echo ===================================

:: Check if running as administrator
net session >nul 2>&1
if %errorLevel% neq 0 (
    echo This script needs to be run as Administrator for some components.
    echo Please right-click and select "Run as administrator"
    pause
    exit /b 1
)

echo.
echo This script will help you install the required dependencies for HeavenClient:
echo 1. Visual Studio 2019 Community (if not installed)
echo 2. Windows SDK 8.1
echo 3. Platform Toolset v140 (Visual Studio 2015 Build Tools)
echo 4. NoLifeWzToNx (for WZ to NX conversion)
echo.

:: Check for Windows SDK 8.1
echo.
echo Checking for Windows SDK 8.1...
if exist "%ProgramFiles(x86)%\Windows Kits\8.1" (
    echo Windows SDK 8.1 found
) else (
    echo Windows SDK 8.1 not found!
    echo.
    echo Please install Windows SDK 8.1:
    echo 1. Go to: https://developer.microsoft.com/en-us/windows/downloads/sdk-archive
    echo 2. Download "Windows SDK for Windows 8.1"
    echo 3. Install it
    echo.
    echo Press any key to open the download page...
    pause >nul
    start https://developer.microsoft.com/en-us/windows/downloads/sdk-archive
    echo.
    echo After installing Windows SDK 8.1, run this script again.
    pause
    exit /b 1
)

:: Check for Platform Toolset v140
echo.
echo Checking for Platform Toolset v140...
if exist "%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC" (
    echo Platform Toolset v140 should be available through Visual Studio 2019
) else if exist "%ProgramFiles(x86)%\Microsoft Visual Studio 14.0\VC\bin" (
    echo Platform Toolset v140 found
) else (
    echo Platform Toolset v140 not found!
    echo.
    echo If you have Visual Studio 2019, you may need to install the v140 toolset:
    echo 1. Open Visual Studio Installer
    echo 2. Modify your Visual Studio installation
    echo 3. Go to Individual Components
    echo 4. Search for "MSVC v140" and install it
    echo.
    echo Alternatively, you can install Visual Studio 2015 Build Tools
)

:: Setup NoLifeWzToNx
echo.
echo Setting up NoLifeWzToNx...
if not exist "NoLifeWzToNx" mkdir "NoLifeWzToNx"
if not exist "NoLifeWzToNx\NoLifeWzToNx.exe" (
    echo.
    echo NoLifeWzToNx not found!
    echo.
    echo Please download NoLifeWzToNx:
    echo 1. Go to: https://github.com/ryantpayton/NoLifeWzToNx/releases
    echo 2. Download the latest release
    echo 3. Extract NoLifeWzToNx.exe to the NoLifeWzToNx folder
    echo.
    echo Press any key to open the download page...
    pause >nul
    start https://github.com/ryantpayton/NoLifeWzToNx/releases
    echo.
    echo After downloading NoLifeWzToNx, run this script again.
    pause
    exit /b 1
) else (
    echo NoLifeWzToNx found!
)

:: Check dependencies in includes folder
echo.
echo Checking included dependencies...
if exist "includes\glew-2.1.0" (
    echo ✓ GLEW found
) else (
    echo ✗ GLEW not found in includes folder
)

if exist "includes\glfw-3.3.2.bin.WIN32" (
    echo ✓ GLFW found
) else (
    echo ✗ GLFW not found in includes folder
)

if exist "includes\freetype" (
    echo ✓ FreeType found
) else (
    echo ✗ FreeType not found in includes folder
)

if exist "includes\bass24" (
    echo ✓ Bass found
) else (
    echo ✗ Bass not found in includes folder
)

if exist "includes\NoLifeNx" (
    echo ✓ NoLifeNx found
) else (
    echo ✗ NoLifeNx not found in includes folder
)

echo.
echo Dependency check complete!
echo.
echo If all dependencies are found, you can now run build.bat to compile the client.
echo.
pause

================
File: IO/Components/AreaButton.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "AreaButton.h"

namespace ms
{
	AreaButton::AreaButton(Point<int16_t> pos, Point<int16_t> dim)
	{
		position = pos;
		dimension = dim;
		state = Button::State::NORMAL;
		active = true;
	}

	Rectangle<int16_t> AreaButton::bounds(Point<int16_t> parentpos) const
	{
		Point<int16_t> absp = position + parentpos;

		return Rectangle<int16_t>(absp, absp + dimension);
	}

	int16_t AreaButton::width() const
	{
		return dimension.x();
	}

	Point<int16_t> AreaButton::origin() const
	{
		return Point<int16_t>();
	}
}

================
File: IO/Components/AreaButton.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Button.h"

namespace ms
{
	// An invisible button which is only defined by it's area.
	class AreaButton : public Button
	{
	public:
		AreaButton(Point<int16_t> position, Point<int16_t> dimensions);

		void draw(Point<int16_t>) const {}
		void update() {}
		Rectangle<int16_t> bounds(Point<int16_t> parentpos) const;
		int16_t width() const;
		Point<int16_t> origin() const;
		Cursor::State send_cursor(bool, Point<int16_t>) { return Cursor::State::IDLE; }

	private:
		Point<int16_t> dimension;
	};
}

================
File: IO/Components/Button.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Button.h"

namespace ms
{
	bool Button::in_combobox(Point<int16_t>)
	{
		return false;
	}

	uint16_t Button::get_selected() const
	{
		return uint16_t();
	}

	void Button::set_position(Point<int16_t> pos)
	{
		position = pos;
	}

	void Button::set_state(State s)
	{
		if (s == Button::State::IDENTITY)
			return;

		state = s;
	}

	void Button::set_active(bool a)
	{
		active = a;
	}

	void Button::toggle_pressed()
	{
		pressed = !pressed;
	}

	bool Button::is_active() const
	{
		return active && state != Button::State::DISABLED;
	}

	Button::State Button::get_state() const
	{
		return state;
	}

	bool Button::is_pressed() const
	{
		return pressed;
	}
}

================
File: IO/Components/Button.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Cursor.h"

namespace ms
{
	// Base class for different button types.
	class Button
	{
	public:
		enum State
		{
			NORMAL,
			DISABLED,
			MOUSEOVER,
			PRESSED,
			IDENTITY,
			NUM_STATES
		};

		virtual ~Button() {}

		virtual void draw(Point<int16_t> parentpos) const = 0;
		virtual void update() = 0;
		virtual Rectangle<int16_t> bounds(Point<int16_t> parentpos) const = 0;
		virtual int16_t width() const = 0;
		virtual Point<int16_t> origin() const = 0;
		virtual Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) = 0;
		virtual bool in_combobox(Point<int16_t> cursorpos);
		virtual uint16_t get_selected() const;

		void set_position(Point<int16_t> position);
		void set_state(State state);
		void set_active(bool active);
		void toggle_pressed();

		bool is_active() const;
		State get_state() const;
		bool is_pressed() const;

	protected:
		State state;
		Point<int16_t> position;
		bool active;
		bool pressed;
	};
}

================
File: IO/Components/Charset.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Charset.h"

namespace ms
{
	Charset::Charset() : Charset({}, Charset::Alignment::LEFT) {}

	Charset::Charset(nl::node src, Alignment alignment) : alignment(alignment)
	{
		for (nl::node node : src)
		{
			std::string name = node.name();

			if (node.data_type() != nl::node::type::bitmap || name.empty())
				continue;

			char c = *name.begin();

			if (c == '\\')
				c = '/';

			chars.emplace(c, node);
		}
	}

	void Charset::draw(int8_t c, const DrawArgument& args) const
	{
		auto iter = chars.find(c);

		if (iter != chars.end())
			iter->second.draw(args);
	}

	int16_t Charset::getw(int8_t c) const
	{
		auto iter = chars.find(c);

		if (iter != chars.end())
			return iter->second.width();

		return 0;
	}

	// TODO: The two below draw methods need combined adding hspace to width only if it does not equal zero
	int16_t Charset::draw(const std::string& text, const DrawArgument& args) const
	{
		int16_t shift = 0;
		int16_t total = 0;

		switch (alignment)
		{
			case Charset::Alignment::CENTER:
			{
				for (char c : text)
				{
					int16_t width = getw(c);

					draw(c, args + Point<int16_t>(shift, 0));

					shift += width + 2;
					total += width;
				}

				shift -= total / 2;
				break;
			}
			case Charset::Alignment::LEFT:
			{
				for (char c : text)
				{
					draw(c, args + Point<int16_t>(shift, 0));

					shift += getw(c) + 1;
				}

				break;
			}
			case Charset::Alignment::RIGHT:
			{
				for (auto iter = text.rbegin(); iter != text.rend(); ++iter)
				{
					char c = *iter;
					shift += getw(c);

					draw(c, args - Point<int16_t>(shift, 0));
				}

				break;
			}
		}

		return shift;
	}

	int16_t Charset::draw(const std::string& text, int16_t hspace, const DrawArgument& args) const
	{
		size_t length = text.size();
		int16_t shift = 0;

		switch (alignment)
		{
			case Charset::Alignment::CENTER:
			{
				shift -= hspace * static_cast<int16_t>(length) / 2;
				break;
			}
			case Charset::Alignment::LEFT:
			{
				for (char c : text)
				{
					draw(c, args + Point<int16_t>(shift, 0));

					shift += hspace;
				}

				break;
			}
			case Charset::Alignment::RIGHT:
			{
				for (auto iter = text.rbegin(); iter != text.rend(); ++iter)
				{
					char c = *iter;

					shift += hspace;

					draw(c, args - Point<int16_t>(shift, 0));
				}

				break;
			}
		}

		return shift;
	}
}

================
File: IO/Components/Charset.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Graphics/Texture.h"

#include <unordered_map>

namespace ms
{
	class Charset
	{
	public:
		enum Alignment
		{
			LEFT,
			CENTER,
			RIGHT
		};

		Charset();
		Charset(nl::node source, Alignment alignment);

		void draw(int8_t character, const DrawArgument& args) const;
		int16_t draw(const std::string& text, const DrawArgument& args) const;
		int16_t draw(const std::string& text, int16_t hspace, const DrawArgument& args) const;
		int16_t getw(int8_t character) const;

	private:
		std::unordered_map<int8_t, Texture> chars;
		Alignment alignment;
	};
}

================
File: IO/Components/ChatBalloon.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "ChatBalloon.h"

#include "../../Constants.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	ChatBalloon::ChatBalloon(int8_t type)
	{
		std::string typestr;

		if (type < 0)
		{
			switch (type)
			{
				case -1:
					typestr = "dead";
					break;
			}
		}
		else
		{
			typestr = std::to_string(type);
		}

		nl::node src = nl::nx::UI["ChatBalloon.img"][typestr];

		arrow = src["arrow"];
		frame = src;

		textlabel = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::BLACK, "", 80);

		duration = 0;
	}

	ChatBalloon::ChatBalloon() : ChatBalloon(0) {}

	void ChatBalloon::change_text(const std::string& text)
	{
		textlabel.change_text(text);

		duration = DURATION;
	}

	void ChatBalloon::draw(Point<int16_t> position) const
	{
		if (duration == 0)
			return;

		int16_t width = textlabel.width();
		int16_t height = textlabel.height();

		frame.draw(position, width, height);
		arrow.draw(position);
		textlabel.draw(position - Point<int16_t>(0, height + 4));
	}

	void ChatBalloon::update()
	{
		duration -= Constants::TIMESTEP;

		if (duration < 0)
			duration = 0;
	}

	void ChatBalloon::expire()
	{
		duration = 0;
	}

	ChatBalloonHorizontal::ChatBalloonHorizontal()
	{
		nl::node Balloon = nl::nx::UI["Login.img"]["WorldNotice"]["Balloon"];

		arrow = Balloon["arrow"];
		center = Balloon["c"];
		northeast = Balloon["ne"];
		north = Balloon["n"];
		northwest = Balloon["nw"];
		west = Balloon["w"];
		southwest = Balloon["sw"];
		south = Balloon["s"];
		southeast = Balloon["se"];

		xtile = std::max<int16_t>(north.width(), 1);
		ytile = std::max<int16_t>(west.height(), 1);

		textlabel = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::BLACK);
	}

	void ChatBalloonHorizontal::draw(Point<int16_t> position) const
	{
		int16_t width = textlabel.width() + 9;
		int16_t height = textlabel.height() - 1;

		int16_t left = position.x() - width / 2;
		int16_t top = position.y() - height;
		int16_t right = left + width;
		int16_t bottom = top + height;

		northwest.draw(DrawArgument(left, top));
		southwest.draw(DrawArgument(left, bottom));

		for (int16_t y = top; y < bottom; y += ytile)
		{
			west.draw(DrawArgument(left, y));
		}

		center.draw(DrawArgument(Point<int16_t>(left, top), Point<int16_t>(width + 1, height)));

		for (int16_t x = left; x < right; x += xtile)
		{
			north.draw(DrawArgument(x, top));
			south.draw(DrawArgument(x, bottom));
		}

		northeast.draw(DrawArgument(right, top));
		southeast.draw(DrawArgument(right, bottom));

		arrow.draw(DrawArgument(right + 1, top));
		textlabel.draw(DrawArgument(left + 6, top - 4));
	}

	void ChatBalloonHorizontal::change_text(const std::string& text)
	{
		textlabel.change_text(text);
	}
}

================
File: IO/Components/ChatBalloon.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "MapleFrame.h"

#include "../../Graphics/Text.h"

namespace ms
{
	class ChatBalloon
	{
	public:
		ChatBalloon(int8_t type);
		ChatBalloon();

		void draw(Point<int16_t> position) const;
		void update();

		void change_text(const std::string& text);
		void expire();

	private:
		// How long a line stays on screen
		static constexpr int16_t DURATION = 4000; // 4 seconds

		MapleFrame frame;
		Text textlabel;
		Texture arrow;
		int16_t duration;
	};

	class ChatBalloonHorizontal
	{
	public:
		ChatBalloonHorizontal();

		void draw(Point<int16_t> position) const;

		void change_text(const std::string& text);

	private:
		Text textlabel;
		Texture arrow;
		Texture center;
		Texture northeast;
		Texture north;
		Texture northwest;
		Texture west;
		Texture southwest;
		Texture south;
		Texture southeast;
		int16_t xtile;
		int16_t ytile;
	};
}

================
File: IO/Components/EquipTooltip.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "EquipTooltip.h"

#include "../../Data/WeaponData.h"
#include "../../Gameplay/Stage.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	EquipTooltip::EquipTooltip()
	{
		nl::node Item = nl::nx::UI["UIToolTip.img"]["Item"];
		nl::node Frame = Item["Frame"];
		nl::node ItemIcon = Item["ItemIcon"];
		nl::node Equip = Item["Equip"];
		nl::node EquipCan = Equip["Can"];
		nl::node EquipCannot = Equip["Cannot"];

		top = Frame["top"];
		mid = Frame["line"];
		line = Frame["dotline"];
		bot = Frame["bottom"];
		base = ItemIcon["base"];
		cover = Frame["cover"];
		itemcover = ItemIcon["cover"];
		type[true] = ItemIcon["new"];
		type[false] = ItemIcon["old"];

		potential[Equip::Potential::POT_NONE] = Texture();
		potential[Equip::Potential::POT_HIDDEN] = ItemIcon["0"];
		potential[Equip::Potential::POT_RARE] = ItemIcon["1"];
		potential[Equip::Potential::POT_EPIC] = ItemIcon["2"];
		potential[Equip::Potential::POT_UNIQUE] = ItemIcon["3"];
		potential[Equip::Potential::POT_LEGENDARY] = ItemIcon["4"];

		requirements.push_back(MapleStat::Id::LEVEL);
		requirements.push_back(MapleStat::Id::STR);
		requirements.push_back(MapleStat::Id::DEX);
		requirements.push_back(MapleStat::Id::INT);
		requirements.push_back(MapleStat::Id::LUK);

		reqstattextures[MapleStat::Id::LEVEL][false] = EquipCannot["reqLEV"];
		reqstattextures[MapleStat::Id::LEVEL][true] = EquipCan["reqLEV"];
		reqstattextures[MapleStat::Id::FAME][false] = EquipCannot["reqPOP"];
		reqstattextures[MapleStat::Id::FAME][true] = EquipCan["reqPOP"];
		reqstattextures[MapleStat::Id::STR][false] = EquipCannot["reqSTR"];
		reqstattextures[MapleStat::Id::STR][true] = EquipCan["reqSTR"];
		reqstattextures[MapleStat::Id::DEX][false] = EquipCannot["reqDEX"];
		reqstattextures[MapleStat::Id::DEX][true] = EquipCan["reqDEX"];
		reqstattextures[MapleStat::Id::INT][false] = EquipCannot["reqINT"];
		reqstattextures[MapleStat::Id::INT][true] = EquipCan["reqINT"];
		reqstattextures[MapleStat::Id::LUK][false] = EquipCannot["reqLUK"];
		reqstattextures[MapleStat::Id::LUK][true] = EquipCan["reqLUK"];

		reqstatpositions[MapleStat::Id::LEVEL] = Point<int16_t>(97, 47);
		reqstatpositions[MapleStat::Id::STR] = Point<int16_t>(97, 62);
		reqstatpositions[MapleStat::Id::LUK] = Point<int16_t>(177, 62);
		reqstatpositions[MapleStat::Id::DEX] = Point<int16_t>(97, 71);
		reqstatpositions[MapleStat::Id::INT] = Point<int16_t>(177, 71);

		reqset[false] = Charset(EquipCannot, Charset::Alignment::LEFT);
		reqset[true] = Charset(EquipCan, Charset::Alignment::LEFT);

		lvset[false] = Charset(EquipCannot, Charset::Alignment::LEFT);
		lvset[true] = Charset(Equip["YellowNumber"], Charset::Alignment::LEFT);

		atkincset[false] = Charset(Equip["Summary"]["decline"], Charset::Alignment::RIGHT);
		atkincset[true] = Charset(Equip["Summary"]["incline"], Charset::Alignment::RIGHT);

		jobsback = Equip["Job"]["normal"];
		jobs[false][0] = Equip["Job"]["disable"]["0"];
		jobs[false][1] = Equip["Job"]["disable"]["1"];
		jobs[false][2] = Equip["Job"]["disable"]["2"];
		jobs[false][3] = Equip["Job"]["disable"]["3"];
		jobs[false][4] = Equip["Job"]["disable"]["4"];
		jobs[false][5] = Equip["Job"]["disable"]["5"];
		jobs[true][0] = Equip["Job"]["enable"]["0"];
		jobs[true][1] = Equip["Job"]["enable"]["1"];
		jobs[true][2] = Equip["Job"]["enable"]["2"];
		jobs[true][3] = Equip["Job"]["enable"]["3"];
		jobs[true][4] = Equip["Job"]["enable"]["4"];
		jobs[true][5] = Equip["Job"]["enable"]["5"];

		invpos = 0;
		invpos_preview = 0;
	}

	void EquipTooltip::set_equip(Tooltip::Parent parent, int16_t ivp)
	{
		if (invpos == ivp)
			return;

		invpos = ivp;
		invpos_preview = 0;

		const Player& player = Stage::get().get_player();

		InventoryType::Id invtype;

		switch (parent)
		{
		case Tooltip::Parent::ITEMINVENTORY:
		case Tooltip::Parent::SHOP:
			invtype = InventoryType::Id::EQUIP;
			break;
		case Tooltip::Parent::EQUIPINVENTORY:
			invtype = InventoryType::Id::EQUIPPED;
			break;
		default:
			invtype = InventoryType::Id::NONE;
		}

		const Inventory& inventory = player.get_inventory();
		auto oequip = inventory.get_equip(invtype, invpos);
		const CharStats& stats = player.get_stats();

		if (invtype == InventoryType::Id::EQUIP)
		{
			const int32_t item_id = oequip.get()->get_item_id();
			const EquipData& equipdata = EquipData::get(item_id);
			EquipSlot::Id eqslot = equipdata.get_eqslot();

			if (inventory.has_equipped(eqslot));
			{
				auto eequip = inventory.get_equip(InventoryType::Id::EQUIPPED, eqslot);

				if (eequip)
				{
					const Equip& equip = *eequip;

					int32_t item_id = equip.get_item_id();

					const EquipData& equipdata = EquipData::get(item_id);
					const ItemData& itemdata = equipdata.get_itemdata();

					height_preview = 540;

					itemicon_preview = itemdata.get_icon(false);

					for (auto& ms : requirements)
					{
						canequip_preview[ms] = stats.get_stat(ms) >= equipdata.get_reqstat(ms);
						std::string reqstr = std::to_string(equipdata.get_reqstat(ms));

						if (ms != MapleStat::Id::LEVEL)
							reqstr.insert(0, 3 - reqstr.size(), '0');

						reqstatstrings_preview[ms] = reqstr;
					}

					okjobs_preview.clear();

					// TODO: Remove from UIItemInventory and move into Job?
					switch (equipdata.get_reqstat(MapleStat::Id::JOB))
					{
					case 0:
						okjobs_preview.push_back(0);
						okjobs_preview.push_back(1);
						okjobs_preview.push_back(2);
						okjobs_preview.push_back(3);
						okjobs_preview.push_back(4);
						okjobs_preview.push_back(5);
						canequip_preview[MapleStat::Id::JOB] = true;
						break;
					case 1:
						okjobs_preview.push_back(1);
						canequip_preview[MapleStat::Id::JOB] = (stats.get_stat(MapleStat::Id::JOB) / 100 == 1) || (stats.get_stat(MapleStat::Id::JOB) / 100 >= 20);
						break;
					case 2:
						okjobs_preview.push_back(2);
						canequip_preview[MapleStat::Id::JOB] = stats.get_stat(MapleStat::Id::JOB) / 100 == 2;
						break;
					case 4:
						okjobs_preview.push_back(3);
						canequip_preview[MapleStat::Id::JOB] = stats.get_stat(MapleStat::Id::JOB) / 100 == 3;
						break;
					case 8:
						okjobs_preview.push_back(4);
						canequip_preview[MapleStat::Id::JOB] = stats.get_stat(MapleStat::Id::JOB) / 100 == 4;
						break;
					case 16:
						okjobs_preview.push_back(5);
						canequip_preview[MapleStat::Id::JOB] = stats.get_stat(MapleStat::Id::JOB) / 100 == 5;
						break;
					default:
						canequip_preview[MapleStat::Id::JOB] = false;
						break;
					}
					// End of TODO

					prank_preview = equip.get_potrank();

					switch (prank_preview)
					{
					case Equip::Potential::POT_HIDDEN:
						potflag_preview = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::RED);
						potflag_preview.change_text("(Hidden Potential)");
						break;
					case Equip::Potential::POT_RARE:
						potflag_preview = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::WHITE);
						potflag_preview.change_text("(Rare Item)");
						break;
					case Equip::Potential::POT_EPIC:
						potflag_preview = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::WHITE);
						potflag_preview.change_text("(Epic Item)");
						break;
					case Equip::Potential::POT_UNIQUE:
						potflag_preview = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::WHITE);
						potflag_preview.change_text("(Unique Item)");
						break;
					case Equip::Potential::POT_LEGENDARY:
						potflag_preview = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::WHITE);
						potflag_preview.change_text("(Legendary Item)");
						break;
					default:
						height_preview -= 16;
						break;
					}

					Color::Name namecolor;

					switch (equip.get_quality())
					{
					case EquipQuality::Id::GREY:
						namecolor = Color::Name::LIGHTGREY;
						break;
					case EquipQuality::Id::ORANGE:
						namecolor = Color::Name::ORANGE;
						break;
					case EquipQuality::Id::BLUE:
						namecolor = Color::Name::MEDIUMBLUE;
						break;
					case EquipQuality::Id::VIOLET:
						namecolor = Color::Name::VIOLET;
						break;
					case EquipQuality::Id::GOLD:
						namecolor = Color::Name::YELLOW;
						break;
					default:
						namecolor = Color::Name::WHITE;
						break;
					}

					std::string namestr = itemdata.get_name();
					const int8_t reqGender = itemdata.get_gender();
					const bool female = stats.get_female();

					switch (reqGender)
					{
					case 0: // Male
						namestr += " (M)";
						break;
					case 1: // Female
						namestr += " (F)";
						break;
					case 2: // Unisex
					default:
						break;
					}

					if (equip.get_level() > 0)
					{
						namestr.append(" (+");
						namestr.append(std::to_string(equip.get_level()));
						namestr.append(")");
					}

					name_preview = Text(Text::Font::A12B, Text::Alignment::LEFT, namecolor, namestr, 400);
					atkinc_preview = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::DUSTYGRAY, "ATT INCREASE");

					std::string desctext = itemdata.get_desc();
					hasdesc_preview = desctext.size() > 0;

					if (hasdesc_preview)
					{
						desc_preview = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::WHITE, desctext, 250);
						height_preview += desc_preview.height() + 10;
					}

					category_preview = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, "Type: " + equipdata.get_type());

					is_weapon_preview = equipdata.is_weapon();

					if (is_weapon_preview)
					{
						const WeaponData& weapon = WeaponData::get(item_id);
						wepspeed_preview = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, "Attack Speed: " + weapon.getspeedstring());
					}
					else
					{
						height_preview -= 18;
					}

					hasslots_preview = (equip.get_slots() > 0) || (equip.get_level() > 0);

					if (hasslots_preview)
					{
						slots_preview = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, "Remaining Enhancements: " + std::to_string(equip.get_slots()));

						std::string vicious = std::to_string(equip.get_vicious());

						if (equip.get_vicious() > 1)
							vicious.append(" (MAX) ");

						hammers_preview = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, "Hammers Applied: " + vicious);
					}
					else
					{
						height_preview -= 36;
					}

					statlabels_preview.clear();

					for (EquipStat::Id es = EquipStat::Id::STR; es <= EquipStat::Id::JUMP; es = static_cast<EquipStat::Id>(es + 1))
					{
						if (equip.get_stat(es) > 0)
						{
							int16_t delta = equip.get_stat(es) - equipdata.get_defstat(es);
							std::string statstr = std::to_string(equip.get_stat(es));

							if (delta != 0)
							{
								statstr.append(" (");
								statstr.append((delta < 0) ? "-" : "+");
								statstr.append(std::to_string(abs(delta)) + ")");
							}

							statlabels_preview[es] = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, EquipStat::names[es] + std::string(": ") + statstr);
						}
						else
						{
							height_preview -= 18;
						}
					}

					invpos_preview = 1;
				}
			}
		}

		if (!oequip)
			return;

		const Equip& equip = *oequip;

		int32_t item_id = equip.get_item_id();

		const EquipData& equipdata = EquipData::get(item_id);
		const ItemData& itemdata = equipdata.get_itemdata();

		height = 540;

		itemicon = itemdata.get_icon(false);

		for (auto& ms : requirements)
		{
			canequip[ms] = stats.get_stat(ms) >= equipdata.get_reqstat(ms);
			std::string reqstr = std::to_string(equipdata.get_reqstat(ms));

			if (ms != MapleStat::Id::LEVEL)
				reqstr.insert(0, 3 - reqstr.size(), '0');

			reqstatstrings[ms] = reqstr;
		}

		okjobs.clear();

		switch (equipdata.get_reqstat(MapleStat::Id::JOB))
		{
		case 0: // Common
			okjobs.push_back(0);
			okjobs.push_back(1);
			okjobs.push_back(2);
			okjobs.push_back(3);
			okjobs.push_back(4);
			okjobs.push_back(5);
			canequip[MapleStat::Id::JOB] = true;
			break;
		case 1: // Warrior
			okjobs.push_back(1);
			canequip[MapleStat::Id::JOB] = (stats.get_stat(MapleStat::Id::JOB) / 100 == 1) || (stats.get_stat(MapleStat::Id::JOB) / 100 >= 20);
			break;
		case 2: // Magician
			okjobs.push_back(2);
			canequip[MapleStat::Id::JOB] = stats.get_stat(MapleStat::Id::JOB) / 100 == 2;
			break;
		case 3: // Magician, Warrior
			okjobs.push_back(1);
			okjobs.push_back(2);
			canequip[MapleStat::Id::JOB] = (stats.get_stat(MapleStat::Id::JOB) / 100 == 1) || (stats.get_stat(MapleStat::Id::JOB) / 100 >= 20) || stats.get_stat(MapleStat::Id::JOB) / 100 == 2;
			break;
		case 4: // Bowman
			okjobs.push_back(3);
			canequip[MapleStat::Id::JOB] = stats.get_stat(MapleStat::Id::JOB) / 100 == 3;
			break;
		case 8: // Thief
			okjobs.push_back(4);
			canequip[MapleStat::Id::JOB] = stats.get_stat(MapleStat::Id::JOB) / 100 == 4;
			break;
		case 16: // Pirate
			okjobs.push_back(5);
			canequip[MapleStat::Id::JOB] = stats.get_stat(MapleStat::Id::JOB) / 100 == 5;
			break;
		default:
			canequip[MapleStat::Id::JOB] = false;
			break;
		}

		prank = equip.get_potrank();

		switch (prank)
		{
		case Equip::Potential::POT_HIDDEN:
			potflag = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::RED);
			potflag.change_text("(Hidden Potential)");
			break;
		case Equip::Potential::POT_RARE:
			potflag = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::WHITE);
			potflag.change_text("(Rare Item)");
			break;
		case Equip::Potential::POT_EPIC:
			potflag = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::WHITE);
			potflag.change_text("(Epic Item)");
			break;
		case Equip::Potential::POT_UNIQUE:
			potflag = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::WHITE);
			potflag.change_text("(Unique Item)");
			break;
		case Equip::Potential::POT_LEGENDARY:
			potflag = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::WHITE);
			potflag.change_text("(Legendary Item)");
			break;
		default:
			height -= 16;
			break;
		}

		Color::Name namecolor;

		switch (equip.get_quality())
		{
		case EquipQuality::Id::GREY:
			namecolor = Color::Name::LIGHTGREY;
			break;
		case EquipQuality::Id::ORANGE:
			namecolor = Color::Name::ORANGE;
			break;
		case EquipQuality::Id::BLUE:
			namecolor = Color::Name::MEDIUMBLUE;
			break;
		case EquipQuality::Id::VIOLET:
			namecolor = Color::Name::VIOLET;
			break;
		case EquipQuality::Id::GOLD:
			namecolor = Color::Name::YELLOW;
			break;
		default:
			namecolor = Color::Name::WHITE;
			break;
		}

		std::string namestr = itemdata.get_name();
		const int8_t reqGender = itemdata.get_gender();
		const bool female = stats.get_female();

		switch (reqGender)
		{
		case 0: // Male
			namestr += " (M)";
			break;
		case 1: // Female
			namestr += " (F)";
			break;
		case 2: // Unisex
		default:
			break;
		}

		if (equip.get_level() > 0)
		{
			namestr.append(" (+");
			namestr.append(std::to_string(equip.get_level()));
			namestr.append(")");
		}

		name = Text(Text::Font::A12B, Text::Alignment::LEFT, namecolor, namestr, 400);
		atkinc = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::DUSTYGRAY, "ATT INCREASE");

		std::string desctext = itemdata.get_desc();
		hasdesc = desctext.size() > 0;

		if (hasdesc)
		{
			desc = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::WHITE, desctext, 250);
			height += desc.height() + 10;
		}

		category = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, "Type: " + equipdata.get_type());

		is_weapon = equipdata.is_weapon();

		if (is_weapon)
		{
			const WeaponData& weapon = WeaponData::get(item_id);
			wepspeed = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, "Attack Speed: " + weapon.getspeedstring());
		}
		else
		{
			height -= 18;
		}

		hasslots = (equip.get_slots() > 0) || (equip.get_level() > 0);

		if (hasslots)
		{
			slots = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, "Remaining Enhancements: " + std::to_string(equip.get_slots()));

			std::string vicious = std::to_string(equip.get_vicious());

			if (equip.get_vicious() > 1)
				vicious.append(" (MAX) ");

			hammers = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, "Hammers Applied: " + vicious);
		}
		else
		{
			height -= 36;
		}

		statlabels.clear();

		for (EquipStat::Id es = EquipStat::Id::STR; es <= EquipStat::Id::JUMP; es = static_cast<EquipStat::Id>(es + 1))
		{
			if (equip.get_stat(es) > 0)
			{
				int16_t delta = equip.get_stat(es) - equipdata.get_defstat(es);
				std::string statstr = std::to_string(equip.get_stat(es));

				if (delta != 0)
				{
					statstr.append(" (");
					statstr.append((delta < 0) ? "-" : "+");
					statstr.append(std::to_string(abs(delta)) + ")");
				}

				statlabels[es] = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, EquipStat::names[es] + std::string(": ") + statstr);
			}
			else
			{
				height -= 18;
			}
		}
	}

	void EquipTooltip::draw(Point<int16_t> pos) const
	{
		if (invpos == 0)
			return;

		draw_preview(pos);

		int16_t max_width = Constants::Constants::get().get_viewwidth();
		int16_t max_height = Constants::Constants::get().get_viewheight();
		int16_t cur_width = pos.x() + top.width();
		int16_t cur_height = pos.y() + 36;

		if (invpos_preview == 1)
			cur_width += top.width();

		if (invpos_preview == 1)
			cur_height += (height > height_preview) ? height : height_preview;
		else
			cur_height += height;

		int16_t adj_x = cur_width - max_width;
		int16_t adj_y = cur_height - max_height;

		if (adj_x > 0)
			pos.shift_x(adj_x * -1);

		if (adj_y > 0)
			pos.shift_y(adj_y * -1);

		top.draw(pos);
		mid.draw(DrawArgument(pos + Point<int16_t>(0, 13), Point<int16_t>(0, height)));
		bot.draw(pos + Point<int16_t>(0, height + 13));
		cover.draw(pos);

		name.draw(pos + Point<int16_t>(17, 7));

		if (prank != Equip::Potential::POT_NONE)
		{
			potflag.draw(pos + Point<int16_t>(130, 20));
			pos.shift_y(16);
		}

		pos.shift_y(44);

		line.draw(pos);

		atkinc.draw(pos + Point<int16_t>(248, 4));
		base.draw(pos + Point<int16_t>(12, 10));
		type[false].draw(pos + Point<int16_t>(12, 10));
		itemicon.draw(DrawArgument(pos + Point<int16_t>(18, 82), 2.0f, 2.0f));
		potential[prank].draw(pos + Point<int16_t>(12, 10));
		itemcover.draw(pos + Point<int16_t>(12, 10));

		int16_t atkincnum = 0;
		std::string atkincstr = std::to_string(atkincnum);
		bool atkinc_pos = true;

		if (canequip[MapleStat::Id::JOB])
		{
			if (atkincnum < 0)
			{
				atkincstr = "m" + atkincstr;
				atkinc_pos = false;
			}
			else if (atkincnum > 0)
			{
				atkincstr = "p" + atkincstr;
				atkinc_pos = true;
			}
			else
			{
				atkinc_pos = true;
			}
		}
		else
		{
			atkincstr = "m";
			atkinc_pos = false;
		}

		atkincset[atkinc_pos].draw(atkincstr, 11, pos + Point<int16_t>(239, 26));

		pos.shift_y(12);

		for (MapleStat::Id ms : requirements)
		{
			Point<int16_t> reqpos = reqstatpositions[ms];
			bool reqok = canequip[ms];
			reqstattextures[ms][reqok].draw(pos + reqpos);

			if (ms != MapleStat::Id::LEVEL)
				reqset[reqok].draw(reqstatstrings[ms], 6, pos + reqpos + Point<int16_t>(54, 0));
			else
				lvset[reqok].draw(reqstatstrings[ms], 6, pos + reqpos + Point<int16_t>(54, 0));
		}

		pos.shift_y(88);

		Point<int16_t> job_position(pos + Point<int16_t>(10, 14));
		jobsback.draw(job_position);

		for (auto& jbit : okjobs)
			jobs[canequip[MapleStat::Id::JOB]].at(jbit).draw(job_position);

		line.draw(pos + Point<int16_t>(0, 47));

		pos.shift_y(49);

		int16_t stat_x = 13;
		int16_t stat_y = 15;

		category.draw(pos + Point<int16_t>(stat_x, 0));

		pos.shift_y(stat_y);

		if (is_weapon)
		{
			wepspeed.draw(pos + Point<int16_t>(stat_x, 0));
			pos.shift_y(stat_y);
		}

		for (const Text& label : statlabels.values())
		{
			if (label.empty())
				continue;

			label.draw(pos + Point<int16_t>(stat_x, 0));
			pos.shift_y(stat_y);
		}

		if (hasslots)
		{
			slots.draw(pos + Point<int16_t>(stat_x, 0));
			pos.shift_y(stat_y);
			hammers.draw(pos + Point<int16_t>(stat_x, 0));
			pos.shift_y(stat_y);
		}

		if (hasdesc)
		{
			pos.shift_y(13);
			line.draw(pos);
			desc.draw(pos + Point<int16_t>(9, 3));
		}
	}

	void EquipTooltip::draw_preview(Point<int16_t> pos) const
	{
		if (invpos_preview == 0)
			return;

		pos.shift_x(top.width());

		int16_t max_width = Constants::Constants::get().get_viewwidth();
		int16_t max_height = Constants::Constants::get().get_viewheight();
		int16_t cur_width = pos.x() + top.width();
		int16_t cur_height = pos.y() + height_preview + 36;

		int16_t adj_x = cur_width - max_width;
		int16_t adj_y = cur_height - max_height;

		if (adj_x > 0)
			pos.shift_x(adj_x * -1);

		if (adj_y > 0)
			pos.shift_y(adj_y * -1);

		top.draw(pos);
		mid.draw(DrawArgument(pos + Point<int16_t>(0, 13), Point<int16_t>(0, height_preview)));
		bot.draw(pos + Point<int16_t>(0, height_preview + 13));
		cover.draw(pos);

		name_preview.draw(pos + Point<int16_t>(17, 7));

		if (prank_preview != Equip::Potential::POT_NONE)
		{
			potflag_preview.draw(pos + Point<int16_t>(130, 20));
			pos.shift_y(16);
		}

		pos.shift_y(44);

		line.draw(pos);

		atkinc_preview.draw(pos + Point<int16_t>(248, 4));
		base.draw(pos + Point<int16_t>(12, 10));
		type[false].draw(pos + Point<int16_t>(12, 10));
		itemicon_preview.draw(DrawArgument(pos + Point<int16_t>(18, 82), 2.0f, 2.0f));
		potential[prank_preview].draw(pos + Point<int16_t>(12, 10));
		itemcover.draw(pos + Point<int16_t>(12, 10));

		int16_t atkincnum = 0;
		std::string atkincstr = std::to_string(atkincnum);
		bool atkinc_pos = true;

		if (canequip_preview[MapleStat::Id::JOB])
		{
			if (atkincnum < 0)
			{
				atkincstr = "m" + atkincstr;
				atkinc_pos = false;
			}
			else if (atkincnum > 0)
			{
				atkincstr = "p" + atkincstr;
				atkinc_pos = true;
			}
			else
			{
				atkinc_pos = true;
			}
		}
		else
		{
			atkincstr = "m";
			atkinc_pos = false;
		}

		atkincset[atkinc_pos].draw(atkincstr, 11, pos + Point<int16_t>(239, 26));

		pos.shift_y(12);

		for (MapleStat::Id ms : requirements)
		{
			Point<int16_t> reqpos = reqstatpositions[ms];
			bool reqok = canequip_preview[ms];
			reqstattextures[ms][reqok].draw(pos + reqpos);

			if (ms != MapleStat::Id::LEVEL)
				reqset[reqok].draw(reqstatstrings_preview[ms], 6, pos + reqpos + Point<int16_t>(54, 0));
			else
				lvset[reqok].draw(reqstatstrings_preview[ms], 6, pos + reqpos + Point<int16_t>(54, 0));
		}

		pos.shift_y(88);

		Point<int16_t> job_position(pos + Point<int16_t>(10, 14));
		jobsback.draw(job_position);

		for (auto& jbit : okjobs_preview)
			jobs[canequip_preview[MapleStat::Id::JOB]].at(jbit).draw(job_position);

		line.draw(pos + Point<int16_t>(0, 47));

		pos.shift_y(49);

		int16_t stat_x = 13;
		int16_t stat_y = 15;

		category_preview.draw(pos + Point<int16_t>(stat_x, 0));

		pos.shift_y(stat_y);

		if (is_weapon_preview)
		{
			wepspeed_preview.draw(pos + Point<int16_t>(stat_x, 0));
			pos.shift_y(stat_y);
		}

		for (const Text& label : statlabels_preview.values())
		{
			if (label.empty())
				continue;

			label.draw(pos + Point<int16_t>(stat_x, 0));
			pos.shift_y(stat_y);
		}

		if (hasslots_preview)
		{
			slots_preview.draw(pos + Point<int16_t>(stat_x, 0));
			pos.shift_y(stat_y);
			hammers_preview.draw(pos + Point<int16_t>(stat_x, 0));
			pos.shift_y(stat_y);
		}

		if (hasdesc_preview)
		{
			pos.shift_y(-4);
			line.draw(pos);
			desc_preview.draw(pos + Point<int16_t>(9, 8));
		}
	}
}

================
File: IO/Components/EquipTooltip.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Charset.h"
#include "Tooltip.h"

#include "../../Character/MapleStat.h"
#include "../../Graphics/Text.h"
#include "../../Template/BoolPair.h"

#include "../../Character/Inventory/Equip.h"

namespace ms
{
	class EquipTooltip : public Tooltip
	{
	public:
		EquipTooltip();

		void set_equip(Tooltip::Parent parent, int16_t invpos);
		void draw(Point<int16_t> position) const override;
		void draw_preview(Point<int16_t> position) const;

	private:
		int16_t invpos;
		int16_t invpos_preview;
		int16_t height;
		int16_t height_preview;
		bool hasdesc;
		bool hasdesc_preview;
		bool hasslots;
		bool hasslots_preview;
		bool is_weapon;
		bool is_weapon_preview;
		EnumMap<MapleStat::Id, std::string> reqstatstrings;
		EnumMap<MapleStat::Id, std::string> reqstatstrings_preview;
		Texture itemicon;
		Texture itemicon_preview;

		Text name;
		Text name_preview;
		Text desc;
		Text desc_preview;
		Text potflag;
		Text potflag_preview;
		Text category;
		Text category_preview;
		Text wepspeed;
		Text wepspeed_preview;
		Text slots;
		Text slots_preview;
		Text hammers;
		Text hammers_preview;
		Text atkinc;
		Text atkinc_preview;
		EnumMap<EquipStat::Id, Text> statlabels;
		EnumMap<EquipStat::Id, Text> statlabels_preview;

		Texture top;
		Texture mid;
		Texture line;
		Texture bot;
		Texture base;

		EnumMap<Equip::Potential, Texture> potential;
		Equip::Potential prank;
		Equip::Potential prank_preview;

		Texture cover;
		Texture itemcover;
		BoolPair<Texture> type;

		std::vector<MapleStat::Id> requirements;
		EnumMap<MapleStat::Id, BoolPair<Texture>> reqstattextures;
		EnumMap<MapleStat::Id, bool> canequip;
		EnumMap<MapleStat::Id, bool> canequip_preview;
		EnumMap<MapleStat::Id, Point<int16_t>> reqstatpositions;
		BoolPair<Charset> reqset;
		BoolPair<Charset> lvset;
		BoolPair<Charset> atkincset;

		Texture jobsback;
		BoolPair<std::map<uint8_t, Texture>> jobs;
		std::vector<uint8_t> okjobs;
		std::vector<uint8_t> okjobs_preview;
	};
}

================
File: IO/Components/Gauge.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Gauge.h"

namespace ms
{
	Gauge::Gauge(Type type, Texture front, int16_t maximum, float percentage) : Gauge(type, front, {}, maximum, percentage) {}
	Gauge::Gauge(Type type, Texture front, Texture middle, int16_t maximum, float percentage) : Gauge(type, front, {}, {}, maximum, percentage) {}
	Gauge::Gauge(Type type, Texture front, Texture middle, Texture end, int16_t maximum, float percentage) : type(type), barfront(front), barmid(middle), barend(end), maximum(maximum), percentage(percentage), target(percentage) {}

	void Gauge::draw(const DrawArgument& args) const
	{
		int16_t length = static_cast<int16_t>(percentage * maximum);

		if (length > 0)
		{
			if (type == Type::DEFAULT)
			{
				barfront.draw(args + DrawArgument(Point<int16_t>(0, 0), Point<int16_t>(length, 0)));
				barmid.draw(args);
				barend.draw(args + Point<int16_t>(length + 8, 20));
			}
			else if (type == Type::CASHSHOP)
			{
				Point<int16_t> pos_adj = Point<int16_t>(45, 1);

				barfront.draw(args - pos_adj);
				barmid.draw(args + DrawArgument(Point<int16_t>(0, 0), Point<int16_t>(length, 0)));
				barend.draw(args - pos_adj + Point<int16_t>(length + barfront.width(), 0));
			}
			else if (type == Type::WORLDSELECT)
			{
				barfront.draw(args, {}, Range<int16_t>(0, barfront.width() - length));
			}
		}
		else
		{
			if (type == Type::WORLDSELECT)
				barfront.draw(args, {}, Range<int16_t>(0, barfront.width() - 1));
		}
	}

	void Gauge::update(float t)
	{
		if (target != t)
		{
			target = t;
			step = (target - percentage) / 24;
		}

		if (percentage != target)
		{
			percentage += step;

			if (step < 0.0f)
			{
				if (target - percentage >= step)
					percentage = target;
			}
			else if (step > 0.0f)
			{
				if (target - percentage <= step)
					percentage = target;
			}
		}
	}
}

================
File: IO/Components/Gauge.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Graphics/Texture.h"

namespace ms
{
	class Gauge
	{
	public:
		enum Type : uint8_t
		{
			DEFAULT,
			CASHSHOP,
			WORLDSELECT
		};

		Gauge() {}
		Gauge(Type type, Texture front, int16_t maximum, float percent);
		Gauge(Type type, Texture front, Texture middle, int16_t maximum, float percent);
		Gauge(Type type, Texture front, Texture middle, Texture end, int16_t maximum, float percentage);

		void draw(const DrawArgument& args) const;
		void update(float target);

	private:
		Texture barfront;
		Texture barmid;
		Texture barend;
		int16_t maximum;

		float percentage;
		float target;
		float step;

		Type type;
	};
}

================
File: IO/Components/Icon.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Icon.h"

#include "Charset.h"

#include "../../Audio/Audio.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Icon::Icon() : Icon(std::make_unique<NullType>(), {}, -1) {}

	Icon::Icon(std::unique_ptr<Type> type, Texture t, int16_t c) : type(std::move(type)), texture(t), count(c)
	{
		texture.shift(Point<int16_t>(0, 32));

		showcount = count > -1;
		dragged = false;
	}

	void Icon::draw(Point<int16_t> position) const
	{
		float opacity = dragged ? 0.5f : 1.0f;
		texture.draw(DrawArgument(position, opacity));

		if (showcount)
		{
			static const Charset countset = Charset(nl::nx::UI["Basic.img"]["ItemNo"], Charset::Alignment::LEFT);
			countset.draw(std::to_string(count), position + Point<int16_t>(0, 20));
		}
	}

	void Icon::dragdraw(Point<int16_t> cursorpos) const
	{
		if (dragged)
			texture.draw(DrawArgument(cursorpos - cursoroffset, 0.5f));
	}

	void Icon::drop_on_stage() const
	{
		type->drop_on_stage();
	}

	void Icon::drop_on_equips(EquipSlot::Id eqslot) const
	{
		type->drop_on_equips(eqslot);
	}

	bool Icon::drop_on_items(InventoryType::Id tab, EquipSlot::Id eqslot, int16_t slot, bool equip) const
	{
		bool remove_icon = type->drop_on_items(tab, eqslot, slot, equip);

		if (remove_icon)
			Sound(Sound::Name::DRAGEND).play();

		return remove_icon;
	}

	void Icon::drop_on_bindings(Point<int16_t> cursorposition, bool remove) const
	{
		type->drop_on_bindings(cursorposition, remove);
	}

	void Icon::start_drag(Point<int16_t> offset)
	{
		cursoroffset = offset;
		dragged = true;

		Sound(Sound::Name::DRAGSTART).play();
	}

	void Icon::reset()
	{
		dragged = false;
	}

	void Icon::set_count(int16_t c)
	{
		count = c;

		type->set_count(count);
	}

	Icon::IconType Icon::get_type()
	{
		return type->get_type();
	}

	int16_t Icon::get_count() const
	{
		return count;
	}

	bool Icon::get_drag()
	{
		return dragged;
	}
}

================
File: IO/Components/Icon.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Graphics/Texture.h"

#include "../../Character/Inventory/Inventory.h"

#include <memory>

namespace ms
{
	class Icon
	{
	public:
		enum IconType : uint8_t
		{
			NONE,
			SKILL,
			EQUIP,
			ITEM,
			KEY,
			NUM_TYPES
		};

		class Type
		{
		public:
			virtual ~Type() {}

			virtual void drop_on_stage() const = 0;
			virtual void drop_on_equips(EquipSlot::Id eqslot) const = 0;
			virtual bool drop_on_items(InventoryType::Id tab, EquipSlot::Id eqslot, int16_t slot, bool equip) const = 0;
			virtual void drop_on_bindings(Point<int16_t> cursorposition, bool remove) const = 0;
			virtual void set_count(int16_t) = 0;
			virtual IconType get_type() = 0;
		};

		class NullType : public Type
		{
			void drop_on_stage() const override {}
			void drop_on_equips(EquipSlot::Id) const override {}
			bool drop_on_items(InventoryType::Id, EquipSlot::Id, int16_t, bool) const override { return true; }
			void drop_on_bindings(Point<int16_t>, bool) const override {}
			void set_count(int16_t) override {}
			IconType get_type() override { return IconType::NONE; }
		};

		Icon();
		Icon(std::unique_ptr<Type> type, Texture texture, int16_t count);

		void drop_on_stage() const;
		void drop_on_equips(EquipSlot::Id eqslot) const;
		bool drop_on_items(InventoryType::Id tab, EquipSlot::Id eqslot, int16_t slot, bool equip) const;
		void drop_on_bindings(Point<int16_t> cursorposition, bool remove) const;
		void set_count(int16_t count);
		IconType get_type();

		void draw(Point<int16_t> position) const;
		void dragdraw(Point<int16_t> cursorpos) const;
		void start_drag(Point<int16_t> offset);
		void reset();
		int16_t get_count() const;
		bool get_drag();

	private:
		std::unique_ptr<Type> type;
		bool showcount;
		int16_t count;

		Texture texture;
		bool dragged;
		Point<int16_t> cursoroffset;
	};
}

================
File: IO/Components/IconCover.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "IconCover.h"

namespace ms
{
	IconCover::IconCover(Type t, int32_t duration)
	{
		cover = ColorBox(30, 30, Color::Name::BLACK, 0.6f);

		if (duration <= Constants::TIMESTEP)
			scalestep = 1.0f;
		else
			scalestep = Constants::TIMESTEP * 1.0f / duration;

		type = t;

		switch (type)
		{
		case Type::BUFF:
			yscale.set(0.0f);
			break;
		case Type::COOLDOWN:
			yscale.set(1.0f);
			break;
		}
	}

	void IconCover::draw(Point<int16_t> position, float alpha) const
	{
		float interyscale = yscale.get(alpha);
		auto interheight = static_cast<int16_t>(30 * interyscale);

		if (interheight == 0)
			return;

		cover.draw(
			DrawArgument(
				position + Point<int16_t>(0, 30 - interheight),
				Point<int16_t>(30, interheight)
				)
			);
	}

	void IconCover::update()
	{
		switch (type)
		{
		case Type::BUFF:
			yscale += scalestep;

			if (yscale.last() >= 1.0f)
			{
				yscale.set(1.0f);
				scalestep = 0.0f;
			}

			break;
		case Type::COOLDOWN:
			yscale -= scalestep;

			if (yscale.last() <= 0.0f)
			{
				yscale.set(0.0f);
				scalestep = 0.0f;
			}

			break;
		}
	}
}

================
File: IO/Components/IconCover.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Graphics/Geometry.h"
#include "../../Template/Interpolated.h"

namespace ms
{
	// A transparent rectangle with icon size (30x30)
	class IconCover
	{
	public:
		enum Type
		{
			BUFF,
			COOLDOWN
		};

		IconCover(Type type, int32_t duration);

		void draw(Point<int16_t> position, float alpha) const;
		void update();

	private:
		ColorBox cover;
		Linear<float> yscale;
		float scalestep;
		Type type;
	};
}

================
File: IO/Components/ItemTooltip.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "ItemTooltip.h"

#include "../../Constants.h"

#include "../../Data/ItemData.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	// TODO: Add blue dot next to name
	ItemTooltip::ItemTooltip()
	{
		nl::node Item = nl::nx::UI["UIToolTip.img"]["Item"];
		nl::node Frame = Item["Frame2"];
		nl::node ItemIcon = Item["ItemIcon"];

		frame = Frame;
		cover = Frame["cover"];
		base = ItemIcon["base"];
		itemcover = ItemIcon["cover"];
		type[true] = ItemIcon["new"];
		type[false] = ItemIcon["old"];

		itemid = 0;
	}

	bool ItemTooltip::set_item(int32_t iid)
	{
		if (itemid == iid)
			return false;

		itemid = iid;

		if (itemid == 0)
			return false;

		const ItemData& idata = ItemData::get(itemid);

		itemicon = idata.get_icon(false);
		untradable = idata.is_untradable();
		unique = idata.is_unique();

		std::string quality = "";

		if (unique && untradable)
			quality = "One-of-a-kind Item, Untradable";
		else if (unique && !untradable)
			quality = "One-of-a-kind Item";
		else if (!unique && untradable)
			quality = "Untradable";
		else
			quality = "";

		name = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::WHITE, idata.get_name(), 240);
		desc = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::WHITE, idata.get_desc(), 185);
		qual = Text(Text::Font::A12M, Text::Alignment::CENTER, Color::Name::ORANGE, quality, 185);

		fillwidth = 264;
		fillheight = 83 + name.height();
		descdelta = desc.height() - 80;

		if (descdelta > 0)
			fillheight += descdelta;

		return true;
	}

	void ItemTooltip::draw(Point<int16_t> pos) const
	{
		if (itemid == 0)
			return;

		int16_t max_width = Constants::Constants::get().get_viewwidth();
		int16_t max_height = Constants::Constants::get().get_viewheight();
		int16_t cur_width = pos.x() + fillwidth + 32;
		int16_t cur_height = pos.y() + fillheight + 40;

		int16_t adj_x = cur_width - max_width;
		int16_t adj_y = cur_height - max_height;

		int16_t adj_d = descdelta > 0 ? descdelta : 0;
		int16_t adj_t = (untradable || unique) ? 19 : 0;

		if (adj_x > 0)
			pos.shift_x(adj_x * -1);

		if (adj_y > 0)
			pos.shift_y(adj_y * -1);

		frame.draw(pos + Point<int16_t>(150, 118 + adj_d + adj_t), fillwidth, fillheight + adj_t);
		cover.draw(pos + Point<int16_t>(4, 4));
		name.draw(pos + Point<int16_t>(22, 8));

		if (untradable || unique)
			qual.draw(pos + Point<int16_t>(148, 27));

		pos.shift(14, 18 + name.height() + adj_t);

		base.draw(pos);
		type[true].draw(pos);
		itemicon.draw(DrawArgument(pos + Point<int16_t>(8, 72), 2.0f, 2.0f));
		itemcover.draw(pos);
		desc.draw(pos + Point<int16_t>(90, -6));
	}
}

================
File: IO/Components/ItemTooltip.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Tooltip.h"

#include "../Components/MapleFrame.h"

#include "../../Graphics/Text.h"
#include "../../Template/BoolPair.h"

namespace ms
{
	class ItemTooltip : public Tooltip
	{
	public:
		ItemTooltip();

		void draw(Point<int16_t> position) const override;

		bool set_item(int32_t itemid);

	private:
		int32_t itemid;
		int16_t fillwidth;
		int16_t fillheight;
		int16_t descdelta;
		Texture itemicon;

		Text name;
		Text desc;
		Text qual;
		MapleFrame frame;
		Texture cover;
		Texture base;
		Texture itemcover;
		BoolPair<Texture> type;
		bool untradable;
		bool unique;
	};
}

================
File: IO/Components/MapleButton.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapleButton.h"

namespace ms
{
	MapleButton::MapleButton(nl::node src, Point<int16_t> pos)
	{
		nl::node normal = src["normal"];

		if (normal.size() > 1)
			animations[Button::State::NORMAL] = normal;
		else
			textures[Button::State::NORMAL] = normal["0"];

		textures[Button::State::PRESSED] = src["pressed"]["0"];
		textures[Button::State::MOUSEOVER] = src["mouseOver"]["0"];
		textures[Button::State::DISABLED] = src["disabled"]["0"];

		active = true;
		position = pos;
		state = Button::State::NORMAL;
	}

	MapleButton::MapleButton(nl::node src, int16_t x, int16_t y) : MapleButton(src, Point<int16_t>(x, y)) {}
	MapleButton::MapleButton(nl::node src) : MapleButton(src, Point<int16_t>()) {}

	void MapleButton::draw(Point<int16_t> parentpos) const
	{
		if (active)
		{
			textures[state].draw(position + parentpos);
			animations[state].draw(position + parentpos, 1.0f);
		}
	}

	void MapleButton::update()
	{
		if (active)
			animations[state].update(6);
	}

	Rectangle<int16_t> MapleButton::bounds(Point<int16_t> parentpos) const
	{
		Point<int16_t> lt;
		Point<int16_t> rb;

		if (textures[state].is_valid())
		{
			lt = parentpos + position - textures[state].get_origin();
			rb = lt + textures[state].get_dimensions();
		}
		else
		{
			lt = parentpos + position - animations[state].get_origin();
			rb = lt + animations[state].get_dimensions();
		}

		return Rectangle<int16_t>(lt, rb);
	}

	int16_t MapleButton::width() const
	{
		return textures[state].width();
	}

	Point<int16_t> MapleButton::origin() const
	{
		return textures[state].get_origin();
	}
}

================
File: IO/Components/MapleButton.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Button.h"

namespace ms
{
	// A standard MapleStory button with 4 states and a texture for each state
	class MapleButton : public Button
	{
	public:
		MapleButton(nl::node src, Point<int16_t> position);
		MapleButton(nl::node src, int16_t x, int16_t y);
		MapleButton(nl::node src);

		void draw(Point<int16_t> position) const;
		void update();
		Rectangle<int16_t> bounds(Point<int16_t> parentpos) const;
		int16_t width() const;
		Point<int16_t> origin() const;
		Cursor::State send_cursor(bool, Point<int16_t>) { return Cursor::State::IDLE; }

	private:
		Texture textures[Button::State::NUM_STATES];
		Animation animations[Button::State::NUM_STATES];
	};
}

================
File: IO/Components/MapleComboBox.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapleComboBox.h"

#include "AreaButton.h"

#include "../../Audio/Audio.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	MapleComboBox::MapleComboBox(Type type, std::vector<std::string> o, uint16_t default_option, Point<int16_t> ppos, Point<int16_t> pos, int64_t w) : options(o), selected_index(default_option), parentpos(ppos), rwidth(w)
	{
		std::string combobox = "ComboBox";

		if (type != Type::DEFAULT)
			combobox += std::to_string(type);

		nl::node src = nl::nx::UI["Basic.img"][combobox];

		textures[Button::State::PRESSED][0] = src["pressed"][0];
		textures[Button::State::PRESSED][1] = src["pressed"][1];
		textures[Button::State::PRESSED][2] = src["pressed"][2];

		textures[Button::State::MOUSEOVER][0] = src["mouseOver"][0];
		textures[Button::State::MOUSEOVER][1] = src["mouseOver"][1];
		textures[Button::State::MOUSEOVER][2] = src["mouseOver"][2];

		textures[Button::State::NORMAL][0] = src["normal"][0];
		textures[Button::State::NORMAL][1] = src["normal"][1];
		textures[Button::State::NORMAL][2] = src["normal"][2];

		textures[Button::State::DISABLED][0] = src["disabled"][0];
		textures[Button::State::DISABLED][1] = src["disabled"][1];
		textures[Button::State::DISABLED][2] = src["disabled"][2];

		for (std::string option : options)
			option_text.push_back(Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::BLACK, option));

		Text::Font selected_font = Text::Font::A12M;
		Color::Name selected_color = Color::Name::BLACK;
		selected_adj = Point<int16_t>(2, -3);

		if (type == Type::BLACKL)
		{
			selected_font = Text::Font::A11M;
			selected_color = Color::Name::WHITE;
			selected_adj = Point<int16_t>(11, 2);
		}

		selected = Text(selected_font, Text::Alignment::LEFT, selected_color, options[selected_index]);

		state = Button::State::NORMAL;
		background = ColorBox(width(), options.size() * HEIGHT, Color::Name::DUSTYGRAY, 1.0f);
		rect = ColorBox(width() - 2, options.size() * HEIGHT - 2, Color::Name::GALLERY, 1.0f);
		current_rect = ColorBox(width() - 2, HEIGHT - 2, Color::Name::GRAYOLIVE, 1.0f);

		Point<int16_t> option_pos = Point<int16_t>(position.x(), position.y() + textures[state][0].get_dimensions().y()) + parentpos;

		for (size_t i = 0; i < option_text.size(); i++)
			buttons[i] = std::make_unique<AreaButton>(Point<int16_t>(option_pos.x() + 1, option_pos.y() + (i * HEIGHT) + 1), Point<int16_t>(width() - 2, HEIGHT - 2));

		current_pos = 0;
		current_shown = false;
		last_shown = 0;

		position = pos;
		active = true;
		pressed = false;
	}

	void MapleComboBox::draw(Point<int16_t>) const
	{
		if (active)
		{
			Point<int16_t> lpos = Point<int16_t>(position + parentpos);

			textures[state][0].draw(lpos);
			lpos.shift_x(textures[state][0].width());

			int16_t middle_width = textures[state][1].width();
			int16_t current_width = middle_width;

			while (current_width < rwidth)
			{
				textures[state][1].draw(lpos);
				lpos.shift_x(middle_width);
				current_width += middle_width;
			}

			textures[state][2].draw(lpos);

			selected.draw(Point<int16_t>(position + parentpos) + selected_adj);

			if (pressed)
			{
				Point<int16_t> pos = Point<int16_t>(position.x(), position.y() + textures[state][0].get_dimensions().y()) + parentpos;

				background.draw(pos + Point<int16_t>(0, 2));
				rect.draw(pos + Point<int16_t>(1, 3));

				if (current_shown)
					current_rect.draw(DrawArgument(pos.x() + 1, pos.y() + current_pos + 3));

				for (size_t i = 0; i < option_text.size(); i++)
					option_text[i].draw(DrawArgument(pos.x() + 6, pos.y() + (i * HEIGHT) - 4));
			}
		}
	}

	Rectangle<int16_t> MapleComboBox::bounds(Point<int16_t>) const
	{
		auto lt = parentpos + position - origin();
		auto rb = lt + textures[state][0].get_dimensions();

		auto end = textures[state][2].get_dimensions();

		rb = Point<int16_t>(rb.x() + end.x() + rwidth, rb.y());

		return Rectangle<int16_t>(lt, rb);
	}

	int16_t MapleComboBox::width() const
	{
		return textures[state][0].width() + textures[state][2].width() + rwidth;
	}

	Point<int16_t> MapleComboBox::origin() const
	{
		return textures[state][0].get_origin();
	}

	Cursor::State MapleComboBox::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		Cursor::State ret = clicked ? Cursor::State::CLICKING : Cursor::State::IDLE;

		current_shown = false;
		option_text[last_shown].change_color(Color::Name::BLACK);

		for (auto& btit : buttons)
		{
			if (btit.second->is_active() && btit.second->bounds(position).contains(cursorpos))
			{
				if (btit.second->get_state() == Button::State::NORMAL)
				{
					Sound(Sound::Name::BUTTONOVER).play();

					btit.second->set_state(Button::State::MOUSEOVER);
					ret = Cursor::State::CANCLICK;
				}
				else if (btit.second->get_state() == Button::State::MOUSEOVER)
				{
					if (clicked)
					{
						Sound(Sound::Name::BUTTONCLICK).play();

						btit.second->set_state(button_pressed(btit.first));

						ret = Cursor::State::IDLE;
					}
					else
					{
						ret = Cursor::State::CANCLICK;
						current_pos = btit.first * HEIGHT;
						current_shown = true;
						last_shown = btit.first;
						option_text[btit.first].change_color(Color::Name::WHITE);
					}
				}
			}
			else if (btit.second->get_state() == Button::State::MOUSEOVER)
			{
				btit.second->set_state(Button::State::NORMAL);
			}
		}

		return ret;
	}

	bool MapleComboBox::in_combobox(Point<int16_t> cursorpos)
	{
		Point<int16_t> lt = Point<int16_t>(position.x() + 1, position.y() + textures[state][0].get_dimensions().y() + 1) + parentpos;
		Point<int16_t> rb = lt + Point<int16_t>(width() - 2, options.size() * HEIGHT - 2);

		return Rectangle<int16_t>(lt, rb).contains(cursorpos);
	}

	uint16_t MapleComboBox::get_selected() const
	{
		return selected_index;
	}

	Button::State MapleComboBox::button_pressed(uint16_t buttonid)
	{
		selected_index = buttonid;

		selected.change_text(options[selected_index]);

		toggle_pressed();

		return Button::State::NORMAL;
	}
}

================
File: IO/Components/MapleComboBox.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Button.h"

#include "../../Graphics/Geometry.h"

#include <memory>

namespace ms
{
	// A standard MapleStory combo box with four states and three textures for each state
	class MapleComboBox : public Button
	{
	public:
		enum Type : uint8_t
		{
			DEFAULT = 1,
			BROWN = 3,
			BLUENEG,
			DEFAULT2,
			BLACKM,
			BLACKL,
			BLACKS,
			BROWNNEG,
			BLACKL2,
			GREENNEG
		};

		MapleComboBox(Type type, std::vector<std::string> options, uint16_t default_option, Point<int16_t> parentpos, Point<int16_t> position, int64_t width);

		void draw(Point<int16_t> parentpos) const override;
		void update() {}
		Rectangle<int16_t> bounds(Point<int16_t> parentpos) const override;
		int16_t width() const override;
		Point<int16_t> origin() const override;
		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;
		bool in_combobox(Point<int16_t> cursorpos) override;
		uint16_t get_selected() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid);

	private:
		enum Buttons : uint16_t
		{
			OPTION1,
			OPTION2,
			OPTION3,
			OPTION4,
			OPTION5,
			OPTION6,
			OPTION7,
			OPTION8,
			OPTION9,
			OPTION10
		};

		Texture textures[Button::State::NUM_STATES][3];
		std::vector<std::string> options;
		std::vector<Text> option_text;
		Text selected;
		ColorBox background;
		ColorBox rect;
		ColorBox current_rect;
		uint16_t rwidth;
		static constexpr uint16_t HEIGHT = 16;
		std::map<uint16_t, std::unique_ptr<Button>> buttons;
		uint16_t current_pos;
		bool current_shown;
		uint16_t last_shown;
		uint16_t selected_index;
		Point<int16_t> selected_adj;
		Point<int16_t> parentpos;
	};
}

================
File: IO/Components/MapleFrame.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapleFrame.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	MapleFrame::MapleFrame(nl::node src)
	{
		center = src["c"];
		east = src["e"];
		northeast = src["ne"];
		north = src["n"];
		northwest = src["nw"];
		west = src["w"];
		southwest = src["sw"];
		south = src["s"];
		southeast = src["se"];

		xtile = std::max<int16_t>(north.width(), 1);
		ytile = std::max<int16_t>(west.height(), 1);
	}

	void MapleFrame::draw(Point<int16_t> position, int16_t rwidth, int16_t rheight) const
	{
		int16_t numhor = rwidth / xtile + 2;
		int16_t numver = rheight / ytile;
		int16_t width = numhor * xtile;
		int16_t height = numver * ytile;
		int16_t left = position.x() - width / 2;
		int16_t top = position.y() - height;
		int16_t right = left + width;
		int16_t bottom = top + height;

		northwest.draw(DrawArgument(left, top));
		southwest.draw(DrawArgument(left, bottom));

		for (int16_t y = top; y < bottom; y += ytile)
		{
			west.draw(DrawArgument(left, y));
			east.draw(DrawArgument(right, y));
		}

		center.draw(DrawArgument(Point<int16_t>(left, top), Point<int16_t>(width, height)));

		for (int16_t x = left; x < right; x += xtile)
		{
			north.draw(DrawArgument(x, top));
			south.draw(DrawArgument(x, bottom));
		}

		northeast.draw(DrawArgument(right, top));
		southeast.draw(DrawArgument(right, bottom));
	}
}

================
File: IO/Components/MapleFrame.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Graphics/Texture.h"

namespace ms
{
	class MapleFrame
	{
	public:
		MapleFrame() {}
		MapleFrame(nl::node src);

		void draw(Point<int16_t> position, int16_t width, int16_t height) const;

	private:
		Texture center;
		Texture east;
		Texture northeast;
		Texture north;
		Texture northwest;
		Texture west;
		Texture southwest;
		Texture south;
		Texture southeast;
		int16_t xtile;
		int16_t ytile;
	};
}

================
File: IO/Components/MapTooltip.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapTooltip.h"

#include "../../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	// TODO: Get number of available quests
	MapTooltip::MapTooltip() : parent(Tooltip::Parent::NONE), title(""), description(""), fillwidth(0), fillheight(0)
	{
		nl::node Frame = nl::nx::UI["UIToolTip.img"]["Item"]["Frame2"];
		nl::node WorldMap = nl::nx::UI["UIWindow2.img"]["ToolTip"]["WorldMap"];

		frame = Frame;
		cover = Frame["cover"];
		Mob = WorldMap["Mob"];
		Npc = WorldMap["Npc"];

		// TODO: Get list of where party members are
		//Party = WorldMap["Party"];
	}

	void MapTooltip::draw(Point<int16_t> position) const
	{
		if (title_label.empty())
			return;

		int16_t max_width = Constants::Constants::get().get_viewwidth();
		int16_t max_height = Constants::Constants::get().get_viewheight();
		int16_t cur_width = position.x() + fillwidth + 14 + 9 + 17;
		int16_t cur_height = position.y() + fillheight + 14 + 4 + 6;
		int16_t adj_x = cur_width - max_width;
		int16_t adj_y = cur_height - max_height;

		if (adj_x > 0)
			position.shift_x(adj_x * -1);

		if (adj_y > 0)
			position.shift_y(adj_y * -1);

		// Shift everything so the cursor is in the top left corner
		position.shift(Point<int16_t>(20, -3));

		switch (parent)
		{
			case Tooltip::Parent::WORLDMAP:
				draw_worldmap(position);
				break;
			case Tooltip::Parent::MINIMAP:
				draw_minimap(position);
				break;
			default:
				break;
		}
	}

	void MapTooltip::set_title(Tooltip::Parent p, std::string t, bool bolded)
	{
		if (parent == p && title == t)
			return;

		parent = p;
		title = t;

		if (title.empty())
			return;

		switch (parent)
		{
			case Tooltip::Parent::WORLDMAP:
				set_worldmap_title(bolded);
				break;
			case Tooltip::Parent::MINIMAP:
				set_minimap_title(bolded);
				break;
			default:
				break;
		}
	}

	void MapTooltip::set_desc(std::string d)
	{
		if (description == d)
			return;

		description = d;

		if (description.empty())
			return;

		switch (parent)
		{
			case Tooltip::Parent::WORLDMAP:
				set_worldmap_desc();
				break;
			case Tooltip::Parent::MINIMAP:
				set_minimap_desc();
				break;
			default:
				break;
		}
	}

	void MapTooltip::set_mapid(int32_t mapid, bool portal)
	{
		std::unordered_map<int64_t, std::pair<std::string, std::string>> life = NxHelper::Map::get_life_on_map(mapid);

		switch (parent)
		{
			case Tooltip::Parent::WORLDMAP:
				set_worldmap_mapid(life, portal);
				break;
			case Tooltip::Parent::MINIMAP:
				set_minimap_mapid(life, portal);
				break;
			default:
				break;
		}
	}

	void MapTooltip::reset()
	{
		parent = Tooltip::Parent::NONE;

		title = "";
		title_label.change_text("");

		description = "";
		desc_label.change_text("");

		for (uint8_t i = 0; i < MAX_LIFE; i++)
		{
			mob_labels[i].change_text("");
			npc_labels[i].change_text("");
		}

		fillwidth = 0;
		fillheight = 0;
	}

	void MapTooltip::draw_worldmap(Point<int16_t> position) const
	{
		int16_t width = fillwidth - 8;
		int16_t halfwidth = width / 2;

		frame.draw(position + Point<int16_t>(halfwidth, fillheight) + Point<int16_t>(14, 14), width, fillheight);
		cover.draw(position + Point<int16_t>(0, 1));

		position.shift(Point<int16_t>(9, 4));

		title_label.draw(position + Point<int16_t>(halfwidth + 5, 0));

		if (!desc_label.empty())
		{
			position.shift_y(title_label.height() + 5);

			desc_label.draw(position + Point<int16_t>(-1, 0));
			position.shift_y(desc_label.height());
		}
		else
		{
			position.shift_y(title_label.height() - 2);
		}

		for (uint8_t i = 0; i < MAX_LIFE; i++)
		{
			Text mob = mob_labels[i];

			if (!mob.empty())
			{
				if (i == 0) {
					separator.draw(position + SEPARATOR_ADJ);
					position.shift_y(10);

					Mob.draw(position + LIFE_ICON_ADJ);
				}

				mob.draw(position + LIFE_LABEL_ADJ);
				position.shift_y(mob.height() + 1);
			}
		}

		if (!mob_labels->empty() && !npc_labels->empty())
			position.shift_y(-2);

		for (uint8_t i = 0; i < MAX_LIFE; i++)
		{
			Text npc = npc_labels[i];

			if (!npc.empty())
			{
				if (i == 0) {
					separator.draw(position + SEPARATOR_ADJ);
					position.shift_y(10);

					Npc.draw(position + LIFE_ICON_ADJ);
				}

				npc.draw(position + LIFE_LABEL_ADJ);
				position.shift_y(npc.height() + 1);
			}
		}
	}

	void MapTooltip::draw_minimap(Point<int16_t> position) const
	{
		bool desc_empty = desc_label.empty();

		if (desc_empty && mob_labels->empty() && npc_labels->empty())
		{
			int16_t width = fillwidth - 12;
			int16_t halfwidth = width / 2;

			int16_t height = fillheight - title_label.height();

			frame.draw(position + Point<int16_t>(halfwidth, height) + Point<int16_t>(14, 14), width, height);

			position.shift(Point<int16_t>(9, 2));

			title_label.draw(position + Point<int16_t>(halfwidth + 5, 0));
		}
		else
		{
			int16_t width = fillwidth - (!desc_empty ? 12 : 8);
			int16_t halfwidth = width / 2;

			int16_t height = fillheight - 2;

			frame.draw(position + Point<int16_t>(halfwidth, height) + Point<int16_t>(14, 14), width, height);
			cover.draw(position + Point<int16_t>(0, 1));

			if (!desc_empty)
				position.shift(Point<int16_t>(7, 2));
			else
				position.shift(Point<int16_t>(9, 4));

			title_label.draw(position + Point<int16_t>(halfwidth + 7, 0));
			position.shift_y(title_label.height());

			if (!desc_empty)
			{
				separator.draw(position + SEPARATOR_ADJ - Point<int16_t>(0, 8));

				desc_label.draw(position + Point<int16_t>(halfwidth + 7, 0));
				position.shift_y(desc_label.height());
			}

			for (uint8_t i = 0; i < MAX_LIFE; i++)
			{
				Text mob = mob_labels[i];

				if (!mob.empty())
				{
					if (i == 0) {
						separator.draw(position + SEPARATOR_ADJ - Point<int16_t>(0, 2));
						position.shift_y(8);

						Mob.draw(position + LIFE_ICON_ADJ);
					}

					mob.draw(position + LIFE_LABEL_ADJ);
					position.shift_y(mob.height() + 1);
				}
			}

			for (uint8_t i = 0; i < MAX_LIFE; i++)
			{
				Text npc = npc_labels[i];

				if (!npc.empty())
				{
					if (i == 0) {
						separator.draw(position + SEPARATOR_ADJ - Point<int16_t>(0, 2));
						position.shift_y(8);

						Npc.draw(position + LIFE_ICON_ADJ);
					}

					npc.draw(position + LIFE_LABEL_ADJ);
					position.shift_y(npc.height() + 1);
				}
			}
		}
	}

	void MapTooltip::set_worldmap_title(bool bolded)
	{
		fillwidth = 206;
		title_label = Text(bolded ? Text::Font::A12B : Text::Font::A12M, Text::Alignment::CENTER, Color::Name::WHITE, title);

		int16_t width = title_label.width();
		int16_t height = title_label.height();

		if (width > fillwidth)
			fillwidth = width;

		separator = ColorLine(fillwidth, Color::Name::WHITE, 0.40f, false);

		if (height > fillheight)
			fillheight = height;
	}

	void MapTooltip::set_minimap_title(bool)
	{
		title_label = Text(Text::Font::A12M, Text::Alignment::CENTER, Color::Name::WHITE, title);

		int16_t width = title_label.width();
		int16_t height = title_label.height();

		if (width > fillwidth)
			fillwidth = width;

		separator = ColorLine(fillwidth, Color::Name::WHITE, 0.40f, false);

		if (height > fillheight)
			fillheight = height;
	}

	void MapTooltip::set_worldmap_desc()
	{
		desc_label = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::WHITE, description, fillwidth);

		int16_t width = desc_label.width();
		int16_t height = desc_label.height();

		if (width > fillwidth)
			fillwidth = width;

		separator = ColorLine(fillwidth, Color::Name::WHITE, 0.40f, false);

		if (height > fillheight)
			fillheight = height;
	}

	void MapTooltip::set_minimap_desc()
	{
		desc_label = Text(Text::Font::A12M, Text::Alignment::CENTER, Color::Name::WHITE, description);

		int16_t width = desc_label.width();
		int16_t height = desc_label.height();

		if (width > fillwidth)
			fillwidth = width;

		separator = ColorLine(fillwidth, Color::Name::WHITE, 0.40f, false);

		if (height > fillheight)
			fillheight = height;
	}

	void MapTooltip::set_worldmap_mapid(std::unordered_map<int64_t, std::pair<std::string, std::string>> life, bool)
	{
		int32_t m = 0;
		int32_t n = 0;
		bool desc_empty = desc_label.empty();

		if (!desc_empty)
			fillheight += title_label.height() + 7;

		for (auto& l : life)
		{
			auto& life_object = l.second;

			if (life_object.first == "m" && m < MAX_LIFE)
			{
				mob_labels[m] = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::CHARTREUSE, life_object.second);
				fillheight += mob_labels->height() + 1;

				m++;
			}
			else if (life_object.first == "n" && n < MAX_LIFE)
			{
				npc_labels[n] = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::MALIBU, life_object.second);

				if (m > 0 && n == 0)
					fillheight += 8;

				fillheight += npc_labels->height() + 1;

				n++;
			}
		}

		fillheight -= 3;

		if (desc_empty && m == 0 && n == 0)
			fillheight -= 8;
	}

	void MapTooltip::set_minimap_mapid(std::unordered_map<int64_t, std::pair<std::string, std::string>> life, bool portal)
	{
		int32_t m = 0;
		int32_t n = 0;
		bool desc_empty = desc_label.empty();

		if (portal && !desc_empty)
			fillheight += title_label.height() + 7;

		for (auto& l : life)
		{
			auto& life_object = l.second;

			if (life_object.first == "m" && m < MAX_LIFE)
			{
				mob_labels[m] = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::CHARTREUSE, life_object.second);

				int16_t width = mob_labels[m].width() + Mob.width() + 8;

				if (width > fillwidth)
					fillwidth = width;

				separator = ColorLine(fillwidth, Color::Name::WHITE, 0.40f, false);
				fillheight += mob_labels->height() + 1;

				m++;
			}
			else if (life_object.first == "n" && n < MAX_LIFE)
			{
				npc_labels[n] = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::MALIBU, life_object.second);

				int16_t width = npc_labels[n].width() + Npc.width() + 8;

				if (width > fillwidth)
					fillwidth = width;

				separator = ColorLine(fillwidth, Color::Name::WHITE, 0.40f, false);

				if (m > 0 && n == 0)
					fillheight += 8;

				fillheight += npc_labels->height() + 1;

				n++;
			}
		}

		if (portal)
		{
			fillheight -= 1;

			if (desc_empty && m == 0 && n == 0)
				fillheight -= 8;
		}
	}
}

================
File: IO/Components/MapTooltip.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "MapleFrame.h"
#include "Tooltip.h"

#include "../../Graphics/Geometry.h"

namespace ms
{
	class MapTooltip : public Tooltip
	{
	public:
		MapTooltip();

		void draw(Point<int16_t> position) const override;

		void set_title(Tooltip::Parent parent, std::string title, bool bolded);
		void set_desc(std::string description);
		void set_mapid(int32_t mapid, bool portal);

		void reset();

	private:
		static constexpr uint8_t MAX_LIFE = 10u;
		static constexpr Point<int16_t> SEPARATOR_ADJ = Point<int16_t>(1, 10);
		static constexpr Point<int16_t> LIFE_LABEL_ADJ = Point<int16_t>(16, 3);
		static constexpr Point<int16_t> LIFE_ICON_ADJ = Point<int16_t>(1, 9);

		void draw_worldmap(Point<int16_t> position) const;
		void draw_minimap(Point<int16_t> position) const;

		void set_worldmap_title(bool bolded);
		void set_minimap_title(bool bolded);
		void set_worldmap_desc();
		void set_minimap_desc();
		void set_worldmap_mapid(std::unordered_map<int64_t, std::pair<std::string, std::string>> life, bool portal);
		void set_minimap_mapid(std::unordered_map<int64_t, std::pair<std::string, std::string>> life, bool portal);

		MapleFrame frame;

		Texture cover;
		Texture Mob;
		Texture Npc;
		//Texture Party;

		Tooltip::Parent parent;

		std::string title;
		std::string description;

		Text title_label;
		Text desc_label;
		Text mob_labels[MAX_LIFE];
		Text npc_labels[MAX_LIFE];

		int16_t fillwidth;
		int16_t fillheight;

		ColorLine separator;
	};
}

================
File: IO/Components/NameTag.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "NameTag.h"

namespace ms
{
	NameTag::NameTag(nl::node src, Text::Font f, std::string n)
	{
		name = OutlinedText(f, Text::Alignment::CENTER, Color::Name::EAGLE, Color::Name::JAMBALAYA);
		name.change_text(n);

		textures[false].push_back(src["0"]["0"]);
		textures[false].push_back(src["0"]["1"]);
		textures[false].push_back(src["0"]["2"]);

		textures[true].push_back(src["1"]["0"]);
		textures[true].push_back(src["1"]["1"]);
		textures[true].push_back(src["1"]["2"]);

		selected = false;
	}

	void NameTag::draw(Point<int16_t> position) const
	{
		position.shift(Point<int16_t>(1, 2));

		auto& tag = textures[selected];

		int16_t width = name.width();

		// If ever changing startpos, confirm with UICharSelect.cpp
		Point<int16_t> startpos = position - Point<int16_t>(6 + width / 2, 0);

		tag[0].draw(startpos);
		tag[1].draw(DrawArgument(startpos + Point<int16_t>(6, 0), Point<int16_t>(width, 0)));
		tag[2].draw(DrawArgument(startpos + Point<int16_t>(width + 6, 0)));

		name.draw(position);
	}

	void NameTag::set_selected(bool s)
	{
		selected = s;

		if (s)
			name.change_color(Color::Name::WHITE);
		else
			name.change_color(Color::Name::EAGLE);
	}
}

================
File: IO/Components/NameTag.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Graphics/SpecialText.h"
#include "../../Graphics/Texture.h"
#include "../../Template/BoolPair.h"

namespace ms
{
	class NameTag
	{
	public:
		NameTag(nl::node src, Text::Font font, std::string name);

		void draw(Point<int16_t> position) const;
		void set_selected(bool selected);

	private:
		OutlinedText name;
		BoolPair<std::vector<Texture>> textures;
		bool selected;
	};
}

================
File: IO/Components/NpcText.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////

// This will be moved into UINpcTalk.
// Keeping it so I can copypaste some code later.

/*
	size_t NpcText::parseL(std::string& str, size_t pos)
	{
		size_t next = str.find_first_of('#', pos + 2);
		if (next != std::string::npos)
		{
			try
			{
				//int32_t selection = std::stoi(str.substr(pos + 2, next - pos + 2));
				str.replace(str.begin() + pos, str.begin() + next + 1, "");
				return pos + 1;
			}
			catch (const std::exception&)
			{
				str.replace(str.begin() + pos, str.begin() + next + 1, "FORMATERROR");
				return pos + 11 + 1;
			}
		}
		else
		{
			str.replace(str.begin() + pos, str.begin() + pos + 2, "SYNTAXERROR");
			return pos + 11 + 1;
		}
	}

	size_t NpcText::parsez(std::string& str, size_t pos)
	{
		size_t next = str.find_first_of('#', pos + 2);
		if (next != std::string::npos)
		{
			try
			{
				const ItemData& idata = ItemData::get(std::stoi(str.substr(pos + 2, next)));
				if (idata.is_valid())
				{
					str.replace(str.begin() + pos, str.begin() + next + 1, idata.get_name());
					return pos + idata.get_name().length() + 1;
				}
				else
				{
					str.replace(str.begin() + pos, str.begin() + next + 1, "IDERROR");
					return pos + 7 + 1;
				}
			}
			catch (const std::exception&)
			{
				str.replace(str.begin() + pos, str.begin() + next + 1, "FORMATERROR");
				return pos + 11 + 1;
			}
		}
		else
		{
			str.replace(str.begin() + pos, str.begin() + pos + 2, "SYNTAXERROR");
			return pos + 11 + 1;
		}
	}

	size_t NpcText::parseh(std::string& str, size_t pos)
	{
		size_t next = str.find_first_of('#', pos + 2);
		if (next != std::string::npos)
		{
			try
			{
				int32_t type = std::stoi(str.substr(pos + 2, next - pos + 2));
				std::string insert;
				switch (type)
				{
				case 0:
					insert = Stage::get().get_player().get_stats().get_name();
					break;
				default:
					insert = "";
				}
				str.replace(str.begin() + pos, str.begin() + next + 1, insert);
				return pos + insert.length() + 1;
			}
			catch (const std::exception&)
			{
				str.replace(str.begin() + pos, str.begin() + next + 1, "FORMATERROR");
				return pos + 11 + 1;
			}
		}
		else
		{
			str.replace(str.begin() + pos, str.begin() + pos + 2, "SYNTAXERROR");
			return pos + 11 + 1;
		}
	}

	size_t NpcText::parsev(std::string& str, size_t pos)
	{
		size_t next = str.find_first_of('#', pos + 2);
		if (next != std::string::npos)
		{
			try
			{
				if (const ItemData& idata = ItemData::get(std::stoi(str.substr(pos + 2, next))))
				{
					Image image = { idata.get_icon(false), offset };
					image.texture.shift(Point<int16_t>(0, 32));
					images.push_back(image);
					offset.shift_x(32);
					str.replace(str.begin() + pos, str.begin() + next + 1, "");
					return pos + 1;
				}
				else
				{
					str.replace(str.begin() + pos, str.begin() + next + 1, "IDERROR");
					return pos + 7 + 1;
				}
			}
			catch (const std::exception&)
			{
				str.replace(str.begin() + pos, str.begin() + next + 1, "FORMATERROR");
				return pos + 11 + 1;
			}
		}
		else
		{
			str.replace(str.begin() + pos, str.begin() + pos + 2, "SYNTAXERROR");
			return pos + 11 + 1;
		}
	}

	void NpcText::draw(Point<int16_t> position) const
	{
		for (auto& line : lines)
		{
			line.text
				.draw(line.offset + position);
		}

		for (auto& image : images)
		{
			image.texture
				.draw(image.offset + position);
		}
	}

	int16_t NpcText::getheight() const
	{
		return offset.y();
	}
*/

================
File: IO/Components/ScrollingNotice.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "ScrollingNotice.h"

namespace ms
{
	ScrollingNotice::ScrollingNotice()
	{
		width = 800;
		background = ColorBox(width, 23, Color::Name::BLACK, 0.535f);
		notice = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::YELLOW);

		xpos.set(0.0);
		active = false;
	}

	void ScrollingNotice::setnotice(std::string n)
	{
		notice.change_text(n);
		xpos.set(static_cast<double>(width));
		active = n.size() > 0;
	}

	void ScrollingNotice::draw(float alpha) const
	{
		if (active)
		{
			int16_t interx = static_cast<int16_t>(std::round(xpos.get(alpha)));
			auto position = Point<int16_t>(interx, -1);

			background.draw(Point<int16_t>(0, 0));
			notice.draw(position);
		}
	}

	void ScrollingNotice::update()
	{
		if (active)
		{
			int16_t new_width = Constants::Constants::get().get_viewwidth();

			if (new_width != width)
			{
				width = new_width;
				background.setwidth(width);
				xpos.set(static_cast<double>(width));
			}

			xpos -= 0.5;

			auto xmin = static_cast<double>(-notice.width());

			if (xpos.last() < xmin)
				xpos.set(static_cast<double>(width));
		}
	}
}

================
File: IO/Components/ScrollingNotice.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Graphics/Geometry.h"
#include "../../Template/Interpolated.h"

namespace ms
{
	// The scrolling server notice at the top of the screen
	class ScrollingNotice
	{
	public:
		ScrollingNotice();

		void setnotice(std::string notice);
		void draw(float alpha) const;
		void update();

	private:
		ColorBox background;
		Text notice;
		Linear<double> xpos;
		bool active;
		int16_t width;
	};
}

================
File: IO/Components/SkillTooltip.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "SkillTooltip.h"

#include "../../Data/SkillData.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	SkillTooltip::SkillTooltip()
	{
		nl::node Frame = nl::nx::UI["UIToolTip.img"]["Item"]["Frame2"];

		frame = Frame;
		cover = Frame["cover"];

		skill_id = 0;
	}

	void SkillTooltip::set_skill(int32_t id, int32_t level, int32_t mlevel, int64_t expiration)
	{
		if (skill_id == id)
			return;

		skill_id = id;

		if (skill_id == 0)
			return;

		const SkillData& data = SkillData::get(id);

		int32_t masterlevel;

		if (mlevel > 0)
			masterlevel = mlevel;
		else
			masterlevel = data.get_masterlevel();

		std::string descstr = data.get_desc();

		if (masterlevel > 0)
		{
			const std::string mltag = "Master Level";
			const std::string mlstr = std::to_string(masterlevel);
			size_t mlstart = descstr.find(mltag);
			size_t mlpos = descstr.find(':', mlstart) + 2;
			size_t mlend = descstr.find("]", mlstart);

			if (mlpos < mlend && mlend != std::string::npos)
			{
				size_t mlsize = mlend - mlpos;
				descstr.erase(mlpos, mlsize);
				descstr.insert(mlpos, mlstr);

				// Fixing errors in the files...
				if (mlstart == 0)
				{
					descstr.insert(0, "[");
					mlend++;
				}

				size_t linebreak = descstr.find("]\\n", mlstart);

				if (linebreak != mlend)
					descstr.insert(mlend + 1, "\\n");
			}
			else
			{
				descstr.insert(0, "[" + mltag + ": " + mlstr + "]\\n");
			}
		}

		const std::string exptag = "#cAvailable until";

		if (expiration > 0)
		{
			// TODO: Blank
		}
		else
		{
			size_t expstart = descstr.find(exptag);
			size_t expend = descstr.find('#', expstart + 1);

			if (expstart < expend && expend != std::string::npos)
			{
				size_t expsize = expend - expstart + 1;
				descstr.erase(expstart, expsize);
			}
		}

		std::string levelstr;
		bool current = level > 0;
		bool next = level < masterlevel;

		if (current)
			levelstr += "[Current Level: " + std::to_string(level) + "]\\n" + data.get_level_desc(level);

		if (current && next)
			levelstr += "\\n";

		if (next)
			levelstr += "[Next Level: " + std::to_string(level + 1) + "]\\n" + data.get_level_desc(level + 1);

		icon = data.get_icon(SkillData::Icon::NORMAL);
		name = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::WHITE, data.get_name(), 320);
		desc = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::WHITE, descstr, 210);
		leveldesc = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::WHITE, levelstr, 290);

		int16_t desc_height = desc.height() + 11;

		icon_offset = name.height();
		level_offset = std::max<int16_t>(desc_height, 85);
		height = icon_offset + level_offset + leveldesc.height();

		int16_t icon_width = (icon.get_dimensions().x() * 2) + 4;
		width = 292;

		line = ColorLine(width + 16, Color::Name::WHITE, 1.0f, false);
		box = ColorBox(icon_width, icon_width, Color::Name::WHITE, 0.65f);
	}

	void SkillTooltip::draw(Point<int16_t> pos) const
	{
		if (skill_id == 0)
			return;

		int16_t max_width = Constants::Constants::get().get_viewwidth();
		int16_t max_height = Constants::Constants::get().get_viewheight();
		int16_t cur_width = pos.x() + width + 45;
		int16_t cur_height = pos.y() + height + 35;

		int16_t adj_x = cur_width - max_width;
		int16_t adj_y = cur_height - max_height;

		if (adj_x > 0)
			pos.shift_x(adj_x * -1);

		if (adj_y > 0)
			pos.shift_y(adj_y * -1);

		frame.draw(pos + Point<int16_t>(176, height + 11), width, height - 1);
		name.draw(pos + Point<int16_t>(33, 3));
		cover.draw(pos + Point<int16_t>(16, -1));

		pos.shift_y(icon_offset);

		box.draw(DrawArgument(pos + Point<int16_t>(26, 21)));
		icon.draw(DrawArgument(pos + Point<int16_t>(28, 87), 2.0f, 2.0f));
		desc.draw(pos + Point<int16_t>(102, 15));

		pos.shift_y(level_offset);

		line.draw(pos + Point<int16_t>(22, 10));
		leveldesc.draw(pos + Point<int16_t>(25, 11));
	}
}

================
File: IO/Components/SkillTooltip.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Tooltip.h"
#include "MapleFrame.h"

#include "../../Graphics/Geometry.h"

namespace ms
{
	class SkillTooltip : public Tooltip
	{
	public:
		SkillTooltip();

		void draw(Point<int16_t> position) const override;

		void set_skill(int32_t id, int32_t level, int32_t masterlevel, int64_t expiration);

	private:
		int32_t skill_id;
		int16_t height;
		int16_t width;
		int16_t icon_offset;
		int16_t level_offset;
		Texture icon;
		Texture required_icon;

		Text name;
		Text desc;
		Text leveldesc;
		MapleFrame frame;
		ColorLine line;
		ColorBox box;
		Texture cover;
	};
}

================
File: IO/Components/Slider.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Slider.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Slider::Slider(int32_t t, Range<int16_t> ver, int16_t xp, int16_t ur, int16_t rm, std::function<void(bool)> om) : type(t), vertical(ver), x(xp), onmoved(om)
	{
		start = Point<int16_t>(x, vertical.first());
		end = Point<int16_t>(x, vertical.second());

		nl::node src;
		std::string base_str = "base";

		if (type == Type::CHATBAR)
		{
			src = nl::nx::UI["StatusBar3.img"]["chat"]["common"]["scroll"];
			base_str += "_c";
		}
		else
		{
			std::string VScr = "VScr";

			if (type != Type::LINE_CYAN)
				VScr += std::to_string(type);

			src = nl::nx::UI["Basic.img"][VScr];
		}

		nl::node dsrc = src["disabled"];

		dbase = dsrc[base_str];

		dprev = dsrc["prev"];
		dnext = dsrc["next"];

		nl::node esrc = src["enabled"];

		base = esrc[base_str];

		prev = TwoSpriteButton(esrc["prev0"], esrc["prev1"], start);
		next = TwoSpriteButton(esrc["next0"], esrc["next1"], end);

		thumb = TwoSpriteButton(esrc["thumb0"], esrc["thumb1"]);

		buttonheight = dnext.get_dimensions().y();

		setrows(ur, rm);

		enabled = true;
		scrolling = false;
	}

	Slider::Slider() : Slider(0, {}, 0, 0, 0, {}) {}

	bool Slider::isenabled() const
	{
		return enabled;
	}

	void Slider::setenabled(bool en)
	{
		enabled = en;
	}

	void Slider::setrows(int16_t nr, int16_t ur, int16_t rm)
	{
		rowmax = rm - ur;

		if (rowmax > 0)
			rowheight = (vertical.length() - buttonheight * 2) / rowmax;
		else
			rowheight = 0;

		row = nr;
	}

	void Slider::setrows(int16_t ur, int16_t rm)
	{
		setrows(0, ur, rm);
	}

	void Slider::setvertical(Range<int16_t> ver)
	{
		vertical = ver;
		start = Point<int16_t>(x, vertical.first());
		end = Point<int16_t>(x, vertical.second());
		prev.set_position(start);
		next.set_position(end);

		if (rowmax > 0)
			rowheight = (vertical.length() - buttonheight * 2) / rowmax;
		else
			rowheight = 0;
	}

	Range<int16_t> Slider::getvertical() const
	{
		return vertical;
	}

	void Slider::draw(Point<int16_t> position) const
	{
		Point<int16_t> base_pos = position + start;
		Point<int16_t> fill = Point<int16_t>(0, vertical.length() + buttonheight - 2);
		DrawArgument base_arg = DrawArgument(Point<int16_t>(base_pos.x(), base_pos.y() + 1), fill);

		int16_t height = dbase.height();
		int16_t maxheight = vertical.first() + height;

		while (maxheight < vertical.second())
		{
			dbase.draw(position + Point<int16_t>(start.x(), maxheight));

			maxheight += height;
		}

		if (enabled)
		{
			if (rowheight > 0)
			{
				prev.draw(position);
				next.draw(position);
				thumb.draw(position + getthumbpos());
			}
			else
			{
				dprev.draw(position + start);
				dnext.draw(position + end);
			}
		}
		else
		{
			dprev.draw(position + start);
			dnext.draw(position + end);
		}
	}

	void Slider::remove_cursor()
	{
		scrolling = false;

		thumb.set_state(Button::State::NORMAL);
		next.set_state(Button::State::NORMAL);
		prev.set_state(Button::State::NORMAL);
	}

	Point<int16_t> Slider::getthumbpos() const
	{
		int16_t y =
			row < rowmax ?
			vertical.first() + row * rowheight + buttonheight :
			vertical.second() - buttonheight * 2 - 2;

		return Point<int16_t>(x, y);
	}

	Cursor::State Slider::send_cursor(Point<int16_t> cursor, bool pressed)
	{
		Point<int16_t> relative = cursor - start;

		if (scrolling)
		{
			if (pressed)
			{
				int16_t thumby = row * rowheight + buttonheight * 2;
				int16_t delta = relative.y() - thumby;

				if (delta > rowheight / 2 && row < rowmax)
				{
					row++;
					onmoved(false);
				}
				else if (delta < -rowheight / 2 && row > 0)
				{
					row--;
					onmoved(true);
				}

				return Cursor::State::VSCROLLIDLE;
			}
			else
			{
				scrolling = false;
			}
		}
		else if (relative.x() < 0 || relative.y() < 0 || relative.x() > 8 || relative.y() > vertical.second())
		{
			thumb.set_state(Button::State::NORMAL);
			next.set_state(Button::State::NORMAL);
			prev.set_state(Button::State::NORMAL);

			return Cursor::State::IDLE;
		}

		Point<int16_t> thumbpos = getthumbpos();

		if (thumb.bounds(thumbpos).contains(cursor))
		{
			if (pressed)
			{
				scrolling = true;
				thumb.set_state(Button::State::PRESSED);

				return Cursor::State::VSCROLLIDLE;
			}
			else
			{
				thumb.set_state(Button::State::NORMAL);

				return Cursor::State::VSCROLL;
			}
		}
		else
		{
			thumb.set_state(Button::State::NORMAL);
		}

		if (prev.bounds(Point<int16_t>()).contains(cursor))
		{
			if (pressed)
			{
				if (row > 0)
				{
					row--;
					onmoved(true);
				}

				prev.set_state(Button::State::PRESSED);

				return Cursor::State::VSCROLLIDLE;
			}
			else
			{
				prev.set_state(Button::State::MOUSEOVER);

				return Cursor::State::VSCROLL;
			}
		}
		else
		{
			prev.set_state(Button::State::NORMAL);
		}

		if (next.bounds(Point<int16_t>()).contains(cursor))
		{
			if (pressed)
			{
				if (row < rowmax)
				{
					row++;
					onmoved(false);
				}

				next.set_state(Button::State::PRESSED);

				return Cursor::State::VSCROLLIDLE;
			}
			else
			{
				next.set_state(Button::State::MOUSEOVER);

				return Cursor::State::VSCROLL;
			}
		}
		else
		{
			next.set_state(Button::State::NORMAL);
		}

		if (cursor.y() < vertical.second())
		{
			if (pressed)
			{
				auto yoffset = static_cast<double>(relative.y() - buttonheight * 2);
				auto cursorrow = static_cast<int16_t>(std::round(yoffset / rowheight));

				if (cursorrow < 0)
					cursorrow = 0;
				else if (cursorrow > rowmax)
					cursorrow = rowmax;

				int16_t delta = row - cursorrow;

				for (size_t i = 0; i < 2; i++)
				{
					if (delta > 0)
					{
						row--;
						delta--;
						onmoved(true);
					}

					if (delta < 0)
					{
						row++;
						delta++;
						onmoved(false);
					}
				}

				return Cursor::State::VSCROLLIDLE;
			}
		}

		return Cursor::State::VSCROLL;
	}

	void Slider::send_scroll(double yoffset)
	{
		if (yoffset < 0 && row < rowmax)
		{
			row++;
			onmoved(false);
		}

		if (yoffset > 0 && row > 0)
		{
			row--;
			onmoved(true);
		}
	}
}

================
File: IO/Components/Slider.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "TwoSpriteButton.h"

#include <functional>

namespace ms
{
	class Slider
	{
	public:
		Slider(int32_t type, Range<int16_t> vertical, int16_t x, int16_t unitrows, int16_t rowmax, std::function<void(bool upwards)> onmoved);
		Slider();

		bool isenabled() const;
		void setenabled(bool enabled);
		void setrows(int16_t newrow, int16_t unitrows, int16_t rowmax);
		void setrows(int16_t unitrows, int16_t rowmax);
		void setvertical(Range<int16_t> vertical);
		Range<int16_t> getvertical() const;

		void draw(Point<int16_t> position) const;
		void remove_cursor();
		Cursor::State send_cursor(Point<int16_t> cursor, bool pressed);
		void send_scroll(double yoffset);

		enum Type
		{
			/// Default
			LINE_CYAN,
			LINE_CONTESSA = 2,
			SMALL_HAVELOCKBLUE,
			NORMAL_CALYPSO,
			NORMAL_ROCKBLUE,
			LINE_PUNGA,
			LINE_YELLOWMETAL,
			NORMAL_JUDGEGRAY,
			DEFAULT_SILVER,
			LINE_MINESHAFT,
			DEFAULT_ALTO,
			DEFAULT_SANDAL,
			DEFAULT_QUICKSAND,
			LINE_HOTCINNAMON,
			THIN_DUSTYGRAY_LIGHT,
			THIN_MINESHAFT,
			THIN_DUSTYGRAY,
			THIN_MINESHAFT_LIGHT,
			THIN_WOODYBROWN,
			BLIZZARDBLUE,
			DEFAULT_ARROWTOWN = 100,
			THIN_ZORBA,
			ARROWS_IRISHCOFFEE,
			THIN_MIKADO,
			ARROWS_TORYBLUE,
			THIN_SLATEGRAY,
			/// Custom
			CHATBAR
		};

	private:
		Point<int16_t> getthumbpos() const;

		std::function<void(bool upwards)> onmoved;

		Range<int16_t> vertical;
		Point<int16_t> start;
		Point<int16_t> end;
		int16_t type;
		int16_t buttonheight;
		int16_t rowheight;
		int16_t x;
		int16_t row;
		int16_t rowmax;
		bool scrolling;
		bool enabled;

		Texture dbase;
		Texture dnext;
		Texture dprev;
		Texture base;
		TwoSpriteButton next;
		TwoSpriteButton prev;
		TwoSpriteButton thumb;
	};
}

================
File: IO/Components/StatefulIcon.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "StatefulIcon.h"

namespace ms
{
	StatefulIcon::StatefulIcon(std::unique_ptr<Type> type, Texture ntx, Texture dtx, Texture motx) : Icon(std::move(type), ntx, -1)
	{
		ntx.shift(Point<int16_t>(0, 32));
		dtx.shift(Point<int16_t>(0, 32));
		motx.shift(Point<int16_t>(0, 32));

		textures[State::NORMAL] = ntx;
		textures[State::DISABLED] = dtx;
		textures[State::MOUSEOVER] = motx;

		state = State::NORMAL;
	}

	Texture StatefulIcon::get_texture() const
	{
		return textures[state];
	}

	void StatefulIcon::set_state(State s)
	{
		state = s;
	}
}

================
File: IO/Components/StatefulIcon.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Icon.h"

namespace ms
{
	class StatefulIcon : public Icon
	{
	public:
		enum State : uint8_t
		{
			NORMAL,
			DISABLED,
			MOUSEOVER,
			LENGTH
		};

		class Type : public Icon::Type
		{
		public:
			virtual ~Type() {}

			virtual void set_state(State state) = 0;
		};

		class NullType : public Type
		{
			void drop_on_stage() const override {}
			void drop_on_equips(EquipSlot::Id) const override {}
			bool drop_on_items(InventoryType::Id, EquipSlot::Id, int16_t, bool) const override { return true; }
			void drop_on_bindings(Point<int16_t>, bool) const override {}
			void set_count(int16_t) override {}
			void set_state(State) override {}
			Icon::IconType get_type() override { return IconType::NONE; }
		};

		StatefulIcon() : StatefulIcon(std::make_unique<NullType>(), Texture(), Texture(), Texture()) {};
		StatefulIcon(std::unique_ptr<Type> type, Texture normal_tx, Texture disabled_tx, Texture mouseover_tx);

		Texture get_texture() const;

		void set_state(State state);

	private:
		State state;
		EnumMap<State, Texture> textures;
	};
}

================
File: IO/Components/Textfield.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Textfield.h"

#include "../UI.h"

#include <sstream>
#include <iostream>

namespace ms
{
	Textfield::Textfield()
	{
		text = "";
	}

	Textfield::Textfield(Text::Font font, Text::Alignment alignment, Color::Name text_color, Rectangle<int16_t> b, size_t limit, int16_t marker_height) : bounds(b), limit(limit)
	{
		textlabel = Text(font, alignment, text_color, "", 0, false);
		marker = ColorLine(marker_height, text_color, 1.0f, true);

#if LOG_LEVEL >= LOG_UI
		boundsoutline = ColorBox(bounds.width(), bounds.height(), Color::Name::RED, 0.5f);
#endif

		text = "";
		markerpos = 0;
		crypt = 0;
		state = State::NORMAL;
	}

	void Textfield::draw(Point<int16_t> position) const
	{
		draw(position, Point<int16_t>(0, 0));
	}

	void Textfield::draw(Point<int16_t> position, Point<int16_t> marker_adjust) const
	{
		Point<int16_t> absp = bounds.get_left_top();

#if LOG_LEVEL >= LOG_UI
		boundsoutline.draw(absp);
#endif

		if (state == State::DISABLED)
			return;

		absp.shift(position);

		if (text.size() > 0)
			textlabel.draw(absp);

		if (state == State::FOCUSED && showmarker)
		{
			Point<int16_t> mpos = absp + Point<int16_t>(textlabel.advance(markerpos) - 1, 8) + marker_adjust;

			if (crypt > 0)
				mpos.shift(1, -3);

			marker.draw(mpos);
		}
	}

	void Textfield::update()
	{
		if (state == State::DISABLED)
			return;

		elapsed += Constants::TIMESTEP;

		if (elapsed > 256)
		{
			showmarker = !showmarker;
			elapsed = 0;
		}
	}

	void Textfield::update(Point<int16_t> position, Point<int16_t> dimensions)
	{
		if (state == State::DISABLED)
			return;

		bounds = Rectangle<int16_t>(position, position + dimensions);

#if LOG_LEVEL >= LOG_UI
		boundsoutline.setwidth(bounds.width());
		boundsoutline.setheight(bounds.height());
#endif

		elapsed += Constants::TIMESTEP;

		if (elapsed > 256)
		{
			showmarker = !showmarker;
			elapsed = 0;
		}
	}

	void Textfield::set_state(State st)
	{
		if (state != st)
		{
			state = st;

			if (state != State::DISABLED)
			{
				elapsed = 0;
				showmarker = true;
			}
			else
			{
				UI::get().remove_textfield();
			}

			if (state == State::FOCUSED)
				UI::get().focus_textfield(this);
		}
	}

	void Textfield::set_enter_callback(std::function<void(std::string)> onr)
	{
		onreturn = onr;
	}

	void Textfield::set_key_callback(KeyAction::Id key, std::function<void(void)> action)
	{
		callbacks[key] = action;
	}

	void Textfield::set_text_callback(std::function<void(void)> action)
	{
		ontext = action;
	}

	void Textfield::send_key(KeyType::Id type, int32_t action, bool pressed)
	{
		if (pressed)
		{
			if (type == KeyType::Id::ACTION)
			{
				switch (action)
				{
					case KeyAction::Id::LEFT:
					{
						if (markerpos > 0)
							markerpos--;

						break;
					}
					case KeyAction::Id::RIGHT:
					{
						if (markerpos < text.size())
							markerpos++;

						break;
					}
					case KeyAction::Id::BACK:
					{
						if (text.size() > 0 && markerpos > 0)
						{
							text.erase(markerpos - 1, 1);

							markerpos--;

							modifytext(text);
						}

						break;
					}
					case KeyAction::Id::RETURN:
					{
						if (onreturn)
							onreturn(text);

						break;
					}
					case KeyAction::Id::SPACE:
					{
						add_string(" ");
						break;
					}
					case KeyAction::Id::HOME:
					{
						markerpos = 0;
						break;
					}
					case KeyAction::Id::END:
					{
						markerpos = text.size();
						break;
					}
					case KeyAction::Id::DELETE:
					{
						if (text.size() > 0 && markerpos < text.size())
						{
							text.erase(markerpos, 1);

							modifytext(text);
						}

						break;
					}
					default:
					{
						if (callbacks.count(action))
							callbacks.at(action)();

						break;
					}
				}
			}
			else if (type == KeyType::Id::TEXT)
			{
				if (ontext)
				{
					if (isdigit(action) || isalpha(action))
					{
						ontext();
						return;
					}
				}

				std::stringstream ss;
				char c = static_cast<int8_t>(action);

				ss << c;

				add_string(ss.str());
			}
		}
	}

	void Textfield::add_string(const std::string& str)
	{
		for (char c : str)
		{
			if (belowlimit())
			{
				text.insert(markerpos, 1, c);

				markerpos++;

				modifytext(text);
			}
		}
	}

	void Textfield::modifytext(const std::string& t)
	{
		if (crypt > 0)
		{
			std::string crypted;
			crypted.insert(0, t.size(), crypt);

			textlabel.change_text(crypted);
		}
		else
		{
			textlabel.change_text(t);
		}

		text = t;
	}

	Cursor::State Textfield::send_cursor(Point<int16_t> cursorpos, bool clicked)
	{
		if (state == State::DISABLED)
			return Cursor::State::IDLE;

		if (bounds.contains(cursorpos))
		{
			if (clicked)
			{
				if (state == State::NORMAL)
					set_state(State::FOCUSED);

				return Cursor::State::CLICKING;
			}
			else
			{
				return Cursor::State::CANCLICK;
			}
		}
		else
		{
#if LOG_LEVEL >= LOG_UI
			Point<int16_t> lt = bounds.get_left_top();
			int16_t lt_x = lt.x();
			int16_t lt_y = lt.y();

			Point<int16_t> rb = bounds.get_right_bottom();
			int16_t rb_x = rb.x();
			int16_t rb_y = rb.y();

			int16_t cur_x = cursorpos.x();
			int16_t cur_y = cursorpos.y();

			LOG(LOG_UI,
				"(" << lt_x << ", " << lt_y << ") != (" << rb_x << ", " << rb_y << ") && "
				<< cur_x << " >= (" << lt_x << ") && "
				<< cur_x << " <= (" << rb_x << ") && "
				<< cur_y << " >= (" << lt_y << ") && "
				<< cur_y << " <= (" << rb_y << ")");
#endif

			if (clicked && state == State::FOCUSED)
				set_state(State::NORMAL);

			return Cursor::State::IDLE;
		}
	}

	void Textfield::change_text(const std::string& t)
	{
		modifytext(t);

		markerpos = text.size();
	}

	void Textfield::set_cryptchar(int8_t character)
	{
		crypt = character;
	}

	void Textfield::set_limit(size_t l)
	{
		limit = l;
	}

	bool Textfield::belowlimit() const
	{
		if (limit > 0)
		{
			return text.size() < limit;
		}
		else
		{
			uint16_t advance = textlabel.advance(text.size());

			return (advance + 50) < bounds.get_horizontal().length();
		}
	}

	const std::string& Textfield::get_text() const
	{
		return text;
	}

	bool Textfield::can_copy_paste() const
	{
		if (ontext)
		{
			ontext();

			return false;
		}
		else
		{
			return true;
		}
	}

	bool Textfield::empty() const
	{
		return text.empty();
	}

	Textfield::State Textfield::get_state() const
	{
		return state;
	}
}

================
File: IO/Components/Textfield.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Cursor.h"
#include "../Keyboard.h"

#include "../../Graphics/Geometry.h"

#include <functional>

namespace ms
{
	class Textfield
	{
	public:
		enum State
		{
			NORMAL,
			DISABLED,
			FOCUSED
		};

		Textfield();
		Textfield(Text::Font font, Text::Alignment alignment, Color::Name text_color, Rectangle<int16_t> bounds, size_t limit, int16_t marker_height = 12);

		void draw(Point<int16_t> position) const;
		void draw(Point<int16_t> position, Point<int16_t> marker_adjust) const;
		void update();
		void update(Point<int16_t> position, Point<int16_t> dimensions);
		void send_key(KeyType::Id type, int32_t action, bool pressed);
		void add_string(const std::string& str);

		void set_state(State state);
		void change_text(const std::string& text);
		void set_cryptchar(int8_t character);
		void set_limit(size_t limit);

		void set_enter_callback(std::function<void(std::string)> onreturn);
		void set_key_callback(KeyAction::Id key, std::function<void(void)> action);
		void set_text_callback(std::function<void(void)> action);

		Cursor::State send_cursor(Point<int16_t> cursorpos, bool clicked);

		bool empty() const;
		State get_state() const;
		const std::string& get_text() const;
		bool can_copy_paste() const;

	private:
		void modifytext(const std::string& t);
		bool belowlimit() const;

		Text textlabel;
		std::string text;
		ColorLine marker;
		bool showmarker;
		uint16_t elapsed;
		size_t markerpos;
		Rectangle<int16_t> bounds;
		size_t limit;
		int8_t crypt;
		State state;

		std::function<void(std::string)> onreturn;
		std::map<int32_t, std::function<void(void)>> callbacks;
		std::function<void(void)> ontext;

#if LOG_LEVEL >= LOG_UI
		ColorBox boundsoutline;
#endif
	};
}

================
File: IO/Components/TextTooltip.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "TextTooltip.h"

#include "../../Constants.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	TextTooltip::TextTooltip()
	{
		nl::node Frame = nl::nx::UI["UIToolTip.img"]["Item"]["Frame2"];

		frame = Frame;
		cover = Frame["cover"];

		text = "";
	}

	void TextTooltip::draw(Point<int16_t> pos) const
	{
		if (text_label.empty())
			return;

		int16_t fillwidth = text_label.width();
		int16_t fillheight = text_label.height();

		if (fillheight < 18)
			fillheight = 18;

		int16_t max_width = Constants::Constants::get().get_viewwidth();
		int16_t max_height = Constants::Constants::get().get_viewheight();
		int16_t cur_width = pos.x() + fillwidth + 21;
		int16_t cur_height = pos.y() + fillheight + 40;

		int16_t adj_x = cur_width - max_width;
		int16_t adj_y = cur_height - max_height;

		if (adj_x > 0)
			pos.shift_x(adj_x * -1);

		if (adj_y > 0)
			pos.shift_y(adj_y * -1);

		if (fillheight > 18)
		{
			frame.draw(pos + Point<int16_t>(fillwidth / 2, fillheight - 6), fillwidth - 19, fillheight - 17);

			if (fillheight > cover.height())
				cover.draw(pos + Point<int16_t>(-5, -2));
			else
				cover.draw(pos + Point<int16_t>(-5, -2), Range<int16_t>(0, fillheight / 2 - 14 + 2));

			text_label.draw(pos + Point<int16_t>(0, 1));
		}
		else
		{
			frame.draw(pos + Point<int16_t>(fillwidth / 2, fillheight - 7), fillwidth - 19, fillheight - 18);
			cover.draw(pos + Point<int16_t>(-5, -2), Range<int16_t>(0, fillheight + 2));
			text_label.draw(pos + Point<int16_t>(-1, -2));
		}
	}

	bool TextTooltip::set_text(std::string t, uint16_t maxwidth, bool formatted, int16_t line_adj)
	{
		if (text == t)
			return false;

		text = t;

		if (text.empty())
			return false;

		text_label = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::WHITE, text, maxwidth, formatted, line_adj);

		return true;
	}
}

================
File: IO/Components/TextTooltip.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Tooltip.h"
#include "MapleFrame.h"

#include "../../Graphics/Text.h"

namespace ms
{
	class TextTooltip : public Tooltip
	{
	public:
		TextTooltip();

		void draw(Point<int16_t> position) const override;

		bool set_text(std::string text, uint16_t maxwidth = 340, bool formatted = true, int16_t line_adj = 2);

	private:
		MapleFrame frame;
		Texture cover;
		std::string text;
		Text text_label;
	};
}

================
File: IO/Components/Tooltip.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../Template/Point.h"

namespace ms
{
	// Interface for tooltips
	// Window with helpful information that appears on mouse hover at a specific location
	class Tooltip
	{
	public:
		// Possible parent UIs for Tooltips
		enum Parent
		{
			NONE,
			EQUIPINVENTORY,
			ITEMINVENTORY,
			SKILLBOOK,
			SHOP,
			EVENT,
			TEXT,
			KEYCONFIG,
			WORLDMAP,
			MINIMAP
		};

		virtual ~Tooltip() {}

		virtual void draw(Point<int16_t> cursorpos) const = 0;
	};
}

================
File: IO/Components/TwoSpriteButton.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "TwoSpriteButton.h"

namespace ms
{
	TwoSpriteButton::TwoSpriteButton(nl::node nsrc, nl::node ssrc, Point<int16_t> np, Point<int16_t> sp) : textures(ssrc, nsrc), npos(np), spos(sp)
	{
		state = Button::State::NORMAL;
		active = true;
	}

	TwoSpriteButton::TwoSpriteButton(nl::node nsrc, nl::node ssrc, Point<int16_t> pos) : TwoSpriteButton(nsrc, ssrc, pos, pos) {}
	TwoSpriteButton::TwoSpriteButton(nl::node nsrc, nl::node ssrc) : TwoSpriteButton(nsrc, ssrc, Point<int16_t>()) {}
	TwoSpriteButton::TwoSpriteButton() : textures({}, {}) {}

	void TwoSpriteButton::draw(Point<int16_t> parentpos) const
	{
		if (active)
		{
			bool selected = state == Button::State::MOUSEOVER || state == Button::State::PRESSED;

			if (selected)
				textures[selected].draw(spos + parentpos);
			else
				textures[selected].draw(npos + parentpos);
		}
	}

	Rectangle<int16_t> TwoSpriteButton::bounds(Point<int16_t> parentpos) const
	{
		bool selected = state == Button::State::MOUSEOVER || state == Button::State::PRESSED;
		Point<int16_t> absp;
		Point<int16_t> dim;

		if (selected)
		{
			absp = parentpos + spos - textures[selected].get_origin();
			dim = textures[selected].get_dimensions();
		}
		else
		{
			absp = parentpos + npos - textures[selected].get_origin();
			dim = textures[selected].get_dimensions();
		}

		return Rectangle<int16_t>(absp, absp + dim);
	}

	int16_t TwoSpriteButton::width() const
	{
		bool selected = state == Button::State::MOUSEOVER || state == Button::State::PRESSED;

		return textures[selected].width();
	}

	Point<int16_t> TwoSpriteButton::origin() const
	{
		bool selected = state == Button::State::MOUSEOVER || state == Button::State::PRESSED;

		return textures[selected].get_origin();
	}
}

================
File: IO/Components/TwoSpriteButton.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Button.h"

#include "../../Template/BoolPair.h"

namespace ms
{
	class TwoSpriteButton : public Button
	{
	public:
		TwoSpriteButton(nl::node nsrc, nl::node ssrc, Point<int16_t> npos, Point<int16_t> spos);
		TwoSpriteButton(nl::node nsrc, nl::node ssrc, Point<int16_t> position);
		TwoSpriteButton(nl::node nsrc, nl::node ssrc);
		TwoSpriteButton();

		void draw(Point<int16_t> position) const;
		void update() {}
		Rectangle<int16_t> bounds(Point<int16_t> position) const;
		int16_t width() const;
		Point<int16_t> origin() const;
		Cursor::State send_cursor(bool, Point<int16_t>) { return Cursor::State::IDLE; }

	private:
		BoolPair<Texture> textures;
		Point<int16_t> npos;
		Point<int16_t> spos;
	};
}

================
File: IO/Cursor.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Cursor.h"

#include "../Constants.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	Cursor::Cursor()
	{
		state = Cursor::State::IDLE;
		hide_counter = 0;
	}

	void Cursor::init()
	{
		nl::node src = nl::nx::UI["Basic.img"]["Cursor"];

		for (auto iter : animations)
			iter.second = src[iter.first];
	}

	void Cursor::draw(float alpha) const
	{
		constexpr int64_t HIDE_AFTER = HIDE_TIME / Constants::TIMESTEP;

		if (hide_counter < HIDE_AFTER)
			animations[state].draw(position, alpha);
	}

	void Cursor::update()
	{
		animations[state].update();

		switch (state)
		{
		case Cursor::State::CANCLICK:
		case Cursor::State::CANCLICK2:
		case Cursor::State::CANGRAB:
		case Cursor::State::CLICKING:
		case Cursor::State::GRABBING:
			hide_counter = 0;
			break;
		default:
			hide_counter++;
			break;
		}
	}

	void Cursor::set_state(State s)
	{
		if (state != s)
		{
			state = s;

			animations[state].reset();
			hide_counter = 0;
		}
	}

	void Cursor::set_position(Point<int16_t> cursor_position)
	{
		position = cursor_position;
		hide_counter = 0;
	}

	Cursor::State Cursor::get_state() const
	{
		return state;
	}

	Point<int16_t> Cursor::get_position() const
	{
		return position;
	}
}

================
File: IO/Cursor.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Graphics/Animation.h"
#include "../Template/EnumMap.h"

namespace ms
{
	// Class that represents the mouse cursor
	class Cursor
	{
	public:
		// Maple cursor states that are linked to the cursor's animation
		enum State
		{
			IDLE,
			CANCLICK,
			GAME,
			HOUSE,
			CANCLICK2,
			CANGRAB,
			GIFT,
			VSCROLL,
			HSCROLL,
			VSCROLLIDLE,
			HSCROLLIDLE,
			GRABBING,
			CLICKING,
			RCLICK,
			LEAF = 18,
			CHATBARVDRAG = 67,
			CHATBARHDRAG,
			CHATBARBLTRDRAG,
			CHATBARMOVE = 72,
			CHATBARBRTLDRAG,
			LENGTH
		};

		Cursor();

		void init();

		void draw(float alpha) const;
		void update();
		void set_state(State state);
		void set_position(Point<int16_t> cursor_position);
		State get_state() const;
		Point<int16_t> get_position() const;

	private:
		EnumMap<State, Animation> animations;

		State state;
		Point<int16_t> position;
		int32_t hide_counter;

		static constexpr int64_t HIDE_TIME = 15'000;
	};
}

================
File: IO/KeyAction.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cstdint>

namespace ms
{
	namespace KeyAction
	{
		// Maple-specific keycodes, sent via the Keymap Packet.
		enum Id : int32_t
		{
			EQUIPMENT,
			ITEMS,
			STATS,
			SKILLS,
			FRIENDS,
			WORLDMAP,
			MAPLECHAT,
			MINIMAP,
			QUESTLOG,
			KEYBINDINGS,
			SAY,
			WHISPER,
			PARTYCHAT,
			FRIENDSCHAT,
			MENU,
			QUICKSLOTS,
			TOGGLECHAT,
			GUILD,
			GUILDCHAT,
			PARTY,
			NOTIFIER,
			MAPLENEWS,			// TOSPOUSE (v83)
			CASHSHOP,			// MONSTERBOOK (v83)
			ALLIANCECHAT,		// CASHSHOP (v83)
			//NONE = 24,		// TOALLIANCE (v83)
			MANAGELEGION = 25,	// PARTYSEARCH (v83)
			MEDALS,				// FAMILY (v83)
			BOSSPARTY,			// MEDAL (v83)
			PROFESSION = 29,
			ITEMPOT,
			EVENT,
			SILENTCRUSADE = 33,
			BITS,
			BATTLEANALYSIS,
			GUIDE = 39,
			VIEWERSCHAT,
			ENHANCEEQUIP,
			MONSTERCOLLECTION,
			SOULWEAPON,
			CHARINFO,
			CHANGECHANNEL,
			MAINMENU,
			SCREENSHOT,
			PICTUREMODE,
			MAPLEACHIEVEMENT,
			PICKUP,
			SIT,
			ATTACK,
			JUMP,
			INTERACT_HARVEST,
			FACE1 = 100,
			FACE2,
			FACE3,
			FACE4,
			FACE5,
			FACE6,
			FACE7,
			MAPLESTORAGE = 200,
			SAFEMODE,
			MUTE,
			EMOTICON,
			MAPLERELAY = 300,
			FAMILIAR = 1000,
			TOSPOUSE,
			// Static keys
			LEFT,
			RIGHT,
			UP,
			DOWN,
			BACK,
			TAB,
			RETURN,
			ESCAPE,
			SPACE,
			DELETE,
			HOME,
			END,
			COPY,
			PASTE,
			LENGTH
		};

		inline Id actionbyid(int32_t id)
		{
			return static_cast<Id>(id);
		}
	}
}

================
File: IO/Keyboard.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Keyboard.h"

#include <glfw3.h>

namespace ms
{
	constexpr int32_t Keytable[90] =
	{
		0, 0, // 1
		GLFW_KEY_1, GLFW_KEY_2, GLFW_KEY_3, GLFW_KEY_4, GLFW_KEY_5, GLFW_KEY_6, GLFW_KEY_7, GLFW_KEY_8, GLFW_KEY_9, GLFW_KEY_0, GLFW_KEY_MINUS, GLFW_KEY_EQUAL,
		0, 0, // 15
		GLFW_KEY_Q, GLFW_KEY_W, GLFW_KEY_E, GLFW_KEY_R, GLFW_KEY_T, GLFW_KEY_Y, GLFW_KEY_U, GLFW_KEY_I, GLFW_KEY_O, GLFW_KEY_P, GLFW_KEY_LEFT_BRACKET, GLFW_KEY_RIGHT_BRACKET,
		0, // 28
		GLFW_KEY_LEFT_CONTROL, GLFW_KEY_A, GLFW_KEY_S, GLFW_KEY_D, GLFW_KEY_F, GLFW_KEY_G, GLFW_KEY_H, GLFW_KEY_J, GLFW_KEY_K, GLFW_KEY_L, GLFW_KEY_SEMICOLON, GLFW_KEY_APOSTROPHE, GLFW_KEY_GRAVE_ACCENT, GLFW_KEY_LEFT_SHIFT, GLFW_KEY_BACKSLASH, GLFW_KEY_Z, GLFW_KEY_X, GLFW_KEY_C, GLFW_KEY_V, GLFW_KEY_B, GLFW_KEY_N, GLFW_KEY_M, GLFW_KEY_COMMA, GLFW_KEY_PERIOD,
		0, 0, 0, // 55
		GLFW_KEY_LEFT_ALT, GLFW_KEY_SPACE,
		0, // 58
		GLFW_KEY_F1, GLFW_KEY_F2, GLFW_KEY_F3, GLFW_KEY_F4, GLFW_KEY_F5, GLFW_KEY_F6, GLFW_KEY_F7, GLFW_KEY_F8, GLFW_KEY_F9, GLFW_KEY_F10, GLFW_KEY_F11, GLFW_KEY_F12, GLFW_KEY_HOME,
		0, // 72
		GLFW_KEY_PAGE_UP,
		0, 0, 0, 0, 0, // 78
		GLFW_KEY_END,
		0, // 80
		GLFW_KEY_PAGE_DOWN, GLFW_KEY_INSERT, GLFW_KEY_DELETE, GLFW_KEY_ESCAPE, GLFW_KEY_RIGHT_CONTROL, GLFW_KEY_RIGHT_SHIFT, GLFW_KEY_RIGHT_ALT, GLFW_KEY_SCROLL_LOCK
	};

	constexpr int32_t Shifttable[126] =
	{
		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, //  10
		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, //  20
		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, //  30
		  0,  0, 49, 39, 51, 52, 53, 55,  0, 57, //  40
		 48, 56, 61,  0,  0,  0,  0,  0,  0,  0, //  50
		  0,  0,  0,  0,  0,  0,  0, 59,  0, 44, //  60
		  0, 46, 47, 50, 97, 98, 99,100,101,102, //  70
		103,104,105,106,107,108,109,110,111,112, //  80
		113,114,115,116,117,118,119,120,121,122, //  90
		  0,  0,  0, 54, 45,  0,  0,  0,  0,  0, // 100
		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 110
		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 120
		  0,  0, 91, 92, 93, 96					 // 126
	};

	constexpr int32_t Specialtable[96] =
	{
		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 10
		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 20
		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 30
		  0,  0,  0,  0,  0,  0,  0,  0, 34,  0, // 40
		  0,  0,  0, 60, 95, 62, 63, 41, 33, 64, // 50
		 35, 36, 37, 94, 38, 42, 40,  0, 58,  0, // 60
		 43,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 70
		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 80
		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, // 90
		123,124,125,  0,  0,126					 // 96
	};

	Keyboard::Keyboard()
	{
		keymap[GLFW_KEY_LEFT] = Mapping(KeyType::Id::ACTION, KeyAction::Id::LEFT);
		keymap[GLFW_KEY_RIGHT] = Mapping(KeyType::Id::ACTION, KeyAction::Id::RIGHT);
		keymap[GLFW_KEY_UP] = Mapping(KeyType::Id::ACTION, KeyAction::Id::UP);
		keymap[GLFW_KEY_DOWN] = Mapping(KeyType::Id::ACTION, KeyAction::Id::DOWN);
		keymap[GLFW_KEY_ENTER] = Mapping(KeyType::Id::ACTION, KeyAction::Id::RETURN);
		keymap[GLFW_KEY_KP_ENTER] = Mapping(KeyType::Id::ACTION, KeyAction::Id::RETURN);
		keymap[GLFW_KEY_TAB] = Mapping(KeyType::Id::ACTION, KeyAction::Id::TAB);

		textactions[GLFW_KEY_BACKSPACE] = KeyAction::Id::BACK;
		textactions[GLFW_KEY_ENTER] = KeyAction::Id::RETURN;
		textactions[GLFW_KEY_KP_ENTER] = KeyAction::Id::RETURN;
		textactions[GLFW_KEY_SPACE] = KeyAction::Id::SPACE;
		textactions[GLFW_KEY_TAB] = KeyAction::Id::TAB;
		textactions[GLFW_KEY_ESCAPE] = KeyAction::Id::ESCAPE;
		textactions[GLFW_KEY_HOME] = KeyAction::Id::HOME;
		textactions[GLFW_KEY_END] = KeyAction::Id::END;
		textactions[GLFW_KEY_DELETE] = KeyAction::Id::DELETE;
	}

	int32_t Keyboard::leftshiftcode() const
	{
		return GLFW_KEY_LEFT_SHIFT;
	}

	int32_t Keyboard::rightshiftcode() const
	{
		return GLFW_KEY_RIGHT_SHIFT;
	}

	int32_t Keyboard::capslockcode() const
	{
		return GLFW_KEY_CAPS_LOCK;
	}

	int32_t Keyboard::leftctrlcode() const
	{
		return GLFW_KEY_LEFT_CONTROL;
	}

	int32_t Keyboard::rightctrlcode() const
	{
		return GLFW_KEY_LEFT_CONTROL;
	}

	std::map<int32_t, Keyboard::Mapping> Keyboard::get_maplekeys() const
	{
		return maplekeys;
	}

	KeyAction::Id Keyboard::get_ctrl_action(int32_t keycode) const
	{
		switch (keycode)
		{
			case GLFW_KEY_C:
				return KeyAction::Id::COPY;
			case GLFW_KEY_V:
				return KeyAction::Id::PASTE;
				//case GLFW_KEY_A:
				//	return KeyAction::Id::SELECTALL;
			default:
				return KeyAction::Id::LENGTH;
		}
	}

	void Keyboard::assign(uint8_t key, uint8_t tid, int32_t action)
	{
		if (KeyType::Id type = KeyType::typebyid(tid))
		{
			Mapping mapping = Mapping(type, action);

			keymap[Keytable[key]] = mapping;
			maplekeys[key] = mapping;
		}
	}

	void Keyboard::remove(uint8_t key)
	{
		Mapping mapping = Mapping(KeyType::Id::NONE, 0);

		keymap[Keytable[key]] = mapping;
		maplekeys[key] = mapping;
	}

	Keyboard::Mapping Keyboard::get_text_mapping(int32_t keycode, bool shift) const
	{
		if (textactions.count(keycode))
		{
			return Mapping(KeyType::Id::ACTION, textactions.at(keycode));
		}
		else if (keycode == 39 || (keycode >= 44 && keycode <= 57) || keycode == 59 || keycode == 61 || (keycode >= 91 && keycode <= 93) || keycode == 96)
		{
			if (!shift)
				return Mapping(KeyType::Id::TEXT, keycode);
			else
				return Mapping(KeyType::Id::TEXT, Specialtable[keycode - 1]);
		}
		else if (keycode >= 33 && keycode <= 126)
		{
			if (shift)
				return Mapping(KeyType::Id::TEXT, keycode);
			else
				return Mapping(KeyType::Id::TEXT, Shifttable[keycode - 1]);
		}
		else
		{
			switch (keycode)
			{
				case GLFW_KEY_LEFT:
				case GLFW_KEY_RIGHT:
				case GLFW_KEY_UP:
				case GLFW_KEY_DOWN:
					return keymap.at(keycode);
				default:
					return Mapping(KeyType::Id::NONE, 0);
			}
		}
	}

	Keyboard::Mapping Keyboard::get_mapping(int32_t keycode) const
	{
		auto iter = keymap.find(keycode);

		if (iter == keymap.end())
			return Mapping(KeyType::Id::NONE, 0);

		return iter->second;
	}

	int32_t Keyboard::get_mapping_index(int32_t action) const
	{
		for (auto key : keymap)
			if (key.second.action == action)
				return key.first;

		return 0;
	}

	Keyboard::Mapping Keyboard::get_maple_mapping(int32_t keycode) const
	{
		auto iter = maplekeys.find(keycode);

		if (iter == maplekeys.end())
			return Mapping(KeyType::Id::NONE, 0);

		return iter->second;
	}
}

================
File: IO/Keyboard.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "KeyAction.h"
#include "KeyType.h"

#include <map>

namespace ms
{
	class Keyboard
	{
	public:
		struct Mapping
		{
			KeyType::Id type;
			int32_t action;

			Mapping() : type(KeyType::Id::NONE), action(0) {}
			Mapping(KeyType::Id in_type, int32_t in_action) : type(in_type), action(in_action) {}

			bool operator==(const Mapping& other) const
			{
				return type == other.type && action == other.action;
			}

			bool operator!=(const Mapping& other) const
			{
				return type != other.type || action != other.action;
			}
		};

		Keyboard();

		void assign(uint8_t key, uint8_t type, int32_t action);
		void remove(uint8_t key);

		int32_t leftshiftcode() const;
		int32_t rightshiftcode() const;
		int32_t capslockcode() const;
		int32_t leftctrlcode() const;
		int32_t rightctrlcode() const;
		std::map<int32_t, Mapping> get_maplekeys() const;
		KeyAction::Id get_ctrl_action(int32_t keycode) const;
		Mapping get_mapping(int32_t keycode) const;
		int32_t get_mapping_index(int32_t action) const;
		Mapping get_maple_mapping(int32_t keycode) const;
		Mapping get_text_mapping(int32_t keycode, bool shift) const;

	private:
		std::map<int32_t, Mapping> keymap;
		std::map<int32_t, Mapping> maplekeys;
		std::map<int32_t, KeyAction::Id> textactions;
		std::map<int32_t, bool> keystate;
	};
}

================
File: IO/KeyConfig.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cstdint>

namespace ms
{
	namespace KeyConfig
	{
		enum Key : uint8_t
		{
			NUM1 = 2,
			NUM2, NUM3, NUM4, NUM5, NUM6, NUM7, NUM8, NUM9, NUM0, MINUS, EQUAL,
			Q = 16,
			W, E, R, T, Y, U, I, O, P, LEFT_BRACKET, RIGHT_BRACKET,
			LEFT_CONTROL = 29,
			A, S, D, F, G, H, J, K, L, SEMICOLON, APOSTROPHE, GRAVE_ACCENT, LEFT_SHIFT, BACKSLASH, Z, X, C, V, B, N, M, COMMA, PERIOD,
			LEFT_ALT = 56,
			SPACE,
			F1 = 59,
			F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, HOME,
			PAGE_UP = 73,
			END = 79,
			PAGE_DOWN = 81,
			INSERT, DELETE, ESCAPE, RIGHT_CONTROL, RIGHT_SHIFT, RIGHT_ALT, SCROLL_LOCK,
			LENGTH
		};

		inline Key actionbyid(int32_t id)
		{
			return static_cast<Key>(id);
		}
	}
}

================
File: IO/KeyType.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cstdint>

namespace ms
{
	namespace KeyType
	{
		// Keytypes determine how a keycode is interpreted.
		enum Id
		{
			NONE = 0,
			SKILL = 1,
			ITEM = 2,
			CASH = 3,
			MENU = 4,
			ACTION = 5,
			FACE = 6,
			MACRO = 8,
			TEXT = 9,
			LENGTH
		};

		inline Id typebyid(uint8_t id)
		{
			if (id <= Id::NONE || id >= Id::LENGTH)
				return Id::NONE;

			return static_cast<Id>(id);
		}
	}
}

================
File: IO/Messages.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Messages.h"

#include "UI.h"

#include "UITypes/UIChatBar.h"

namespace ms
{
	const EnumMap<Messages::Type, const char*> Messages::messages =
	{
		"",
		"You cannot use this skill with this weapon.",
		"You do not have enough hp to use this skill.",
		"You do not have enough mp to use this skill.",
		"You do not have enough arrows to use this attack.",
		"You do not have enough bullets to use this attack.",
		"You do not have enough throwing stars to use this attack.",
		"You cannot use this skill as it is on cooldown.",
		"The scroll lights up and it's mysterious powers have been transferred to the item.",
		"The scroll lights up but the item remains as if nothing happened.",
		"The item has been destroyed due to the overwhelming power of the scroll."
	};

	InChatMessage::InChatMessage(Messages::Type t)
	{
		type = t;
	}

	void InChatMessage::drop() const
	{
		if (type == Messages::Type::NONE)
			return;

		if (auto chatbar = UI::get().get_element<UIChatBar>())
			chatbar->show_message(Messages::messages[type], UIChatBar::RED);
	}

	ForbidSkillMessage::ForbidSkillMessage(SpecialMove::ForbidReason reason, Weapon::Type weapon) : InChatMessage(message_by_reason(reason, weapon)) {}

	Messages::Type ForbidSkillMessage::message_by_reason(SpecialMove::ForbidReason reason, Weapon::Type weapon)
	{
		switch (reason)
		{
		case SpecialMove::ForbidReason::FBR_WEAPONTYPE:
			return Messages::Type::SKILL_WEAPONTYPE;
		case SpecialMove::ForbidReason::FBR_HPCOST:
			return Messages::Type::SKILL_HPCOST;
		case SpecialMove::ForbidReason::FBR_MPCOST:
			return Messages::Type::SKILL_MPCOST;
		case SpecialMove::ForbidReason::FBR_COOLDOWN:
			return Messages::Type::SKILL_COOLDOWN;
		case SpecialMove::ForbidReason::FBR_BULLETCOST:
			return message_by_weapon(weapon);
		default:
			return Messages::Type::NONE;
		}
	}

	Messages::Type ForbidSkillMessage::message_by_weapon(Weapon::Type weapon)
	{
		switch (weapon)
		{
		case Weapon::Type::BOW:
		case Weapon::Type::CROSSBOW:
			return Messages::Type::SKILL_NOARROWS;
		case Weapon::Type::CLAW:
			return Messages::Type::SKILL_NOSTARS;
		default:
			return Messages::Type::SKILL_NOBULLETS;
		}
	}
}

================
File: IO/Messages.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Character/Inventory/Weapon.h"
#include "../Gameplay/Combat/SpecialMove.h"

namespace ms
{
	namespace Messages
	{
		enum Type
		{
			NONE,
			// Cannot use a skill
			SKILL_WEAPONTYPE,
			SKILL_HPCOST,
			SKILL_MPCOST,
			SKILL_NOARROWS,
			SKILL_NOBULLETS,
			SKILL_NOSTARS,
			SKILL_COOLDOWN,

			// Scrolling result
			SCROLL_SUCCESS,
			SCROLL_FAILURE,
			SCROLL_DESTROYED,
			LENGTH
		};

		extern const EnumMap<Type, const char*> messages;
	};

	class InChatMessage
	{
	public:
		InChatMessage(Messages::Type type);

		void drop() const;

	private:
		Messages::Type type;
	};

	class ForbidSkillMessage : public InChatMessage
	{
	public:
		ForbidSkillMessage(SpecialMove::ForbidReason reason, Weapon::Type weapon);

	private:
		Messages::Type message_by_reason(SpecialMove::ForbidReason reason, Weapon::Type weapon);
		Messages::Type message_by_weapon(Weapon::Type weapon);
	};
}

================
File: IO/UI.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UI.h"

#include "UIStateCashShop.h"
#include "UIStateGame.h"
#include "UIStateLogin.h"
#include "Window.h"
#include "../Graphics/GraphicsGL.h"

#include <iostream>

#include "UITypes/UIChannel.h"
#include "UITypes/UIChat.h"
#include "UITypes/UIChatBar.h"
#include "UITypes/UIJoypad.h"
#include "UITypes/UINpcTalk.h"
#include "UITypes/UIOptionMenu.h"
#include "UITypes/UIQuit.h"
#include "UITypes/UIShop.h"
#include "UITypes/UIStatusBar.h"
#include "UITypes/UIWorldMap.h"

namespace ms
{
	UI::UI()
	{
		state = std::make_unique<UIStateNull>();
		enabled = true;
	}

	void UI::init()
	{
		caps_lock_enabled = Configuration::get().get_caps_lock_enabled();
	
		cursor.init();

		change_state(State::LOGIN);
	}

	void UI::draw(float alpha) const
	{
		// Drawing UI
		state->draw(alpha, cursor.get_position());

		scrollingnotice.draw(alpha);

		cursor.draw(alpha);
	}

	void UI::update()
	{
		state->update();

		scrollingnotice.update();

		cursor.update();
	}

	void UI::enable()
	{
		enabled = true;
	}

	void UI::disable()
	{
		enabled = false;
	}

	void UI::change_state(State id)
	{
		switch (id)
		{
			case State::LOGIN:
				state = std::make_unique<UIStateLogin>();
				break;
			case State::GAME:
				state = std::make_unique<UIStateGame>();
				break;
			case State::CASHSHOP:
				state = std::make_unique<UIStateCashShop>();
				break;
		}
	}

	void UI::quit()
	{
		quitted = true;
	}

	bool UI::not_quitted() const
	{
		return !quitted;
	}

	bool UI::has_capslocks() const
	{
		return caps_lock_enabled;
	}

	void UI::send_cursor(Point<int16_t> cursor_position, Cursor::State cursor_state)
	{
		Cursor::State next_state = state->send_cursor(cursor_position, cursor_state);

		cursor.set_state(next_state);
		cursor.set_position(cursor_position);
	}

	void UI::send_focus(int focused)
	{
		if (focused)
		{
			// The window gained input focus
			uint8_t sfxvolume = Setting<SFXVolume>::get().load();
			Sound::set_sfxvolume(sfxvolume);

			uint8_t bgmvolume = Setting<BGMVolume>::get().load();
			Music::set_bgmvolume(bgmvolume);
		}
		else
		{
			// The window lost input focus
			Sound::set_sfxvolume(0);
			Music::set_bgmvolume(0);
		}
	}

	void UI::send_scroll(double yoffset)
	{
		state->send_scroll(yoffset);
	}

	void UI::send_close()
	{
		state->send_close();
	}

	void UI::send_cursor(bool pressed)
	{
		Cursor::State cursorstate = (pressed && enabled) ? Cursor::State::CLICKING : Cursor::State::IDLE;
		Point<int16_t> cursorpos = cursor.get_position();
		send_cursor(cursorpos, cursorstate);

		if (focusedtextfield && pressed)
		{
			Cursor::State tstate = focusedtextfield->send_cursor(cursorpos, pressed);

			switch (tstate)
			{
				case Cursor::State::IDLE:
					focusedtextfield = {};
					break;
			}
		}
	}

	void UI::send_cursor(Point<int16_t> cursor_position)
	{
		send_cursor(cursor_position, cursor.get_state());
	}

	void UI::rightclick()
	{
		Point<int16_t> pos = cursor.get_position();
		state->rightclick(pos);
	}

	void UI::doubleclick()
	{
		Point<int16_t> pos = cursor.get_position();
		state->doubleclick(pos);
	}

	void UI::send_key(int32_t keycode, bool pressed)
	{
		if ((is_key_down[GLFW_KEY_LEFT_ALT] || is_key_down[GLFW_KEY_RIGHT_ALT]) && (is_key_down[GLFW_KEY_ENTER] || is_key_down[GLFW_KEY_KP_ENTER]))
		{
			Window::get().toggle_fullscreen();

			is_key_down[GLFW_KEY_LEFT_ALT] = false;
			is_key_down[GLFW_KEY_RIGHT_ALT] = false;
			is_key_down[GLFW_KEY_ENTER] = false;
			is_key_down[GLFW_KEY_KP_ENTER] = false;

			return;
		}

		if (is_key_down[keyboard.capslockcode()])
			caps_lock_enabled = !caps_lock_enabled;

		if (focusedtextfield)
		{
			bool ctrl = is_key_down[keyboard.leftctrlcode()] || is_key_down[keyboard.rightctrlcode()];

			if (ctrl && pressed)
			{
				KeyAction::Id action = keyboard.get_ctrl_action(keycode);

				if (action == KeyAction::Id::COPY || action == KeyAction::Id::PASTE)
				{
					if (focusedtextfield->can_copy_paste())
					{
						switch (action)
						{
							case KeyAction::Id::COPY:
								Window::get().setclipboard(focusedtextfield->get_text());
								break;
							case KeyAction::Id::PASTE:
								focusedtextfield->add_string(Window::get().getclipboard());
								break;
						}
					}
				}
			}
			else
			{
				bool shift = is_key_down[keyboard.leftshiftcode()] || is_key_down[keyboard.rightshiftcode()] || caps_lock_enabled;
				Keyboard::Mapping mapping = keyboard.get_text_mapping(keycode, shift);
				focusedtextfield->send_key(mapping.type, mapping.action, pressed);
			}
		}
		else
		{
			Keyboard::Mapping mapping = keyboard.get_mapping(keycode);

			// Debug camera controls (WASD + R for reset)
			if (pressed) {
				switch (keycode) {
					case GLFW_KEY_W:
						GraphicsGL::get().move_camera(0, -20);
						return;
					case GLFW_KEY_A:
						GraphicsGL::get().move_camera(-20, 0);
						return;
					case GLFW_KEY_S:
						GraphicsGL::get().move_camera(0, 20);
						return;
					case GLFW_KEY_D:
						GraphicsGL::get().move_camera(20, 0);
						return;
					case GLFW_KEY_R:
						GraphicsGL::get().reset_camera();
						return;
					case GLFW_KEY_C:
						GraphicsGL::get().clear_atlas_cache();
						return;
					case GLFW_KEY_T:
						GraphicsGL::get().toggle_debug_mode();
						return;
				}
			}

			bool sent = false;
			std::list<UIElement::Type> types;

			bool escape = keycode == GLFW_KEY_ESCAPE;
			bool tab = keycode == GLFW_KEY_TAB;
			bool enter = keycode == GLFW_KEY_ENTER || keycode == GLFW_KEY_KP_ENTER;
			bool up_down = keycode == GLFW_KEY_UP || keycode == GLFW_KEY_DOWN;
			bool left_right = keycode == GLFW_KEY_LEFT || keycode == GLFW_KEY_RIGHT;
			bool arrows = up_down || left_right;

			auto statusbar = UI::get().get_element<UIStatusBar>();
			auto channel = UI::get().get_element<UIChannel>();
			auto worldmap = UI::get().get_element<UIWorldMap>();
			auto optionmenu = UI::get().get_element<UIOptionMenu>();
			auto shop = UI::get().get_element<UIShop>();
			auto joypad = UI::get().get_element<UIJoypad>();
			auto rank = UI::get().get_element<UIRank>();
			auto quit = UI::get().get_element<UIQuit>();
			auto npctalk = UI::get().get_element<UINpcTalk>();
			//auto report = UI::get().get_element<UIReport>();
			//auto whisper = UI::get().get_element<UIWhisper>();

			if (npctalk && npctalk->is_active())
			{
				npctalk->send_key(mapping.action, pressed, escape);
				sent = true;
			}
			else if (statusbar && statusbar->is_menu_active())
			{
				statusbar->send_key(mapping.action, pressed, escape);
				sent = true;
			}
			else if (channel && channel->is_active() && mapping.action != KeyAction::Id::CHANGECHANNEL)
			{
				channel->send_key(mapping.action, pressed, escape);
				sent = true;
			}
			else if (worldmap && worldmap->is_active() && mapping.action != KeyAction::Id::WORLDMAP)
			{
				worldmap->send_key(mapping.action, pressed, escape);
				sent = true;
			}
			else if (optionmenu && optionmenu->is_active())
			{
				optionmenu->send_key(mapping.action, pressed, escape);
				sent = true;
			}
			else if (shop && shop->is_active())
			{
				shop->send_key(mapping.action, pressed, escape);
				sent = true;
			}
			else if (joypad && joypad->is_active())
			{
				joypad->send_key(mapping.action, pressed, escape);
				sent = true;
			}
			else if (rank && rank->is_active())
			{
				rank->send_key(mapping.action, pressed, escape);
				sent = true;
			}
			else if (quit && quit->is_active())
			{
				quit->send_key(mapping.action, pressed, escape);
				sent = true;
			}
			else
			{
				// All
				if (escape || tab || enter || arrows)
				{
					// Login
					types.emplace_back(UIElement::Type::WORLDSELECT);
					types.emplace_back(UIElement::Type::CHARSELECT);
					types.emplace_back(UIElement::Type::RACESELECT);			// No tab
					types.emplace_back(UIElement::Type::CLASSCREATION);			// No tab (No arrows, but shouldn't send else where)
					types.emplace_back(UIElement::Type::LOGINNOTICE);			// No tab (No arrows, but shouldn't send else where)
					types.emplace_back(UIElement::Type::LOGINNOTICE_CONFIRM);	// No tab (No arrows, but shouldn't send else where)
					types.emplace_back(UIElement::Type::LOGINWAIT);				// No tab (No arrows, but shouldn't send else where)
				}

				if (escape)
				{
					// Login
					types.emplace_back(UIElement::Type::SOFTKEYBOARD);

					// Game
					types.emplace_back(UIElement::Type::NOTICE);
					types.emplace_back(UIElement::Type::KEYCONFIG);
					types.emplace_back(UIElement::Type::CHAT);
					types.emplace_back(UIElement::Type::EVENT);
					types.emplace_back(UIElement::Type::STATSINFO);
					types.emplace_back(UIElement::Type::ITEMINVENTORY);
					types.emplace_back(UIElement::Type::EQUIPINVENTORY);
					types.emplace_back(UIElement::Type::SKILLBOOK);
					types.emplace_back(UIElement::Type::QUESTLOG);
					types.emplace_back(UIElement::Type::USERLIST);
					types.emplace_back(UIElement::Type::NPCTALK);
					types.emplace_back(UIElement::Type::CHARINFO);
				}
				else if (enter)
				{
					// Login
					types.emplace_back(UIElement::Type::SOFTKEYBOARD);

					// Game
					types.emplace_back(UIElement::Type::NOTICE);
				}
				else if (tab)
				{
					// Game
					types.emplace_back(UIElement::Type::ITEMINVENTORY);
					types.emplace_back(UIElement::Type::EQUIPINVENTORY);
					types.emplace_back(UIElement::Type::SKILLBOOK);
					types.emplace_back(UIElement::Type::QUESTLOG);
					types.emplace_back(UIElement::Type::USERLIST);
				}

				if (types.size() > 0)
				{
					auto element = state->get_front(types);

					if (element && element != nullptr)
					{
						element->send_key(mapping.action, pressed, escape);
						sent = true;
					}
				}
			}

			if (!sent)
			{
				if (escape)
				{
					state->send_key(mapping.type, mapping.action, pressed, escape);
				}
				else if (enter)
				{
					if (auto chatbar = UI::get().get_element<UIChatBar>())
						chatbar->send_key(mapping.action, pressed, escape);
					else
						state->send_key(mapping.type, mapping.action, pressed, escape);
				}
				else
				{
					state->send_key(mapping.type, mapping.action, pressed, escape);
				}
			}
		}

		is_key_down[keycode] = pressed;
	}

	void UI::set_scrollnotice(const std::string& notice)
	{
		scrollingnotice.setnotice(notice);
	}

	void UI::focus_textfield(Textfield* tofocus)
	{
		if (focusedtextfield)
			focusedtextfield->set_state(Textfield::State::NORMAL);

		focusedtextfield = tofocus;
	}

	void UI::remove_textfield()
	{
		if (focusedtextfield)
			focusedtextfield->set_state(Textfield::State::NORMAL);

		focusedtextfield = {};
	}

	void UI::drag_icon(Icon* icon)
	{
		state->drag_icon(icon);
	}

	void UI::add_keymapping(uint8_t no, uint8_t type, int32_t action)
	{
		keyboard.assign(no, type, action);
	}

	void UI::clear_tooltip(Tooltip::Parent parent)
	{
		state->clear_tooltip(parent);
	}

	void UI::show_equip(Tooltip::Parent parent, int16_t slot)
	{
		state->show_equip(parent, slot);
	}

	void UI::show_item(Tooltip::Parent parent, int32_t item_id)
	{
		state->show_item(parent, item_id);
	}

	void UI::show_skill(Tooltip::Parent parent, int32_t skill_id, int32_t level, int32_t masterlevel, int64_t expiration)
	{
		state->show_skill(parent, skill_id, level, masterlevel, expiration);
	}

	void UI::show_text(Tooltip::Parent parent, std::string text)
	{
		state->show_text(parent, text);
	}

	void UI::show_map(Tooltip::Parent parent, std::string title, std::string description, int32_t mapid, bool bolded, bool portal)
	{
		state->show_map(parent, title, description, mapid, bolded, portal);
	}

	Keyboard& UI::get_keyboard()
	{
		return keyboard;
	}

	Point<int16_t> UI::get_cursor_position() const
	{
		return cursor.get_position();
	}

	void UI::remove(UIElement::Type type)
	{
		focusedtextfield = {};

		state->remove(type);
	}
}

================
File: IO/UI.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "UIState.h"

#include "Components/ScrollingNotice.h"
#include "Components/Textfield.h"

namespace ms
{
	class UI : public Singleton<UI>
	{
	public:
		enum State
		{
			LOGIN,
			GAME,
			CASHSHOP
		};

		UI();

		void init();
		void draw(float alpha) const;
		void update();

		void enable();
		void disable();
		void change_state(State state);

		void quit();
		bool not_quitted() const;
		bool has_capslocks() const;

		void send_cursor(Point<int16_t> cursor_position);
		void send_cursor(bool pressed);
		void send_cursor(Point<int16_t> cursor_position, Cursor::State cursor_state);
		void send_focus(int focused);
		void send_scroll(double yoffset);
		void send_close();
		void rightclick();
		void doubleclick();
		void send_key(int32_t keycode, bool pressed);

		void set_scrollnotice(const std::string& notice);
		void focus_textfield(Textfield* textfield);
		void remove_textfield();
		void drag_icon(Icon* icon);

		void add_keymapping(uint8_t no, uint8_t type, int32_t action);

		void clear_tooltip(Tooltip::Parent parent);
		void show_equip(Tooltip::Parent parent, int16_t slot);
		void show_item(Tooltip::Parent parent, int32_t item_id);
		void show_skill(Tooltip::Parent parent, int32_t skill_id, int32_t level, int32_t masterlevel, int64_t expiration);
		void show_text(Tooltip::Parent parent, std::string text);
		void show_map(Tooltip::Parent parent, std::string title, std::string description, int32_t mapid, bool bolded, bool portal);

		Keyboard& get_keyboard();
		Point<int16_t> get_cursor_position() const;

		template <class T, typename...Args>
		Optional<T> emplace(Args&& ...args)
		{
			if (auto iter = state->pre_add(T::TYPE, T::TOGGLED, T::FOCUSED))
			{
				(*iter).second = std::make_unique<T>(
					std::forward<Args>(args)...
					);
			}

			return state->get(T::TYPE);
		}

		template <class T>
		Optional<T> get_element()
		{
			UIElement::Type type = T::TYPE;
			UIElement* element = state->get(type);

			return static_cast<T*>(element);
		}

		void remove(UIElement::Type type);

	private:
		std::unique_ptr<UIState> state;
		Keyboard keyboard;
		Cursor cursor;
		ScrollingNotice scrollingnotice;

		Optional<Textfield> focusedtextfield;
		std::unordered_map<int32_t, bool> is_key_down;

		bool enabled;
		bool quitted;
		bool caps_lock_enabled;
	};
}

================
File: IO/UIDragElement.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "UIElement.h"

#include "../Configuration.h"

namespace ms
{
	template <typename T>
	// Base class for UI Windows which can be moved with the mouse cursor.
	class UIDragElement : public UIElement
	{
	public:
		void remove_cursor() override
		{
			UIElement::remove_cursor();

			if (dragged)
			{
				dragged = false;

				Setting<T>::get().save(position);
			}
		}

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override
		{
			if (clicked)
			{
				if (dragged)
				{
					position = cursorpos - cursoroffset;

					return Cursor::State::CLICKING;
				}
				else if (indragrange(cursorpos))
				{
					cursoroffset = cursorpos - position;
					dragged = true;

					return UIElement::send_cursor(clicked, cursorpos);
				}
			}
			else
			{
				if (dragged)
				{
					dragged = false;

					Setting<T>::get().save(position);
				}
			}

			return UIElement::send_cursor(clicked, cursorpos);
		}

	protected:
		UIDragElement() : UIDragElement(Point<int16_t>(0, 0)) {}

		UIDragElement(Point<int16_t> d) : dragarea(d)
		{
			position = Setting<T>::get().load();
		}

		bool dragged = false;
		Point<int16_t> dragarea;
		Point<int16_t> cursoroffset;

	private:
		virtual bool indragrange(Point<int16_t> cursorpos) const
		{
			auto bounds = Rectangle<int16_t>(position, position + dragarea);

			return bounds.contains(cursorpos);
		}
	};
}

================
File: IO/UIElement.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIElement.h"

#include "../Audio/Audio.h"
#include <iostream>

namespace ms
{
	UIElement::UIElement(Point<int16_t> p, Point<int16_t> d, bool a) : position(p), dimension(d), active(a) {}
	UIElement::UIElement(Point<int16_t> p, Point<int16_t> d) : UIElement(p, d, true) {}
	UIElement::UIElement() : UIElement(Point<int16_t>(), Point<int16_t>()) {}

	void UIElement::draw(float alpha) const
	{
		draw_sprites(alpha);
		draw_buttons(alpha);
	}

	void UIElement::draw_sprites(float alpha) const
	{
		// Drawing sprites
		for (const Sprite& sprite : sprites)
		{
			// Drawing sprite
			sprite.draw(position, alpha);
		}
	}

	void UIElement::draw_buttons(float) const
	{
		for (auto& iter : buttons)
			if (const Button* button = iter.second.get())
				button->draw(position);
	}

	void UIElement::update()
	{
		for (auto& sprite : sprites)
			sprite.update();

		for (auto& iter : buttons)
			if (Button* button = iter.second.get())
				button->update();
	}

	void UIElement::makeactive()
	{
		active = true;
	}

	void UIElement::deactivate()
	{
		active = false;
	}

	bool UIElement::is_active() const
	{
		return active;
	}

	void UIElement::toggle_active()
	{
		if (active)
			deactivate();
		else
			makeactive();
	}

	bool UIElement::is_in_range(Point<int16_t> cursor_position) const
	{
		auto bounds = Rectangle<int16_t>(position, position + dimension);

		return bounds.contains(cursor_position);
	}

	void UIElement::remove_cursor()
	{
		for (auto& btit : buttons)
		{
			auto button = btit.second.get();

			if (button->get_state() == Button::State::MOUSEOVER)
				button->set_state(Button::State::NORMAL);
		}
	}

	Cursor::State UIElement::send_cursor(bool clicked, Point<int16_t> cursor_position)
	{
		Cursor::State ret = clicked ? Cursor::State::CLICKING : Cursor::State::IDLE;

		for (auto& btit : buttons)
		{
			if (btit.second->is_active() && btit.second->bounds(position).contains(cursor_position))
			{
				if (btit.second->get_state() == Button::State::NORMAL)
				{
					Sound(Sound::Name::BUTTONOVER).play();

					btit.second->set_state(Button::State::MOUSEOVER);
					ret = Cursor::State::CANCLICK;
				}
				else if (btit.second->get_state() == Button::State::MOUSEOVER)
				{
					if (clicked)
					{
						Sound(Sound::Name::BUTTONCLICK).play();

						btit.second->set_state(button_pressed(btit.first));

						ret = Cursor::State::IDLE;
					}
					else
					{
						ret = Cursor::State::CANCLICK;
					}
				}
			}
			else if (btit.second->get_state() == Button::State::MOUSEOVER)
			{
				btit.second->set_state(Button::State::NORMAL);
			}
		}

		return ret;
	}
}

================
File: IO/UIElement.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Components/Button.h"
#include "Components/Icon.h"

#include "../Graphics/Sprite.h"

namespace ms
{
	// Base class for all types of user interfaces on screen.
	class UIElement
	{
	public:
		using UPtr = std::unique_ptr<UIElement>;

		enum Type
		{
			NONE,
			START,
			LOGIN,
			TOS,
			GENDER,
			WORLDSELECT,
			REGION,
			CHARSELECT,
			LOGINWAIT,
			RACESELECT,
			CLASSCREATION,
			SOFTKEYBOARD,
			LOGINNOTICE,
			LOGINNOTICE_CONFIRM,
			STATUSMESSENGER,
			STATUSBAR,
			CHATBAR,
			BUFFLIST,
			NOTICE,
			NPCTALK,
			SHOP,
			STATSINFO,
			ITEMINVENTORY,
			EQUIPINVENTORY,
			SKILLBOOK,
			QUESTLOG,
			WORLDMAP,
			USERLIST,
			MINIMAP,
			CHANNEL,
			CHAT,
			CHATRANK,
			JOYPAD,
			EVENT,
			KEYCONFIG,
			OPTIONMENU,
			QUIT,
			CHARINFO,
			CASHSHOP,
			NUM_TYPES
		};

		virtual ~UIElement() {}

		virtual void draw(float inter) const;
		virtual void update();
		virtual void update_screen(int16_t new_width, int16_t new_height) {}

		void makeactive();
		void deactivate();
		bool is_active() const;

		virtual void toggle_active();
		virtual Button::State button_pressed(uint16_t buttonid) { return Button::State::DISABLED; }
		virtual bool send_icon(const Icon& icon, Point<int16_t> cursor_position) { return true; }

		virtual void doubleclick(Point<int16_t> cursorpos) {}
		virtual void rightclick(Point<int16_t> cursorpos) {}
		virtual bool is_in_range(Point<int16_t> cursor_position) const;
		virtual void remove_cursor();
		virtual Cursor::State send_cursor(bool clicked, Point<int16_t> cursor_position);
		virtual void send_scroll(double yoffset) {}
		virtual void send_key(int32_t keycode, bool pressed, bool escape) {}

		virtual UIElement::Type get_type() const = 0;

	protected:
		UIElement(Point<int16_t> position, Point<int16_t> dimension, bool active);
		UIElement(Point<int16_t> position, Point<int16_t> dimension);
		UIElement();

		void draw_sprites(float alpha) const;
		void draw_buttons(float alpha) const;

		std::map<uint16_t, std::unique_ptr<Button>> buttons;
		std::vector<Sprite> sprites;
		Point<int16_t> position;
		Point<int16_t> dimension;
		bool active;
	};
}

================
File: IO/UIState.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Keyboard.h"
#include "UIElement.h"

#include "Components/Tooltip.h"

namespace ms
{
	class UIState
	{
	public:
		using Iterator = EnumMap<UIElement::Type, std::unique_ptr<UIElement>, UIElement::Type::NUM_TYPES>::iterator;

		virtual ~UIState() {}

		virtual void draw(float inter, Point<int16_t> cursor) const = 0;
		virtual void update() = 0;

		virtual void doubleclick(Point<int16_t> pos) = 0;
		virtual void rightclick(Point<int16_t> pos) = 0;
		virtual void send_key(KeyType::Id type, int32_t action, bool pressed, bool escape) = 0;
		virtual Cursor::State send_cursor(Point<int16_t> cursor_position, Cursor::State cursor_state) = 0;
		virtual void send_scroll(double yoffset) = 0;
		virtual void send_close() = 0;

		virtual void drag_icon(Icon* icon) = 0;
		virtual void clear_tooltip(Tooltip::Parent parent) = 0;
		virtual void show_equip(Tooltip::Parent parent, int16_t slot) = 0;
		virtual void show_item(Tooltip::Parent parent, int32_t itemid) = 0;
		virtual void show_skill(Tooltip::Parent parent, int32_t skill_id, int32_t level, int32_t masterlevel, int64_t expiration) = 0;
		virtual void show_text(Tooltip::Parent parent, std::string text) = 0;
		virtual void show_map(Tooltip::Parent parent, std::string name, std::string description, int32_t mapid, bool bolded, bool portal) = 0;

		virtual Iterator pre_add(UIElement::Type type, bool toggled, bool focused) = 0;
		virtual void remove(UIElement::Type type) = 0;
		virtual UIElement* get(UIElement::Type type) = 0;
		virtual UIElement* get_front(std::list<UIElement::Type> types) = 0;
		virtual UIElement* get_front(Point<int16_t> cursor_position) = 0;
	};

	class UIStateNull : public UIState
	{
		void draw(float, Point<int16_t>) const override {}
		void update() override {}
		void doubleclick(Point<int16_t>) override {}
		void rightclick(Point<int16_t>) override {}
		void send_key(KeyType::Id, int32_t, bool, bool) override {}
		Cursor::State send_cursor(Point<int16_t>, Cursor::State) override { return Cursor::State::IDLE; }
		void send_scroll(double) override {}
		void send_close() override {}
		void drag_icon(Icon*) override {}
		void clear_tooltip(Tooltip::Parent) override {}
		void show_equip(Tooltip::Parent, int16_t) override {}
		void show_item(Tooltip::Parent, int32_t) override {}
		void show_skill(Tooltip::Parent, int32_t, int32_t, int32_t, int64_t) override {}
		void show_text(Tooltip::Parent, std::string) override {}
		void show_map(Tooltip::Parent, std::string, std::string, int32_t, bool, bool) override {}
		Iterator pre_add(UIElement::Type, bool, bool) override { return { nullptr, UIElement::Type::NUM_TYPES }; }
		void remove(UIElement::Type) override {}
		UIElement* get(UIElement::Type) override { return nullptr; }
		UIElement* get_front(std::list<UIElement::Type>) override { return nullptr; }
		UIElement* get_front(Point<int16_t>) override { return nullptr; }
	};
}

================
File: IO/UIStateCashShop.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIStateCashShop.h"

#include "UITypes/UICashShop.h"

namespace ms
{
	UIStateCashShop::UIStateCashShop()
	{
		focused = UIElement::NONE;

		emplace<UICashShop>();
	}

	void UIStateCashShop::draw(float inter, Point<int16_t> cursor) const
	{
		for (auto iter : elements)
		{
			UIElement* element = iter.second.get();

			if (element && element->is_active())
				element->draw(inter);
		}
	}

	void UIStateCashShop::update()
	{
		for (auto iter : elements)
		{
			UIElement* element = iter.second.get();

			if (element && element->is_active())
				element->update();
		}
	}

	Cursor::State UIStateCashShop::send_cursor(Point<int16_t> cursor_position, Cursor::State cursor_state)
	{
		bool clicked = cursor_state == Cursor::State::CLICKING || cursor_state == Cursor::State::VSCROLLIDLE;

		if (auto focusedelement = get(focused))
		{
			if (focusedelement->is_active())
			{
				remove_cursor(focusedelement->get_type());

				return focusedelement->send_cursor(clicked, cursor_position);
			}
			else
			{
				focused = UIElement::NONE;

				return cursor_state;
			}
		}
		else
		{
			if (auto front = get_front())
			{
				remove_cursor(front->get_type());

				return front->send_cursor(clicked, cursor_position);
			}
			else
			{
				return Cursor::State::IDLE;
			}
		}
	}

	UIState::Iterator UIStateCashShop::pre_add(UIElement::Type type, bool toggled, bool is_focused)
	{
		remove(type);

		if (is_focused)
			focused = type;

		return elements.find(type);
	}

	void UIStateCashShop::remove(UIElement::Type type)
	{
		if (focused == type)
			focused = UIElement::Type::NONE;

		if (auto& element = elements[type])
		{
			element->deactivate();
			element.release();
		}
	}

	UIElement* UIStateCashShop::get(UIElement::Type type)
	{
		return elements[type].get();
	}

	UIElement* UIStateCashShop::get_front()
	{
		UIElement* front = nullptr;

		for (auto iter : elements)
		{
			auto& element = iter.second;

			if (element && element->is_active())
				front = element.get();
		}

		return front;
	}

	void UIStateCashShop::remove_cursor(UIElement::Type type)
	{
		for (auto iter : elements)
		{
			auto& element = iter.second;

			if (element && element->is_active() && element->get_type() != type)
				element->remove_cursor();
		}
	}

	template <class T, typename...Args>
	void UIStateCashShop::emplace(Args&& ...args)
	{
		if (auto iter = pre_add(T::TYPE, T::TOGGLED, T::FOCUSED))
		{
			(*iter).second = std::make_unique<T>(
				std::forward<Args>(args)...
				);
		}
	}
}

================
File: IO/UIStateCashShop.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "UIState.h"

namespace ms
{
	class UIStateCashShop : public UIState
	{
	public:
		UIStateCashShop();

		void draw(float inter, Point<int16_t> cursor) const override;
		void update() override;

		void doubleclick(Point<int16_t>) override {}
		void rightclick(Point<int16_t>) override {}
		void send_key(KeyType::Id, int32_t, bool, bool) override {}
		Cursor::State send_cursor(Point<int16_t> cursor_position, Cursor::State cursor_state) override;
		void send_scroll(double yoffset) override {}
		void send_close() override {}

		void drag_icon(Icon*) override {}
		void clear_tooltip(Tooltip::Parent) override {}
		void show_equip(Tooltip::Parent, int16_t) override {}
		void show_item(Tooltip::Parent, int32_t) override {}
		void show_skill(Tooltip::Parent, int32_t, int32_t, int32_t, int64_t) override {}
		void show_text(Tooltip::Parent, std::string) override {}
		void show_map(Tooltip::Parent, std::string, std::string, int32_t, bool, bool) override {}

		Iterator pre_add(UIElement::Type type, bool toggled, bool focused) override;
		void remove(UIElement::Type type) override;
		UIElement* get(UIElement::Type type) override;
		UIElement* get_front();
		UIElement* get_front(std::list<UIElement::Type>) override { return nullptr; }
		UIElement* get_front(Point<int16_t>) override { return nullptr; }

	private:
		void remove_cursor(UIElement::Type type);

		template <class T, typename...Args>
		void emplace(Args&& ...args);

		EnumMap<UIElement::Type, UIElement::UPtr, UIElement::Type::NUM_TYPES> elements;
		UIElement::Type focused;
	};
}

================
File: IO/UIStateGame.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIStateGame.h"

#include "UI.h"

#include "UITypes/UIBuffList.h"
#include "UITypes/UIChannel.h"
#include "UITypes/UICharInfo.h"
#include "UITypes/UIChat.h"
#include "UITypes/UIChatBar.h"
#include "UITypes/UIEquipInventory.h"
#include "UITypes/UIEvent.h"
#include "UITypes/UIItemInventory.h"
#include "UITypes/UIKeyConfig.h"
#include "UITypes/UIMiniMap.h"
#include "UITypes/UIQuestLog.h"
#include "UITypes/UIQuit.h"
#include "UITypes/UIShop.h"
#include "UITypes/UISkillBook.h"
#include "UITypes/UIStatsInfo.h"
#include "UITypes/UIStatusBar.h"
#include "UITypes/UIStatusMessenger.h"
#include "UITypes/UIUserList.h"
#include "UITypes/UIWorldMap.h"

#include "../Net/Packets/GameplayPackets.h"

namespace ms
{
	UIStateGame::UIStateGame() : stats(Stage::get().get_player().get_stats()), dragged(nullptr)
	{
		focused = UIElement::Type::NONE;
		tooltipparent = Tooltip::Parent::NONE;

		const CharLook& look = Stage::get().get_player().get_look();
		const Inventory& inventory = Stage::get().get_player().get_inventory();

		emplace<UIStatusMessenger>();
		emplace<UIStatusBar>(stats);
		emplace<UIChatBar>();
		emplace<UIMiniMap>(stats);
		emplace<UIBuffList>();
		emplace<UIShop>(look, inventory);

		VWIDTH = Constants::Constants::get().get_viewwidth();
		VHEIGHT = Constants::Constants::get().get_viewheight();
	}

	void UIStateGame::draw(float inter, Point<int16_t> cursor) const
	{
		for (auto& type : elementorder)
		{
			auto& element = elements[type];

			if (element && element->is_active())
				element->draw(inter);
		}

		if (tooltip)
			tooltip->draw(cursor + Point<int16_t>(0, 22));

		if (draggedicon)
			draggedicon->dragdraw(cursor);
	}

	void UIStateGame::update()
	{
		bool update_screen = false;
		int16_t new_width = Constants::Constants::get().get_viewwidth();
		int16_t new_height = Constants::Constants::get().get_viewheight();

		if (VWIDTH != new_width || VHEIGHT != new_height)
		{
			update_screen = true;
			VWIDTH = new_width;
			VHEIGHT = new_height;

			UI::get().remove(UIElement::Type::STATUSBAR);

			const CharStats& stats = Stage::get().get_player().get_stats();
			emplace<UIStatusBar>(stats);
		}

		for (auto& type : elementorder)
		{
			auto& element = elements[type];

			if (element && element->is_active())
			{
				element->update();

				if (update_screen)
					element->update_screen(new_width, new_height);
			}
		}
	}

	bool UIStateGame::drop_icon(const Icon& icon, Point<int16_t> cursor_position)
	{
		if (UIElement* front = get_front(cursor_position))
			return front->send_icon(icon, cursor_position);
		else
			icon.drop_on_stage();

		return true;
	}

	void UIStateGame::remove_icon()
	{
		draggedicon->reset();
		draggedicon = {};
	}

	void UIStateGame::remove_cursors()
	{
		for (auto type : elementorder)
		{
			auto element = elements[type].get();

			if (element && element->is_active())
				element->remove_cursor();
		}
	}

	void UIStateGame::remove_cursor(UIElement::Type t)
	{
		for (auto type : elementorder)
		{
			auto element = elements[type].get();

			if (element && element->is_active() && element->get_type() != t)
				element->remove_cursor();
		}
	}

	void UIStateGame::doubleclick(Point<int16_t> pos)
	{
		if (UIElement* front = get_front(pos))
			front->doubleclick(pos);
	}

	void UIStateGame::rightclick(Point<int16_t> pos)
	{
		if (UIElement* front = get_front(pos))
			front->rightclick(pos);
	}

	void UIStateGame::send_key(KeyType::Id type, int32_t action, bool pressed, bool escape)
	{
		if (UIElement* focusedelement = get(focused))
		{
			if (focusedelement->is_active())
			{
				return focusedelement->send_key(action, pressed, escape);
			}
			else
			{
				focused = UIElement::NONE;

				return;
			}
		}
		else
		{
			switch (type)
			{
				case KeyType::Id::MENU:
				{
					if (pressed)
					{
						switch (action)
						{
							case KeyAction::Id::EQUIPMENT:
							{
								emplace<UIEquipInventory>(
									Stage::get().get_player().get_inventory()
									);

								break;
							}
							case KeyAction::Id::ITEMS:
							{
								emplace<UIItemInventory>(
									Stage::get().get_player().get_inventory()
									);

								break;
							}
							case KeyAction::Id::STATS:
							{
								emplace<UIStatsInfo>(
									Stage::get().get_player().get_stats()
									);

								break;
							}
							case KeyAction::Id::SKILLS:
							{
								emplace<UISkillBook>(
									Stage::get().get_player().get_stats(),
									Stage::get().get_player().get_skills()
									);

								break;
							}
							case KeyAction::Id::FRIENDS:
							case KeyAction::Id::PARTY:
							case KeyAction::Id::BOSSPARTY:
							{
								UIUserList::Tab tab;

								switch (action)
								{
									case KeyAction::Id::FRIENDS:
										tab = UIUserList::Tab::FRIEND;
										break;
									case KeyAction::Id::PARTY:
										tab = UIUserList::Tab::PARTY;
										break;
									case KeyAction::Id::BOSSPARTY:
										tab = UIUserList::Tab::BOSS;
										break;
								}

								auto userlist = UI::get().get_element<UIUserList>();

								if (userlist && userlist->get_tab() != tab && userlist->is_active())
								{
									userlist->change_tab(tab);
								}
								else
								{
									emplace<UIUserList>(tab);

									if (userlist && userlist->get_tab() != tab && userlist->is_active())
										userlist->change_tab(tab);
								}

								break;
							}
							case KeyAction::Id::WORLDMAP:
							{
								emplace<UIWorldMap>();
								break;
							}
							case KeyAction::Id::MAPLECHAT:
							{
								auto chat = UI::get().get_element<UIChat>();

								if (!chat || !chat->is_active())
									emplace<UIChat>();

								break;
							}
							case KeyAction::Id::MINIMAP:
							{
								if (auto minimap = UI::get().get_element<UIMiniMap>())
									minimap->send_key(action, pressed, escape);

								break;
							}
							case KeyAction::Id::QUESTLOG:
							{
								emplace<UIQuestLog>(
									Stage::get().get_player().get_quests()
									);

								break;
							}
							case KeyAction::Id::KEYBINDINGS:
							{
								auto keyconfig = UI::get().get_element<UIKeyConfig>();

								if (!keyconfig || !keyconfig->is_active())
								{
									emplace<UIKeyConfig>(
										Stage::get().get_player().get_inventory(),
										Stage::get().get_player().get_skills()
										);
								}
								else if (keyconfig && keyconfig->is_active())
								{
									keyconfig->close();
								}

								break;
							}
							case KeyAction::Id::SAY:
							case KeyAction::Id::PARTYCHAT:
							case KeyAction::Id::FRIENDSCHAT:
							case KeyAction::Id::GUILDCHAT:
							case KeyAction::Id::ALLIANCECHAT:
							case KeyAction::Id::TOSPOUSE:
							{
								if (auto chatbar = UI::get().get_element<UIChatBar>())
									chatbar->change_target(action);

								break;
							}
							case KeyAction::Id::MENU:
							{
								if (auto statusbar = UI::get().get_element<UIStatusBar>())
									statusbar->toggle_menu();

								break;
							}
							case KeyAction::Id::QUICKSLOTS:
							{
								if (auto statusbar = UI::get().get_element<UIStatusBar>())
									statusbar->toggle_qs();

								break;
							}
							case KeyAction::Id::TOGGLECHAT:
							{
								if (auto chatbar = UI::get().get_element<UIChatBar>())
								{
									if (chatbar->has_input())
										chatbar->send_key(action, pressed, escape);
									else
										chatbar->toggle_view();
								}

								break;
							}
							case KeyAction::Id::CASHSHOP:
							{
								EnterCashShopPacket().dispatch();
								break;
							}
							case KeyAction::Id::EVENT:
							{
								emplace<UIEvent>();
								break;
							}
							case KeyAction::Id::CHARINFO:
							{
								emplace<UICharInfo>(
									Stage::get().get_player().get_oid()
									);

								break;
							}
							case KeyAction::Id::CHANGECHANNEL:
							{
								emplace<UIChannel>();
								break;
							}
							case KeyAction::Id::MAINMENU:
							{
								if (auto statusbar = UI::get().get_element<UIStatusBar>())
									statusbar->send_key(action, pressed, escape);

								break;
							}
							default:
							{
								LOG(LOG_DEBUG, "Unknown KeyAction::Id action: [" << action << "]");
								break;
							}
						}
					}

					break;
				}
				case KeyType::Id::ACTION:
				case KeyType::Id::FACE:
				case KeyType::Id::ITEM:
				case KeyType::Id::SKILL:
				{
					Stage::get().send_key(type, action, pressed);
					break;
				}
			}
		}
	}

	Cursor::State UIStateGame::send_cursor(Point<int16_t> cursor_position, Cursor::State cursor_state)
	{
		if (draggedicon)
		{
			if (cursor_state == Cursor::State::CLICKING)
			{
				if (drop_icon(*draggedicon, cursor_position))
					remove_icon();

				return cursor_state;
			}

			return Cursor::State::GRABBING;
		}
		else
		{
			bool clicked = cursor_state == Cursor::State::CLICKING || cursor_state == Cursor::State::VSCROLLIDLE || (dragged && (cursor_state == Cursor::State::CHATBARMOVE || cursor_state == Cursor::State::CHATBARVDRAG || cursor_state == Cursor::State::CHATBARHDRAG || cursor_state == Cursor::State::CHATBARBLTRDRAG || cursor_state == Cursor::State::CHATBARBRTLDRAG));

			if (auto focusedelement = get(focused))
			{
				if (focusedelement->is_active())
				{
					remove_cursor(focusedelement->get_type());

					return focusedelement->send_cursor(clicked, cursor_position);
				}
				else
				{
					focused = UIElement::Type::NONE;

					return cursor_state;
				}
			}
			else
			{
				if (!clicked)
				{
					dragged = nullptr;

					if (auto front = get_front(cursor_position))
					{
						UIElement::Type front_type = front->get_type();

						if (tooltipparent != UIElement::Type::NONE)
							if (front_type != tooltipparent)
								clear_tooltip(tooltipparent);

						remove_cursor(front_type);

						return front->send_cursor(clicked, cursor_position);
					}
					else
					{
						remove_cursors();

						return Stage::get().send_cursor(clicked, cursor_position);
					}
				}
				else
				{
					if (!dragged)
					{
						UIElement::Type drag_element_type = UIElement::Type::NONE;

						for (auto iter = elementorder.rbegin(); iter != elementorder.rend(); ++iter)
						{
							auto& element = elements[*iter];

							if (element && element->is_active() && element->is_in_range(cursor_position))
							{
								dragged = element.get();
								drag_element_type = *iter;
								break;
							}
						}

						if (drag_element_type != UIElement::Type::NONE)
						{
							elementorder.remove(drag_element_type);
							elementorder.push_back(drag_element_type);
						}
					}

					if (dragged)
						return dragged->send_cursor(clicked, cursor_position);
					else
						return Stage::get().send_cursor(clicked, cursor_position);
				}
			}
		}
	}

	void UIStateGame::send_scroll(double yoffset)
	{
		for (auto& type : elementorder)
		{
			auto& element = elements[type];

			if (element && element->is_active())
				element->send_scroll(yoffset);
		}
	}

	void UIStateGame::send_close()
	{
		UI::get().emplace<UIQuit>(stats);
	}

	void UIStateGame::drag_icon(Icon* drgic)
	{
		draggedicon = drgic;
	}

	void UIStateGame::clear_tooltip(Tooltip::Parent parent)
	{
		if (parent == tooltipparent)
		{
			eqtooltip.set_equip(Tooltip::Parent::NONE, 0);
			ittooltip.set_item(0);
			tetooltip.set_text("");
			matooltip.reset();
			tooltip = {};
			tooltipparent = Tooltip::Parent::NONE;
		}
	}

	void UIStateGame::show_equip(Tooltip::Parent parent, int16_t slot)
	{
		eqtooltip.set_equip(parent, slot);

		if (slot)
		{
			tooltip = eqtooltip;
			tooltipparent = parent;
		}
	}

	void UIStateGame::show_item(Tooltip::Parent parent, int32_t itemid)
	{
		ittooltip.set_item(itemid);

		if (itemid)
		{
			tooltip = ittooltip;
			tooltipparent = parent;
		}
	}

	void UIStateGame::show_skill(Tooltip::Parent parent, int32_t skill_id, int32_t level, int32_t masterlevel, int64_t expiration)
	{
		sktooltip.set_skill(skill_id, level, masterlevel, expiration);

		if (skill_id)
		{
			tooltip = sktooltip;
			tooltipparent = parent;
		}
	}

	void UIStateGame::show_text(Tooltip::Parent parent, std::string text)
	{
		tetooltip.set_text(text);

		if (!text.empty())
		{
			tooltip = tetooltip;
			tooltipparent = parent;
		}
	}

	void UIStateGame::show_map(Tooltip::Parent parent, std::string title, std::string description, int32_t mapid, bool bolded, bool portal)
	{
		matooltip.set_title(parent, title, bolded);
		matooltip.set_desc(description);
		matooltip.set_mapid(mapid, portal);

		if (!title.empty())
		{
			tooltip = matooltip;
			tooltipparent = parent;
		}
	}

	template <class T, typename...Args>
	void UIStateGame::emplace(Args&& ...args)
	{
		if (auto iter = pre_add(T::TYPE, T::TOGGLED, T::FOCUSED))
		{
			(*iter).second = std::make_unique<T>(
				std::forward<Args>(args)...
				);

			auto silent_types = {
				UIElement::Type::STATUSMESSENGER,
				UIElement::Type::STATUSBAR,
				UIElement::Type::CHATBAR,
				UIElement::Type::MINIMAP,
				UIElement::Type::BUFFLIST,
				UIElement::Type::NPCTALK,
				UIElement::Type::SHOP
			};

			if (std::find(silent_types.begin(), silent_types.end(), T::TYPE) == silent_types.end())
			{
				if (T::TYPE == UIElement::Type::WORLDMAP)
					Sound(Sound::Name::WORLDMAPOPEN).play();
				else
					Sound(Sound::Name::MENUUP).play();

				UI::get().send_cursor(false);
			}
		}
	}

	UIState::Iterator UIStateGame::pre_add(UIElement::Type type, bool is_toggled, bool is_focused)
	{
		auto& element = elements[type];

		if (element && is_toggled)
		{
			elementorder.remove(type);
			elementorder.push_back(type);

			bool active = element->is_active();

			element->toggle_active();

			if (active != element->is_active())
			{
				if (element->is_active())
				{
					if (type == UIElement::Type::WORLDMAP)
						Sound(Sound::Name::WORLDMAPOPEN).play();
					else
						Sound(Sound::Name::MENUUP).play();

					UI::get().send_cursor(false);
				}
				else
				{
					if (type == UIElement::Type::WORLDMAP)
						Sound(Sound::Name::WORLDMAPCLOSE).play();
					else
						Sound(Sound::Name::MENUDOWN).play();

					element->remove_cursor();

					if (draggedicon)
						if (element->get_type() == icon_map[draggedicon.get()->get_type()])
							remove_icon();

					UI::get().send_cursor(false);
				}
			}

			return elements.end();
		}
		else
		{
			remove(type);
			elementorder.push_back(type);

			if (is_focused)
				focused = type;

			return elements.find(type);
		}
	}

	void UIStateGame::remove(UIElement::Type type)
	{
		if (type == focused)
			focused = UIElement::Type::NONE;

		if (type == tooltipparent)
			clear_tooltip(tooltipparent);

		elementorder.remove(type);

		if (auto& element = elements[type])
		{
			element->deactivate();
			element.release();
		}
	}

	UIElement* UIStateGame::get(UIElement::Type type)
	{
		return elements[type].get();
	}

	UIElement* UIStateGame::get_front(std::list<UIElement::Type> types)
	{
		auto begin = elementorder.rbegin();
		auto end = elementorder.rend();

		for (auto& iter = begin; iter != end; ++iter)
		{
			if (std::find(types.begin(), types.end(), *iter) != types.end())
			{
				auto& element = elements[*iter];

				if (element && element->is_active())
					return element.get();
			}
		}

		return nullptr;
	}

	UIElement* UIStateGame::get_front(Point<int16_t> cursor_position)
	{
		auto begin = elementorder.rbegin();
		auto end = elementorder.rend();

		for (auto& iter = begin; iter != end; ++iter)
		{
			auto& element = elements[*iter];

			if (element && element->is_active() && element->is_in_range(cursor_position))
				return element.get();
		}

		return nullptr;
	}
}

================
File: IO/UIStateGame.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "UIState.h"

#include "Components/EquipTooltip.h"
#include "Components/ItemTooltip.h"
#include "Components/MapTooltip.h"
#include "Components/SkillTooltip.h"
#include "Components/TextTooltip.h"

#include "../Character/CharStats.h"

namespace ms
{
	class UIStateGame : public UIState
	{
	public:
		UIStateGame();

		void draw(float inter, Point<int16_t> cursor) const override;
		void update() override;

		void doubleclick(Point<int16_t> pos) override;
		void rightclick(Point<int16_t> pos) override;
		void send_key(KeyType::Id type, int32_t action, bool pressed, bool escape) override;
		Cursor::State send_cursor(Point<int16_t> cursor_position, Cursor::State cursor_state) override;
		void send_scroll(double yoffset) override;
		void send_close() override;

		void drag_icon(Icon* icon) override;
		void clear_tooltip(Tooltip::Parent parent) override;
		void show_equip(Tooltip::Parent parent, int16_t slot) override;
		void show_item(Tooltip::Parent parent, int32_t itemid) override;
		void show_skill(Tooltip::Parent parent, int32_t skill_id, int32_t level, int32_t masterlevel, int64_t expiration) override;
		void show_text(Tooltip::Parent parent, std::string text) override;
		void show_map(Tooltip::Parent parent, std::string title, std::string description, int32_t mapid, bool bolded, bool portal) override;

		Iterator pre_add(UIElement::Type type, bool toggled, bool focused);
		void remove(UIElement::Type type) override;
		UIElement* get(UIElement::Type type) override;
		UIElement* get_front(std::list<UIElement::Type> types) override;
		UIElement* get_front(Point<int16_t> cursor_position) override;

	private:
		const CharStats& stats;

		bool drop_icon(const Icon& icon, Point<int16_t> cursor_position);
		void remove_icon();
		void remove_cursors();
		void remove_cursor(UIElement::Type type);

		template <class T, typename...Args>
		void emplace(Args&& ...args);

		EnumMap<UIElement::Type, UIElement::UPtr, UIElement::Type::NUM_TYPES> elements;
		std::list<UIElement::Type> elementorder;
		UIElement::Type focused;
		UIElement* dragged;

		EquipTooltip eqtooltip;
		ItemTooltip ittooltip;
		SkillTooltip sktooltip;
		TextTooltip tetooltip;
		MapTooltip matooltip;
		Optional<Tooltip> tooltip;
		Tooltip::Parent tooltipparent;

		Optional<Icon> draggedicon;

		std::map<Icon::IconType, UIElement::Type> icon_map =
		{
			{ Icon::IconType::NONE,			UIElement::Type::NONE			},
			{ Icon::IconType::SKILL,		UIElement::Type::SKILLBOOK		},
			{ Icon::IconType::EQUIP,		UIElement::Type::EQUIPINVENTORY	},
			{ Icon::IconType::ITEM,			UIElement::Type::ITEMINVENTORY	},
			{ Icon::IconType::KEY,			UIElement::Type::KEYCONFIG		},
			{ Icon::IconType::NUM_TYPES,	UIElement::Type::NUM_TYPES		}
		};

		int16_t VWIDTH;
		int16_t VHEIGHT;
	};
}

================
File: IO/UIStateLogin.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIStateLogin.h"

#include "UITypes/UICharSelect.h"
#include "UITypes/UILogin.h"
#include "UITypes/UILoginNotice.h"
#include "UITypes/UILogo.h"
#include "UITypes/UIRegion.h"

#include "../Configuration.h"
#include <iostream>

namespace ms
{
	UIStateLogin::UIStateLogin()
	{
		focused = UIElement::Type::NONE;

		bool start_shown = Configuration::get().get_start_shown();

		// Skip logo for faster testing
		//if (!start_shown)
		//	emplace<UILogo>();
		//else
			emplace<UILogin>();
	}

	void UIStateLogin::draw(float inter, Point<int16_t> cursor) const
	{
		// Drawing UI elements
		for (auto iter : elements)
		{
			UIElement* element = iter.second.get();

			if (element && element->is_active())
			{
				// Drawing active element
				element->draw(inter);
			}
			else if (element)
			{
				// Skipping inactive element
			}
		}

		if (tooltip)
			tooltip->draw(cursor + Point<int16_t>(0, 22));
	}

	void UIStateLogin::update()
	{
		for (auto iter : elements)
		{
			UIElement* element = iter.second.get();

			if (element && element->is_active())
				element->update();
		}
	}

	void UIStateLogin::doubleclick(Point<int16_t> pos)
	{
		if (auto charselect = UI::get().get_element<UICharSelect>())
			charselect->doubleclick(pos);
	}

	void UIStateLogin::send_key(KeyType::Id type, int32_t action, bool pressed, bool escape)
	{
		if (UIElement* focusedelement = get(focused))
		{
			if (focusedelement->is_active())
			{
				return focusedelement->send_key(action, pressed, escape);
			}
			else
			{
				focused = UIElement::Type::NONE;

				return;
			}
		}
	}

	Cursor::State UIStateLogin::send_cursor(Point<int16_t> cursor_position, Cursor::State cursor_state)
	{
		bool clicked = cursor_state == Cursor::State::CLICKING || cursor_state == Cursor::State::VSCROLLIDLE;

		if (auto focusedelement = get(focused))
		{
			if (focusedelement->is_active())
			{
				remove_cursor(focusedelement->get_type());

				return focusedelement->send_cursor(clicked, cursor_position);
			}
			else
			{
				focused = UIElement::Type::NONE;

				return cursor_state;
			}
		}
		else
		{
			if (auto front = get_front())
			{
				remove_cursor(front->get_type());

				return front->send_cursor(clicked, cursor_position);
			}
			else
			{
				return Cursor::State::IDLE;
			}
		}
	}

	void UIStateLogin::send_close()
	{
		auto logo = UI::get().get_element<UILogo>();
		auto login = UI::get().get_element<UILogin>();
		auto region = UI::get().get_element<UIRegion>();

		if (logo && logo->is_active() || login && login->is_active() || region && region->is_active())
			UI::get().quit();
		else
			UI::get().emplace<UIQuitConfirm>();
	}

	void UIStateLogin::clear_tooltip(Tooltip::Parent parent)
	{
		if (parent == tooltipparent)
		{
			tetooltip.set_text("");
			tooltip = {};
			tooltipparent = Tooltip::Parent::NONE;
		}
	}

	void UIStateLogin::show_text(Tooltip::Parent parent, std::string text)
	{
		tetooltip.set_text(text);

		if (!text.empty())
		{
			tooltip = tetooltip;
			tooltipparent = parent;
		}
	}

	template <class T, typename...Args>
	void UIStateLogin::emplace(Args&& ...args)
	{
		if (auto iter = pre_add(T::TYPE, T::TOGGLED, T::FOCUSED))
		{
			(*iter).second = std::make_unique<T>(
				std::forward<Args>(args)...
			);
		}
	}

	UIState::Iterator UIStateLogin::pre_add(UIElement::Type type, bool, bool is_focused)
	{
		remove(type);

		if (is_focused)
			focused = type;

		return elements.find(type);
	}

	void UIStateLogin::remove(UIElement::Type type)
	{
		if (focused == type)
			focused = UIElement::Type::NONE;

		if (auto& element = elements[type])
		{
			element->deactivate();
			element.release();
		}
	}

	UIElement* UIStateLogin::get(UIElement::Type type)
	{
		return elements[type].get();
	}

	UIElement* UIStateLogin::get_front()
	{
		UIElement* front = nullptr;

		for (auto iter : elements)
		{
			auto& element = iter.second;

			if (element && element->is_active())
				front = element.get();
		}

		return front;
	}

	UIElement* UIStateLogin::get_front(std::list<UIElement::Type> types)
	{
		auto begin = types.rbegin();
		auto end = types.rend();

		for (auto iter = begin; iter != end; ++iter)
		{
			auto& element = elements[*iter];

			if (element && element->is_active())
				return element.get();
		}

		return nullptr;
	}

	UIElement* UIStateLogin::get_front(Point<int16_t> cursor_position)
	{
		auto begin = elements.values().rbegin();
		auto end = elements.values().rend();

		for (auto iter = begin; iter != end; ++iter)
		{
			auto& element = *iter;

			if (element && element->is_active() && element->is_in_range(cursor_position))
				return element.get();
		}

		return nullptr;
	}

	void UIStateLogin::remove_cursor(UIElement::Type type)
	{
		for (auto iter : elements)
		{
			auto& element = iter.second;

			if (element && element->is_active() && element->get_type() != type)
				element->remove_cursor();
		}
	}
}

================
File: IO/UIStateLogin.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "UIState.h"

#include "Components/TextTooltip.h"

namespace ms
{
	class UIStateLogin : public UIState
	{
	public:
		UIStateLogin();

		void draw(float inter, Point<int16_t> cursor) const override;
		void update() override;

		void doubleclick(Point<int16_t> pos) override;
		void rightclick(Point<int16_t>) override {}
		void send_key(KeyType::Id type, int32_t action, bool pressed, bool escape) override;
		Cursor::State send_cursor(Point<int16_t> cursor_position, Cursor::State cursor_state) override;
		void send_scroll(double) override {}
		void send_close() override;

		void drag_icon(Icon*) override {}
		void clear_tooltip(Tooltip::Parent parent) override;
		void show_equip(Tooltip::Parent, int16_t) override {}
		void show_item(Tooltip::Parent, int32_t) override {}
		void show_skill(Tooltip::Parent, int32_t, int32_t, int32_t, int64_t) override {}
		void show_text(Tooltip::Parent parent, std::string text) override;
		void show_map(Tooltip::Parent, std::string, std::string, int32_t, bool, bool) {}

		Iterator pre_add(UIElement::Type type, bool toggled, bool focused) override;
		void remove(UIElement::Type type) override;
		UIElement* get(UIElement::Type type) override;
		UIElement* get_front();
		UIElement* get_front(std::list<UIElement::Type> types) override;
		UIElement* get_front(Point<int16_t> cursor_position) override;

	private:
		void remove_cursor(UIElement::Type type);

		template <class T, typename...Args>
		void emplace(Args&& ...args);

		EnumMap<UIElement::Type, UIElement::UPtr, UIElement::Type::NUM_TYPES> elements;
		UIElement::Type focused;

		TextTooltip tetooltip;
		Optional<Tooltip> tooltip;
		Tooltip::Parent tooltipparent;
	};
}

================
File: IO/UITypes/UIAranCreation.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "UICommonCreation.h"

namespace ms
{
	class UIAranCreation : public UICommonCreation
	{
	public:
		UIAranCreation() : UICommonCreation("2000") {}
	};
}

================
File: IO/UITypes/UIBuffList.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIBuffList.h"

#include "../../Data/ItemData.h"
#include "../../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	BuffIcon::BuffIcon(int32_t buff, int32_t dur) : cover(IconCover::BUFF, dur - FLASH_TIME)
	{
		buffid = buff;
		duration = dur;
		opacity.set(1.0f);
		opcstep = -0.05f;

		if (buffid >= 0)
		{
			std::string strid = string_format::extend_id(buffid, 7);
			nl::node src = nl::nx::Skill[strid.substr(0, 3) + ".img"]["skill"][strid];
			icon = src["icon"];
		}
		else
		{
			icon = ItemData::get(-buffid).get_icon(true);
		}
	}

	void BuffIcon::draw(Point<int16_t> position, float alpha) const
	{
		icon.draw(DrawArgument(position, opacity.get(alpha)));
		cover.draw(position + Point<int16_t>(1, -31), alpha);
	}

	bool BuffIcon::update()
	{
		if (duration <= FLASH_TIME)
		{
			opacity += opcstep;

			bool fadedout = opcstep < 0.0f && opacity.last() <= 0.0f;
			bool fadedin = opcstep > 0.0f && opacity.last() >= 1.0f;

			if (fadedout || fadedin)
				opcstep = -opcstep;
		}

		cover.update();

		duration -= Constants::TIMESTEP;

		return duration < Constants::TIMESTEP;
	}

	UIBuffList::UIBuffList()
	{
		int16_t height = Constants::Constants::get().get_viewheight();
		int16_t width = Constants::Constants::get().get_viewwidth();

		update_screen(width, height);
	}

	void UIBuffList::draw(float alpha) const
	{
		Point<int16_t> icpos = position;

		for (auto& icon : icons)
		{
			icon.second.draw(icpos, alpha);
			icpos.shift_x(-32);
		}
	}

	void UIBuffList::update()
	{
		for (auto iter = icons.begin(); iter != icons.end();)
		{
			bool expired = iter->second.update();

			if (expired)
				iter = icons.erase(iter);
			else
				iter++;
		}
	}

	void UIBuffList::update_screen(int16_t new_width, int16_t)
	{
		position = Point<int16_t>(new_width - 35, 55);
		dimension = Point<int16_t>(position.x(), 32);
	}

	Cursor::State UIBuffList::send_cursor(bool pressed, Point<int16_t> cursorposition)
	{
		return UIElement::send_cursor(pressed, cursorposition);
	}

	UIElement::Type UIBuffList::get_type() const
	{
		return TYPE;
	}

	void UIBuffList::add_buff(int32_t buffid, int32_t duration)
	{
		icons.emplace(
			std::piecewise_construct,
			std::forward_as_tuple(buffid),
			std::forward_as_tuple(buffid, duration)
		);
	}
}

================
File: IO/UITypes/UIBuffList.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../Components/IconCover.h"

namespace ms
{
	class BuffIcon
	{
	public:
		BuffIcon(int32_t buff, int32_t dur);

		void draw(Point<int16_t> position, float alpha) const;
		bool update();

	private:
		static const uint16_t FLASH_TIME = 3'000;

		Texture icon;
		IconCover cover;
		int32_t buffid;
		int32_t duration;
		Linear<float> opacity;
		float opcstep;
	};


	class UIBuffList : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::BUFFLIST;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = false;

		UIBuffList();

		void draw(float inter) const override;
		void update() override;
		void update_screen(int16_t new_width, int16_t new_height) override;

		Cursor::State send_cursor(bool pressed, Point<int16_t> position) override;

		UIElement::Type get_type() const override;

		void add_buff(int32_t buffid, int32_t duration);

	private:
		std::unordered_map<int32_t, BuffIcon> icons;
	};
}

================
File: IO/UITypes/UICashShop.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UICashShop.h"

#include "../UI.h"
#include "../Window.h"

#include "../Components/MapleButton.h"

#include "../../Gameplay/Stage.h"

#include "../../Net/Packets/GameplayPackets.h"
#include "../../Net/Packets/LoginPackets.h"

#include <windows.h>

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UICashShop::UICashShop() : preview_index(0), menu_index(1), promotion_index(0), mvp_grade(1), mvp_exp(0.07f), list_offset(0)
	{
		nl::node CashShop = nl::nx::UI["CashShop.img"];
		nl::node Base = CashShop["Base"];
		nl::node backgrnd = Base["backgrnd"];
		nl::node BestNew = Base["BestNew"];
		nl::node Preview = Base["Preview"];
		nl::node CSTab = CashShop["CSTab"];
		nl::node CSGLChargeNX = CSTab["CSGLChargeNX"];
		nl::node CSStatus = CashShop["CSStatus"];
		nl::node CSPromotionBanner = CashShop["CSPromotionBanner"];
		nl::node CSMVPBanner = CashShop["CSMVPBanner"];
		nl::node CSItemSearch = CashShop["CSItemSearch"];
		nl::node CSChar = CashShop["CSChar"];
		nl::node CSList = CashShop["CSList"];
		nl::node CSEffect = CashShop["CSEffect"];

		sprites.emplace_back(backgrnd);
		sprites.emplace_back(BestNew, Point<int16_t>(139, 346));

		BestNew_dim = Texture(BestNew).get_dimensions();

		for (size_t i = 0; i < 3; i++)
			preview_sprites[i] = Preview[i];

		for (size_t i = 0; i < 3; i++)
			buttons[Buttons::BtPreview1 + i] = std::make_unique<TwoSpriteButton>(Base["Tab"]["Disable"][i], Base["Tab"]["Enable"][i], Point<int16_t>(957 + (i * 17), 46));

		buttons[Buttons::BtPreview1]->set_state(Button::State::PRESSED);

		buttons[Buttons::BtExit] = std::make_unique<MapleButton>(CSTab["BtExit"], Point<int16_t>(5, 728));
		buttons[Buttons::BtChargeNX] = std::make_unique<MapleButton>(CSGLChargeNX["BtChargeNX"], Point<int16_t>(5, 554));
		buttons[Buttons::BtChargeRefresh] = std::make_unique<MapleButton>(CSGLChargeNX["BtChargeRefresh"], Point<int16_t>(92, 554));

		for (size_t i = 0; i < 9; i++)
			menu_tabs[i] = CSTab["Tab"][i];

		buttons[Buttons::BtChargeRefresh] = std::make_unique<MapleButton>(CSGLChargeNX["BtChargeRefresh"], Point<int16_t>(92, 554));
		buttons[Buttons::BtWish] = std::make_unique<MapleButton>(CSStatus["BtWish"], Point<int16_t>(226, 6));
		buttons[Buttons::BtMileage] = std::make_unique<MapleButton>(CSStatus["BtMileage"], Point<int16_t>(869, 4));
		buttons[Buttons::BtHelp] = std::make_unique<MapleButton>(CSStatus["BtHelp"], Point<int16_t>(997, 4));
		buttons[Buttons::BtCoupon] = std::make_unique<MapleButton>(CSStatus["BtCoupon"], Point<int16_t>(950, 4));

		Charset tab;

		job_label = Text(Text::Font::A11B, Text::Alignment::LEFT, Color::Name::SUPERNOVA, "Illium");
		name_label = Text(Text::Font::A11B, Text::Alignment::LEFT, Color::Name::WHITE, "ShomeiZekkou");

		promotion_pos = Point<int16_t>(138, 40);
		sprites.emplace_back(CSPromotionBanner["shadow"], promotion_pos);

		promotion_sprites.emplace_back(CSPromotionBanner["basic"]);

		buttons[Buttons::BtNext] = std::make_unique<MapleButton>(CSPromotionBanner["BtNext"], promotion_pos);
		buttons[Buttons::BtPrev] = std::make_unique<MapleButton>(CSPromotionBanner["BtPrev"], promotion_pos);

		for (size_t i = 0; i < 7; i++)
			mvp_sprites[i] = CSMVPBanner["grade"][i];

		mvp_pos = Point<int16_t>(63, 681);
		buttons[Buttons::BtDetailPackage] = std::make_unique<MapleButton>(CSMVPBanner["BtDetailPackage"], mvp_pos);
		buttons[Buttons::BtNonGrade] = std::make_unique<MapleButton>(CSMVPBanner["BtNonGrade"], mvp_pos);

		buttons[Buttons::BtDetailPackage]->set_active(mvp_grade);
		buttons[Buttons::BtNonGrade]->set_active(!mvp_grade);

		mvp_gauge = Gauge(
			Gauge::Type::CASHSHOP,
			CSMVPBanner["gage"][0],
			CSMVPBanner["gage"][2],
			CSMVPBanner["gage"][1],
			84,
			0.0f
		);

		Point<int16_t> search_pos = Point<int16_t>(0, 36);
		sprites.emplace_back(CSItemSearch["backgrnd"], search_pos);
		sprites.emplace_back(CSItemSearch["search"], search_pos + Point<int16_t>(35, 8));

		buttons[Buttons::BtBuyAvatar] = std::make_unique<MapleButton>(CSChar["BtBuyAvatar"], Point<int16_t>(642, 305));
		buttons[Buttons::BtDefaultAvatar] = std::make_unique<MapleButton>(CSChar["BtDefaultAvatar"], Point<int16_t>(716, 305));
		buttons[Buttons::BtInventory] = std::make_unique<MapleButton>(CSChar["BtInventory"], Point<int16_t>(938, 305));
		buttons[Buttons::BtSaveAvatar] = std::make_unique<MapleButton>(CSChar["BtSaveAvatar"], Point<int16_t>(864, 305));
		buttons[Buttons::BtTakeoffAvatar] = std::make_unique<MapleButton>(CSChar["BtTakeoffAvatar"], Point<int16_t>(790, 305));

		charge_charset = Charset(CSGLChargeNX["Number"], Charset::Alignment::RIGHT);

		item_base = CSList["Base"];
		item_line = Base["line"];
		item_none = Base["noItem"];

		for (nl::node item_label : CSEffect)
			item_labels.emplace_back(item_label);

		items.push_back({ 5220000, Item::Label::HOT,	34000,	11 });
		items.push_back({ 5220000, Item::Label::HOT,	34000,	11 });
		items.push_back({ 5220000, Item::Label::HOT,	0,		0 });
		items.push_back({ 5220000, Item::Label::HOT,	0,		0 });
		items.push_back({ 5220000, Item::Label::HOT,	10000,	11 });
		items.push_back({ 5220000, Item::Label::NEW,	0,		0 });
		items.push_back({ 5220000, Item::Label::SALE,	7000,	0 });
		items.push_back({ 5220000, Item::Label::NEW,	13440,	0 });
		items.push_back({ 5220000, Item::Label::NEW,	7480,	0 });
		items.push_back({ 5220000, Item::Label::NEW,	7480,	0 });
		items.push_back({ 5220000, Item::Label::NEW,	7480,	0 });
		items.push_back({ 5220000, Item::Label::NONE,	12000,	11 });
		items.push_back({ 5220000, Item::Label::NONE,	22000,	11 });
		items.push_back({ 5220000, Item::Label::NONE,	0,		0 });
		items.push_back({ 5220000, Item::Label::NONE,	0,		0 });
		items.push_back({ 5220000, Item::Label::MASTER,	0,		15 });

		for (size_t i = 0; i < MAX_ITEMS; i++)
		{
			div_t div = std::div(i, 7);

			buttons[Buttons::BtBuy + i] = std::make_unique<MapleButton>(CSList["BtBuy"], Point<int16_t>(146, 523) + Point<int16_t>(124 * div.rem, 205 * div.quot));

			item_name[i] = Text(Text::Font::A11B, Text::Alignment::CENTER, Color::Name::MINESHAFT);
			item_price[i] = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::GRAY);
			item_discount[i] = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::SILVERCHALICE);
			item_percent[i] = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::TORCHRED);
		}

		Point<int16_t> slider_pos = Point<int16_t>(1007, 372);

		list_slider = Slider(
			Slider::Type::THIN_MINESHAFT,
			Range<int16_t>(slider_pos.y(), slider_pos.y() + 381),
			slider_pos.x(),
			2,
			7,
			[&](bool upwards)
			{
				int16_t shift = upwards ? -7 : 7;
				bool above = list_offset >= 0;
				bool below = list_offset + shift < items.size();

				if (above && below)
				{
					list_offset += shift;

					update_items();
				}
			}
		);

		update_items();

		dimension = Texture(backgrnd).get_dimensions();
	}

	void UICashShop::draw(float inter) const
	{
		preview_sprites[preview_index].draw(position + Point<int16_t>(644, 65), inter);

		UIElement::draw_sprites(inter);

		menu_tabs[menu_index].draw(position + Point<int16_t>(0, 63), inter);

		Point<int16_t> label_pos = position + Point<int16_t>(4, 3);
		job_label.draw(label_pos);

		size_t length = job_label.width();
		name_label.draw(label_pos + Point<int16_t>(length + 10, 0));

		promotion_sprites[promotion_index].draw(position + promotion_pos, inter);

		mvp_sprites[mvp_grade].draw(position + mvp_pos, inter);
		mvp_gauge.draw(position + mvp_pos);

		Point<int16_t> charge_pos = position + Point<int16_t>(107, 388);

		charge_charset.draw("0", charge_pos + Point<int16_t>(0, 30 * 1));
		charge_charset.draw("3,300", charge_pos + Point<int16_t>(0, 30 * 2));
		charge_charset.draw("0", charge_pos + Point<int16_t>(0, 30 * 3));
		charge_charset.draw("8,698,565", charge_pos + Point<int16_t>(0, 30 * 4));
		charge_charset.draw("0", charge_pos + Point<int16_t>(0, 30 * 5));

		if (items.size() > 0)
			item_line.draw(position + Point<int16_t>(139, 566), inter);
		else
			item_none.draw(position + Point<int16_t>(137, 372) + Point<int16_t>(BestNew_dim.x() / 2, list_slider.getvertical().length() / 2) - item_none.get_dimensions() / 2, inter);

		for (size_t i = 0; i < MAX_ITEMS; i++)
		{
			int16_t index = i + list_offset;

			if (index < items.size())
			{
				div_t div = std::div(i, 7);
				Item item = items[index];

				item_base.draw(position + Point<int16_t>(137, 372) + Point<int16_t>(124 * div.rem, 205 * div.quot), inter);
				item.draw(DrawArgument(position + Point<int16_t>(164, 473) + Point<int16_t>(124 * div.rem, 205 * div.quot), 2.0f, 2.0f));

				if (item.label != Item::Label::NONE)
					item_labels[item.label + 1].draw(position + Point<int16_t>(152, 372) + Point<int16_t>(124 * div.rem, 205 * div.quot), inter);

				item_name[i].draw(position + Point<int16_t>(192, 480) + Point<int16_t>(124 * div.rem, 205 * div.quot));

				if (item_discount[i].get_text() == "")
				{
					item_price[i].draw(position + Point<int16_t>(195, 499) + Point<int16_t>(124 * div.rem, 205 * div.quot));
				}
				else
				{
					item_price[i].draw(position + Point<int16_t>(196, 506) + Point<int16_t>(124 * div.rem, 205 * div.quot));

					item_discount[i].draw(position + Point<int16_t>(185, 495) + Point<int16_t>(124 * div.rem, 205 * div.quot));
					item_percent[i].draw(position + Point<int16_t>(198 + (item_discount[i].width() / 2), 495) + Point<int16_t>(124 * div.rem, 205 * div.quot));
				}
			}
		}

		list_slider.draw(position);

		UIElement::draw_buttons(inter);
	}

	void UICashShop::update()
	{
		UIElement::update();

		mvp_gauge.update(mvp_exp);
	}

	Button::State UICashShop::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
		case Buttons::BtPreview1:
		case Buttons::BtPreview2:
		case Buttons::BtPreview3:
			buttons[preview_index]->set_state(Button::State::NORMAL);

			preview_index = buttonid;
			return Button::State::PRESSED;
		case Buttons::BtExit:
		{
			uint16_t width = Setting<Width>::get().load();
			uint16_t height = Setting<Height>::get().load();

			Constants::Constants::get().set_viewwidth(width);
			Constants::Constants::get().set_viewheight(height);

			float fadestep = 0.025f;

			Window::get().fadeout(
				fadestep,
				[]()
				{
					GraphicsGL::get().clear();
					ChangeMapPacket().dispatch();
				}
			);

			GraphicsGL::get().lock();
			Stage::get().clear();
			Timer::get().start();

			return Button::State::NORMAL;
		}
		case Buttons::BtNext:
		{
			size_t size = promotion_sprites.size() - 1;

			promotion_index++;

			if (promotion_index > size)
				promotion_index = 0;

			return Button::State::NORMAL;
		}
		case Buttons::BtPrev:
		{
			size_t size = promotion_sprites.size() - 1;

			promotion_index--;

			if (promotion_index < 0)
				promotion_index = size;

			return Button::State::NORMAL;
		}
		case Buttons::BtChargeNX:
		{
			std::string url = Configuration::get().get_chargenx();

			ShellExecuteA(NULL, "open", url.c_str(), NULL, NULL, SW_SHOWNORMAL);

			return Button::State::NORMAL;
		}
		default:
			break;
		}

		if (buttonid >= Buttons::BtBuy)
		{
			int16_t index = buttonid - Buttons::BtBuy + list_offset;

			Item item = items[index];

			// TODO: Purchase item

			return Button::State::NORMAL;
		}

		return Button::State::DISABLED;
	}

	Cursor::State UICashShop::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		Point<int16_t> cursor_relative = cursorpos - position;

		if (list_slider.isenabled())
		{
			Cursor::State state = list_slider.send_cursor(cursor_relative, clicked);

			if (state != Cursor::State::IDLE)
				return state;
		}

		return UIElement::send_cursor(clicked, cursorpos);
	}

	UIElement::Type UICashShop::get_type() const
	{
		return TYPE;
	}

	void UICashShop::exit_cashshop()
	{
		UI& ui = UI::get();
		ui.change_state(UI::State::GAME);

		Stage& stage = Stage::get();
		Player& player = stage.get_player();

		PlayerLoginPacket(player.get_oid()).dispatch();

		int32_t mapid = player.get_stats().get_mapid();
		uint8_t portalid = player.get_stats().get_portal();

		stage.load(mapid, portalid);
		stage.transfer_player();

		ui.enable();
		Timer::get().start();
		GraphicsGL::get().unlock();
	}

	void UICashShop::update_items()
	{
		for (size_t i = 0; i < MAX_ITEMS; i++)
		{
			int16_t index = i + list_offset;
			bool found_item = index < items.size();

			buttons[Buttons::BtBuy + i]->set_active(found_item);

			std::string name = "";
			std::string price_text = "";
			std::string discount_text = "";
			std::string percent_text = "";

			if (found_item)
			{
				Item item = items[index];

				name = item.get_name();

				int32_t price = item.get_price();
				price_text = std::to_string(price);

				if (item.discount_price > 0 && price > 0)
				{
					discount_text = price_text;

					uint32_t discount = item.discount_price;
					price_text = std::to_string(discount);

					float_t percent = (float)discount / price;
					std::string percent_str = std::to_string(percent);
					percent_text = "(" + percent_str.substr(2, 1) + "%)";
				}

				string_format::split_number(price_text);
				string_format::split_number(discount_text);

				price_text += " NX";

				if (discount_text != "")
					discount_text += " NX";

				if (item.count > 0)
					price_text += "(" + std::to_string(item.count) + ")";
			}

			item_name[i].change_text(name);
			item_price[i].change_text(price_text);
			item_discount[i].change_text(discount_text);
			item_percent[i].change_text(percent_text);

			string_format::format_with_ellipsis(item_name[i], 92);
		}
	}
}

================
File: IO/UITypes/UICashShop.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../Components/Charset.h"
#include "../Components/Gauge.h"
#include "../Components/Slider.h"

#include "../../Data/ItemData.h"
#include "../../Graphics/Text.h"

namespace ms
{
	class UICashShop : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::CASHSHOP;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = false;

		UICashShop();

		void draw(float inter) const;
		void update() override;

		Button::State button_pressed(uint16_t buttonid);

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;

		UIElement::Type get_type() const override;

		void exit_cashshop();

	private:
		void update_items();

		static constexpr uint8_t MAX_ITEMS = 7u * 2u + 1u;

		class Item
		{
		public:
			enum Label : uint8_t
			{
				ACTION,
				BOMB_SALE,
				BONUS,
				EVENT = 4,
				HOT,
				LIMITED,
				LIMITED_BRONZE,
				LIMITED_GOLD,
				LIMITED_SILVER,
				LUNA_CRYSTAL,
				MASTER = 12,
				MUST,
				NEW,
				SALE = 17,
				SPEICAL,
				SPECIAL_PRICE,
				TIME,
				TODAY,
				WEEKLY,
				WONDER_BERRY,
				WORLD_SALE,
				NONE
			};

			Item(int32_t itemid, Label label, int32_t discount, uint16_t count) : label(label), discount_price(discount), count(count), data(ItemData::get(itemid)) {}

			Label label;
			int32_t discount_price;
			uint16_t count;

			void draw(const DrawArgument& args) const
			{
				data.get_icon(false).draw(args);
			}

			const std::string get_name() const
			{
				return data.get_name();
			}

			const int32_t get_price() const
			{
				return data.get_price();
			}

		private:
			const ItemData& data;
		};

		enum Buttons : uint16_t
		{
			BtPreview1,
			BtPreview2,
			BtPreview3,
			BtExit,
			BtChargeNX,
			BtChargeRefresh,
			BtWish,
			BtMileage,
			BtHelp,
			BtCoupon,
			BtNext,
			BtPrev,
			BtDetailPackage,
			BtNonGrade,
			BtBuyAvatar,
			BtDefaultAvatar,
			BtInventory,
			BtSaveAvatar,
			BtTakeoffAvatar,
			BtBuy
		};

		Point<int16_t> BestNew_dim;

		Sprite preview_sprites[3];
		uint8_t preview_index;

		Sprite menu_tabs[9];
		uint8_t menu_index;

		Text job_label;
		Text name_label;

		std::vector<Sprite> promotion_sprites;
		Point<int16_t> promotion_pos;
		int8_t promotion_index;

		Sprite mvp_sprites[7];
		Point<int16_t> mvp_pos;
		uint8_t mvp_grade;
		Gauge mvp_gauge;
		float_t mvp_exp;

		Charset charge_charset;

		Sprite item_base;
		Sprite item_line;
		Sprite item_none;
		std::vector<Sprite> item_labels;
		std::vector<Item> items;
		Text item_name[MAX_ITEMS];
		Text item_price[MAX_ITEMS];
		Text item_discount[MAX_ITEMS];
		Text item_percent[MAX_ITEMS];

		Slider list_slider;
		int16_t list_offset;
	};
}

================
File: IO/UITypes/UIChannel.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIChannel.h"

#include "../KeyAction.h"

#include "../Components/AreaButton.h"
#include "../Components/MapleButton.h"

#include "../../Audio/Audio.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIChannel::UIChannel() : UIDragElement<PosCHANNEL>()
	{
		uint8_t selected_world = 1; // TODO: Need to get current world user is on
		current_channel = 9; // TODO: Need to get current channel user is on
		selected_channel = current_channel;
		channel_count = 20; // TODO: Need to get total number of channels on world

		nl::node Channel = nl::nx::UI["UIWindow2.img"]["Channel"];

		nl::node backgrnd = Channel["backgrnd"];
		Texture bg = backgrnd;

		sprites.emplace_back(backgrnd, Point<int16_t>(1, 0));
		sprites.emplace_back(Channel["backgrnd2"]);
		sprites.emplace_back(Channel["backgrnd3"]);
		sprites.emplace_back(Channel["world"][selected_world], Point<int16_t>(16, 30));

		buttons[Buttons::CANCEL] = std::make_unique<MapleButton>(Channel["BtCancel"]);
		buttons[Buttons::CHANGE] = std::make_unique<MapleButton>(Channel["BtChange"], Point<int16_t>(-20, 0));

		channel[true] = Channel["channel1"];
		channel[false] = Channel["channel0"];

		size_t x = 0;
		size_t y = 0;

		for (size_t i = 0; i < channel_count; i++)
		{
			if (x >= 5)
			{
				x = 0;
				y++;
			}

			ch.emplace_back(Channel["ch"][i], Point<int16_t>(19 + 70 * x, 60 + 20 * y));
			buttons[Buttons::CH + i] = std::make_unique<AreaButton>(Point<int16_t>(11 + 70 * x, 55 + 20 * y), channel[true].get_dimensions());

			if (i == selected_channel)
			{
				current_channel_x = 11 + 70 * x;
				current_channel_y = 55 + 20 * y;
				selected_channel_x = current_channel_x;
				selected_channel_y = current_channel_y;
			}

			x++;
		}

		dimension = bg.get_dimensions();
		dragarea = Point<int16_t>(dimension.x(), 20);
	}

	void UIChannel::draw(float inter) const
	{
		UIElement::draw(inter);

		if (current_channel == selected_channel)
		{
			channel[true].draw(DrawArgument(position.x() + selected_channel_x, position.y() + selected_channel_y));
		}
		else
		{
			channel[true].draw(DrawArgument(position.x() + selected_channel_x, position.y() + selected_channel_y));
			channel[false].draw(DrawArgument(position.x() + current_channel_x, position.y() + current_channel_y));
		}

		for (Sprite sprite : ch)
			sprite.draw(position, inter);
	}

	void UIChannel::update()
	{
		UIElement::update();

		for (Sprite sprite : ch)
			sprite.update();
	}

	void UIChannel::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
			{
				cancel();
			}
			else if (keycode == KeyAction::Id::RETURN)
			{
				change_channel();
			}
			else if (keycode == KeyAction::Id::UP)
			{
				if (selected_channel > 4)
				{
					selected_channel -= 5;
				}
				else
				{
					for (size_t i = 0; i < 3; i++)
						selected_channel += 5;
				}

				if (selected_channel == current_channel)
				{
					if (selected_channel > 4)
					{
						selected_channel -= 5;
					}
					else
					{
						for (size_t i = 0; i < 3; i++)
							selected_channel += 5;
					}
				}

				update_selected_channel_position();
			}
			else if (keycode == KeyAction::Id::DOWN)
			{
				if (selected_channel < 15)
				{
					selected_channel += 5;
				}
				else
				{
					for (size_t i = 0; i < 3; i++)
						selected_channel -= 5;
				}

				if (selected_channel == current_channel)
				{
					if (selected_channel < 15)
					{
						selected_channel += 5;
					}
					else
					{
						for (size_t i = 0; i < 3; i++)
							selected_channel -= 5;
					}
				}

				update_selected_channel_position();
			}
			else if (keycode == KeyAction::Id::LEFT)
			{
				if (selected_channel != 0)
					selected_channel--;
				else
					selected_channel = channel_count - 1;

				if (selected_channel == current_channel)
				{
					if (selected_channel != 0)
						selected_channel--;
					else
						selected_channel = channel_count - 1;
				}

				update_selected_channel_position();
			}
			else if (keycode == KeyAction::Id::RIGHT)
			{
				if (selected_channel != channel_count - 1)
					selected_channel++;
				else
					selected_channel = 0;

				if (selected_channel == current_channel)
				{
					if (selected_channel != channel_count - 1)
						selected_channel++;
					else
						selected_channel = 0;
				}

				update_selected_channel_position();
			}
		}
	}

	Cursor::State UIChannel::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		Cursor::State dstate = UIDragElement::send_cursor(clicked, cursorpos);

		if (dragged)
			return dstate;

		Cursor::State ret = clicked ? Cursor::State::CLICKING : Cursor::State::IDLE;

		for (size_t i = 0; i < channel_count + Buttons::CH; i++)
		{
			if (buttons[i]->is_active() && buttons[i]->bounds(position).contains(cursorpos))
			{
				if (buttons[i]->get_state() == Button::State::NORMAL)
				{
					if (i < Buttons::CH)
					{
						Sound(Sound::Name::BUTTONOVER).play();

						buttons[i]->set_state(Button::State::MOUSEOVER);
						ret = Cursor::State::CANCLICK;
					}
					else
					{
						buttons[i]->set_state(Button::State::MOUSEOVER);
						ret = Cursor::State::IDLE;
					}
				}
				else if (buttons[i]->get_state() == Button::State::MOUSEOVER)
				{
					if (clicked)
					{
						if (i < Buttons::CH)
							Sound(Sound::Name::BUTTONCLICK).play();

						buttons[i]->set_state(button_pressed(i));

						ret = Cursor::State::IDLE;
					}
					else
					{
						if (i < Buttons::CH)
							ret = Cursor::State::CANCLICK;
						else
							ret = Cursor::State::IDLE;
					}
				}
			}
			else if (buttons[i]->get_state() == Button::State::MOUSEOVER)
			{
				buttons[i]->set_state(Button::State::NORMAL);
			}
		}

		return ret;
	}

	UIElement::Type UIChannel::get_type() const
	{
		return TYPE;
	}

	Button::State UIChannel::button_pressed(uint16_t buttonid)
	{
		if (buttonid < Buttons::CH)
		{
			switch (buttonid)
			{
				case Buttons::CANCEL:
					cancel();
					break;
				case Buttons::CHANGE:
					change_channel();
					break;
				default:
					break;
			}
		}
		else
		{
			if (buttonid - Buttons::CH == current_channel)
				return Button::State::NORMAL;

			selected_channel = buttonid - Buttons::CH;
			update_selected_channel_position();
		}

		return Button::State::NORMAL;
	}

	void UIChannel::cancel()
	{
		deactivate();

		current_channel = 9; // TODO: Need to get current channel user is on
		selected_channel = current_channel;
		selected_channel_x = current_channel_x;
		selected_channel_y = current_channel_y;
	}

	void UIChannel::change_channel()
	{
		// TODO: Send packet to change channel?
		cancel();
	}

	void UIChannel::update_selected_channel_position()
	{
		size_t x = 0;
		size_t y = 0;

		for (size_t i = 0; i < channel_count; i++)
		{
			if (x >= 5)
			{
				x = 0;
				y++;
			}

			if (i == selected_channel)
			{
				selected_channel_x = 11 + 70 * x;
				selected_channel_y = 55 + 20 * y;
				break;
			}

			x++;
		}
	}
}

================
File: IO/UITypes/UIChannel.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../../Template/BoolPair.h"

namespace ms
{
	class UIChannel : public UIDragElement<PosCHANNEL>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::CHANNEL;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIChannel();

		void draw(float inter) const override;
		void update() override;

		void send_key(int32_t keycode, bool pressed, bool escape) override;
		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void cancel();
		void change_channel();
		void update_selected_channel_position();

		enum Buttons : uint16_t
		{
			CANCEL,
			CHANGE,
			CH
		};

		uint8_t current_channel;
		uint8_t selected_channel;
		uint8_t channel_count;
		BoolPair<Texture> channel;
		std::vector<Sprite> ch;
		int16_t current_channel_x;
		int16_t current_channel_y;
		int16_t selected_channel_x;
		int16_t selected_channel_y;
	};
}

================
File: IO/UITypes/UICharInfo.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UICharInfo.h"

#include "../Components/MapleButton.h"

#include "../../Gameplay/Stage.h"

#include "../../Net/Packets/PlayerInteractionPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UICharInfo::UICharInfo(int32_t cid) : UIDragElement<PosCHARINFO>(), is_loading(true), timestep(Constants::TIMESTEP), personality_enabled(false), collect_enabled(false), damage_enabled(false), item_enabled(false)
	{
		nl::node close = nl::nx::UI["Basic.img"]["BtClose3"];
		nl::node UserInfo = nl::nx::UI["UIWindow2.img"]["UserInfo"];
		nl::node character = UserInfo["character"];
		nl::node backgrnd = character["backgrnd"];

		/// Main Window
		sprites.emplace_back(backgrnd);
		sprites.emplace_back(character["backgrnd2"]);
		sprites.emplace_back(character["name"]);

		Point<int16_t> backgrnd_dim = Texture(backgrnd).get_dimensions();
		Point<int16_t> close_dimensions = Point<int16_t>(backgrnd_dim.x() - 21, 6);

		buttons[Buttons::BtClose] = std::make_unique<MapleButton>(close, close_dimensions);
		buttons[Buttons::BtCollect] = std::make_unique<MapleButton>(character["BtCollect"]);
		buttons[Buttons::BtDamage] = std::make_unique<MapleButton>(character["BtDamage"]);
		buttons[Buttons::BtFamily] = std::make_unique<MapleButton>(character["BtFamily"]);
		buttons[Buttons::BtItem] = std::make_unique<MapleButton>(character["BtItem"]);
		buttons[Buttons::BtParty] = std::make_unique<MapleButton>(character["BtParty"]);
		buttons[Buttons::BtPersonality] = std::make_unique<MapleButton>(character["BtPersonality"]);
		buttons[Buttons::BtPet] = std::make_unique<MapleButton>(character["BtPet"]);
		buttons[Buttons::BtPopDown] = std::make_unique<MapleButton>(character["BtPopDown"]);
		buttons[Buttons::BtPopUp] = std::make_unique<MapleButton>(character["BtPopUp"]);
		buttons[Buttons::BtRide] = std::make_unique<MapleButton>(character["BtRide"]);
		buttons[Buttons::BtTrad] = std::make_unique<MapleButton>(character["BtTrad"]);

		name = Text(Text::Font::A12M, Text::Alignment::CENTER, Color::Name::WHITE);
		job = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::EMPEROR);
		level = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::EMPEROR);
		fame = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::EMPEROR);
		guild = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::EMPEROR);
		alliance = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::EMPEROR);

		// TODO: Check if player has a mount or pet, disable if they don't
		buttons[Buttons::BtPet]->set_state(Button::State::DISABLED);
		buttons[Buttons::BtRide]->set_state(Button::State::DISABLED);

		/// Farm
		nl::node farm = UserInfo["farm"];
		nl::node farm_backgrnd = farm["backgrnd"];

		loading = farm["loading"];

		farm_dim = Texture(farm_backgrnd).get_dimensions();
		farm_adj = Point<int16_t>(-farm_dim.x(), 0);

		sprites.emplace_back(farm_backgrnd, farm_adj);
		sprites.emplace_back(farm["backgrnd2"], farm_adj);
		sprites.emplace_back(farm["default"], farm_adj);
		sprites.emplace_back(farm["cover"], farm_adj);

		buttons[Buttons::BtFriend] = std::make_unique<MapleButton>(farm["btFriend"], farm_adj);
		buttons[Buttons::BtVisit] = std::make_unique<MapleButton>(farm["btVisit"], farm_adj);

		farm_name = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::SUPERNOVA);
		farm_level = Charset(farm["number"], Charset::Alignment::LEFT);

#pragma region BottomWindow
		bottom_window_adj = Point<int16_t>(0, backgrnd_dim.y() + 1);

		/// Personality
		nl::node personality = UserInfo["personality"];
		nl::node personality_backgrnd = personality["backgrnd"];

		personality_sprites.emplace_back(personality_backgrnd, bottom_window_adj);
		personality_sprites.emplace_back(personality["backgrnd2"], bottom_window_adj);

		personality_sprites_enabled[true].emplace_back(personality["backgrnd3"], bottom_window_adj);
		personality_sprites_enabled[true].emplace_back(personality["backgrnd4"], bottom_window_adj);
		personality_sprites_enabled[true].emplace_back(personality["center"], bottom_window_adj);
		personality_sprites_enabled[false].emplace_back(personality["before30level"], bottom_window_adj);

		personality_dimensions = Texture(personality_backgrnd).get_dimensions();

		/// Collect
		nl::node collect = UserInfo["collect"];
		nl::node collect_backgrnd = collect["backgrnd"];

		collect_sprites.emplace_back(collect_backgrnd, bottom_window_adj);
		collect_sprites.emplace_back(collect["backgrnd2"], bottom_window_adj);

		default_medal = collect["icon1"];

		buttons[Buttons::BtArrayGet] = std::make_unique<MapleButton>(collect["BtArrayGet"], bottom_window_adj);
		buttons[Buttons::BtArrayName] = std::make_unique<MapleButton>(collect["BtArrayName"], bottom_window_adj);

		medal_text = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::EMPEROR, "Junior Adventurer");
		medal_total = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::EMPEROR, "2");

		collect_dimensions = Texture(collect_backgrnd).get_dimensions();

		/// Damage
		nl::node damage = UserInfo["damage"];
		nl::node damage_backgrnd = damage["backgrnd"];

		damage_sprites.emplace_back(damage_backgrnd, bottom_window_adj);
		damage_sprites.emplace_back(damage["backgrnd2"], bottom_window_adj);
		damage_sprites.emplace_back(damage["backgrnd3"], bottom_window_adj);

		buttons[Buttons::BtFAQ] = std::make_unique<MapleButton>(damage["BtFAQ"], bottom_window_adj);
		buttons[Buttons::BtRegist] = std::make_unique<MapleButton>(damage["BtRegist"], bottom_window_adj);

		damage_dimensions = Texture(damage_backgrnd).get_dimensions();
#pragma endregion

#pragma region RightWindow
		right_window_adj = Point<int16_t>(backgrnd_dim.x(), 0);

		/// Item
		nl::node item = UserInfo["item"];
		nl::node item_backgrnd = item["backgrnd"];

		item_sprites.emplace_back(item_backgrnd, right_window_adj);
		item_sprites.emplace_back(item["backgrnd2"], right_window_adj);

		item_dimensions = Texture(item_backgrnd).get_dimensions();
#pragma endregion


		dimension = backgrnd_dim;
		dragarea = Point<int16_t>(dimension.x(), 20);

		target_character = Stage::get().get_character(cid).get();

		CharInfoRequestPacket(cid).dispatch();
	}

	void UICharInfo::draw(float inter) const
	{
		UIElement::draw_sprites(inter);

		for (size_t i = 0; i < Buttons::BtArrayGet; i++)
			if (const auto button = buttons.at(i).get())
				button->draw(position);

		/// Main Window
		int16_t row_height = 18;
		Point<int16_t> text_pos = position + Point<int16_t>(153, 65);

		target_character->draw_preview(position + Point<int16_t>(63, 129), inter);

		name.draw(position + Point<int16_t>(59, 131));
		level.draw(text_pos + Point<int16_t>(0, row_height * 0));
		job.draw(text_pos + Point<int16_t>(0, row_height * 1));
		fame.draw(text_pos + Point<int16_t>(0, row_height * 2));
		guild.draw(text_pos + Point<int16_t>(0, row_height * 3) + Point<int16_t>(0, 1));
		alliance.draw(text_pos + Point<int16_t>(0, row_height * 4));

		/// Farm
		Point<int16_t> farm_pos = position + farm_adj;

		if (is_loading)
			loading.draw(farm_pos, inter);

		farm_name.draw(farm_pos + Point<int16_t>(136, 51));
		farm_level.draw(farm_level_text, farm_pos + Point<int16_t>(126, 34));

		/// Personality
		if (personality_enabled)
		{
			for (Sprite sprite : personality_sprites)
				sprite.draw(position, inter);

			bool show_personality = (target_character->get_level() >= 30);

			for (Sprite sprite : personality_sprites_enabled[show_personality])
				sprite.draw(position, inter);
		}

		/// Collect
		if (collect_enabled)
		{
			for (Sprite sprite : collect_sprites)
				sprite.draw(position, inter);

			for (size_t i = 0; i < 15; i++)
			{
				div_t div = std::div(i, 5);
				default_medal.draw(position + bottom_window_adj + Point<int16_t>(61, 66) + Point<int16_t>(38 * div.rem, 38 * div.quot), inter);
			}

			for (size_t i = Buttons::BtArrayGet; i < Buttons::BtFAQ; i++)
				if (const auto button = buttons.at(i).get())
					button->draw(position);

			Point<int16_t> text_pos = Point<int16_t>(121, 8);

			medal_text.draw(position + bottom_window_adj + text_pos);
			medal_total.draw(position + bottom_window_adj + text_pos + Point<int16_t>(0, 19));
		}

		/// Damage
		if (damage_enabled)
		{
			for (Sprite sprite : damage_sprites)
				sprite.draw(position, inter);

			for (size_t i = Buttons::BtFAQ; i < buttons.size(); i++)
				if (const auto button = buttons.at(i).get())
					button->draw(position);
		}

		/// Item
		if (item_enabled)
			for (Sprite sprite : item_sprites)
				sprite.draw(position, inter);
	}

	void UICharInfo::update()
	{
		if (timestep >= Constants::TIMESTEP * UCHAR_MAX)
		{
			is_loading = false;
		}
		else
		{
			loading.update();
			timestep += Constants::TIMESTEP;
		}
	}

	Button::State UICharInfo::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			case Buttons::BtClose:
			{
				deactivate();

				return Button::State::NORMAL;
			}
			case Buttons::BtFamily:
			case Buttons::BtParty:
			{
				break;
			}
			case Buttons::BtItem:
			{
				show_right_window(buttonid);

				return Button::State::NORMAL;
			}
			case Buttons::BtCollect:
			case Buttons::BtPersonality:
			case Buttons::BtRide:
			case Buttons::BtPet:
			case Buttons::BtDamage:
			{
				show_bottom_window(buttonid);

				return Button::State::NORMAL;
			}
			case Buttons::BtPopDown:
			case Buttons::BtPopUp:
			case Buttons::BtTrad:
			case Buttons::BtFriend:
			case Buttons::BtVisit:
			default:
			{
				break;
			}
		}

		return Button::State::DISABLED;
	}

	bool UICharInfo::is_in_range(Point<int16_t> cursorpos) const
	{
		Rectangle<int16_t> bounds = Rectangle<int16_t>(position, position + dimension);

		Rectangle<int16_t> farm_bounds = Rectangle<int16_t>(position, position + farm_dim);
		farm_bounds.shift(farm_adj);

		Rectangle<int16_t> bottom_bounds = Rectangle<int16_t>(Point<int16_t>(0, 0), Point<int16_t>(0, 0));
		Rectangle<int16_t> right_bounds = Rectangle<int16_t>(Point<int16_t>(0, 0), Point<int16_t>(0, 0));

		int16_t cur_x = cursorpos.x();
		int16_t cur_y = cursorpos.y();

		if (personality_enabled)
		{
			bottom_bounds = Rectangle<int16_t>(position, position + personality_dimensions);
			bottom_bounds.shift(bottom_window_adj);
		}

		if (collect_enabled)
		{
			bottom_bounds = Rectangle<int16_t>(position, position + collect_dimensions);
			bottom_bounds.shift(bottom_window_adj);
		}

		if (damage_enabled)
		{
			bottom_bounds = Rectangle<int16_t>(position, position + damage_dimensions);
			bottom_bounds.shift(bottom_window_adj);
		}

		if (item_enabled)
		{
			right_bounds = Rectangle<int16_t>(position, position + item_dimensions);
			right_bounds.shift(right_window_adj);
		}

		return bounds.contains(cursorpos) || farm_bounds.contains(cursorpos) || bottom_bounds.contains(cursorpos) || right_bounds.contains(cursorpos);
	}

	void UICharInfo::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed && escape)
			deactivate();
	}

	UIElement::Type UICharInfo::get_type() const
	{
		return TYPE;
	}

	void UICharInfo::update_stats(int32_t character_id, int16_t job_id, uint16_t lv, int16_t f, std::string g, std::string a)
	{
		int32_t player_id = Stage::get().get_player().get_oid();

		if (character_id == player_id)
		{
			buttons[Buttons::BtParty]->set_state(Button::State::DISABLED);
			buttons[Buttons::BtPopDown]->set_state(Button::State::DISABLED);
			buttons[Buttons::BtPopUp]->set_state(Button::State::DISABLED);
			buttons[Buttons::BtFriend]->set_state(Button::State::DISABLED);
		}

		Job character_job = Job(job_id);

		name.change_text(target_character->get_name());
		job.change_text(character_job.get_name());
		level.change_text(std::to_string(lv));
		fame.change_text(std::to_string(f));

		if (g == "")
			guild.change_text("-");
		else
			guild.change_text(g);

		alliance.change_text(a);

		farm_name.change_text("");
		farm_level_text = "1";
	}

	void UICharInfo::show_bottom_window(uint16_t buttonid)
	{
		personality_enabled = false;
		collect_enabled = false;
		damage_enabled = false;

		switch (buttonid)
		{
			case Buttons::BtPersonality:
				personality_enabled = true;
				break;
			case Buttons::BtCollect:
				collect_enabled = true;
				break;
			case Buttons::BtDamage:
				damage_enabled = true;
				break;
		}
	}

	void UICharInfo::show_right_window(uint16_t buttonid)
	{
		item_enabled = false;

		switch (buttonid)
		{
			case Buttons::BtItem:
				item_enabled = true;
				break;
		}
	}
}

================
File: IO/UITypes/UICharInfo.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../../Character/Char.h"

namespace ms
{
	class UICharInfo : public UIDragElement<PosCHARINFO>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::CHARINFO;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UICharInfo(int32_t cid);

		void draw(float inter) const override;
		void update() override;

		Button::State button_pressed(uint16_t buttonid) override;

		bool is_in_range(Point<int16_t> cursorpos) const override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		void update_stats(int32_t character_id, int16_t job_id, uint16_t level, int16_t fame, std::string guild, std::string alliance);

	private:
		void show_bottom_window(uint16_t buttonid);
		void show_right_window(uint16_t buttonid);

		enum Buttons : uint16_t
		{
			BtClose,
			BtCollect,
			BtDamage,
			BtFamily,
			BtItem,
			BtParty,
			BtPersonality,
			BtPet,
			BtPopDown,
			BtPopUp,
			BtRide,
			BtTrad,
			BtFriend,
			BtVisit,
			BtArrayGet,
			BtArrayName,
			BtFAQ,
			BtRegist
		};

		/// Main Window
		Text name;
		Text job;
		Text level;
		Text fame;
		Text guild;
		Text alliance;

		Char* target_character;

		/// Sub Windows
		Point<int16_t> bottom_window_adj;
		Point<int16_t> right_window_adj;

		/// Farm
		Text farm_name;
		Sprite loading;
		bool is_loading;
		uint16_t timestep;
		Charset farm_level;
		Point<int16_t> farm_dim;
		Point<int16_t> farm_adj;
		std::string farm_level_text;

		/// Personality
		bool personality_enabled;
		std::vector<Sprite> personality_sprites;
		BoolPair<std::vector<Sprite>> personality_sprites_enabled;
		Point<int16_t> personality_dimensions;

		/// Collect
		bool collect_enabled;
		std::vector<Sprite> collect_sprites;
		Point<int16_t> collect_dimensions;
		Point<int16_t> collect_adj;
		Sprite default_medal;
		Text medal_text;
		Text medal_total;

		/// Damage
		bool damage_enabled;
		std::vector<Sprite> damage_sprites;
		Point<int16_t> damage_dimensions;

		/// Item
		bool item_enabled;
		std::vector<Sprite> item_sprites;
		Point<int16_t> item_dimensions;
	};
}

================
File: IO/UITypes/UICharSelect.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UICharSelect.h"

#include "UILoginNotice.h"
#include "UIRaceSelect.h"
#include "UISoftKey.h"
#include "UIWorldSelect.h"

#include "../UI.h"

#include "../Components/AreaButton.h"
#include "../Components/MapleButton.h"

#include "../../Configuration.h"

#include "../../Audio/Audio.h"
#include "../../Character/Job.h"

#include "../../Net/Packets/SelectCharPackets.h"

#define NOMINMAX
#include <windows.h>

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UICharSelect::UICharSelect(std::vector<CharEntry> characters, int8_t characters_count, int32_t slots, int8_t require_pic) : UIElement(Point<int16_t>(0, 0), Point<int16_t>(800, 600)),
		characters(characters), characters_count(characters_count), slots(slots), require_pic(require_pic), tab_index(0), tab_active(false), tab_move(false), charslot_y(0), use_timestamp(false), burning_character(true), show_pic_btns(false)
	{
		std::string version_text = Configuration::get().get_version();
		version = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::LEMONGRASS, "Ver. " + version_text);

		nl::node Login = nl::nx::UI["Login.img"];
		nl::node Common = Login["Common"];
		version_pos = Common["version"]["pos"];

		selected_character = Setting<DefaultCharacter>::get().load();
		selected_page = selected_character / PAGESIZE;
		page_count = std::ceil((double)slots / (double)PAGESIZE);

		tab = nl::nx::UI["Basic.img"]["Cursor"]["18"]["0"];
		tab_move_pos = 0;

		tab_map[0] = Buttons::BtSelect;
		tab_map[1] = Buttons::BtNew;
		tab_map[2] = Buttons::BtDelete;

		nl::node CharSelect = Login["CharSelect"];
		nl::node selectedWorld = CharSelect["selectedWorld"];
		nl::node pageNew = CharSelect["pageNew"];

		uint16_t world;
		uint8_t world_id = Configuration::get().get_worldid();
		uint8_t channel_id = Configuration::get().get_channelid();

		if (auto worldselect = UI::get().get_element<UIWorldSelect>())
			world = worldselect->get_worldbyid(world_id);

		world_sprites.emplace_back(Common["selectWorld"]);
		world_sprites.emplace_back(selectedWorld["icon"][world]);
		world_sprites.emplace_back(selectedWorld["name"][world]);
		world_sprites.emplace_back(selectedWorld["ch"][channel_id]);

		// Try multiple paths for v83 compatibility
		nl::node map = nl::nx::Map001["Back"]["UI_login.img"];
		if (map.name().empty()) {
			// Try direct Map path (v83)
			map = nl::nx::Map["Back"]["UI_login.img"];
		}
		if (map.name().empty()) {
			// Try UI Login.img path (alternative v83 location)  
			map = nl::nx::UI["Login.img"];
		}
		nl::node back = map["back"];

		sprites.emplace_back(back["1"], Point<int16_t>(512, 384));

		for (nl::node node : map["ani"])
			sprites.emplace_back(node, Point<int16_t>(0, -2));

		sprites.emplace_back(back["2"], Point<int16_t>(512, 384));

		nl::node BurningNotice = Common["Burning"]["BurningNotice"];
		burning_notice = BurningNotice;
		burning_numPos = BurningNotice["numPos"];
		burning_count = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::CREAM, "1");

		charinfo = CharSelect["charInfo1"];

		nl::node charSlot = CharSelect["charSlot"];
		charslot = charSlot["0"];
		charslot_pos = charSlot["pos"];
		charslot_bounds = Rectangle<int16_t>(charSlot["worldInfoLT"], charSlot["worldInfoRB"]);

		pagebase = pageNew["base"]["0"];
		pagenumber = Charset(pageNew["number"], Charset::Alignment::LEFT);
		pagenumberpos = pageNew["numberpos"];
		pagepos = pageNew["pos"];

		signpost[0] = CharSelect["adventure"]["0"];
		signpost[1] = CharSelect["knight"]["0"];
		signpost[2] = CharSelect["aran"]["0"];

		nametag = CharSelect["nameTag"];

		nl::node BtNew = CharSelect["BtNew"];
		Texture BtNewTexture = Texture(BtNew["normal"]["0"]);
		Point<int16_t> BtNewDim = BtNewTexture.get_dimensions();
		BtNewPos = BtNewTexture.get_origin().abs();

		nl::node BtSelect = CharSelect["BtSelect"];
		Point<int16_t> BtSelectPos = Texture(BtSelect["normal"]["0"]).get_origin().abs();

		Point<int16_t> tab_adj = Point<int16_t>(107, 8);

		tab_pos[0] = tab_adj + BtSelectPos + Point<int16_t>(2, 0);
		tab_pos[1] = tab_adj + BtNewPos;
		tab_pos[2] = tab_adj + BtNewPos + Point<int16_t>(BtNewDim.x() - 1, 0);

		buttons[Buttons::BtSelect] = std::make_unique<MapleButton>(BtSelect);
		buttons[Buttons::BtNew] = std::make_unique<MapleButton>(BtNew);
		buttons[Buttons::BtDelete] = std::make_unique<MapleButton>(CharSelect["BtDelete"]);
		buttons[Buttons::BtPageL] = std::make_unique<MapleButton>(CharSelect["pageL"]);
		buttons[Buttons::BtPageR] = std::make_unique<MapleButton>(CharSelect["pageR"]);
		buttons[Buttons::BtChangePIC] = std::make_unique<MapleButton>(Common["BtChangePIC"]);
		buttons[Buttons::BtResetPIC] = std::make_unique<MapleButton>(Login["WorldSelect"]["BtResetPIC"]);
		buttons[Buttons::BtCharacter] = std::make_unique<MapleButton>(CharSelect["EditCharList"]["BtCharacter"]);
		buttons[Buttons::BtPreview] = std::make_unique<MapleButton>(Common["BtPreview"]);

		nl::node pos = CharSelect["pos"];
		nl::node avatarPos = pos["avatarPos"];
		avatarLT = avatarPos["avatarLT"];
		avatarRB = avatarPos["avatarRB"];
		avatarSpace = avatarPos["avatarSpace"];

		Point<int16_t> screen_adj = Point<int16_t>(0, 3);

		nl::node detailPos = pos["detailPos"];
		jobPos = detailPos["jobPos"];
		levelPos = detailPos["levelPos"];
		namePos = detailPos["namePos"];
		statDEXPos = detailPos["statDEXPos"];
		statINTPos = detailPos["statINTPos"];
		statLUKPos = detailPos["statLUKPos"];
		statSTRPos = detailPos["statSTRPos"];

		jobPos -= screen_adj;
		namePos -= Point<int16_t>(0, 5);
		statDEXPos -= screen_adj;
		statINTPos -= screen_adj;
		statLUKPos -= screen_adj;
		statSTRPos -= screen_adj;

		for (size_t i = 0; i < PAGESIZE; i++)
			buttons[Buttons::CHARACTER_SLOT0 + i] = std::make_unique<AreaButton>(get_character_slot_pos(i), avatarRB - avatarLT);

		if (require_pic == 0 || !show_pic_btns)
		{
			buttons[Buttons::BtChangePIC]->set_active(false);
			buttons[Buttons::BtResetPIC]->set_active(false);
		}

		levelset = Charset(CharSelect["lv"], Charset::Alignment::CENTER);
		namelabel = OutlinedText(Text::Font::A14B, Text::Alignment::CENTER, Color::Name::WHITE, Color::Name::IRISHCOFFEE);

		for (size_t i = 0; i < InfoLabel::NUM_LABELS; i++)
			infolabels[i] = OutlinedText(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::WHITE, Color::Name::TOBACCOBROWN);

		for (CharEntry& entry : characters)
		{
			charlooks.emplace_back(entry.look);
			nametags.emplace_back(nametag, Text::Font::A12M, entry.stats.name);
		}

		emptyslot_effect = CharSelect["character"]["0"];
		emptyslot = CharSelect["character"]["1"]["0"];

		selectedslot_effect[0] = CharSelect["effect"][0];
		selectedslot_effect[1] = CharSelect["effect"][1];

		charslotlabel = OutlinedText(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::WHITE, Color::Name::JAMBALAYA);
		charslotlabel.change_text(get_slot_text());

		update_buttons();

		if (characters_count > 0)
		{
			if (selected_character < characters_count)
				update_selected_character();
			else
				select_last_slot();
		}

		if (Configuration::get().get_auto_login())
		{
			SelectCharPicPacket(
				Configuration::get().get_auto_pic(),
				Configuration::get().get_auto_cid()
			).dispatch();
		}
	}

	void UICharSelect::draw(float inter) const
	{
		UIElement::draw_sprites(inter);

		version.draw(position + version_pos - Point<int16_t>(0, 5));

		charslot.draw(position + charslot_pos - Point<int16_t>(0, charslot_y));
		charslotlabel.draw(position + charslot_pos + Point<int16_t>(113, 5 - charslot_y));

		for (Sprite sprite : world_sprites)
			sprite.draw(position, inter);

		std::string total = pad_number_with_leading_zero(page_count);
		std::string current = pad_number_with_leading_zero(selected_page + 1);

		std::list<uint8_t> fliplist = { 3, 4, 5, 9, 10, 11 };

		for (uint8_t i = 0; i < PAGESIZE; i++)
		{
			uint8_t index = i + selected_page * PAGESIZE;
			bool flip_character = std::find(fliplist.begin(), fliplist.end(), i) != fliplist.end();
			bool selectedslot = index == selected_character;

			if (index < characters_count)
			{
				Point<int16_t> charpos = get_character_slot_pos(i);
				DrawArgument chararg = DrawArgument(charpos, flip_character);

				nametags[index].draw(charpos + Point<int16_t>(2, 1));

				const StatsEntry& character_stats = characters[index].stats;

				if (selectedslot)
				{
					selectedslot_effect[1].draw(charpos + Point<int16_t>(-5, 16), inter);
					charinfo.draw(position);

					std::string levelstr = std::to_string(character_stats.stats[MapleStat::Id::LEVEL]);
					int8_t lvy = 19;
					int16_t lvx = levelset.draw("201", levelPos + Point<int16_t>(-1, lvy));

					levelset.draw('l', levelPos + Point<int16_t>(-lvx - 3, lvy - 1));
					namelabel.draw(namePos);

					for (size_t i = 0; i < InfoLabel::NUM_LABELS; i++)
					{
						Point<int16_t> labelpos = get_infolabel_pos(i);
						infolabels[i].draw(labelpos);
					}
				}

				uint8_t j = 0;
				uint16_t job = character_stats.stats[MapleStat::Id::JOB];

				if (job >= 0 && job < 1000)
					j = 0;
				else if (job >= 1000 && job < 2000)
					j = 1;
				else if (job >= 2000 && job < 2200)
					j = 2;
				else
					j = 0;

				signpost[j].draw(chararg);
				charlooks[index].draw(chararg, inter);

				if (selectedslot)
					selectedslot_effect[0].draw(charpos + Point<int16_t>(-5, -298), inter);
			}
			else if (i < slots)
			{
				Point<int16_t> emptyslotpos = get_character_slot_pos(i);

				emptyslot_effect.draw(emptyslotpos, inter);
				emptyslot.draw(DrawArgument(emptyslotpos, flip_character));
			}
		}

		UIElement::draw_buttons(inter);

		if (tab_active)
			tab.draw(position + tab_pos[tab_index] + Point<int16_t>(0, tab_move_pos));

		if (burning_character)
		{
			burning_notice.draw(position + BtNewPos, inter);
			burning_count.draw(position + BtNewPos + burning_numPos + Point<int16_t>(8, -4));
		}

		pagebase.draw(position + pagepos);
		pagenumber.draw(current.substr(0, 1), position + pagepos + Point<int16_t>(pagenumberpos[0]));
		pagenumber.draw(current.substr(1, 1), position + pagepos + Point<int16_t>(pagenumberpos[1]));
		pagenumber.draw(total.substr(0, 1), position + pagepos + Point<int16_t>(pagenumberpos[2]));
		pagenumber.draw(total.substr(1, 1), position + pagepos + Point<int16_t>(pagenumberpos[3]));
	}

	void UICharSelect::update()
	{
		UIElement::update();

		int16_t timestep_max = CHARSLOT_Y_MAX * Constants::TIMESTEP;

		if (use_timestamp)
		{
			if (show_timestamp)
			{
				if (timestamp > 0)
				{
					timestamp -= Constants::TIMESTEP;

					if (timestamp <= timestep_max)
						charslot_y += 1;
				}
			}
			else
			{
				if (timestamp <= timestep_max)
				{
					timestamp += Constants::TIMESTEP;

					if (charslot_y >= 0)
						charslot_y -= 1;
				}
			}
		}

		if (tab_move && tab_move_pos < 4)
			tab_move_pos += 1;

		if (tab_move && tab_move_pos == 4)
			tab_move = false;

		if (!tab_move && tab_move_pos > 0)
			tab_move_pos -= 1;

		for (CharLook& charlook : charlooks)
			charlook.update(Constants::TIMESTEP);

		for (Animation& effect : selectedslot_effect)
			effect.update();

		emptyslot_effect.update();

		if (burning_character)
			burning_notice.update();
	}

	void UICharSelect::doubleclick(Point<int16_t> cursorpos)
	{
		uint16_t button_index = selected_character + Buttons::CHARACTER_SLOT0;
		auto& btit = buttons[button_index];

		if (btit->is_active() && btit->bounds(position).contains(cursorpos) && btit->get_state() == Button::State::NORMAL && button_index >= Buttons::CHARACTER_SLOT0)
			button_pressed(Buttons::BtSelect);
	}

	Cursor::State UICharSelect::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		if (charslot_bounds.contains(cursorpos))
		{
			if (clicked)
			{
				if (use_timestamp)
					show_timestamp = !show_timestamp;

				return Cursor::State::CLICKING;
			}
		}

		Cursor::State ret = clicked ? Cursor::State::CLICKING : Cursor::State::IDLE;

		for (auto& btit : buttons)
		{
			if (btit.second->is_active() && btit.second->bounds(position).contains(cursorpos))
			{
				if (btit.second->get_state() == Button::State::NORMAL)
				{
					Sound(Sound::Name::BUTTONOVER).play();

					btit.second->set_state(Button::State::MOUSEOVER);
					ret = Cursor::State::CANCLICK;
				}
				else if (btit.second->get_state() == Button::State::MOUSEOVER)
				{
					if (clicked)
					{
						Sound(Sound::Name::BUTTONCLICK).play();

						btit.second->set_state(button_pressed(btit.first));

						if (tab_active && btit.first == tab_map[tab_index])
							btit.second->set_state(Button::State::MOUSEOVER);

						ret = Cursor::State::IDLE;
					}
					else
					{
						if (!tab_active || btit.first != tab_map[tab_index])
							ret = Cursor::State::CANCLICK;
					}
				}
			}
			else if (btit.second->get_state() == Button::State::MOUSEOVER)
			{
				if (!tab_active || btit.first != tab_map[tab_index])
					btit.second->set_state(Button::State::NORMAL);
			}
		}

		return ret;
	}

	void UICharSelect::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
			{
				button_pressed(Buttons::BtPreview);
			}
			else if (keycode == KeyAction::Id::RETURN)
			{
				if (tab_active)
				{
					uint16_t btn_index = tab_map[tab_index];

					auto& btn = buttons[btn_index];
					Button::State state = btn->get_state();

					if (state != Button::State::DISABLED)
						button_pressed(btn_index);
				}
				else
				{
					button_pressed(Buttons::BtSelect);
				}
			}
			else
			{
				if (keycode == KeyAction::Id::TAB)
				{
					uint8_t prev_tab = tab_index;

					if (!tab_active)
					{
						tab_active = true;

						if (!buttons[Buttons::BtSelect]->is_active())
							tab_index++;
					}
					else
					{
						tab_index++;

						if (tab_index > 2)
						{
							tab_active = false;
							tab_index = 0;
						}
					}

					tab_move = true;
					tab_move_pos = 0;

					auto& prev_btn = buttons[tab_map[prev_tab]];
					Button::State prev_state = prev_btn->get_state();

					if (prev_state != Button::State::DISABLED)
						prev_btn->set_state(Button::State::NORMAL);

					if (tab_active)
					{
						auto& btn = buttons[tab_map[tab_index]];
						Button::State state = btn->get_state();

						if (state != Button::State::DISABLED)
							btn->set_state(Button::State::MOUSEOVER);
					}
				}
				else
				{
					uint8_t selected_index = selected_character;
					uint8_t index_total = std::min(characters_count, static_cast<int8_t>((selected_page + 1) * PAGESIZE));

					uint8_t COLUMNS = 4;
					uint8_t columns = std::min(index_total, COLUMNS);

					uint8_t rows = std::floor((index_total - 1) / COLUMNS) + 1;

					int32_t current_col = 0;

					if (columns > 0)
					{
						div_t div = std::div(selected_index, columns);
						current_col = div.rem;
					}

					if (keycode == KeyAction::Id::UP)
					{
						uint8_t next_index = (selected_index - COLUMNS < 0 ? (selected_index - COLUMNS) + rows * COLUMNS : selected_index - COLUMNS);

						if (next_index == selected_character)
							return;

						if (next_index >= index_total)
							button_pressed(next_index - COLUMNS + Buttons::CHARACTER_SLOT0);
						else
							button_pressed(next_index + Buttons::CHARACTER_SLOT0);
					}
					else if (keycode == KeyAction::Id::DOWN)
					{
						uint8_t next_index = (selected_index + COLUMNS >= index_total ? current_col : selected_index + COLUMNS);

						if (next_index == selected_character)
							return;

						if (next_index > index_total)
							button_pressed(next_index + COLUMNS + Buttons::CHARACTER_SLOT0);
						else
							button_pressed(next_index + Buttons::CHARACTER_SLOT0);
					}
					else if (keycode == KeyAction::Id::LEFT)
					{
						if (selected_index != 0)
						{
							selected_index--;

							if (selected_index >= (selected_page + 1) * PAGESIZE - PAGESIZE)
								button_pressed(selected_index + Buttons::CHARACTER_SLOT0);
							else
								button_pressed(Buttons::BtPageL);
						}
					}
					else if (keycode == KeyAction::Id::RIGHT)
					{
						if (selected_index != characters_count - 1)
						{
							selected_index++;

							if (selected_index < index_total)
								button_pressed(selected_index + Buttons::CHARACTER_SLOT0);
							else
								button_pressed(Buttons::BtPageR);
						}
					}
				}
			}
		}
	}

	UIElement::Type UICharSelect::get_type() const
	{
		return TYPE;
	}

	void UICharSelect::add_character(CharEntry&& character)
	{
		charlooks.emplace_back(character.look);
		nametags.emplace_back(nametag, Text::Font::A13M, character.stats.name);
		characters.emplace_back(std::forward<CharEntry>(character));

		characters_count++;
	}

	void UICharSelect::post_add_character()
	{
		bool page_matches = (characters_count - 1) / PAGESIZE == selected_page;

		if (!page_matches)
			button_pressed(Buttons::BtPageR);

		update_buttons();

		if (characters_count > 1)
			select_last_slot();
		else
			update_selected_character();

		makeactive();

		charslotlabel.change_text(get_slot_text());
	}

	void UICharSelect::remove_character(int32_t id)
	{
		for (size_t i = 0; i < characters.size(); i++)
		{
			if (characters[i].id == id)
			{
				charlooks.erase(charlooks.begin() + i);
				nametags.erase(nametags.begin() + i);
				characters.erase(characters.begin() + i);

				characters_count--;

				charslotlabel.change_text(get_slot_text());

				if (selected_page > 0)
				{
					bool page_matches = (characters_count - 1) / PAGESIZE == selected_page;

					if (!page_matches)
						button_pressed(Buttons::BtPageL);
				}

				update_buttons();

				if (selected_character < characters_count)
					update_selected_character();
				else
					select_last_slot();

				return;
			}
		}
	}

	const CharEntry& UICharSelect::get_character(int32_t id)
	{
		for (CharEntry& character : characters)
			if (character.id == id)
				return character;

		LOG(LOG_DEBUG, "Invalid character id: [" << id << "]");

		static const CharEntry null_character = { {}, {}, 0 };

		return null_character;
	}

	Button::State UICharSelect::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			case Buttons::BtSelect:
			{
				if (characters.size() > 0)
				{
					Setting<DefaultCharacter>::get().save(selected_character);
					int32_t id = characters[selected_character].id;

					switch (require_pic)
					{
						case 0:
						{
							std::function<void()> onok = [&]()
							{
								request_pic();
							};

							UI::get().emplace<UILoginNotice>(UILoginNotice::Message::PIC_REQ, onok);
							break;
						}
						case 1:
						{
							std::function<void(const std::string&)> onok = [id](const std::string& pic)
							{
								SelectCharPicPacket(pic, id).dispatch();
							};

							UI::get().emplace<UISoftKey>(onok);
							break;
						}
						case 2:
						{
							SelectCharPacket(id).dispatch();
							break;
						}
					}
				}

				break;
			}
			case Buttons::BtNew:
			{
				Sound(Sound::Name::SCROLLUP).play();

				deactivate();

				tab_index = 0;
				tab_active = false;
				tab_move = false;
				tab_move_pos = 0;

				UI::get().emplace<UIRaceSelect>();
				break;
			}
			case Buttons::BtDelete:
			{
				int32_t id = characters[selected_character].id;

				switch (require_pic)
				{
					case 0:
					{
						std::function<void()> onok = [&]()
						{
							charslotlabel.change_text(get_slot_text());
						};

						UI::get().emplace<UILoginNotice>(UILoginNotice::Message::CHAR_DEL_FAIL_NO_PIC, onok);
						break;
					}
					case 1:
					{
						std::function<void()> oncancel = [&]()
						{
							charslotlabel.change_text(get_slot_text());
						};

						std::function<void()> onok = [&, id, oncancel]()
						{
							std::function<void(const std::string&)> onok = [&, id](const std::string& pic)
							{
								DeleteCharPicPacket(pic, id).dispatch();
							};

							UI::get().emplace<UISoftKey>(onok, oncancel);
						};

						const StatsEntry& character_stats = characters[selected_character].stats;
						uint16_t cjob = character_stats.stats[MapleStat::Id::JOB];

						if (cjob < 1000)
							UI::get().emplace<UILoginNotice>(UILoginNotice::Message::DELETE_CONFIRMATION, onok, oncancel);
						else
							UI::get().emplace<UILoginNotice>(UILoginNotice::Message::CASH_ITEMS_CONFIRM_DELETION, onok, oncancel);

						break;
					}
					case 2:
					{
						DeleteCharPacket(id).dispatch();
						break;
					}
				}

				break;
			}
			case Buttons::BtPageL:
			{
				uint8_t previous_page = selected_page;

				if (selected_page > 0)
					selected_page--;
				else
					selected_page = page_count - 1;

				if (previous_page != selected_page)
					update_buttons();

				select_last_slot();
				break;
			}
			case Buttons::BtPageR:
			{
				uint8_t previous_page = selected_page;

				if (selected_page < page_count - 1)
					selected_page++;
				else
					selected_page = 0;

				if (previous_page != selected_page)
				{
					update_buttons();

					button_pressed(Buttons::CHARACTER_SLOT0);
				}

				break;
			}
			case Buttons::BtChangePIC:
			{
				break;
			}
			case Buttons::BtResetPIC:
			{
				std::string url = Configuration::get().get_resetpic();

				ShellExecuteA(NULL, "open", url.c_str(), NULL, NULL, SW_SHOWNORMAL);
				break;
			}
			case Buttons::BtCharacter:
			{
				break;
			}
			case Buttons::BtPreview:
			{
				deactivate();

				Sound(Sound::Name::SCROLLUP).play();

				if (auto worldselect = UI::get().get_element<UIWorldSelect>())
					worldselect->makeactive();

				break;
			}
			default:
			{
				if (buttonid >= Buttons::CHARACTER_SLOT0)
				{
					uint8_t previous_character = selected_character;
					selected_character = buttonid - Buttons::CHARACTER_SLOT0 + selected_page * PAGESIZE;

					if (previous_character != selected_character)
					{
						if (previous_character < characters_count)
						{
							charlooks[previous_character].set_stance(Stance::Id::STAND1);
							nametags[previous_character].set_selected(false);
						}

						if (selected_character < characters_count)
							update_selected_character();
					}
				}

				break;
			}
		}

		return Button::State::NORMAL;
	}

	void UICharSelect::update_buttons()
	{
		for (uint8_t i = 0; i < PAGESIZE; i++)
		{
			uint8_t index = i + selected_page * PAGESIZE;

			if (index < characters_count)
				buttons[Buttons::CHARACTER_SLOT0 + i]->set_state(Button::State::NORMAL);
			else
				buttons[Buttons::CHARACTER_SLOT0 + i]->set_state(Button::State::DISABLED);
		}

		if (characters_count >= slots)
			buttons[Buttons::BtNew]->set_state(Button::State::DISABLED);
		else
			buttons[Buttons::BtNew]->set_state(Button::State::NORMAL);

		bool character_found = false;

		for (int8_t i = PAGESIZE - 1; i >= 0; i--)
		{
			uint8_t index = i + selected_page * PAGESIZE;

			if (index < characters_count)
			{
				character_found = true;

				break;
			}
		}

		buttons[Buttons::BtSelect]->set_active(character_found);
		buttons[Buttons::BtDelete]->set_state(character_found ? Button::State::NORMAL : Button::State::DISABLED);
	}

	void UICharSelect::update_selected_character()
	{
		Sound(Sound::Name::CHARSELECT).play();

		if (charlooks.size() > selected_character)
		{
			charlooks[selected_character].set_stance(Stance::Id::WALK1);
			nametags[selected_character].set_selected(true);

			const StatsEntry& character_stats = characters[selected_character].stats;

			namelabel.change_text(character_stats.name);

			for (size_t i = 0; i < InfoLabel::NUM_LABELS; i++)
				infolabels[i].change_text(get_infolabel(i, character_stats));
		}
	}

	void UICharSelect::select_last_slot()
	{
		for (int8_t i = PAGESIZE - 1; i >= 0; i--)
		{
			uint8_t index = i + selected_page * PAGESIZE;

			if (index < characters_count)
			{
				button_pressed(i + Buttons::CHARACTER_SLOT0);

				return;
			}
		}
	}

	std::string UICharSelect::get_slot_text()
	{
		if (use_timestamp)
		{
			show_timestamp = true;
			timestamp = 7 * 1000;
			charslot_y = 0;
		}

		return pad_number_with_leading_zero(characters_count) + "/" + pad_number_with_leading_zero(slots);
	}

	std::string UICharSelect::pad_number_with_leading_zero(uint8_t value) const
	{
		std::string return_val = std::to_string(value);
		return_val.insert(return_val.begin(), 2 - return_val.length(), '0');

		return return_val;
	}

	Point<int16_t> UICharSelect::get_character_slot_pos(size_t index) const
	{
		int16_t x = avatarSpace.x() * (index % 6);
		int16_t y = avatarSpace.y() * (index > 5);

		return Point<int16_t>(x, y) + avatarLT;
	}

	Point<int16_t> UICharSelect::get_infolabel_pos(size_t index) const
	{
		switch (index)
		{
			case InfoLabel::JOB:
				return jobPos;
			case InfoLabel::STR:
				return statSTRPos;
			case InfoLabel::DEX:
				return statDEXPos;
			case InfoLabel::INT:
				return statINTPos;
			case InfoLabel::LUK:
				return statLUKPos;
			case InfoLabel::NUM_LABELS:
			default:
				break;
		}

		return Point<int16_t>();
	}

	std::string UICharSelect::get_infolabel(size_t index, StatsEntry character_stats) const
	{
		switch (index)
		{
			case InfoLabel::JOB:
				return Job(character_stats.stats[MapleStat::Id::JOB]).get_name();
			case InfoLabel::STR:
				return std::to_string(character_stats.stats[MapleStat::Id::STR]);
			case InfoLabel::DEX:
				return std::to_string(character_stats.stats[MapleStat::Id::DEX]);
			case InfoLabel::INT:
				return std::to_string(character_stats.stats[MapleStat::Id::INT]);
			case InfoLabel::LUK:
				return std::to_string(character_stats.stats[MapleStat::Id::LUK]);
			case InfoLabel::NUM_LABELS:
				break;
			default:
				break;
		}

		return "";
	}

	void UICharSelect::request_pic()
	{
		std::function<void(const std::string&)> enterpic = [&](const std::string& entered_pic)
		{
			std::function<void(const std::string&)> verifypic = [&, entered_pic](const std::string& verify_pic)
			{
				if (entered_pic == verify_pic)
				{
					RegisterPicPacket(
						characters[selected_character].id,
						entered_pic
					).dispatch();
				}
				else
				{
					std::function<void()> onreturn = [&]()
					{
						request_pic();
					};

					UI::get().emplace<UILoginNotice>(UILoginNotice::Message::PASSWORD_IS_INCORRECT, onreturn);
				}
			};

			UI::get().emplace<UISoftKey>(verifypic, []() {}, "Please re-enter your new PIC.", Point<int16_t>(24, 0));
		};

		UI::get().emplace<UISoftKey>(enterpic, []() {}, "Your new PIC must at least be 6 characters long.", Point<int16_t>(24, 0));
	}
}

================
File: IO/UITypes/UICharSelect.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../Components/Charset.h"
#include "../Components/NameTag.h"

#include "../../Character/Look/CharLook.h"

namespace ms
{
	// The character selection screen
	class UICharSelect : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::CHARSELECT;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = false;

		UICharSelect(std::vector<CharEntry> characters, int8_t characters_count, int32_t slots, int8_t require_pic);

		void draw(float inter) const override;
		void update() override;

		void doubleclick(Point<int16_t> cursorpos) override;
		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		void add_character(CharEntry&& character);
		void post_add_character();
		void remove_character(int32_t id);

		const CharEntry& get_character(int32_t id);

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void update_buttons();
		void update_selected_character();
		void select_last_slot();
		std::string get_slot_text();
		std::string pad_number_with_leading_zero(uint8_t value) const;
		Point<int16_t> get_character_slot_pos(size_t index) const;
		Point<int16_t> get_infolabel_pos(size_t index) const;
		std::string get_infolabel(size_t index, StatsEntry character_stats) const;
		void request_pic();

		static constexpr uint8_t PAGESIZE = 12;
		static constexpr int16_t CHARSLOT_Y_MAX = 24;

		enum Buttons : uint16_t
		{
			BtSelect,
			BtNew,
			BtDelete,
			BtPageL,
			BtPageR,
			BtChangePIC,
			BtResetPIC,
			BtCharacter,
			BtPreview,
			CHARACTER_SLOT0
		};

		std::vector<CharEntry> characters;
		int8_t characters_count;
		int32_t slots;
		int8_t require_pic;
		Text version;
		Point<int16_t> version_pos;
		Point<int16_t> pagepos;
		Point<int16_t> BtNewPos;
		uint8_t selected_character;
		uint8_t selected_page;
		uint8_t page_count;
		Texture tab;
		uint8_t tab_index;
		bool tab_active;
		bool tab_move;
		Point<int16_t> tab_pos[3];
		int16_t tab_move_pos;
		std::map<uint8_t, uint16_t> tab_map;
		Animation burning_notice;
		Point <int16_t> burning_numPos;
		Text burning_count;
		std::vector<Sprite> world_sprites;
		Texture charinfo;
		Point<int16_t> avatarLT;
		Point<int16_t> avatarRB;
		Point<int16_t> avatarSpace;
		Point<int16_t> jobPos;
		Point<int16_t> levelPos;
		Point<int16_t> namePos;
		Point<int16_t> statDEXPos;
		Point<int16_t> statINTPos;
		Point<int16_t> statLUKPos;
		Point<int16_t> statSTRPos;
		Texture charslot;
		Point<int16_t> charslot_pos;
		Rectangle<int16_t> charslot_bounds;
		Texture pagebase;
		Charset pagenumber;
		nl::node pagenumberpos;
		Texture signpost[3];
		nl::node nametag;
		Charset levelset;
		OutlinedText namelabel;
		std::vector<CharLook> charlooks;
		std::vector<NameTag> nametags;
		Animation emptyslot_effect;
		Texture emptyslot;
		Animation selectedslot_effect[2];
		OutlinedText charslotlabel;
		int16_t timestamp;
		uint16_t charslot_y;
		bool use_timestamp;
		bool show_timestamp;
		bool burning_character;
		bool show_pic_btns;

		enum InfoLabel : uint8_t
		{
			JOB,
			STR,
			DEX,
			INT,
			LUK,
			NUM_LABELS
		};

		OutlinedText infolabels[UICharSelect::InfoLabel::NUM_LABELS];
	};
}

================
File: IO/UITypes/UIChat.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIChat.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIChat::UIChat() : UIDragElement<PosMAPLECHAT>()
	{
		show_weekly = Configuration::get().get_show_weekly();

		nl::node socialChatEnter = nl::nx::UI["UIWindow2.img"]["socialChatEnter"];

		nl::node backgrnd = socialChatEnter["backgrnd"];
		nl::node backgrnd4 = socialChatEnter["backgrnd4"];
		nl::node backgrnd5 = socialChatEnter["backgrnd5"];

		rank_shift = Point<int16_t>(86, 130);
		name_shift = Point<int16_t>(50, 5);

		origin_left = Texture(backgrnd4).get_origin();
		origin_right = Texture(backgrnd5).get_origin();

		origin_left = Point<int16_t>(std::abs(origin_left.x()), std::abs(origin_left.y()));
		origin_right = Point<int16_t>(std::abs(origin_right.x()), std::abs(origin_right.y()));

		sprites.emplace_back(socialChatEnter["ribbon"]);
		sprites.emplace_back(backgrnd);
		sprites.emplace_back(socialChatEnter["backgrnd2"]);
		sprites.emplace_back(socialChatEnter["backgrnd3"]);
		sprites.emplace_back(backgrnd4);
		sprites.emplace_back(backgrnd5);

		buttons[Buttons::CLOSE] = std::make_unique<MapleButton>(socialChatEnter["btX"]);
		buttons[Buttons::CHAT_DUO] = std::make_unique<MapleButton>(socialChatEnter["duoChat"]);
		buttons[Buttons::CHAT_FRIEND] = std::make_unique<MapleButton>(socialChatEnter["groupChatFrd"]);
		buttons[Buttons::CHAT_RANDOM] = std::make_unique<MapleButton>(socialChatEnter["groupChatRnd"]);

		charset = Charset(socialChatEnter["number"], Charset::Alignment::RIGHT);

		name_left = Text(Text::Font::A12B, Text::Alignment::CENTER, Color::Name::WHITE);
		name_right = Text(Text::Font::A12B, Text::Alignment::CENTER, Color::Name::WHITE);

		dimension = Texture(backgrnd).get_dimensions();

		if (show_weekly)
			UI::get().emplace<UIRank>();
	}

	void UIChat::draw(float inter) const
	{
		UIElement::draw(inter);

		charset.draw("0", position + origin_left + rank_shift);
		charset.draw("0", position + origin_right + rank_shift);

		name_left.draw(position + origin_left + name_shift);
		name_right.draw(position + origin_right + name_shift);
	}

	void UIChat::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed && escape)
			close();
	}

	UIElement::Type UIChat::get_type() const
	{
		return TYPE;
	}

	Button::State UIChat::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
		case Buttons::CLOSE:
			close();
			break;
		case Buttons::CHAT_DUO:
			break;
		case Buttons::CHAT_FRIEND:
			break;
		case Buttons::CHAT_RANDOM:
			break;
		default:
			break;
		}

		return Button::State::NORMAL;
	}

	void UIChat::close()
	{
		deactivate();
	}

	UIRank::UIRank() : UIDragElement<PosMAPLECHAT>()
	{
		Configuration::get().set_show_weekly(false);

		nl::node socialRank = nl::nx::UI["UIWindow2.img"]["socialRank"];

		nl::node backgrnd = socialRank["backgrnd"];
		nl::node backgrnd4 = socialRank["backgrnd4"];
		nl::node backgrnd5 = socialRank["backgrnd5"];

		rank_shift = Point<int16_t>(86, 130);
		name_shift = Point<int16_t>(52, 4);

		origin_left = Texture(backgrnd4).get_origin();
		origin_right = Texture(backgrnd5).get_origin();

		origin_left = Point<int16_t>(std::abs(origin_left.x()) - 1, std::abs(origin_left.y()));
		origin_right = Point<int16_t>(std::abs(origin_right.x()), std::abs(origin_right.y()));

		sprites.emplace_back(socialRank["ribbon"]);
		sprites.emplace_back(backgrnd);
		sprites.emplace_back(socialRank["backgrnd2"]);
		sprites.emplace_back(socialRank["backgrnd3"]);
		sprites.emplace_back(backgrnd4);
		sprites.emplace_back(backgrnd5);

		buttons[Buttons::CLOSE] = std::make_unique<MapleButton>(socialRank["btX"]);

		charset = Charset(socialRank["number"], Charset::Alignment::RIGHT);

		name_left = Text(Text::Font::A12B, Text::Alignment::CENTER, Color::Name::WHITE);
		name_right = Text(Text::Font::A12B, Text::Alignment::CENTER, Color::Name::WHITE);

		dimension = Texture(backgrnd).get_dimensions();
		position = position + Point<int16_t>(211, 124);
	}

	void UIRank::draw(float inter) const
	{
		UIElement::draw(inter);

		charset.draw("0", position + origin_left + rank_shift);
		charset.draw("0", position + origin_right + rank_shift);

		name_left.draw(position + origin_left + name_shift);
		name_right.draw(position + origin_right + name_shift);
	}

	void UIRank::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed && escape)
			close();
	}

	UIElement::Type UIRank::get_type() const
	{
		return TYPE;
	}

	Button::State UIRank::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
		case Buttons::CLOSE:
			close();
			break;
		default:
			break;
		}

		return Button::State::NORMAL;
	}

	void UIRank::close()
	{
		deactivate();
	}
}

================
File: IO/UITypes/UIChat.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../Components/Charset.h"

namespace ms
{
	class UIChat : public UIDragElement<PosMAPLECHAT>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::CHAT;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIChat();

		void draw(float inter) const override;

		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void close();

		enum Buttons : uint16_t
		{
			CLOSE,
			CHAT_DUO,
			CHAT_FRIEND,
			CHAT_RANDOM
		};

		bool show_weekly;
		Point<int16_t> rank_shift;
		Point<int16_t> name_shift;
		Point<int16_t> origin_left;
		Point<int16_t> origin_right;
		Charset charset;
		Text name_left;
		Text name_right;
	};

	class UIRank : public UIDragElement<PosMAPLECHAT>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::CHATRANK;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIRank();

		void draw(float inter) const override;

		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void close();

		enum Buttons : uint16_t
		{
			CLOSE
		};

		Point<int16_t> rank_shift;
		Point<int16_t> name_shift;
		Point<int16_t> origin_left;
		Point<int16_t> origin_right;
		Charset charset;
		Text name_left;
		Text name_right;
	};
}

================
File: IO/UITypes/UIChatBar.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIChatBar.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#include "../../Net/Packets/MessagingPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIChatBar::UIChatBar() : temp_view_x(0), temp_view_y(0), drag_direction(DragDirection::NONE), view_input(false), view_adjusted(false), position_adjusted(false)
	{
		nl::node ingame = nl::nx::UI["StatusBar3.img"]["chat"]["ingame"];
		nl::node input = ingame["input"];

		nl::node view = ingame["view"];
		nl::node max = view["max"];
		nl::node min = view["min"];

		drag = view["drag"];

		max_textures.emplace_back(max["top"]);
		max_textures.emplace_back(max["center"]);
		max_textures.emplace_back(max["bottom"]);

		min_textures.emplace_back(min["top"]);
		min_textures.emplace_back(min["center"]);
		min_textures.emplace_back(min["bottom"]);

		min_x = min_textures[0].width();
		max_x = max_textures[0].width();
		top_y = min_textures[0].height();
		center_y = min_textures[1].height();
		bottom_y = min_textures[2].height();
		btMin_x = Texture(view["btMin"]["normal"]["0"]).width();

		input_textures.emplace_back(input["layer:backgrnd"]);
		input_textures.emplace_back(input["layer:chatEnter"]);

		input_bg_x = input_textures[0].width();
		input_bg_y = input_textures[0].height();
		input_max_x = input_textures[1].width();

		Point<int16_t> input_origin = input_textures[1].get_origin().abs();
		input_origin_x = input_origin.x();
		input_origin_y = input_origin.y();

		min_view_y = Constants::Constants::get().get_viewheight() - input_bg_y;
		user_view_x = Setting<ChatViewX>::get().load();

		if (user_view_x == 0)
			user_view_x = min_x;

		user_view_y = Setting<ChatViewY>::get().load();

		if (user_view_y == 0)
		{
			// 20 pixels for the extra height by default
			user_view_y = top_y + center_y + bottom_y + 20;
		}

		int16_t btMax_x = Texture(view["btMax"]["normal"]["0"]).width();

		// Five pixels left and seven pixels up for padding
		buttons[Buttons::BtMax] = std::make_unique<MapleButton>(view["btMax"], Point<int16_t>(min_x - btMax_x - 5, -7));
		buttons[Buttons::BtMin] = std::make_unique<MapleButton>(view["btMin"]);

		Point<int16_t> input_btns_pos = Point<int16_t>(input_max_x - (input_bg_x - user_view_x) + input_origin_x - 17, 15 + input_origin_y + 1);
		int16_t input_btns_padding = 3;
		input_btns_x = Texture(input["button:chat"]["normal"]["0"]).width() + input_btns_padding;

		// Create basic chat button (should exist in v87)
		buttons[Buttons::BtChat] = std::make_unique<MapleButton>(input["button:chat"], input_btns_pos + Point<int16_t>(input_btns_x * 0, 0));
		
		// v87 compatibility: only create buttons if they exist
		int16_t button_index = 1;
		
		if (input["button:itemLink"])
		{
			buttons[Buttons::BtItemLink] = std::make_unique<MapleButton>(input["button:itemLink"], input_btns_pos + Point<int16_t>(input_btns_x * button_index, 0));
			buttons[Buttons::BtItemLink]->set_active(false);
			button_index++;
		}
		
		if (input["button:chatEmoticon"])
		{
			buttons[Buttons::BtChatEmoticon] = std::make_unique<MapleButton>(input["button:chatEmoticon"], input_btns_pos + Point<int16_t>(input_btns_x * button_index, 0));
			buttons[Buttons::BtChatEmoticon]->set_active(false);
			button_index++;
		}
		
		if (input["button:help"])
		{
			buttons[Buttons::BtHelp] = std::make_unique<MapleButton>(input["button:help"], input_btns_pos + Point<int16_t>(input_btns_x * button_index, 0));
			buttons[Buttons::BtHelp]->set_active(false);
			button_index++;
		}
		
		if (input["button:outChat"])
		{
			buttons[Buttons::BtOutChat] = std::make_unique<MapleButton>(input["button:outChat"], input_btns_pos + Point<int16_t>(input_btns_x * button_index, 0));
			buttons[Buttons::BtOutChat]->set_active(false);
		}

		buttons[Buttons::BtChat]->set_active(false);

		int16_t input_text_limit = 70;
		int16_t input_text_marker_height = 11;

		input_text = Textfield(
			Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE,
			Rectangle<int16_t>(get_input_text_position(), get_input_text_position() + Point<int16_t>(283, INPUT_TEXT_HEIGHT)),
			input_text_limit, input_text_marker_height
		);

		input_text.set_enter_callback(
			[&](std::string message)
			{
				input_text_enter_callback(message);
			}
		);

		input_text.set_key_callback(
			KeyAction::Id::ESCAPE,
			[&]()
			{
				input_text_escape_callback();
			}
		);

		input_text.set_key_callback(
			KeyAction::Id::UP,
			[&]()
			{
				change_message(true);
			}
		);

		input_text.set_key_callback(
			KeyAction::Id::DOWN,
			[&]()
			{
				change_message(false);
			}
		);

		dragarea = drag.get_dimensions();

		toggle_view(Setting<ChatViewMax>::get().load(), false);

#if LOG_LEVEL >= LOG_UI
		dragarea_box = ColorBox(dragarea.x(), dragarea.y(), Color::Name::BLUE, 0.5f);
		input_box = ColorBox(input_bg_x, input_bg_y, Color::Name::RED, 0.5f);
#endif

		show_message("[Welcome] Welcome to MapleStory!!", MessageType::YELLOW);
	}

	void UIChatBar::draw(float inter) const
	{
		if (view_max)
		{
			Range<int16_t> vertical = Range<int16_t>(0, 0);

			max_textures[0].draw(position - Point<int16_t>(0, center_y + user_view_y), vertical, Range<int16_t>(0, max_x - user_view_x + 5));
			max_textures[0].draw(position - Point<int16_t>(max_x - user_view_x, center_y + user_view_y), vertical, Range<int16_t>(max_x - 5, 0));

			max_textures[1].draw(DrawArgument(position - Point<int16_t>(0, center_y + user_view_y), Point<int16_t>(0, user_view_y + 1)), vertical, Range<int16_t>(0, max_x - user_view_x + 2));
			max_textures[1].draw(DrawArgument(position - Point<int16_t>(max_x - user_view_x, center_y + user_view_y), Point<int16_t>(0, user_view_y + 1)), vertical, Range<int16_t>(max_x - 2, 0));

			max_textures[2].draw(position, vertical, Range<int16_t>(0, max_x - user_view_x + 5));
			max_textures[2].draw(position - Point<int16_t>(max_x - user_view_x, 0), vertical, Range<int16_t>(max_x - 5, 0));

			drag.draw(position - Point<int16_t>(0, top_y + center_y + user_view_y));

			int16_t message_y = 0;

			for (int i = message_history.size() - 1; i >= 0; i--)
			{
				if (message_y <= center_y + user_view_y)
				{
					message_history[i].text.draw(position - Point<int16_t>(drag.get_origin().x() - 2, 5) - Point<int16_t>(0, message_y));

					message_y += 13;
				}
			}

			if (view_input)
			{
				Point<int16_t> pos = get_input_position();

				input_textures[0].draw(pos, vertical, Range<int16_t>(0, input_bg_x - user_view_x + 5));
				input_textures[0].draw(pos - Point<int16_t>(input_bg_x - user_view_x, 0), vertical, Range<int16_t>(input_bg_x - 5, 0));

				input_textures[1].draw(pos, vertical, Range<int16_t>(0, input_max_x - (input_bg_x - user_view_x) - input_origin_x - 22 + 3));
				input_textures[1].draw(pos - Point<int16_t>(input_max_x - (input_bg_x - user_view_x) - input_origin_x - 22, 0), vertical, Range<int16_t>(input_max_x - 3, 0));

				input_text.draw(Point<int16_t>(1, -2), Point<int16_t>(1, -3));

#if LOG_LEVEL >= LOG_UI
				input_box.draw(pos);
#endif
			}

			if (dragged)
			{
				if (temp_view_y > 0 && temp_view_x == 0)
				{
					Point<int16_t> pos = position;

					if (drag_direction == DragDirection::DOWN)
						pos = temp_position;

					max_textures[0].draw(pos - Point<int16_t>(0, center_y + temp_view_y), vertical, Range<int16_t>(0, max_x - user_view_x + 5));
					max_textures[0].draw(pos - Point<int16_t>(max_x - user_view_x, center_y + temp_view_y), vertical, Range<int16_t>(max_x - 5, 0));

					max_textures[1].draw(DrawArgument(pos - Point<int16_t>(0, center_y + temp_view_y), Point<int16_t>(0, temp_view_y + 1)), vertical, Range<int16_t>(0, max_x - user_view_x + 2));
					max_textures[1].draw(DrawArgument(pos - Point<int16_t>(max_x - user_view_x, center_y + temp_view_y), Point<int16_t>(0, temp_view_y + 1)), vertical, Range<int16_t>(max_x - 2, 0));

					max_textures[2].draw(pos, vertical, Range<int16_t>(0, max_x - user_view_x + 5));
					max_textures[2].draw(pos - Point<int16_t>(max_x - user_view_x, 0), vertical, Range<int16_t>(max_x - 5, 0));
				}
				else if (temp_view_y == 0 && temp_view_x > 0)
				{
					Point<int16_t> pos = position;

					if (drag_direction == DragDirection::LEFT)
						pos = temp_position;

					max_textures[0].draw(pos - Point<int16_t>(0, center_y + user_view_y), vertical, Range<int16_t>(0, max_x - temp_view_x + 5));
					max_textures[0].draw(pos - Point<int16_t>(max_x - temp_view_x, center_y + user_view_y), vertical, Range<int16_t>(max_x - 5, 0));

					max_textures[1].draw(DrawArgument(pos - Point<int16_t>(0, center_y + user_view_y), Point<int16_t>(0, user_view_y + 1)), vertical, Range<int16_t>(0, max_x - temp_view_x + 2));
					max_textures[1].draw(DrawArgument(pos - Point<int16_t>(max_x - temp_view_x, center_y + user_view_y), Point<int16_t>(0, user_view_y + 1)), vertical, Range<int16_t>(max_x - 2, 0));

					max_textures[2].draw(pos, vertical, Range<int16_t>(0, max_x - temp_view_x + 5));
					max_textures[2].draw(pos - Point<int16_t>(max_x - temp_view_x, 0), vertical, Range<int16_t>(max_x - 5, 0));
				}
				else if (temp_view_y > 0 && temp_view_x > 0)
				{
					Point<int16_t> pos = position;

					if (drag_direction == DragDirection::DOWN || drag_direction == DragDirection::LEFT || drag_direction == DragDirection::DOWNLEFT)
						pos = temp_position;

					max_textures[0].draw(pos - Point<int16_t>(0, center_y + temp_view_y), vertical, Range<int16_t>(0, max_x - temp_view_x + 5));
					max_textures[0].draw(pos - Point<int16_t>(max_x - temp_view_x, center_y + temp_view_y), vertical, Range<int16_t>(max_x - 5, 0));

					max_textures[1].draw(DrawArgument(pos - Point<int16_t>(0, center_y + temp_view_y), Point<int16_t>(0, temp_view_y + 1)), vertical, Range<int16_t>(0, max_x - temp_view_x + 2));
					max_textures[1].draw(DrawArgument(pos - Point<int16_t>(max_x - temp_view_x, center_y + temp_view_y), Point<int16_t>(0, temp_view_y + 1)), vertical, Range<int16_t>(max_x - 2, 0));

					max_textures[2].draw(pos, vertical, Range<int16_t>(0, max_x - temp_view_x + 5));
					max_textures[2].draw(pos - Point<int16_t>(max_x - temp_view_x, 0), vertical, Range<int16_t>(max_x - 5, 0));
				}
			}
		}
		else
		{
			min_textures[0].draw(position - Point<int16_t>(0, center_y));
			min_textures[1].draw(position - Point<int16_t>(0, center_y));
			min_textures[2].draw(position);

			drag.draw(position - Point<int16_t>(0, top_y + center_y));

			const size_t size = message_history.size();

			if (size > 0)
				message_history[size - 1].text.draw(position - Point<int16_t>(0, top_y + center_y) + Point<int16_t>(drag.get_origin().abs().x(), drag.height()) + Point<int16_t>(2, 7));
		}

		UIElement::draw(inter);

#if LOG_LEVEL >= LOG_UI
		dimension_box.draw(get_position());
		dragarea_box.draw(get_dragarea_position());

		if (view_max)
		{
			top_box.draw(get_position());
			bottom_box.draw(get_position() + Point<int16_t>(0, dimension.y() - 3));
			left_box.draw(get_position());
			right_box.draw(get_position() + Point<int16_t>(dimension.x() - 3, 0));
		}
#endif
	}

	void UIChatBar::update()
	{
		input_text.update(get_input_text_position(), Point<int16_t>(input_max_x - (input_bg_x - user_view_x) - 22, INPUT_TEXT_HEIGHT));
	}

	Button::State UIChatBar::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			case ms::UIChatBar::BtMax:
			{
				toggle_view(true, true);

				return Button::State::NORMAL;
			}
			case ms::UIChatBar::BtMin:
			{
				toggle_view(false, true);

				return Button::State::NORMAL;
			}
			default:
			{
				return Button::State::DISABLED;
			}
		}
	}

	bool UIChatBar::is_in_range(Point<int16_t> cursor_position) const
	{
		if (temp_view_y == 0 && temp_view_x == 0)
		{
			Rectangle<int16_t> bounds = Rectangle<int16_t>(get_position(), get_position() + dimension);
			Rectangle<int16_t> input_bounds = Rectangle<int16_t>(get_input_position(), get_input_position() + Point<int16_t>(user_view_x, input_bg_y));

			return bounds.contains(cursor_position) || input_bounds.contains(cursor_position);
		}
		else
		{
			Rectangle<int16_t> bounds = Rectangle<int16_t>(
				Point<int16_t>(0, 0),
				Point<int16_t>(
					Constants::Constants::get().get_viewwidth(),
					Constants::Constants::get().get_viewheight()
				)
			);

			return bounds.contains(cursor_position);
		}
	}

	Cursor::State UIChatBar::send_cursor(bool clicked, Point<int16_t> cursor_position)
	{
		if (view_input && temp_view_y == 0 && temp_view_x == 0)
			if (Cursor::State new_state = input_text.send_cursor(cursor_position, clicked))
				return new_state;

		if (clicked)
		{
			if (dragged)
			{
				if (temp_view_y == 0 && temp_view_x == 0)
				{
					Point<int16_t> new_pos = cursor_position - cursoroffset;
					int16_t new_pos_x = new_pos.x();
					int16_t new_pos_y = new_pos.y();

					if (new_pos_x < 0)
						new_pos.set_x(0);

					int16_t min_y = MIN_HEIGHT - 2 + drag.get_origin().y() * -1;

					if (view_input)
						min_y += user_view_y;

					if (new_pos_y < min_y)
						new_pos.set_y(min_y);

					int16_t max_x = Constants::Constants::get().get_viewwidth() - user_view_x;

					if (new_pos_x > max_x)
						new_pos.set_x(max_x);

					int16_t max_y = min_view_y;

					if (view_input)
						max_y -= input_bg_y;

					if (new_pos_y > max_y)
						new_pos.set_y(max_y);

					position = new_pos;

					return Cursor::State::CHATBARMOVE;
				}
				else
				{
					if (temp_view_x == 0)
					{
						if (drag_direction == DragDirection::DOWN)
						{
							// TODO: The top gets shifted by a pixel
							Point<int16_t> pos_y = cursor_position - position + Point<int16_t>(0, user_view_y) - Point<int16_t>(0, 13);
							Point<int16_t> pos = cursor_position - cursoroffset;

							if (pos_y.y() <= MIN_HEIGHT)
							{
								temp_view_y = MIN_HEIGHT;
								temp_position = position - Point<int16_t>(0, user_view_y) + Point<int16_t>(0, 13);
							}
							else if (pos_y.y() >= MAX_HEIGHT)
							{
								temp_view_y = MAX_HEIGHT;
								temp_position = position - Point<int16_t>(0, user_view_y) + Point<int16_t>(0, MAX_HEIGHT);
							}
							else
							{
								temp_view_y = pos_y.y();
								temp_position = Point<int16_t>(position.x(), pos.y());
							}
						}
						else
						{
							Point<int16_t> pos = position - cursor_position - Point<int16_t>(0, 13);

							if (pos.y() <= MIN_HEIGHT)
								temp_view_y = MIN_HEIGHT;
							else if (pos.y() >= MAX_HEIGHT)
								temp_view_y = MAX_HEIGHT;
							else
								temp_view_y = pos.y();
						}

#if LOG_LEVEL >= LOG_UI
						dimension = Point<int16_t>(user_view_x, top_y + center_y + bottom_y) + Point<int16_t>(0, temp_view_y);

						dimension_box = ColorBox(dimension.x(), dimension.y(), Color::Name::RED, 0.5f);
						left_box = ColorBox(3, dimension.y(), Color::Name::YELLOW, 0.5f);
						right_box = ColorBox(3, dimension.y(), Color::Name::YELLOW, 0.5f);
#endif

						return Cursor::State::CHATBARVDRAG;
					}
					else if (temp_view_y == 0)
					{
						if (drag_direction == DragDirection::LEFT)
						{
							// TODO: The right gets shifted by a pixel
							Point<int16_t> pos_x = position - cursor_position + Point<int16_t>(user_view_x, 0);
							Point<int16_t> pos = cursor_position - cursoroffset;

							if (pos_x.x() <= min_x)
							{
								temp_view_x = min_x;
								temp_position = position + Point<int16_t>(user_view_x, 0) - Point<int16_t>(min_x, 0);
							}
							else if (pos_x.x() >= max_x)
							{
								temp_view_x = max_x;
								temp_position = position - Point<int16_t>(max_x, 0) + Point<int16_t>(user_view_x, 0);
							}
							else
							{
								temp_view_x = pos_x.x();
								temp_position = Point<int16_t>(pos.x(), position.y());
							}
						}
						else
						{
							Point<int16_t> pos = cursor_position - position;

							if (pos.x() <= min_x)
								temp_view_x = min_x;
							else if (pos.x() >= max_x)
								temp_view_x = max_x;
							else
								temp_view_x = pos.x();
						}

#if LOG_LEVEL >= LOG_UI
						dimension = Point<int16_t>(temp_view_x, top_y + center_y + bottom_y) + Point<int16_t>(0, user_view_y);

						dimension_box = ColorBox(dimension.x(), dimension.y(), Color::Name::RED, 0.5f);
						top_box = ColorBox(dimension.x(), 3, Color::Name::GREEN, 0.5f);
						bottom_box = ColorBox(dimension.x(), 3, Color::Name::GREEN, 0.5f);
#endif

						return Cursor::State::CHATBARHDRAG;
					}
					else
					{
						if (drag_direction == DragDirection::DOWNLEFT)
						{
							int16_t temp_position_x, temp_position_y;

							Point<int16_t> pos = cursor_position - cursoroffset;

							// TODO: The right gets shifted by a pixel
							Point<int16_t> pos_x = position - cursor_position + Point<int16_t>(user_view_x, 0);

							if (pos_x.x() <= min_x)
							{
								temp_view_x = min_x;
								temp_position_x = position.x() + user_view_x - min_x;
							}
							else if (pos_x.x() >= max_x)
							{
								temp_view_x = max_x;
								temp_position_x = position.x() - max_x + user_view_x;
							}
							else
							{
								temp_view_x = pos_x.x();
								temp_position_x = pos.x();
							}

							// TODO: The top gets shifted by a pixel
							Point<int16_t> pos_y = cursor_position - position + Point<int16_t>(0, user_view_y) - Point<int16_t>(0, 13);

							if (pos_y.y() <= MIN_HEIGHT)
							{
								temp_view_y = MIN_HEIGHT;
								temp_position_y = position.y() - user_view_y + 13;
							}
							else if (pos_y.y() >= MAX_HEIGHT)
							{
								temp_view_y = MAX_HEIGHT;
								temp_position_y = position.y() - user_view_y + MAX_HEIGHT;
							}
							else
							{
								temp_view_y = pos_y.y();
								temp_position_y = pos.y();
							}

							temp_position = Point<int16_t>(temp_position_x, temp_position_y);
						}
						else
						{
							if (drag_direction == DragDirection::LEFT)
							{
								// TODO: The right gets shifted by a pixel
								Point<int16_t> pos_x = position - cursor_position + Point<int16_t>(user_view_x, 0);
								Point<int16_t> pos = cursor_position - cursoroffset;

								if (pos_x.x() <= min_x)
								{
									temp_view_x = min_x;
									temp_position = position + Point<int16_t>(user_view_x, 0) - Point<int16_t>(min_x, 0);
								}
								else if (pos_x.x() >= max_x)
								{
									temp_view_x = max_x;
									temp_position = position - Point<int16_t>(max_x, 0) + Point<int16_t>(user_view_x, 0);
								}
								else
								{
									temp_view_x = pos_x.x();
									temp_position = Point<int16_t>(pos.x(), position.y());
								}
							}
							else
							{
								Point<int16_t> pos_x = cursor_position - position;

								if (pos_x.x() <= min_x)
									temp_view_x = min_x;
								else if (pos_x.x() >= max_x)
									temp_view_x = max_x;
								else
									temp_view_x = pos_x.x();
							}

							if (drag_direction == DragDirection::DOWN)
							{
								// TODO: The top gets shifted by a pixel
								Point<int16_t> pos_y = cursor_position - position + Point<int16_t>(0, user_view_y) - Point<int16_t>(0, 13);
								Point<int16_t> pos = cursor_position - cursoroffset;

								if (pos_y.y() <= MIN_HEIGHT)
								{
									temp_view_y = MIN_HEIGHT;
									temp_position = position - Point<int16_t>(0, user_view_y) + Point<int16_t>(0, 13);
								}
								else if (pos_y.y() >= MAX_HEIGHT)
								{
									temp_view_y = MAX_HEIGHT;
									temp_position = position - Point<int16_t>(0, user_view_y) + Point<int16_t>(0, MAX_HEIGHT);
								}
								else
								{
									temp_view_y = pos_y.y();
									temp_position = Point<int16_t>(position.x(), pos.y());
								}
							}
							else
							{
								Point<int16_t> pos_y = position - cursor_position - Point<int16_t>(0, 13);

								if (pos_y.y() <= MIN_HEIGHT)
									temp_view_y = MIN_HEIGHT;
								else if (pos_y.y() >= MAX_HEIGHT)
									temp_view_y = MAX_HEIGHT;
								else
									temp_view_y = pos_y.y();
							}
						}

#if LOG_LEVEL >= LOG_UI
						dimension = Point<int16_t>(temp_view_x, top_y + center_y + bottom_y) + Point<int16_t>(0, temp_view_y);

						dimension_box = ColorBox(dimension.x(), dimension.y(), Color::Name::RED, 0.5f);
						top_box = ColorBox(dimension.x(), 3, Color::Name::GREEN, 0.5f);
						bottom_box = ColorBox(dimension.x(), 3, Color::Name::GREEN, 0.5f);
						left_box = ColorBox(3, dimension.y(), Color::Name::YELLOW, 0.5f);
						right_box = ColorBox(3, dimension.y(), Color::Name::YELLOW, 0.5f);
#endif

						if (drag_direction == DragDirection::DOWN || drag_direction == DragDirection::LEFT)
							return Cursor::State::CHATBARBRTLDRAG;
						else
							return Cursor::State::CHATBARBLTRDRAG;
					}
				}
			}
			else if (indragrange(cursor_position))
			{
				cursoroffset = cursor_position - position;
				dragged = true;

				return Cursor::State::CHATBARMOVE;
			}
			else if (view_max)
			{
				if (intoprange(cursor_position) && !inleftrange(cursor_position) && !inrightrange(cursor_position))
				{
					dragged = true;

					temp_view_y = user_view_y;

					return Cursor::State::CHATBARVDRAG;
				}
				else if (inrightrange(cursor_position) && !intoprange(cursor_position) && !inbottomrange(cursor_position))
				{
					dragged = true;

					temp_view_x = user_view_x;

					return Cursor::State::CHATBARHDRAG;
				}
				else if (intoprightrange(cursor_position))
				{
					dragged = true;

					temp_view_x = user_view_x;
					temp_view_y = user_view_y;

					return Cursor::State::CHATBARBLTRDRAG;
				}
				else if (inbottomrange(cursor_position) && !inleftrange(cursor_position) && !inrightrange(cursor_position))
				{
					cursoroffset = cursor_position - position;
					dragged = true;

					temp_view_y = user_view_y;
					temp_position = position;
					drag_direction = DragDirection::DOWN;

					return Cursor::State::CHATBARVDRAG;
				}
				else if (inbottomrightrange(cursor_position))
				{
					cursoroffset = cursor_position - position;
					dragged = true;

					temp_view_x = user_view_x;
					temp_view_y = user_view_y;
					temp_position = position;
					drag_direction = DragDirection::DOWN;

					return Cursor::State::CHATBARBRTLDRAG;
				}
				else if (inleftrange(cursor_position) && !intoprange(cursor_position) && !inbottomrange(cursor_position))
				{
					cursoroffset = cursor_position - position;
					dragged = true;

					temp_view_x = user_view_x;
					temp_position = position;
					drag_direction = DragDirection::LEFT;

					return Cursor::State::CHATBARHDRAG;
				}
				else if (intopleftrange(cursor_position))
				{
					cursoroffset = cursor_position - position;
					dragged = true;

					temp_view_x = user_view_x;
					temp_view_y = user_view_y;
					temp_position = position;
					drag_direction = DragDirection::LEFT;

					return Cursor::State::CHATBARBRTLDRAG;
				}
				else if (inbottomleftrange(cursor_position))
				{
					cursoroffset = cursor_position - position;
					dragged = true;

					temp_view_x = user_view_x;
					temp_view_y = user_view_y;
					temp_position = position;
					drag_direction = DragDirection::DOWNLEFT;

					return Cursor::State::CHATBARBLTRDRAG;
				}
			}
		}
		else
		{
			if (dragged)
			{
				if (temp_view_y == 0 && temp_view_x == 0)
				{
					dragged = false;

					Setting<PosCHAT>::get().save(position);

					return Cursor::State::CHATBARMOVE;
				}
				else
				{
					if (temp_view_x == 0)
					{
						user_view_y = temp_view_y;
						temp_view_y = 0;
						dragged = false;

						update_view(false);

						Setting<ChatViewY>::get().save(user_view_y);

						if (drag_direction == DragDirection::DOWN)
						{
							drag_direction = DragDirection::NONE;

							if (temp_position.y() > min_view_y - input_bg_y)
							{
								if (view_input)
									temp_position.set_y(min_view_y - input_bg_y);
								else
									temp_position.set_y(min_view_y);
							}

							position = temp_position;

							Setting<PosCHAT>::get().save(position);
						}

						return Cursor::State::CHATBARVDRAG;
					}
					else if (temp_view_y == 0)
					{
						user_view_x = temp_view_x;
						temp_view_x = 0;
						dragged = false;

						update_view(false);

						Setting<ChatViewX>::get().save(user_view_x);

						if (drag_direction == DragDirection::LEFT)
						{
							drag_direction = DragDirection::NONE;

							position = temp_position;

							Setting<PosCHAT>::get().save(position);
						}

						return Cursor::State::CHATBARHDRAG;
					}
					else
					{
						user_view_x = temp_view_x;
						temp_view_x = 0;

						user_view_y = temp_view_y;
						temp_view_y = 0;

						dragged = false;

						update_view(false);

						Setting<ChatViewX>::get().save(user_view_x);
						Setting<ChatViewY>::get().save(user_view_y);

						if (drag_direction == DragDirection::DOWN || drag_direction == DragDirection::LEFT || drag_direction == DragDirection::DOWNLEFT)
						{
							drag_direction = DragDirection::NONE;

							if (temp_position.y() > min_view_y - input_bg_y)
							{
								if (view_input)
									temp_position.set_y(min_view_y - input_bg_y);
								else
									temp_position.set_y(min_view_y);
							}

							position = temp_position;

							Setting<PosCHAT>::get().save(position);

							if (drag_direction != DragDirection::DOWNLEFT)
								return Cursor::State::CHATBARBRTLDRAG;
						}

						return Cursor::State::CHATBARBLTRDRAG;
					}
				}
			}
			else if (indragrange(cursor_position))
			{
				return Cursor::State::CHATBARMOVE;
			}
			else if (view_max)
			{
				if (intopleftrange(cursor_position) || inbottomrightrange(cursor_position))
					return Cursor::State::CHATBARBRTLDRAG;
				else if (intoprightrange(cursor_position) || inbottomleftrange(cursor_position))
					return Cursor::State::CHATBARBLTRDRAG;
				else if (intoprange(cursor_position) || inbottomrange(cursor_position))
					return Cursor::State::CHATBARVDRAG;
				else if (inleftrange(cursor_position) || inrightrange(cursor_position))
					return Cursor::State::CHATBARHDRAG;
			}
		}

		return UIElement::send_cursor(clicked, cursor_position);
	}

	void UIChatBar::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (keycode == KeyAction::Id::RETURN)
			{
				if (!view_input)
				{
					toggle_input(true);
				}
				else
				{
					input_text.change_text("");
					input_text.set_state(Textfield::State::FOCUSED);
				}
			}
			else
			{
				int32_t index = UI::get().get_keyboard().get_mapping_index(keycode);

				input_text.change_text("");
				input_text.set_state(Textfield::State::FOCUSED);
				input_text.send_key(KeyType::Id::TEXT, index, pressed);
			}
		}
	}

	UIElement::Type UIChatBar::get_type() const
	{
		return TYPE;
	}

	bool UIChatBar::has_input() const
	{
		return view_input;
	}

	void UIChatBar::toggle_view()
	{
		toggle_view(!view_max, true);
	}

	void UIChatBar::show_message(const char* message, MessageType type)
	{
		Color::Name color = Color::Name::RED;

		if (type == MessageType::YELLOW)
			color = Color::Name::YELLOW;
		else if (type == MessageType::WHITE)
			color = Color::Name::WHITE;
		else
			LOG(LOG_DEBUG, "[UIChatBar::show_message]: " << type << " not supported.");

		message_history.push_back(Message(MessageGroup::ALL, type, Text(Text::Font::A11M, Text::Alignment::LEFT, color, message)));
	}

	bool UIChatBar::indragrange(Point<int16_t> cursor_position) const
	{
		Rectangle<int16_t> bounds = Rectangle<int16_t>(get_dragarea_position(), get_dragarea_position() + dragarea);

		return bounds.contains(cursor_position);
	}

	bool UIChatBar::intoprange(Point<int16_t> cursor_position) const
	{
		Rectangle<int16_t> bounds = Rectangle<int16_t>(get_position(), get_position() + Point<int16_t>(dimension.x(), 3));

		return bounds.contains(cursor_position);
	}

	bool UIChatBar::inbottomrange(Point<int16_t> cursor_position) const
	{
		Point<int16_t> position = get_position() + Point<int16_t>(0, dimension.y() - 3);
		Rectangle<int16_t> bounds = Rectangle<int16_t>(position, position + Point<int16_t>(dimension.x(), 3));

		return bounds.contains(cursor_position);
	}

	bool UIChatBar::inleftrange(Point<int16_t> cursor_position) const
	{
		Rectangle<int16_t> bounds = Rectangle<int16_t>(get_position(), get_position() + Point<int16_t>(3, dimension.y()));

		return bounds.contains(cursor_position);
	}

	bool UIChatBar::inrightrange(Point<int16_t> cursor_position) const
	{
		Point<int16_t> position = get_position() + Point<int16_t>(dimension.x() - 3, 0);
		Rectangle<int16_t> bounds = Rectangle<int16_t>(position, position + Point<int16_t>(3, dimension.y()));

		return bounds.contains(cursor_position);
	}

	bool UIChatBar::intopleftrange(Point<int16_t> cursor_position) const
	{
		return intoprange(cursor_position) && inleftrange(cursor_position);
	}

	bool UIChatBar::inbottomrightrange(Point<int16_t> cursor_position) const
	{
		return inbottomrange(cursor_position) && inrightrange(cursor_position);
	}

	bool UIChatBar::intoprightrange(Point<int16_t> cursor_position) const
	{
		return intoprange(cursor_position) && inrightrange(cursor_position);
	}

	bool UIChatBar::inbottomleftrange(Point<int16_t> cursor_position) const
	{
		return inbottomrange(cursor_position) && inleftrange(cursor_position);
	}

	Point<int16_t> UIChatBar::get_position() const
	{
		if (temp_view_y == 0 && temp_view_x == 0)
		{
			if (view_max)
				return position - Point<int16_t>(0, top_y + center_y + user_view_y);
			else
				return position - Point<int16_t>(0, top_y + center_y);
		}
		else
		{
			if (temp_view_y > 0 && temp_view_x == 0)
			{
				if (drag_direction == DragDirection::DOWN)
					return temp_position - Point<int16_t>(0, top_y + center_y + temp_view_y);
				else
					return position - Point<int16_t>(0, top_y + center_y + temp_view_y);
			}
			else if (temp_view_y == 0 && temp_view_x > 0)
			{
				if (drag_direction == DragDirection::LEFT)
					return temp_position - Point<int16_t>(0, top_y + center_y + user_view_y);
				else
					return position - Point<int16_t>(0, top_y + center_y + user_view_y);
			}
			else
			{
				if (drag_direction == DragDirection::DOWN || drag_direction == DragDirection::LEFT || drag_direction == DragDirection::DOWNLEFT)
					return temp_position - Point<int16_t>(0, top_y + center_y + temp_view_y);
				else
					return position - Point<int16_t>(0, top_y + center_y + temp_view_y);
			}
		}
	}

	Point<int16_t> UIChatBar::get_dragarea_position() const
	{
		Point<int16_t> drag_origin = drag.get_origin();

		if (view_max)
			return position - Point<int16_t>(drag_origin.x(), top_y + center_y + user_view_y + drag_origin.y());
		else
			return position - Point<int16_t>(drag_origin.x(), top_y + center_y + drag_origin.y());
	}

	Point<int16_t> UIChatBar::get_input_position() const
	{
		return position + Point<int16_t>(0, 15);
	}

	Point<int16_t> UIChatBar::get_input_text_position()
	{
		Point<int16_t> adjust = Point<int16_t>(57, 20);

		return position + adjust;
	}

	void UIChatBar::toggle_input(bool enabled)
	{
		view_input = enabled;

		if (view_input && !view_max)
		{
			view_adjusted = true;

			toggle_view(true, true);
		}
		else
		{
			if (view_adjusted)
			{
				view_adjusted = false;

				toggle_view(false, true);
			}
			else
			{
				update_view(true);
			}
		}

		buttons[Buttons::BtChat]->set_active(view_input);
		buttons[Buttons::BtItemLink]->set_active(view_input);
		buttons[Buttons::BtChatEmoticon]->set_active(view_input);
		buttons[Buttons::BtHelp]->set_active(view_input);
		buttons[Buttons::BtOutChat]->set_active(view_input);
	}

	void UIChatBar::toggle_view(bool max, bool pressed)
	{
		view_max = max;

		if (!view_max)
		{
			view_input = false;
			view_adjusted = false;

			buttons[Buttons::BtChat]->set_active(view_input);
			buttons[Buttons::BtItemLink]->set_active(view_input);
			buttons[Buttons::BtChatEmoticon]->set_active(view_input);
			buttons[Buttons::BtHelp]->set_active(view_input);
			buttons[Buttons::BtOutChat]->set_active(view_input);
		}

		Setting<ChatViewMax>::get().save(view_max);

		buttons[Buttons::BtMax]->set_active(!view_max);
		buttons[Buttons::BtMin]->set_active(view_max);

		update_view(pressed);
	}

	void UIChatBar::update_view(bool pressed)
	{
		if (view_input)
			input_text.set_state(Textfield::State::FOCUSED);
		else
			input_text.set_state(Textfield::State::DISABLED);

		if (pressed)
		{
			if (position_adjusted)
			{
				position_adjusted = false;

				if (position.y() >= min_view_y - input_bg_y)
					position.shift_y(input_bg_y);
			}
			else
			{
				if (view_input && position.y() >= min_view_y)
				{
					position_adjusted = true;
					position.shift_y(-input_bg_y);
				}
			}
		}

		int16_t y = position.y() - center_y - user_view_y;

		if (y < 0)
		{
			position.shift_y(-y);
			position.shift_y(15);
		}

		Point<int16_t> btMin_padding = Point<int16_t>(-4, 3);

		if (view_max)
		{
			dimension = Point<int16_t>(user_view_x, top_y + center_y + bottom_y) + Point<int16_t>(0, user_view_y);

			buttons[Buttons::BtMin]->set_position(Point<int16_t>(user_view_x - btMin_x, -top_y - center_y - user_view_y) + btMin_padding);

			Point<int16_t> input_btns_pos = Point<int16_t>(input_max_x - (input_bg_x - user_view_x) + input_origin_x - 17, 15 + input_origin_y + 1);

			buttons[Buttons::BtChat]->set_position(input_btns_pos + Point<int16_t>(input_btns_x * 0, 0));
			buttons[Buttons::BtItemLink]->set_position(input_btns_pos + Point<int16_t>(input_btns_x * 1, 0));
			buttons[Buttons::BtChatEmoticon]->set_position(input_btns_pos + Point<int16_t>(input_btns_x * 2, 0));
			buttons[Buttons::BtHelp]->set_position(input_btns_pos + Point<int16_t>(input_btns_x * 3, 0));
			buttons[Buttons::BtOutChat]->set_position(input_btns_pos + Point<int16_t>(input_btns_x * 4, 0));
		}
		else
		{
			dimension = Point<int16_t>(min_x, top_y + center_y + bottom_y);

			buttons[Buttons::BtMin]->set_position(Point<int16_t>(min_x - btMin_x, -top_y - center_y - user_view_y) + btMin_padding);
		}

#if LOG_LEVEL >= LOG_UI
		dimension_box = ColorBox(dimension.x(), dimension.y(), Color::Name::RED, 0.5f);
		top_box = ColorBox(dimension.x(), 3, Color::Name::GREEN, 0.5f);
		bottom_box = ColorBox(dimension.x(), 3, Color::Name::GREEN, 0.5f);
		left_box = ColorBox(3, dimension.y(), Color::Name::YELLOW, 0.5f);
		right_box = ColorBox(3, dimension.y(), Color::Name::YELLOW, 0.5f);
		input_box = ColorBox(user_view_x, input_bg_y, Color::Name::RED, 0.5f);
#endif
	}

	void UIChatBar::input_text_enter_callback(std::string message)
	{
		if (message == "")
		{
			input_text_escape_callback();
		}
		else
		{
			user_message_history.push_back(message);
			user_message_history_index = user_message_history.size();

			GeneralChatPacket(message, true).dispatch();

			input_text.change_text("");
		}
	}

	void UIChatBar::input_text_escape_callback()
	{
		toggle_input(false);
	}

	void UIChatBar::change_message(bool up)
	{
		size_t size = user_message_history.size();
		size_t message_history_min = 1;
		size_t message_history_max = size;
		size_t max = 7;

		if (size > max)
			message_history_min = size - max;

		if (user_message_history.size() > 0)
		{
			if (up && user_message_history_index > message_history_min)
				user_message_history_index--;

			if (!up && user_message_history_index < message_history_max)
				user_message_history_index++;

			input_text.change_text(user_message_history[user_message_history_index - 1]);
		}
	}
}

================
File: IO/UITypes/UIChatBar.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../Components/Textfield.h"

// TODO: Change these?
#include "../Messages.h"

namespace ms
{
	class UIChatBar : public UIDragElement<PosCHAT>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::CHATBAR;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIChatBar();

		void draw(float inter) const override;
		void update() override;

		Button::State button_pressed(uint16_t buttonid) override;

		bool is_in_range(Point<int16_t> cursor_position) const override;
		Cursor::State send_cursor(bool clicked, Point<int16_t> cursor_position) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		enum MessageGroup : uint8_t
		{
			ALL,
			BATTLE,
			PARTY,
			FRIEND,
			GUILD,
			ALLIANCE,
			SPOUSE,
			GROUP,
			LENGTH
		};

		enum MessageType : uint8_t
		{
			UNK0,
			WHITE,
			RED,
			BLUE,
			YELLOW
		};

		bool has_input() const;
		void toggle_view();
		void show_message(const char* message, MessageType type);

		// TODO: Change these?
		void change_target(int32_t action) {}

	private:
		static constexpr int16_t INPUT_TEXT_HEIGHT = 18;
		static constexpr int16_t MIN_HEIGHT = 12;
		static constexpr int16_t MAX_HEIGHT = 467;

		bool indragrange(Point<int16_t> cursor_position) const override;
		bool intoprange(Point<int16_t> cursor_position) const;
		bool inbottomrange(Point<int16_t> cursor_position) const;
		bool inleftrange(Point<int16_t> cursor_position)  const;
		bool inrightrange(Point<int16_t> cursor_position) const;
		bool intopleftrange(Point<int16_t> cursor_position)  const;
		bool inbottomrightrange(Point<int16_t> cursor_position) const;
		bool intoprightrange(Point<int16_t> cursor_position)  const;
		bool inbottomleftrange(Point<int16_t> cursor_position) const;

		Point<int16_t> get_position() const;
		Point<int16_t> get_dragarea_position() const;
		Point<int16_t> get_input_position() const;
		Point<int16_t> get_input_text_position();
		void toggle_input(bool enabled);
		void toggle_view(bool max, bool pressed);
		void update_view(bool pressed);
		void input_text_enter_callback(std::string message);
		void input_text_escape_callback();
		void change_message(bool up);

		enum Buttons
		{
			BtMax,
			BtMin,
			BtChat,
			BtHelp,
			BtItemLink,
			BtChatEmoticon,
			BtOutChat
		};

		enum DragDirection
		{
			NONE,
			DOWN,
			LEFT,
			DOWNLEFT
		};

		Texture drag;
		std::vector<Texture> max_textures;
		std::vector<Texture> min_textures;
		std::vector<Texture> input_textures;

		int16_t min_x;
		int16_t max_x;
		int16_t top_y;
		int16_t center_y;
		int16_t bottom_y;
		int16_t btMin_x;
		int16_t user_view_x;
		int16_t user_view_y;
		int16_t temp_view_x;
		int16_t temp_view_y;
		int16_t min_view_y;
		bool view_max;
		bool view_input;
		bool view_adjusted;
		bool position_adjusted;
		DragDirection drag_direction;
		Point<int16_t> temp_position;

		int16_t input_bg_x;
		int16_t input_bg_y;
		int16_t input_max_x;
		int16_t input_origin_x;
		int16_t input_origin_y;
		int16_t input_btns_x;
		Textfield input_text;

		struct Message
		{
			MessageGroup group;
			MessageType type;
			Text text;

			Message() : group(MessageGroup::ALL), type(MessageType::UNK0), text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, "") {}
			Message(std::string text) : group(MessageGroup::ALL), type(MessageType::UNK0), text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, text) {}
			Message(MessageGroup group, MessageType type, Text text) : group(group), type(type), text(text) {}
		};

		std::vector<Message> message_history;
		std::vector<std::string> user_message_history;
		size_t user_message_history_index;

#if LOG_LEVEL >= LOG_UI
		ColorBox dimension_box;
		ColorBox dragarea_box;
		ColorBox top_box;
		ColorBox bottom_box;
		ColorBox left_box;
		ColorBox right_box;
		ColorBox input_box;
#endif
	};
}

================
File: IO/UITypes/UICommonCreation.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UICommonCreation.h"

#include "UICharSelect.h"
#include "UILoginNotice.h"
#include "UIRaceSelect.h"
#include "UIWorldSelect.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#include "../../Configuration.h"

#include "../../Audio/Audio.h"
#include "../../Data/ItemData.h"

#include "../../Net/Packets/CharCreationPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UICommonCreation::UICommonCreation(const std::string& c) : UIElement(Point<int16_t>(0, 0), Point<int16_t>(800, 600)), classType(c), className(class_map[c]), genderSelected(false), charLookSelected(false), charNameSelected(false), newCharNameDisabled(true), female(false)
	{
		load_char_look();

		std::string version_text = Configuration::get().get_version();
		version = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::LEMONGRASS, "Ver. " + version_text);

		nl::node Login = nl::nx::UI["Login.img"];
		nl::node Common = Login["Common"];
		version_pos = Common["version"]["pos"];

		nl::node createLimit = Login["NewChar"]["createLimit"];
		nl::node CustomizeChar = Login["CustomizeChar"][classType];
		nl::node board = CustomizeChar["board"];
		nl::node genderSelect = CustomizeChar["genderSelect"];
		nl::node CustomizeCharInfo = CustomizeChar["info"];

		avatarOrigin = CustomizeCharInfo["avatarOrigin"];
		Point<int16_t> avatarSize = CustomizeCharInfo["avatarSize"];
		charNameOrigin = CustomizeCharInfo["charNameOrigin"];
		Point<int16_t> genderFemale = CustomizeCharInfo["genderFemale"];
		Point<int16_t> genderMale = CustomizeCharInfo["genderMale"];
		int16_t genderMarginX = CustomizeCharInfo["genderMarginX"];
		int16_t genderMarginY = CustomizeCharInfo["genderMarginY"];
		genderOrigin = CustomizeCharInfo["genderOrigin"];
		Point<int16_t> genderSize = CustomizeCharInfo["genderSize"];
		Point<int16_t> nameEditCtrlPos = CustomizeCharInfo["nameEditCtrlPos"];
		std::string nameEditFontColor = CustomizeCharInfo["nameEditFontColor"];
		newAvatarPos = CustomizeCharInfo["newAvatarPos"];
		Point<int16_t> offsetForElemBack = CustomizeCharInfo["offsetForElemBack"];
		vCanvasCount = CustomizeCharInfo["vCanvasCount"];

		if (vCanvasCount == 0)
		{
			if (className == "adventurer")
				vCanvasCount = 6;
			else if (className == "cygnusKnight")
				vCanvasCount = 7;
		}

		nl::node CustomizeCharObj = nl::nx::Map["Obj"]["login.img"]["CustomizeChar"][class_map[classType]];

		int16_t genderHeight = board["genderHeight"];
		int16_t avatarHeight = board["avatarHeight"];

		nl::node genderTop = board["genderTop"];
		genderTopHeight = Texture(genderTop).height();

		nl::node boardBottom = board["boardBottom"];
		int16_t boardBottomHeight = Texture(boardBottom).height();

		nl::node boardMid = board["boardMid"];
		boardMidHeight = Texture(boardMid).height();

		sprites_background.emplace_back(CustomizeCharObj["0"], Point<int16_t>(512, 384));

		sprites.emplace_back(createLimit["backgrnd"]);

		if (className == "adventurer" || className == "cygnusKnight")
			sprites_gender_select.emplace_back(genderTop, genderOrigin);
		else
			sprites_gender_select.emplace_back(genderTop, genderOrigin - Point<int16_t>(1, 0));

		if (className == "cygnusKnight")
			sprites_gender_select.emplace_back(boardMid, genderOrigin - Point<int16_t>(0, 112));
		else
			sprites_gender_select.emplace_back(boardMid, genderOrigin);

		if (className == "cygnusKnight")
			sprites_gender_select.emplace_back(boardBottom, genderOrigin + Point<int16_t>(0, genderHeight - boardBottomHeight) - Point<int16_t>(0, 238));
		else
			sprites_gender_select.emplace_back(boardBottom, genderOrigin + Point<int16_t>(0, genderHeight - boardBottomHeight));

		if (className == "adventurer")
			sprites_lookboard.emplace_back(board["avatarTop"], genderOrigin);
		else
			sprites_lookboard.emplace_back(board["avatarTop"], genderOrigin + Point<int16_t>(1, 0));

		sprites_lookboard.emplace_back(boardMid, genderOrigin);

		if (className == "cygnusKnight")
			sprites_lookboard.emplace_back(boardBottom, genderOrigin);
		else
			sprites_lookboard.emplace_back(boardBottom, genderOrigin + Point<int16_t>(0, avatarHeight - boardBottomHeight));

		nl::node avatarSel = CustomizeChar["avatarSel"];

		Point<int16_t> avatarSelAdj = Point<int16_t>(0, 0);

		if (className == "adventurer")
			avatarSelAdj = Point<int16_t>(44, 108);
		else if (className == "aran")
			avatarSelAdj = Point<int16_t>(36, 92);
		else if (className == "cygnusKnight")
			avatarSelAdj = Point<int16_t>(0, 18);
		else
			avatarSelAdj = Point<int16_t>(0, 0);

		if (className == "cygnusKnight")
			sprites_char_look.emplace_back(avatarSel["WZ2_skin"], avatarOrigin - Point<int16_t>(0, 18 * 3));
		else
			sprites_char_look.emplace_back(avatarSel["WZ2_skin"], avatarOrigin + avatarSelAdj);

		for (size_t i = 0; i < avatarSel.size() - 1; i++)
		{
			size_t t = i;

			if (className == "adventurer" && i >= 2)
				t++;

			if (className == "cygnusKnight")
			{
				if (i == 2)
					sprites_char_look.emplace_back(avatarSel[i]["normal"], avatarOrigin + avatarSelAdj - Point<int16_t>(0, 16));
				else if (i > 2)
					sprites_char_look.emplace_back(avatarSel[i]["normal"], avatarOrigin + avatarSelAdj - Point<int16_t>(0, 18));
				else
					sprites_char_look.emplace_back(avatarSel[i]["normal"], avatarOrigin + avatarSelAdj);
			}
			else
			{
				sprites_char_look.emplace_back(avatarSel[i]["normal"], avatarOrigin + avatarSelAdj + Point<int16_t>(0, 18 * (t + 1)));
			}
		}

		nameboard = CustomizeChar["charName"];
		createLimitPos = Texture(createLimit["backgrnd"]).get_origin();
		createLimitNum = Charset(createLimit["num"], Charset::Alignment::RIGHT);

		buttons[Buttons::BtStart] = std::make_unique<MapleButton>(Common["BtStart"], Point<int16_t>(0, 1));
		buttons[Buttons::BtPreview] = std::make_unique<MapleButton>(Common["BtPreview"]);
		buttons[Buttons::BtGenderMale] = std::make_unique<MapleButton>(genderSelect["male"], getGenderSelectMalePos());
		buttons[Buttons::BtGenderFemale] = std::make_unique<MapleButton>(genderSelect["female"], getGenderSelectFemalePos());

		Point<int16_t> charLookAdj = Point<int16_t>(0, 0);

		if (className == "adventurer")
			charLookAdj = Point<int16_t>(75, 108);
		else if (className == "aran")
			charLookAdj = Point<int16_t>(69, 92);
		else
			charLookAdj = Point<int16_t>(0, 0);

		Point<int16_t> charLookLeft = avatarOrigin + charLookAdj;
		Point<int16_t> charLookRight = charLookLeft;

		if (className == "adventurer")
			charLookRight += Point<int16_t>(118, 0);
		else if (className == "aran")
			charLookRight += Point<int16_t>(110, 0);
		else
			charLookRight += Point<int16_t>(0, 0);

		buttons[Buttons::BtSkinLeft] = std::make_unique<MapleButton>(CustomizeChar["BtLeft"], charLookLeft);
		buttons[Buttons::BtSkinRight] = std::make_unique<MapleButton>(CustomizeChar["BtRight"], charLookRight);

		charLookLeft.shift_y(18);
		charLookRight.shift_y(18);

		buttons[Buttons::BtFaceLeft] = std::make_unique<MapleButton>(CustomizeChar["BtLeft"], charLookLeft);
		buttons[Buttons::BtFaceRight] = std::make_unique<MapleButton>(CustomizeChar["BtRight"], charLookRight);

		charLookLeft.shift_y(18);
		charLookRight.shift_y(18);

		buttons[Buttons::BtHairLeft] = std::make_unique<MapleButton>(CustomizeChar["BtLeft"], charLookLeft);
		buttons[Buttons::BtHairRight] = std::make_unique<MapleButton>(CustomizeChar["BtRight"], charLookRight);

		charLookLeft.shift_y(18);
		charLookRight.shift_y(18);

		if (hairColorEnabled)
		{
			charLookLeft.shift_y(18);
			charLookRight.shift_y(18);
		}

		buttons[Buttons::BtTopLeft] = std::make_unique<MapleButton>(CustomizeChar["BtLeft"], charLookLeft);
		buttons[Buttons::BtTopRight] = std::make_unique<MapleButton>(CustomizeChar["BtRight"], charLookRight);

		charLookLeft.shift_y(18);
		charLookRight.shift_y(18);

		if (bottomEnabled)
		{
			buttons[Buttons::BtBottomLeft] = std::make_unique<MapleButton>(CustomizeChar["BtLeft"], charLookLeft);
			buttons[Buttons::BtBottomRight] = std::make_unique<MapleButton>(CustomizeChar["BtRight"], charLookRight);

			charLookLeft.shift_y(18);
			charLookRight.shift_y(18);
		}

		if (capeEnabled)
		{
			buttons[Buttons::BtCapeLeft] = std::make_unique<MapleButton>(CustomizeChar["BtLeft"], charLookLeft);
			buttons[Buttons::BtCapeRight] = std::make_unique<MapleButton>(CustomizeChar["BtRight"], charLookRight);

			charLookLeft.shift_y(18);
			charLookRight.shift_y(18);
		}

		buttons[Buttons::BtShoesLeft] = std::make_unique<MapleButton>(CustomizeChar["BtLeft"], charLookLeft);
		buttons[Buttons::BtShoesRight] = std::make_unique<MapleButton>(CustomizeChar["BtRight"], charLookRight);

		charLookLeft.shift_y(18);
		charLookRight.shift_y(18);

		buttons[Buttons::BtWeaponLeft] = std::make_unique<MapleButton>(CustomizeChar["BtLeft"], charLookLeft);
		buttons[Buttons::BtWeaponRight] = std::make_unique<MapleButton>(CustomizeChar["BtRight"], charLookRight);

		nl::node BtYes = CustomizeChar["BtYes"];
		BtYesPos = BtYes["pos"];

		nl::node BtNo = CustomizeChar["BtNo"];
		BtNoPos = BtNo["pos"];

		buttons[Buttons::BtYes] = std::make_unique<MapleButton>(BtYes, genderOrigin + Point<int16_t>(BtYesPos["gender"]));
		buttons[Buttons::BtNo] = std::make_unique<MapleButton>(BtNo, genderOrigin + Point<int16_t>(BtNoPos["gender"]));

		nl::node hairSelect = CustomizeChar["hairSelect"];
		hairSelectSize = hairSelect.size();

		for (size_t i = 0; i < hairSelectSize; i++)
			buttons[Buttons::BtHairSelect0 + i] = std::make_unique<MapleButton>(hairSelect[i], getHairSelectPos(i));

		disable_char_look();

		newCharNamePos = charNameOrigin + nameEditCtrlPos - Point<int16_t>(5, 5);

		if (className == "adventurer")
			newCharNamePos += Point<int16_t>(3, 0);
		else if (className == "cygnusKnight")
			newCharNamePos += Point<int16_t>(-1, 1);

		Point<int16_t> newCharNameDim = Point<int16_t>(0, 0);

		if (className == "adventurer")
			newCharNameDim = Point<int16_t>(163, 24);
		else if (className == "aran")
			newCharNameDim = Point<int16_t>(149, 25);
		else if (className == "cygnusKnight")
			newCharNameDim = Point<int16_t>(147, 19);
		else
			newCharNameDim = Point<int16_t>(0, 0);

		newCharName = Textfield(Text::Font::A12M, Text::Alignment::LEFT, getNewCharNameColor(), Rectangle<int16_t>(newCharNamePos, newCharNamePos + newCharNameDim), 12);

		newCharName.set_enter_callback(
			[&](std::string)
			{
				button_pressed(Buttons::BtYes);
			}
		);

		newCharName.set_key_callback(
			KeyAction::Id::ESCAPE,
			[&]()
			{
				button_pressed(Buttons::BtNo);
			}
		);

		skinColorName = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::BLACK);
		faceName = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::BLACK);
		hairStyleName = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::BLACK);
		topName = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::BLACK);
		bottomName = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::BLACK);
		capeName = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::BLACK);
		shoeName = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::BLACK);
		weaponName = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::BLACK);

		randomize_look();

		newCharLook.set_direction(true);
	}

	void UICommonCreation::draw(float inter) const
	{
		for (const Sprite& sprite : sprites_background)
			sprite.draw(position, inter);

		if (!genderSelected)
		{
			for (size_t i = 0; i < sprites_gender_select.size(); i++)
			{
				if (i == 1)
				{
					for (size_t f = 0; f < vCanvasCount; f++)
						sprites_gender_select[i].draw(position + Point<int16_t>(0, genderTopHeight + (boardMidHeight * f)), inter);
				}
				else
				{
					sprites_gender_select[i].draw(position, inter);
				}
			}

			UIElement::draw(inter);

			newCharLook.draw(newAvatarPos, inter);
		}
		else
		{
			if (!charLookSelected)
			{
				UIElement::draw_sprites(inter);

				for (size_t i = 0; i < sprites_lookboard.size(); i++)
				{
					if (i == 0 && className == "cygnusKnight")
					{
						sprites_lookboard[i].draw(position - Point<int16_t>(1, 0), inter);
					}
					else if (i == 1)
					{
						for (size_t f = 0; f < vCanvasCount; f++)
						{
							if (className == "cygnusKnight")
								sprites_lookboard[i].draw(position + Point<int16_t>(0, boardMidHeight * f), inter);
							else
								sprites_lookboard[i].draw(position + Point<int16_t>(0, genderTopHeight + (boardMidHeight * f)), inter);
						}
					}
					else
					{
						sprites_lookboard[i].draw(position, inter);
					}
				}

				for (auto& sprite : sprites_char_look)
					sprite.draw(position, inter);

				Point<int16_t> label_pos = avatarOrigin;

				if (className == "adventurer")
					label_pos += Point<int16_t>(140, 107);
				else if (className == "aran")
					label_pos += Point<int16_t>(132, 91);
				else if (className == "cygnusKnight")
					label_pos += Point<int16_t>(199, 105);
				else
					label_pos += Point<int16_t>(0, 0);

				skinColorName.draw(label_pos);

				label_pos.shift_y(18);

				faceName.draw(label_pos);

				label_pos.shift_y(18);

				hairStyleName.draw(label_pos);

				label_pos.shift_y(18);

				if (hairColorEnabled)
					label_pos.shift_y(18);

				topName.draw(label_pos);

				label_pos.shift_y(18);

				if (bottomEnabled)
				{
					bottomName.draw(label_pos);

					label_pos.shift_y(18);
				}

				if (capeEnabled)
				{
					capeName.draw(label_pos);

					label_pos.shift_y(18);
				}

				shoeName.draw(label_pos);

				label_pos.shift_y(18);

				weaponName.draw(label_pos);
				newCharLook.draw(newAvatarPos, inter);

				UIElement::draw_buttons(inter);
			}
			else
			{
				if (!charNameSelected)
				{
					UIElement::draw_sprites(inter);

					nameboard.draw(charNameOrigin);

					if (className == "adventurer")
						newCharName.draw(position + Point<int16_t>(2, -2), Point<int16_t>(1, -1));
					else if (className == "cygnusKnight")
						newCharName.draw(position + Point<int16_t>(6, -3), Point<int16_t>(1, -1));
					else if (className == "aran")
						newCharName.draw(position + Point<int16_t>(6, -2), Point<int16_t>(1, -1));
					else
						newCharName.draw(position);

					newCharLook.draw(newAvatarPos, inter);

					UIElement::draw_buttons(inter);
				}
				else
				{
					UIElement::draw_sprites(inter);

					nameboard.draw(charNameOrigin);

					UIElement::draw_buttons(inter);
				}
			}
		}

		// TOOD: Get number of character able to create
		createLimitNum.draw("10", 5, position - createLimitPos + Point<int16_t>(7, 0));

		version.draw(position + version_pos - Point<int16_t>(0, 5));
	}

	void UICommonCreation::update()
	{
		if (!genderSelected)
		{
			for (Sprite& sprite : sprites_gender_select)
				sprite.update();
		}
		else
		{
			if (!charLookSelected)
			{
				for (Sprite& sprite : sprites_lookboard)
					sprite.update();

				for (Sprite& sprite : sprites_char_look)
					sprite.update();
			}
			else
			{
				if (!charNameSelected)
				{
					newCharName.update();

					if (!newCharNameDisabled)
						newCharName.set_state(Textfield::State::FOCUSED);
					else
						newCharName.set_state(Textfield::State::DISABLED);
				}
				else
				{
					newCharName.set_state(Textfield::State::DISABLED);
				}
			}
		}

		UIElement::update();
	}

	void UICommonCreation::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
				button_pressed(Buttons::BtNo);
			else if (keycode == KeyAction::Id::RETURN)
				button_pressed(Buttons::BtYes);
		}
	}

	UIElement::Type UICommonCreation::get_type() const
	{
		return TYPE;
	}

	void UICommonCreation::send_naming_result(bool nameused)
	{
		if (!charNameSelected)
		{
			if (!nameused)
			{
				charNameSelected = true;

				std::string name = newCharName.get_text();
				int32_t job = -1;
				int64_t face = faces[female][faceIndex];

				int64_t hair = 0;
				int64_t hairStyle = hairStyles[female][hairStyleIndex];
				auto hairColors_ = hairColors[female][hairStyle];

				if (hairColors_.size() > 0)
					hair = hairColors_[hairColorIndex];
				else
					hair = hairStyle;

				int64_t skin = skinColors[skinColorIndex];
				int64_t top = tops[female][topIndex];

				int64_t bottom = 0;

				if (bottoms[female].size() > 0)
					bottom = bottoms[female][bottomIndex];

				// TODO: Need to do something with cape
				int64_t cape = 0;

				if (capes[female].size() > 0)
					cape = capes[female][capeIndex];

				int64_t shoe = shoes[female][shoeIndex];
				int64_t weapon = weapons[female][weaponIndex];

				if (className == "adventurer")
					job = 1;
				else if (className == "aran")
					job = 2;
				else if (className == "cygnusKnight")
					job = 0;

				if (job >= 0)
				{
					CreateCharPacket(name, job, face, hair, skin, top, bottom, shoe, weapon, female).dispatch();

					auto onok = [&](bool alternate)
					{
						Sound(Sound::Name::SCROLLUP).play();

						UI::get().remove(UIElement::Type::LOGINNOTICE_CONFIRM);
						UI::get().remove(UIElement::Type::LOGINNOTICE);
						UI::get().remove(UIElement::Type::CLASSCREATION);
						UI::get().remove(UIElement::Type::RACESELECT);

						if (auto charselect = UI::get().get_element<UICharSelect>())
							charselect->post_add_character();
					};

					UI::get().emplace<UIKeySelect>(onok, true);
				}
			}
			else
			{
				auto onok = [&]()
				{
					newCharNameDisabled = false;

					buttons[Buttons::BtYes]->set_state(Button::State::NORMAL);
					buttons[Buttons::BtNo]->set_state(Button::State::NORMAL);
				};

				UI::get().emplace<UILoginNotice>(UILoginNotice::Message::NAME_IN_USE, onok);
			}
		}
	}

	Button::State UICommonCreation::button_pressed(uint16_t buttonid)
	{
		if (buttonid == Buttons::BtStart)
		{
			Sound(Sound::Name::SCROLLUP).play();

			UI::get().remove(UIElement::Type::CLASSCREATION);
			UI::get().remove(UIElement::Type::RACESELECT);
			UI::get().remove(UIElement::Type::CHARSELECT);

			if (auto worldselect = UI::get().get_element<UIWorldSelect>())
				worldselect->makeactive();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtPreview)
		{
			Sound(Sound::Name::SCROLLUP).play();

			UI::get().remove(UIElement::Type::CLASSCREATION);

			UI::get().emplace<UIRaceSelect>();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtYes)
		{
			if (!genderSelected)
			{
				genderSelected = true;

				buttons[Buttons::BtGenderMale]->set_active(false);
				buttons[Buttons::BtGenderFemale]->set_active(false);

				enable_char_look();

				return Button::State::NORMAL;
			}
			else
			{
				if (!charLookSelected)
				{
					charLookSelected = true;

					disable_char_look();

					buttons[Buttons::BtYes]->set_position(genderOrigin + Point<int16_t>(BtYesPos["name"]));
					buttons[Buttons::BtNo]->set_position(genderOrigin + Point<int16_t>(BtNoPos["name"]));

					newCharNameDisabled = false;

					return Button::State::NORMAL;
				}
				else
				{
					if (!charNameSelected)
					{
						std::string name = newCharName.get_text();

						if (name.size() <= 0)
						{
							return Button::State::NORMAL;
						}
						else if (name.size() >= 4)
						{
							newCharNameDisabled = true;

							buttons[Buttons::BtYes]->set_state(Button::State::DISABLED);
							buttons[Buttons::BtNo]->set_state(Button::State::DISABLED);

							if (auto raceselect = UI::get().get_element<UIRaceSelect>())
							{
								if (raceselect->check_name(name))
								{
									NameCharPacket(name).dispatch();

									return Button::State::IDENTITY;
								}
							}

							auto okhandler = [&]()
							{
								newCharNameDisabled = false;

								buttons[Buttons::BtYes]->set_state(Button::State::NORMAL);
								buttons[Buttons::BtNo]->set_state(Button::State::NORMAL);
							};

							UI::get().emplace<UILoginNotice>(UILoginNotice::Message::ILLEGAL_NAME, okhandler);

							return Button::State::NORMAL;
						}
						else
						{
							newCharNameDisabled = true;

							buttons[Buttons::BtYes]->set_state(Button::State::DISABLED);
							buttons[Buttons::BtNo]->set_state(Button::State::DISABLED);

							auto okhandler = [&]()
							{
								newCharNameDisabled = false;

								buttons[Buttons::BtYes]->set_state(Button::State::NORMAL);
								buttons[Buttons::BtNo]->set_state(Button::State::NORMAL);
							};

							UI::get().emplace<UILoginNotice>(UILoginNotice::Message::ILLEGAL_NAME, okhandler);

							return Button::State::IDENTITY;
						}
					}
					else
					{
						return Button::State::NORMAL;
					}
				}
			}
		}
		else if (buttonid == Buttons::BtNo)
		{
			if (charLookSelected)
			{
				charLookSelected = false;

				enable_char_look();

				newCharNameDisabled = true;

				return Button::State::NORMAL;
			}
			else
			{
				if (genderSelected && choosableGender)
				{
					genderSelected = false;

					buttons[Buttons::BtGenderMale]->set_active(true);
					buttons[Buttons::BtGenderFemale]->set_active(true);

					disable_char_look();

					buttons[Buttons::BtYes]->set_position(genderOrigin + Point<int16_t>(BtYesPos["gender"]));
					buttons[Buttons::BtNo]->set_position(genderOrigin + Point<int16_t>(BtNoPos["gender"]));

					return Button::State::NORMAL;
				}
				else
				{
					button_pressed(Buttons::BtPreview);

					return Button::State::NORMAL;
				}
			}
		}
		else if (buttonid == Buttons::BtSkinLeft)
		{
			skinColorIndex = (skinColorIndex > 0) ? skinColorIndex - 1 : skinColors.size() - 1;

			newCharLook.set_body(skinColors[skinColorIndex]);
			skinColorName.change_text(newCharLook.get_body()->get_name());

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtSkinRight)
		{
			skinColorIndex = (skinColorIndex < skinColors.size() - 1) ? skinColorIndex + 1 : 0;

			newCharLook.set_body(skinColors[skinColorIndex]);
			skinColorName.change_text(newCharLook.get_body()->get_name());

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtFaceLeft)
		{
			faceIndex = (faceIndex > 0) ? faceIndex - 1 : faces[female].size() - 1;

			newCharLook.set_face(faces[female][faceIndex]);
			faceName.change_text(newCharLook.get_face()->get_name());

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtFaceRight)
		{
			faceIndex = (faceIndex < faces[female].size() - 1) ? faceIndex + 1 : 0;

			newCharLook.set_face(faces[female][faceIndex]);
			faceName.change_text(newCharLook.get_face()->get_name());

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtHairLeft)
		{
			hairStyleIndex = (hairStyleIndex > 0) ? hairStyleIndex - 1 : hairStyles[female].size() - 1;

			int64_t hairStyle = hairStyles[female][hairStyleIndex];
			auto hairColors_ = hairColors[female][hairStyle];

			newCharLook.set_hair(hairColors_[hairColorIndex]);
			hairStyleName.change_text(newCharLook.get_hair()->get_name());

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtHairRight)
		{
			hairStyleIndex = (hairStyleIndex < hairStyles[female].size() - 1) ? hairStyleIndex + 1 : 0;

			int64_t hairStyle = hairStyles[female][hairStyleIndex];
			auto hairColors_ = hairColors[female][hairStyle];

			newCharLook.set_hair(hairColors_[hairColorIndex]);
			hairStyleName.change_text(newCharLook.get_hair()->get_name());

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtTopLeft)
		{
			topIndex = (topIndex > 0) ? topIndex - 1 : tops[female].size() - 1;

			newCharLook.add_equip(tops[female][topIndex]);
			topName.change_text(get_equipname(EquipSlot::Id::TOP));

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtTopRight)
		{
			topIndex = (topIndex < tops[female].size() - 1) ? topIndex + 1 : 0;

			newCharLook.add_equip(tops[female][topIndex]);
			topName.change_text(get_equipname(EquipSlot::Id::TOP));

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtBottomLeft)
		{
			bottomIndex = (bottomIndex > 0) ? bottomIndex - 1 : bottoms[female].size() - 1;

			newCharLook.add_equip(bottoms[female][bottomIndex]);
			bottomName.change_text(get_equipname(EquipSlot::Id::BOTTOM));

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtBottomRight)
		{
			bottomIndex = (bottomIndex < bottoms[female].size() - 1) ? bottomIndex + 1 : 0;

			newCharLook.add_equip(bottoms[female][bottomIndex]);
			bottomName.change_text(get_equipname(EquipSlot::Id::BOTTOM));

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtCapeLeft)
		{
			capeIndex = (capeIndex > 0) ? capeIndex - 1 : capes[female].size() - 1;

			newCharLook.add_equip(capes[female][capeIndex]);
			capeName.change_text(get_equipname(EquipSlot::Id::CAPE));

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtCapeRight)
		{
			capeIndex = (capeIndex < capes[female].size() - 1) ? capeIndex + 1 : 0;

			newCharLook.add_equip(capes[female][capeIndex]);
			capeName.change_text(get_equipname(EquipSlot::Id::CAPE));

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtShoesLeft)
		{
			shoeIndex = (shoeIndex > 0) ? shoeIndex - 1 : shoes[female].size() - 1;

			newCharLook.add_equip(shoes[female][shoeIndex]);
			shoeName.change_text(get_equipname(EquipSlot::Id::SHOES));

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtShoesRight)
		{
			shoeIndex = (shoeIndex < shoes[female].size() - 1) ? shoeIndex + 1 : 0;

			newCharLook.add_equip(shoes[female][shoeIndex]);
			shoeName.change_text(get_equipname(EquipSlot::Id::SHOES));

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtWeaponLeft)
		{
			weaponIndex = (weaponIndex > 0) ? weaponIndex - 1 : weapons[female].size() - 1;

			newCharLook.add_equip(weapons[female][weaponIndex]);
			weaponName.change_text(get_equipname(EquipSlot::Id::WEAPON));

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtWeaponRight)
		{
			weaponIndex = (weaponIndex < weapons[female].size() - 1) ? weaponIndex + 1 : 0;

			newCharLook.add_equip(weapons[female][weaponIndex]);
			weaponName.change_text(get_equipname(EquipSlot::Id::WEAPON));

			check_names();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtGenderMale)
		{
			if (female)
			{
				female = false;

				randomize_look();
			}

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtGenderFemale)
		{
			if (!female)
			{
				female = true;

				randomize_look();
			}

			return Button::State::NORMAL;
		}
		else if (buttonid >= Buttons::BtHairSelect0 && buttonid < Buttons::LENGTH)
		{
			hairColorIndex = buttonid - Buttons::BtHairSelect0;

			int64_t hairStyle = hairStyles[female][hairStyleIndex];
			auto hairColors_ = hairColors[female][hairStyle];

			newCharLook.set_hair(hairColors_[hairColorIndex]);
			hairStyleName.change_text(newCharLook.get_hair()->get_name());

			check_names();

			return Button::State::NORMAL;
		}
		else
		{
			return Button::State::PRESSED;
		}
	}

	void UICommonCreation::randomize_look()
	{
		skinColorIndex = randomizer.next_int(skinColors.size());
		faceIndex = randomizer.next_int(faces[female].size());
		hairStyleIndex = randomizer.next_int(hairStyles[female].size());

		int64_t hairStyle = hairStyles[female][hairStyleIndex];
		auto& hairColors_ = hairColors[female][hairStyle];
		hairColorIndex = randomizer.next_int(hairColors_.size());

		topIndex = randomizer.next_int(tops[female].size());
		bottomIndex = randomizer.next_int(bottoms[female].size());
		capeIndex = randomizer.next_int(capes[female].size());
		shoeIndex = randomizer.next_int(shoes[female].size());
		weaponIndex = randomizer.next_int(weapons[female].size());

		newCharLook.set_body(skinColors[skinColorIndex]);
		newCharLook.set_face(faces[female][faceIndex]);

		if (hairColors_.size() > 0)
			newCharLook.set_hair(hairColors_[hairColorIndex]);
		else
			newCharLook.set_hair(hairStyle);

		newCharLook.add_equip(tops[female][topIndex]);

		if (bottoms[female].size() > 0)
			newCharLook.add_equip(bottoms[female][bottomIndex]);

		if (capes[female].size() > 0)
			newCharLook.add_equip(capes[female][capeIndex]);

		newCharLook.add_equip(shoes[female][shoeIndex]);
		newCharLook.add_equip(weapons[female][weaponIndex]);

		skinColorName.change_text(newCharLook.get_body()->get_name());
		faceName.change_text(newCharLook.get_face()->get_name());
		hairStyleName.change_text(newCharLook.get_hair()->get_name());
		topName.change_text(get_equipname(EquipSlot::Id::TOP));
		bottomName.change_text(get_equipname(EquipSlot::Id::BOTTOM));
		capeName.change_text(get_equipname(EquipSlot::Id::CAPE));
		shoeName.change_text(get_equipname(EquipSlot::Id::SHOES));
		weaponName.change_text(get_equipname(EquipSlot::Id::WEAPON));

		check_names();
	}

	void UICommonCreation::load_char_look()
	{
		size_t color_count = 0, bottom_count = 0, cape_count = 0;

		nl::node MakeCharInfo = nl::nx::Etc["MakeCharInfo.img"][classType];

		for (nl::node gender_node : MakeCharInfo)
		{
			std::string gender_node_name = gender_node.name();

			if (gender_node_name == "info")
			{
				choosableGender = gender_node["choosableGender"].get_bool();

				if (!choosableGender)
					button_pressed(Buttons::BtYes);

				nl::node skins = gender_node["WZ2_skin"];

				for (nl::node skin : skins)
					skinColors.push_back(skin["id"].get_integer() - 12000);

				continue;
			}

			bool f = gender_node_name == "female";

			for (size_t type = 0; type < gender_node.size(); type++)
			{
				for (nl::node id_node : gender_node[type])
				{
					std::string id_node_name = id_node.name();

					if (id_node_name == "color" || id_node_name == "name")
						continue;

					int64_t id_node_value = id_node.get_integer();

					switch (type)
					{
						case 0:
						{
							faces[f].push_back(id_node_value);
							break;
						}
						case 1:
						{
							hairStyles[f].push_back(id_node_value);

							for (nl::node color_node : gender_node[type]["color"][id_node_value])
							{
								hairColors[f][id_node_value].push_back(color_node);

								color_count++;
							}

							break;
						}
						case 2:
						{
							tops[f].push_back(id_node_value);
							break;
						}
						default:
						{
							int64_t id_node_prefix = id_node_value / 10000;

							if (id_node_prefix == 106)
							{
								bottoms[f].push_back(id_node_value);

								bottom_count++;
								break;
							}
							else if (id_node_prefix == 107)
							{
								shoes[f].push_back(id_node_value);
								break;
							}
							else if (id_node_prefix == 110)
							{
								capes[f].push_back(id_node_value);

								cape_count++;
								break;
							}
							else
							{
								weapons[f].push_back(id_node_value);
								break;
							}
						}
					}
				}
			}
		}

		if (color_count > 0)
			hairColorEnabled = true;

		if (bottom_count > 0)
			bottomEnabled = true;

		if (cape_count > 0)
			capeEnabled = true;
	}

	void UICommonCreation::enable_char_look()
	{
		buttons[Buttons::BtYes]->set_position(genderOrigin + Point<int16_t>(BtYesPos["avatar"]));
		buttons[Buttons::BtNo]->set_position(genderOrigin + Point<int16_t>(BtNoPos["avatar"]));

		if (faces[female].size() > 1)
		{
			buttons[Buttons::BtFaceLeft]->set_active(true);
			buttons[Buttons::BtFaceRight]->set_active(true);
		}

		if (hairStyles[female].size() > 1)
		{
			buttons[Buttons::BtHairLeft]->set_active(true);
			buttons[Buttons::BtHairRight]->set_active(true);
		}

		if (skinColors.size() > 1)
		{
			buttons[Buttons::BtSkinLeft]->set_active(true);
			buttons[Buttons::BtSkinRight]->set_active(true);
		}

		if (tops[female].size() > 1)
		{
			buttons[Buttons::BtTopLeft]->set_active(true);
			buttons[Buttons::BtTopRight]->set_active(true);
		}

		if (bottomEnabled && bottoms[female].size() > 1)
		{
			buttons[Buttons::BtBottomLeft]->set_active(true);
			buttons[Buttons::BtBottomRight]->set_active(true);
		}

		if (capeEnabled && capes[female].size() > 1)
		{
			buttons[Buttons::BtCapeLeft]->set_active(true);
			buttons[Buttons::BtCapeRight]->set_active(true);
		}

		if (shoes[female].size() > 1)
		{
			buttons[Buttons::BtShoesLeft]->set_active(true);
			buttons[Buttons::BtShoesRight]->set_active(true);
		}

		if (weapons[female].size() > 1)
		{
			buttons[Buttons::BtWeaponLeft]->set_active(true);
			buttons[Buttons::BtWeaponRight]->set_active(true);
		}

		if (hairColorEnabled)
			for (size_t i = 0; i < hairSelectSize; i++)
				buttons[Buttons::BtHairSelect0 + i]->set_active(true);
	}

	void UICommonCreation::disable_char_look()
	{
		buttons[Buttons::BtFaceLeft]->set_active(false);
		buttons[Buttons::BtFaceRight]->set_active(false);
		buttons[Buttons::BtHairLeft]->set_active(false);
		buttons[Buttons::BtHairRight]->set_active(false);
		buttons[Buttons::BtSkinLeft]->set_active(false);
		buttons[Buttons::BtSkinRight]->set_active(false);
		buttons[Buttons::BtTopLeft]->set_active(false);
		buttons[Buttons::BtTopRight]->set_active(false);

		if (bottomEnabled)
		{
			buttons[Buttons::BtBottomLeft]->set_active(false);
			buttons[Buttons::BtBottomRight]->set_active(false);
		}

		if (capeEnabled)
		{
			buttons[Buttons::BtCapeLeft]->set_active(false);
			buttons[Buttons::BtCapeRight]->set_active(false);
		}

		buttons[Buttons::BtShoesLeft]->set_active(false);
		buttons[Buttons::BtShoesRight]->set_active(false);
		buttons[Buttons::BtWeaponLeft]->set_active(false);
		buttons[Buttons::BtWeaponRight]->set_active(false);

		for (size_t i = 0; i < hairSelectSize; i++)
			buttons[Buttons::BtHairSelect0 + i]->set_active(false);
	}

	void UICommonCreation::check_names()
	{
		int16_t max_width = getMaxWidth();

		string_format::format_with_ellipsis(skinColorName, max_width, 3, false);
		string_format::format_with_ellipsis(faceName, max_width, 3, false);
		string_format::format_with_ellipsis(hairStyleName, max_width, 3, false);
		string_format::format_with_ellipsis(topName, max_width, 3, false);
		string_format::format_with_ellipsis(bottomName, max_width, 3, false);
		string_format::format_with_ellipsis(capeName, max_width, 3, false);
		string_format::format_with_ellipsis(shoeName, max_width, 3, false);
		string_format::format_with_ellipsis(weaponName, max_width, 3, false);
	}

	const std::string& UICommonCreation::get_equipname(EquipSlot::Id slot) const
	{
		if (int32_t item_id = newCharLook.get_equips().get_equip(slot))
		{
			return ItemData::get(item_id).get_name();
		}
		else
		{
			static const std::string& nullstr = "NULL";

			return nullstr;
		}
	}

	Point<int16_t> UICommonCreation::getGenderTopPos()
	{
		if (className == "adventurer")
			return Point<int16_t>(486, 95);
		else if (className == "aran")
			return Point<int16_t>(491, 168);
		else if (className == "cygnusKnight")
			return Point<int16_t>(423, 104);
		else
			return Point<int16_t>(0, 0);
	}

	Point<int16_t> UICommonCreation::getBoardMidPos()
	{
		if (className == "adventurer")
			return Point<int16_t>(486, 209);
		else if (className == "aran")
			return Point<int16_t>(491, 220);
		else if (className == "cygnusKnight")
			return Point<int16_t>(423, 222);
		else
			return Point<int16_t>(0, 0);
	}

	Point<int16_t> UICommonCreation::getBoardBottomPos()
	{
		if (className == "adventurer")
			return Point<int16_t>(486, 329);
		else if (className == "aran")
			return Point<int16_t>(491, 313);
		else if (className == "cygnusKnight")
			return Point<int16_t>(423, 348);
		else
			return Point<int16_t>(0, 0);
	}

	Point<int16_t> UICommonCreation::getAvatarSelPos(size_t index)
	{
		if (className == "adventurer")
		{
			if (index >= 2)
				index++;

			return Point<int16_t>(497, 197 + index * 18);
		}
		else if (className == "aran")
		{
			return Point<int16_t>(504, 187 + index * 18);
		}
		else if (className == "cygnusKnight")
		{
			int16_t y = 0;

			if (index == 3)
				y = 2;

			return Point<int16_t>(416, 98 + y);
		}
		else
		{
			return Point<int16_t>(0, 0);
		}
	}

	Point<int16_t> UICommonCreation::getGenderSelectMalePos()
	{
		Point<int16_t> genderSelectAdj = Point<int16_t>(-33, -13);

		if (className == "adventurer")
			genderSelectAdj = Point<int16_t>(0, -4);
		else if (className == "aran")
			genderSelectAdj = Point<int16_t>(-33, -13);
		else if (className == "cygnusKnight")
			genderSelectAdj = Point<int16_t>(2, 3);

		return genderOrigin + genderSelectAdj;
	}

	Point<int16_t> UICommonCreation::getGenderSelectFemalePos()
	{
		Point<int16_t> genderSelectMalePos = getGenderSelectMalePos();

		if (className == "adventurer")
			return genderSelectMalePos;
		else
			return genderSelectMalePos - Point<int16_t>(2, 0);
	}

	int16_t UICommonCreation::getCharLookY()
	{
		if (className == "adventurer")
			return 198;
		else if (className == "aran")
			return 187;
		else if (className == "cygnusKnight")
			return 81;
		else
			return 0;
	}

	Point<int16_t> UICommonCreation::getCharLookLeftPos()
	{
		int16_t charLookY = getCharLookY();

		if (className == "adventurer")
			return Point<int16_t>(552, charLookY);
		else if (className == "aran")
			return Point<int16_t>(562, charLookY);
		else if (className == "cygnusKnight")
			return Point<int16_t>(418, charLookY);
		else
			return Point<int16_t>(0, 0);
	}

	Point<int16_t> UICommonCreation::getCharLookRightPos()
	{
		int16_t charLookY = getCharLookY();

		if (className == "adventurer")
			return Point<int16_t>(684, charLookY);
		else if (className == "aran")
			return Point<int16_t>(699, charLookY);
		else if (className == "cygnusKnight")
			return Point<int16_t>(415, charLookY);
		else
			return Point<int16_t>(0, 0);
	}

	Point<int16_t> UICommonCreation::getBtYesPos(uint8_t step)
	{
		if (className == "adventurer")
		{
			switch (step)
			{
				case 0:
					return Point<int16_t>(514, 394);
				case 1:
					return Point<int16_t>(523, 425);
				case 2:
					return Point<int16_t>(513, 273);
			}
		}
		else if (className == "aran")
		{
			switch (step)
			{
				case 0:
					return Point<int16_t>(520, 397);
				case 1:
					return Point<int16_t>(533, 368);
				case 2:
					return Point<int16_t>(523, 243);
			}
		}
		else if (className == "cygnusKnight")
		{
			switch (step)
			{
				case 0:
					return Point<int16_t>(510, 396);
				case 1:
					return Point<int16_t>(502, 381);
				case 2:
					return Point<int16_t>(510, 289);
			}
		}

		return Point<int16_t>(0, 0);
	}

	Point<int16_t> UICommonCreation::getBtNoPos(uint8_t step)
	{
		if (className == "adventurer")
		{
			switch (step)
			{
				case 0:
					return Point<int16_t>(590, 394);
				case 1:
					return Point<int16_t>(597, 425);
				case 2:
					return Point<int16_t>(587, 273);
			}
		}
		else if (className == "aran")
		{
			switch (step)
			{
				case 0:
					return Point<int16_t>(594, 397);
				case 1:
					return Point<int16_t>(607, 368);
				case 2:
					return Point<int16_t>(597, 243);
			}
		}
		else if (className == "cygnusKnight")
		{
			switch (step)
			{
				case 0:
					return Point<int16_t>(615, 396);
				case 1:
					return Point<int16_t>(607, 381);
				case 2:
					return Point<int16_t>(615, 289);
			}
		}

		return Point<int16_t>(0, 0);
	}

	Point<int16_t> UICommonCreation::getHairSelectPos(size_t index)
	{
		if (className == "adventurer")
			return Point<int16_t>(677 + (index * 15), 339);
		else if (className == "cygnusKnight")
			return Point<int16_t>(674 + (index * 15), 349);
		else
			return Point<int16_t>(0, 0);
	}

	Color::Name UICommonCreation::getNewCharNameColor()
	{
		if (className == "aran")
			return Color::Name::WHITE;
		else
			return Color::Name::BLACK;
	}

	Rectangle<int16_t> UICommonCreation::getNewCharNameRect()
	{
		if (className == "adventurer")
		{
			Point<int16_t> pos = Point<int16_t>(514, 198);

			return Rectangle<int16_t>(pos, pos + Point<int16_t>(148, 24));
		}
		else if (className == "aran")
		{
			Point<int16_t> pos = Point<int16_t>(522, 197);

			return Rectangle<int16_t>(pos, pos + Point<int16_t>(146, 25));
		}
		else if (className == "cygnusKnight")
		{
			Point<int16_t> pos = Point<int16_t>(533, 213);

			return Rectangle<int16_t>(pos, pos + Point<int16_t>(147, 19));
		}
		else
		{
			return Rectangle<int16_t>(Point<int16_t>(0, 0), Point<int16_t>(0, 0));
		}
	}

	size_t UICommonCreation::getVerticalCount() const
	{
		if (className == "adventurer" || className == "aran")
			return 4;
		else if (className == "cygnusKnight")
			return 6;
		else
			return 0;
	}

	int16_t UICommonCreation::getVerticalAdj() const
	{
		if (className == "adventurer" || className == "aran")
			return 24;
		else if (className == "cygnusKnight")
			return 18;
		else
			return 0;
	}

	Point<int16_t> UICommonCreation::getNamePos(size_t index) const
	{
		int16_t name_x = 0;
		int16_t name_y = 0;

		if (className == "adventurer")
			name_x = 626;
		else if (className == "aran")
			name_x = 647;
		else if (className == "cygnusKnight")
			name_x = 618;

		if (className == "adventurer")
			name_y = 196;
		else if (className == "aran")
			name_y = 186;
		else if (className == "cygnusKnight")
			name_y = 203;

		return Point<int16_t>(name_x, name_y + index * 18);
	}

	Point<int16_t> UICommonCreation::getNameboardPos() const
	{
		if (className == "adventurer")
			return Point<int16_t>(486, 95);
		else if (className == "aran")
			return Point<int16_t>(489, 106);
		else if (className == "cygnusKnight")
			return Point<int16_t>(423, 104);
		else
			return Point<int16_t>(0, 0);
	}

	Point<int16_t> UICommonCreation::getTextfieldPos() const
	{
		if (className == "adventurer")
			return Point<int16_t>(8, -2);
		else if (className == "aran")
			return Point<int16_t>(3, 0);
		else if (className == "cygnusKnight")
			return Point<int16_t>(6, -3);
		else
			return Point<int16_t>(0, 0);
	}

	int16_t UICommonCreation::getMaxWidth() const
	{
		if (className == "adventurer")
			return 89;
		else if (className == "aran")
			return 94;
		else if (className == "cygnusKnight")
			return 97;
		else
			return 0;
	}
}

================
File: IO/UITypes/UICommonCreation.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../Components/Charset.h"
#include "../Components/Textfield.h"

#include "../../Template/BoolPair.h"

#include "../../Character/Look/CharLook.h"

namespace ms
{
	class UICommonCreation : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::CLASSCREATION;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = false;

		UICommonCreation(const std::string& classType);

		void draw(float inter) const override;
		void update() override;

		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		void send_naming_result(bool nameused);

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

		std::vector<Sprite> sprites_background;
		std::vector<Sprite> sprites_lookboard;

	private:
		void randomize_look();
		void load_char_look();
		void enable_char_look();
		void disable_char_look();
		void check_names();

		const std::string& get_equipname(EquipSlot::Id slot) const;

		Point<int16_t> getGenderTopPos();
		Point<int16_t> getBoardMidPos();
		Point<int16_t> getBoardBottomPos();
		Point<int16_t> getAvatarSelPos(size_t index);
		Point<int16_t> getGenderSelectMalePos();
		Point<int16_t> getGenderSelectFemalePos();
		int16_t getCharLookY();
		Point<int16_t> getCharLookLeftPos();
		Point<int16_t> getCharLookRightPos();
		Point<int16_t> getBtYesPos(uint8_t step);
		Point<int16_t> getBtNoPos(uint8_t step);
		Point<int16_t> getHairSelectPos(size_t index);
		Color::Name getNewCharNameColor();
		Rectangle<int16_t> getNewCharNameRect();
		size_t getVerticalCount() const;
		int16_t getVerticalAdj() const;
		Point<int16_t> getNamePos(size_t index) const;
		Point<int16_t> getNameboardPos() const;
		Point<int16_t> getTextfieldPos() const;
		int16_t getMaxWidth() const;

		enum Buttons : uint16_t
		{
			BtStart,
			BtPreview,
			BtYes,
			BtNo,
			BtSkinLeft,
			BtSkinRight,
			BtFaceLeft,
			BtFaceRight,
			BtHairLeft,
			BtHairRight,
			BtTopLeft,
			BtTopRight,
			BtBottomLeft,
			BtBottomRight,
			BtCapeLeft,
			BtCapeRight,
			BtShoesLeft,
			BtShoesRight,
			BtWeaponLeft,
			BtWeaponRight,
			BtGenderMale,
			BtGenderFemale,
			BtHairSelect0,
			BtHairSelect1,
			BtHairSelect2,
			BtHairSelect3,
			BtHairSelect4,
			BtHairSelect5,
			BtHairSelect6,
			BtHairSelect7,
			LENGTH
		};

		std::map<std::string, std::string> class_map =
		{
			{ "000",	"adventurer"	},
			{ "1000",	"cygnusKnight"	},
			{ "2000",	"aran"			}
		};

		Text version;
		Point<int16_t> version_pos;
		Texture nameboard;
		std::vector<Sprite> sprites_char_look;
		std::vector<Sprite> sprites_gender_select;

		Point<int16_t> avatarOrigin;
		Point<int16_t> charNameOrigin;
		Point<int16_t> genderOrigin;
		Point<int16_t> newAvatarPos;
		int16_t vCanvasCount;
		int16_t genderTopHeight;
		int16_t boardMidHeight;

		nl::node BtYesPos;
		nl::node BtNoPos;

		size_t hairSelectSize;
		Randomizer randomizer;

		bool female;
		bool genderSelected;
		bool charLookSelected;
		bool charNameSelected;
		bool newCharNameDisabled;
		bool choosableGender;
		std::string classType;
		std::string className;

		Charset createLimitNum;
		Point<int16_t> createLimitPos;

		CharLook newCharLook;
		Point<int16_t> newCharNamePos;
		Textfield newCharName;

		size_t faceIndex;
		Text faceName;
		BoolPair<std::vector<int64_t>> faces;

		size_t hairStyleIndex;
		Text hairStyleName;
		BoolPair<std::vector<int64_t>> hairStyles;

		bool hairColorEnabled;
		size_t hairColorIndex;
		BoolPair<std::unordered_map<int64_t, std::vector<int64_t>>> hairColors;

		size_t skinColorIndex;
		Text skinColorName;
		std::vector<int64_t> skinColors;

		size_t topIndex;
		Text topName;
		BoolPair<std::vector<int64_t>> tops;

		bool capeEnabled;
		size_t capeIndex;
		Text capeName;
		BoolPair<std::vector<int64_t>> capes;

		bool bottomEnabled;
		size_t bottomIndex;
		Text bottomName;
		BoolPair<std::vector<int64_t>> bottoms;

		size_t shoeIndex;
		Text shoeName;
		BoolPair<std::vector<int64_t>> shoes;

		size_t weaponIndex;
		Text weaponName;
		BoolPair<std::vector<int64_t>> weapons;
	};
}

================
File: IO/UITypes/UICygnusCreation.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "UICommonCreation.h"

namespace ms
{
	class UICygnusCreation : public UICommonCreation
	{
	public:
		UICygnusCreation() : UICommonCreation("1000") {}
	};
}

================
File: IO/UITypes/UIEquipInventory.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIEquipInventory.h"

#include "../UI.h"

#include "../Components/MapleButton.h"
#include "../UITypes/UIItemInventory.h"

#include "../../Audio/Audio.h"
#include "../../Data/ItemData.h"

#include "../../Net/Packets/InventoryPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIEquipInventory::UIEquipInventory(const Inventory& invent) : UIDragElement<PosEQINV>(), inventory(invent), tab(Buttons::BT_TAB1), hasPendantSlot(false), hasPocketSlot(false)
	{
		// Column 1
		iconpositions[EquipSlot::Id::RING1] = Point<int16_t>(14, 50);
		iconpositions[EquipSlot::Id::RING2] = Point<int16_t>(14, 91);
		iconpositions[EquipSlot::Id::RING3] = Point<int16_t>(14, 132);
		iconpositions[EquipSlot::Id::RING4] = Point<int16_t>(14, 173);
		iconpositions[EquipSlot::Id::POCKET] = Point<int16_t>(14, 214);
		iconpositions[EquipSlot::Id::BOOK] = Point<int16_t>(14, 255);

		// Column 2
		//iconpositions[EquipSlot::Id::NONE] = Point<int16_t>(55, 50);
		iconpositions[EquipSlot::Id::PENDANT2] = Point<int16_t>(55, 91);
		iconpositions[EquipSlot::Id::PENDANT1] = Point<int16_t>(55, 132);
		iconpositions[EquipSlot::Id::WEAPON] = Point<int16_t>(55, 173);
		iconpositions[EquipSlot::Id::BELT] = Point<int16_t>(55, 214);
		//iconpositions[EquipSlot::Id::NONE] = Point<int16_t>(55, 255);

		// Column 3
		iconpositions[EquipSlot::Id::HAT] = Point<int16_t>(96, 50);
		iconpositions[EquipSlot::Id::FACE] = Point<int16_t>(96, 91);
		iconpositions[EquipSlot::Id::EYEACC] = Point<int16_t>(96, 132);
		iconpositions[EquipSlot::Id::TOP] = Point<int16_t>(96, 173);
		iconpositions[EquipSlot::Id::BOTTOM] = Point<int16_t>(96, 214);
		iconpositions[EquipSlot::Id::SHOES] = Point<int16_t>(96, 255);

		// Column 4
		//iconpositions[EquipSlot::Id::NONE] = Point<int16_t>(137, 50);
		//iconpositions[EquipSlot::Id::NONE] = Point<int16_t>(137, 91);
		iconpositions[EquipSlot::Id::EARACC] = Point<int16_t>(137, 132);
		iconpositions[EquipSlot::Id::SHOULDER] = Point<int16_t>(137, 173);
		iconpositions[EquipSlot::Id::GLOVES] = Point<int16_t>(137, 214);
		iconpositions[EquipSlot::Id::ANDROID] = Point<int16_t>(137, 255);

		// Column 5
		iconpositions[EquipSlot::Id::EMBLEM] = Point<int16_t>(178, 50);
		iconpositions[EquipSlot::Id::BADGE] = Point<int16_t>(178, 91);
		iconpositions[EquipSlot::Id::MEDAL] = Point<int16_t>(178, 132);
		iconpositions[EquipSlot::Id::SUBWEAPON] = Point<int16_t>(178, 173);
		iconpositions[EquipSlot::Id::CAPE] = Point<int16_t>(178, 214);
		iconpositions[EquipSlot::Id::HEART] = Point<int16_t>(178, 255);

		//iconpositions[EquipSlot::Id::SHIELD] = Point<int16_t>(142, 124);
		//iconpositions[EquipSlot::Id::TAMEDMOB] = Point<int16_t>(142, 91);
		//iconpositions[EquipSlot::Id::SADDLE] = Point<int16_t>(76, 124);

		tab_source[Buttons::BT_TAB0] = "Equip";
		tab_source[Buttons::BT_TAB1] = "Cash";
		tab_source[Buttons::BT_TAB2] = "Pet";
		tab_source[Buttons::BT_TAB3] = "Android";

		nl::node close = nl::nx::UI["Basic.img"]["BtClose3"];
		nl::node Equip = nl::nx::UI["UIWindow4.img"]["Equip"];

		background[Buttons::BT_TAB0] = Equip[tab_source[Buttons::BT_TAB0]]["backgrnd"];
		background[Buttons::BT_TAB1] = Equip[tab_source[Buttons::BT_TAB1]]["backgrnd"];
		background[Buttons::BT_TAB2] = Equip[tab_source[Buttons::BT_TAB2]]["backgrnd"];
		background[Buttons::BT_TAB3] = Equip[tab_source[Buttons::BT_TAB3]]["backgrnd"];

		for (uint16_t i = Buttons::BT_TAB0; i < Buttons::BT_TABE; i++)
			for (auto slot : Equip[tab_source[i]]["Slots"])
				if (slot.name().find("_") == std::string::npos)
					Slots[i].emplace_back(slot);

		nl::node EquipGL = nl::nx::UI["UIWindowGL.img"]["Equip"];
		nl::node backgrnd = Equip["backgrnd"];
		nl::node totem_backgrnd = EquipGL["Totem"]["backgrnd"];

		Point<int16_t> bg_dimensions = Texture(backgrnd).get_dimensions();
		totem_dimensions = Texture(totem_backgrnd).get_dimensions();
		totem_adj = Point<int16_t>(-totem_dimensions.x() + 4, 0);

		sprites.emplace_back(totem_backgrnd, totem_adj);
		sprites.emplace_back(backgrnd);
		sprites.emplace_back(Equip["backgrnd2"]);

		tabbar = Equip["tabbar"];
		disabled = Equip[tab_source[Buttons::BT_TAB0]]["disabled"];
		disabled2 = Equip[tab_source[Buttons::BT_TAB0]]["disabled2"];

		buttons[Buttons::BT_CLOSE] = std::make_unique<MapleButton>(close, Point<int16_t>(bg_dimensions.x() - 19, 5));
		buttons[Buttons::BT_SLOT] = std::make_unique<MapleButton>(Equip[tab_source[Buttons::BT_TAB0]]["BtSlot"]);
		buttons[Buttons::BT_EFFECT] = std::make_unique<MapleButton>(EquipGL["Equip"]["btEffect"]);
		buttons[Buttons::BT_SALON] = std::make_unique<MapleButton>(EquipGL["Equip"]["btSalon"]);
		buttons[Buttons::BT_CONSUMESETTING] = std::make_unique<MapleButton>(Equip[tab_source[Buttons::BT_TAB2]]["BtConsumeSetting"]);
		buttons[Buttons::BT_EXCEPTION] = std::make_unique<MapleButton>(Equip[tab_source[Buttons::BT_TAB2]]["BtException"]);
		buttons[Buttons::BT_SHOP] = std::make_unique<MapleButton>(Equip[tab_source[Buttons::BT_TAB3]]["BtShop"]);

		buttons[Buttons::BT_CONSUMESETTING]->set_state(Button::State::DISABLED);
		buttons[Buttons::BT_EXCEPTION]->set_state(Button::State::DISABLED);
		buttons[Buttons::BT_SHOP]->set_state(Button::State::DISABLED);

		nl::node Tab = Equip["Tab"];

		for (uint16_t i = Buttons::BT_TAB0; i < Buttons::BT_TABE; i++)
			buttons[Buttons::BT_TAB0 + i] = std::make_unique<TwoSpriteButton>(Tab["disabled"][i], Tab["enabled"][i], Point<int16_t>(0, 3));

		dimension = bg_dimensions;
		dragarea = Point<int16_t>(bg_dimensions.x(), 20);

		load_icons();
		change_tab(Buttons::BT_TAB0);
	}

	void UIEquipInventory::draw(float alpha) const
	{
		UIElement::draw(alpha);

		background[tab].draw(position);
		tabbar.draw(position);

		for (auto slot : Slots[tab])
			slot.draw(position);

		if (tab == Buttons::BT_TAB0)
		{
			if (!hasPendantSlot)
				disabled.draw(position + iconpositions[EquipSlot::Id::PENDANT2]);

			if (!hasPocketSlot)
				disabled.draw(position + iconpositions[EquipSlot::Id::POCKET]);

			for (auto iter : icons)
				if (iter.second)
					iter.second->draw(position + iconpositions[iter.first] + Point<int16_t>(4, 4));
		}
		else if (tab == Buttons::BT_TAB2)
		{
			disabled2.draw(position + Point<int16_t>(113, 57));
			disabled2.draw(position + Point<int16_t>(113, 106));
			disabled2.draw(position + Point<int16_t>(113, 155));
		}
	}

	Button::State UIEquipInventory::button_pressed(uint16_t id)
	{
		switch (id)
		{
		case Buttons::BT_CLOSE:
			toggle_active();
			break;
		case Buttons::BT_TAB0:
		case Buttons::BT_TAB1:
		case Buttons::BT_TAB2:
		case Buttons::BT_TAB3:
			change_tab(id);

			return Button::State::IDENTITY;
		default:
			break;
		}

		return Button::State::NORMAL;
	}

	void UIEquipInventory::update_slot(EquipSlot::Id slot)
	{
		if (int32_t item_id = inventory.get_item_id(InventoryType::Id::EQUIPPED, slot))
		{
			const Texture& texture = ItemData::get(item_id).get_icon(false);

			icons[slot] = std::make_unique<Icon>(
				std::make_unique<EquipIcon>(slot),
				texture,
				-1
				);
		}
		else if (icons[slot])
		{
			icons[slot].release();
		}

		clear_tooltip();
	}

	void UIEquipInventory::load_icons()
	{
		icons.clear();

		for (auto iter : EquipSlot::values)
			update_slot(iter);
	}

	Cursor::State UIEquipInventory::send_cursor(bool pressed, Point<int16_t> cursorpos)
	{
		Cursor::State dstate = UIDragElement::send_cursor(pressed, cursorpos);

		if (dragged)
		{
			clear_tooltip();

			return dstate;
		}

		EquipSlot::Id slot = slot_by_position(cursorpos);

		if (auto icon = icons[slot].get())
		{
			if (pressed)
			{
				icon->start_drag(cursorpos - position - iconpositions[slot]);

				UI::get().drag_icon(icon);

				clear_tooltip();

				return Cursor::State::GRABBING;
			}
			else
			{
				show_equip(slot);

				return Cursor::State::CANGRAB;
			}
		}
		else
		{
			clear_tooltip();

			return Cursor::State::IDLE;
		}
	}

	void UIEquipInventory::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
			{
				toggle_active();
			}
			else if (keycode == KeyAction::Id::TAB)
			{
				uint16_t newtab = tab + 1;

				if (newtab >= Buttons::BT_TABE)
					newtab = Buttons::BT_TAB0;

				change_tab(newtab);
			}
		}
	}

	UIElement::Type UIEquipInventory::get_type() const
	{
		return TYPE;
	}

	void UIEquipInventory::doubleclick(Point<int16_t> cursorpos)
	{
		EquipSlot::Id slot = slot_by_position(cursorpos);

		if (icons[slot])
			if (int16_t freeslot = inventory.find_free_slot(InventoryType::Id::EQUIP))
				UnequipItemPacket(slot, freeslot).dispatch();
	}

	bool UIEquipInventory::is_in_range(Point<int16_t> cursorpos) const
	{
		Rectangle<int16_t> bounds = Rectangle<int16_t>(position, position + dimension);

		Rectangle<int16_t> totem_bounds = Rectangle<int16_t>(position, position + totem_dimensions);
		totem_bounds.shift(totem_adj);

		return bounds.contains(cursorpos) || totem_bounds.contains(cursorpos);
	}

	bool UIEquipInventory::send_icon(const Icon& icon, Point<int16_t> cursorpos)
	{
		if (EquipSlot::Id slot = slot_by_position(cursorpos))
			icon.drop_on_equips(slot);

		return true;
	}

	void UIEquipInventory::toggle_active()
	{
		clear_tooltip();

		UIElement::toggle_active();
	}

	void UIEquipInventory::modify(int16_t pos, int8_t mode, int16_t arg)
	{
		EquipSlot::Id eqpos = EquipSlot::by_id(pos);
		EquipSlot::Id eqarg = EquipSlot::by_id(arg);

		switch (mode)
		{
		case 0:
		case 3:
			update_slot(eqpos);
			break;
		case 2:
			update_slot(eqpos);
			update_slot(eqarg);
			break;
		}
	}

	void UIEquipInventory::show_equip(EquipSlot::Id slot)
	{
		UI::get().show_equip(Tooltip::Parent::EQUIPINVENTORY, slot);
	}

	void UIEquipInventory::clear_tooltip()
	{
		UI::get().clear_tooltip(Tooltip::Parent::EQUIPINVENTORY);
	}

	EquipSlot::Id UIEquipInventory::slot_by_position(Point<int16_t> cursorpos) const
	{
		if (tab != Buttons::BT_TAB0)
			return EquipSlot::Id::NONE;

		for (auto iter : iconpositions)
		{
			Rectangle<int16_t> iconrect = Rectangle<int16_t>(
				position + iter.second,
				position + iter.second + Point<int16_t>(32, 32)
				);

			if (iconrect.contains(cursorpos))
				return iter.first;
		}

		return EquipSlot::Id::NONE;
	}

	void UIEquipInventory::change_tab(uint16_t tabid)
	{
		uint8_t oldtab = tab;
		tab = tabid;

		if (oldtab != tab)
		{
			clear_tooltip();

			buttons[oldtab]->set_state(Button::State::NORMAL);
			buttons[tab]->set_state(Button::State::PRESSED);

			if (tab == Buttons::BT_TAB0)
				buttons[Buttons::BT_SLOT]->set_active(true);
			else
				buttons[Buttons::BT_SLOT]->set_active(false);

			if (tab == Buttons::BT_TAB2)
			{
				buttons[Buttons::BT_CONSUMESETTING]->set_active(true);
				buttons[Buttons::BT_EXCEPTION]->set_active(true);
			}
			else
			{
				buttons[Buttons::BT_CONSUMESETTING]->set_active(false);
				buttons[Buttons::BT_EXCEPTION]->set_active(false);
			}

			if (tab == Buttons::BT_TAB3)
				buttons[Buttons::BT_SHOP]->set_active(true);
			else
				buttons[Buttons::BT_SHOP]->set_active(false);
		}
	}

	UIEquipInventory::EquipIcon::EquipIcon(int16_t s)
	{
		source = s;
	}

	void UIEquipInventory::EquipIcon::drop_on_stage() const
	{
		Sound(Sound::Name::DRAGEND).play();
	}

	void UIEquipInventory::EquipIcon::drop_on_equips(EquipSlot::Id slot) const
	{
		if (source == slot)
			Sound(Sound::Name::DRAGEND).play();
	}

	bool UIEquipInventory::EquipIcon::drop_on_items(InventoryType::Id tab, EquipSlot::Id eqslot, int16_t slot, bool equip) const
	{
		if (tab != InventoryType::Id::EQUIP)
		{
			if (auto iteminventory = UI::get().get_element<UIItemInventory>())
			{
				if (iteminventory->is_active())
				{
					iteminventory->change_tab(InventoryType::Id::EQUIP);
					return false;
				}
			}
		}

		if (equip)
		{
			if (eqslot == source)
				EquipItemPacket(slot, eqslot).dispatch();
		}
		else
		{
			UnequipItemPacket(source, slot).dispatch();
		}

		return true;
	}

	Icon::IconType UIEquipInventory::EquipIcon::get_type()
	{
		return Icon::IconType::EQUIP;
	}
}

================
File: IO/UITypes/UIEquipInventory.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

namespace ms
{
	// The Equip inventory
	class UIEquipInventory : public UIDragElement<PosEQINV>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::EQUIPINVENTORY;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIEquipInventory(const Inventory& inventory);

		void draw(float inter) const override;

		void toggle_active() override;
		bool send_icon(const Icon& icon, Point<int16_t> position) override;

		void doubleclick(Point<int16_t> position) override;
		bool is_in_range(Point<int16_t> cursorpos) const override;
		Cursor::State send_cursor(bool pressed, Point<int16_t> position) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		void modify(int16_t pos, int8_t mode, int16_t arg);

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void show_equip(EquipSlot::Id slot);
		void clear_tooltip();
		void load_icons();
		void update_slot(EquipSlot::Id slot);
		EquipSlot::Id slot_by_position(Point<int16_t> position) const;
		void change_tab(uint16_t tabid);

		class EquipIcon : public Icon::Type
		{
		public:
			EquipIcon(int16_t source);

			void drop_on_stage() const override;
			void drop_on_equips(EquipSlot::Id slot) const override;
			bool drop_on_items(InventoryType::Id tab, EquipSlot::Id eqslot, int16_t slot, bool equip) const override;
			void drop_on_bindings(Point<int16_t>, bool) const override {}
			void set_count(int16_t) override {}
			Icon::IconType get_type() override;

		private:
			int16_t source;
		};

		enum Buttons : uint16_t
		{
			BT_TAB0,
			BT_TAB1,
			BT_TAB2,
			BT_TAB3,
			BT_TABE,
			BT_CLOSE,
			BT_SLOT,
			BT_EFFECT,
			BT_SALON,
			BT_CONSUMESETTING,
			BT_EXCEPTION,
			BT_SHOP
		};

		const Inventory& inventory;

		EnumMap<EquipSlot::Id, Point<int16_t>> iconpositions;
		EnumMap<EquipSlot::Id, std::unique_ptr<Icon>> icons;

		uint16_t tab;
		std::string tab_source[Buttons::BT_TABE];
		Texture tabbar;
		Texture background[Buttons::BT_TABE];
		Texture disabled;
		Texture disabled2;
		std::vector<Texture> Slots[Buttons::BT_TABE];

		Point<int16_t> totem_dimensions;
		Point<int16_t> totem_adj;

		bool hasPendantSlot;
		bool hasPocketSlot;
	};
}

================
File: IO/UITypes/UIEvent.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIEvent.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#include "../../Data/ItemData.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIEvent::UIEvent() : UIDragElement<PosEVENT>()
	{
		offset = 0;
		event_count = 16;

		nl::node main = nl::nx::UI["UIWindow2.img"]["EventList"]["main"];
		nl::node close = nl::nx::UI["Basic.img"]["BtClose3"];

		nl::node backgrnd = main["backgrnd"];
		Point<int16_t> bg_dimensions = Texture(backgrnd).get_dimensions();

		sprites.emplace_back(backgrnd);
		sprites.emplace_back(main["backgrnd2"], Point<int16_t>(1, 0));

		buttons[Buttons::CLOSE] = std::make_unique<MapleButton>(close, Point<int16_t>(bg_dimensions.x() - 19, 6));

		bool in_progress = false;
		bool item_rewards = false;

		for (size_t i = 0; i < 5; i++)
			events.emplace_back(BoolPair<bool>(true, true));

		for (size_t i = 0; i < 10; i++)
			events.emplace_back(BoolPair<bool>(false, true));

		events.emplace_back(BoolPair<bool>(false, false));

		for (size_t i = 0; i < 3; i++)
			event_title[i] = ShadowText(Text::Font::A18M, Text::Alignment::LEFT, Color::Name::HALFANDHALF, Color::Name::ENDEAVOUR);

		for (size_t i = 0; i < 3; i++)
			event_date[i] = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::WHITE);

		item_reward = main["event"]["normal"];
		text_reward = main["liveEvent"]["normal"];
		next = main["liveEvent"]["next"];
		label_on = main["label_on"]["0"];
		label_next = main["label_next"]["0"];

		slider = Slider(
			Slider::Type::DEFAULT_SILVER, Range<int16_t>(86, 449), 396, 3, event_count,
			[&](bool upwards)
			{
				int16_t shift = upwards ? -1 : 1;
				bool above = offset + shift >= 0;
				bool below = offset + shift <= event_count - 3;

				if (above && below)
					offset += shift;
			}
		);

		dimension = bg_dimensions;
		dragarea = Point<int16_t>(dimension.x(), 20);
	}

	void UIEvent::draw(float inter) const
	{
		UIElement::draw(inter);

		slider.draw(position);

		for (size_t i = 0; i < 3; i++)
		{
			int16_t slot = i + offset;

			if (slot >= event_count)
				break;

			Point<int16_t> event_pos = Point<int16_t>(12, 87 + 125 * i);

			BoolPair<bool> evnt = events[slot];
			bool in_progress = evnt[1];
			bool itm_reward = evnt[0];

			if (itm_reward)
			{
				item_reward.draw(position + event_pos);

				int16_t x_adj = 0;

				for (size_t f = 0; f < 5; f++)
				{
					const ItemData& item_data = ItemData::get(2000000 + f);
					Texture icon = item_data.get_icon(true);

					if (f == 2)
						x_adj = 2;
					else if (f == 3)
						x_adj = 6;
					else if (f == 4)
						x_adj = 9;

					icon.draw(position + Point<int16_t>(33 + x_adj + 46 * f, 191 + 125 * i));
				}
			}
			else
			{
				text_reward.draw(position + event_pos);

				if (!in_progress)
					next.draw(position + event_pos);
			}

			if (in_progress)
				label_on.draw(position + event_pos);
			else
				label_next.draw(position + event_pos);

			auto title_pos = Point<int16_t>(28, 95 + 125 * i);
			auto date_pos = Point<int16_t>(28, 123 + 125 * i);

			event_title[i].draw(position + title_pos);
			event_date[i].draw(position + date_pos);
		}
	}

	void UIEvent::update()
	{
		UIElement::update();

		for (size_t i = 0; i < 3; i++)
		{
			int16_t slot = i + offset;

			if (slot >= event_count)
				break;

			std::string title = get_event_title(slot);

			if (title.length() > 35)
				title = title.substr(0, 35) + "..";

			event_title[i].change_text(title);
			event_date[i].change_text(get_event_date(slot));
		}
	}

	void UIEvent::remove_cursor()
	{
		UIDragElement::remove_cursor();

		UI::get().clear_tooltip(Tooltip::Parent::EVENT);

		slider.remove_cursor();
	}

	Cursor::State UIEvent::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		Point<int16_t> cursoroffset = cursorpos - position;

		if (slider.isenabled())
			if (Cursor::State new_state = slider.send_cursor(cursoroffset, clicked))
				return new_state;

		int16_t yoff = cursoroffset.y();
		int16_t xoff = cursoroffset.x();
		int16_t row = row_by_position(yoff);
		int16_t col = col_by_position(xoff);

		if (row > 0 && row < 4 && col > 0 && col < 6)
			show_item(row, col);

		return UIDragElement::send_cursor(clicked, cursorpos);
	}

	void UIEvent::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed && escape)
			close();
	}

	UIElement::Type UIEvent::get_type() const
	{
		return TYPE;
	}

	Button::State UIEvent::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			case Buttons::CLOSE:
				close();
			default:
				break;
		}

		return Button::State::NORMAL;
	}

	void UIEvent::close()
	{
		deactivate();
	}

	std::string UIEvent::get_event_title(uint8_t id)
	{
		switch (id)
		{
			case 0:
				return "LINE FRIENDS";
			case 1:
				return "LINE FRIENDS Coin Shop";
			case 2:
				return "[14th Street] Big Bang Store";
			case 3:
				return "[14th Street] Override Fashion Marketing";
			case 4:
				return "[14th Street] Dance Battle V";
			case 5:
				return "MapleStory 14th Anniversary Appre..";
			case 6:
				return "[14th Street] Big Bang Store Season..";
			case 7:
				return "[14th Street] Maplelin Star Grub!";
			case 8:
				return "[14th Street] Sub-Zero Hunt";
			case 9:
				return "[14th Street] The Legends Return!";
			case 10:
				return "[14th Street] Renegade Personal Training";
			case 11:
				return "[14th Street] Round-We-Go Cafe Rising Heroes!";
			case 12:
				return "[14th Street] Big Bang Attack!";
			case 13:
				return "[14th Street] Spiegelmann's Art Retrieval";
			case 14:
				return "[14th Street] 14th Street Sky";
			case 15:
				return "[Sunny Sunday] Perks Abound!";
			default:
				return "";
		}
	}

	std::string UIEvent::get_event_date(uint8_t id)
	{
		switch (id)
		{
			case 0:
			case 1:
			case 2:
				return "04/24/2019 - 05/21/2019, 23:59";
			case 3:
				return "04/24/2019 - 05/07/2019, 23:59";
			case 4:
				return "04/24/2019 - 06/11/2019, 23:59";
			case 5:
				return "05/11/2019 - 05/11/2019, 23:59";
			case 6:
			case 10:
			case 11:
			case 12:
				return "05/22/2019 - 06/11/2019, 23:59";
			case 7:
			case 8:
				return "05/08/2019 - 05/21/2019, 23:59";
			case 9:
				return "05/08/2019 - 06/11/2019, 23:59";
			case 13:
			case 14:
				return "05/29/2019 - 06/11/2019, 23:59";
			case 15:
				return "05/05/2019 - 05/05/2019, 23:59";
			default:
				return "";
		}
	}

	int16_t UIEvent::row_by_position(int16_t y)
	{
		int16_t item_height = 43;

		if (y >= 148 && y <= 148 + item_height)
			return 1;
		else if (y >= 273 && y <= 273 + item_height)
			return 2;
		else if (y >= 398 && y <= 398 + item_height)
			return 3;
		else
			return -1;
	}

	int16_t UIEvent::col_by_position(int16_t x)
	{
		int16_t item_width = 43;

		if (x >= 25 && x <= 25 + item_width)
			return 1;
		else if (x >= 71 && x <= 71 + item_width)
			return 2;
		else if (x >= 117 && x <= 117 + item_width)
			return 3;
		else if (x >= 163 && x <= 163 + item_width)
			return 4;
		else if (x >= 209 && x <= 209 + item_width)
			return 5;
		else
			return -1;
	}

	void UIEvent::show_item(int16_t row, int16_t col)
	{
		UI::get().show_item(Tooltip::Parent::EVENT, 2000000 + col - 1);
	}
}

================
File: IO/UITypes/UIEvent.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../Components/Slider.h"

#include "../../Graphics/SpecialText.h"

namespace ms
{
	class UIEvent : public UIDragElement<PosEVENT>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::EVENT;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIEvent();

		void draw(float inter) const override;
		void update() override;

		void remove_cursor() override;
		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void close();
		std::string get_event_title(uint8_t id);
		std::string get_event_date(uint8_t id);
		int16_t row_by_position(int16_t y);
		int16_t col_by_position(int16_t x);
		void show_item(int16_t row, int16_t col);

		enum Buttons : uint16_t
		{
			CLOSE
		};

		int16_t offset;
		int16_t event_count;
		ShadowText event_title[3];
		Text event_date[3];
		Slider slider;
		Texture item_reward;
		Texture text_reward;
		Texture next;
		Texture label_on;
		Texture label_next;
		std::vector<BoolPair<bool>> events;
	};
}

================
File: IO/UITypes/UIExplorerCreation.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "UICommonCreation.h"

namespace ms
{
	class UIExplorerCreation : public UICommonCreation
	{
	public:
		UIExplorerCreation() : UICommonCreation("000") {}
	};
}

================
File: IO/UITypes/UIGender.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIGender.h"

#include "../UI.h"

#include "../Components/MapleButton.h"
#include "../Components/MapleComboBox.h"
#include "../UITypes/UILoginWait.h"

#include "../../Net/Packets/LoginPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIGender::UIGender(std::function<void()> oh) : UIElement(Point<int16_t>(0, 15), Point<int16_t>(0, 0)), okhandler(oh)
	{
		CUR_TIMESTEP = 0;

		nl::node Gender = nl::nx::UI["Login.img"]["Gender"];

		for (size_t i = 0; i < 3; i++)
			gender_sprites[i] = Gender["scroll"]["0"][i];

		sprites.emplace_back(Gender["text"]["0"], Point<int16_t>(601, 326));

		std::vector<std::string> options;
		options.push_back("Male");
		options.push_back("Female");

		uint16_t default_option = 0;

		buttons[Buttons::NO] = std::make_unique<MapleButton>(Gender["BtNo"], Point<int16_t>(650, 349));
		buttons[Buttons::YES] = std::make_unique<MapleButton>(Gender["BtYes"], Point<int16_t>(578, 349));
		buttons[Buttons::SELECT] = std::make_unique<MapleComboBox>(MapleComboBox::Type::DEFAULT, options, default_option, position, Point<int16_t>(510, 283), 65);

		dimension = Texture(gender_sprites[2]).get_dimensions();
	}

	void UIGender::draw(float inter) const
	{
		Point<int16_t> gender_pos = Point<int16_t>(355, 185);

		if (CUR_TIMESTEP == 0)
		{
			gender_sprites[0].draw(position + gender_pos);
		}
		else if (CUR_TIMESTEP == Constants::TIMESTEP * 3)
		{
			gender_sprites[1].draw(position + gender_pos);
		}
		else if (CUR_TIMESTEP >= Constants::TIMESTEP * 6)
		{
			gender_sprites[2].draw(position + gender_pos);

			UIElement::draw(inter);
		}
	}

	void UIGender::update()
	{
		UIElement::update();

		if (CUR_TIMESTEP <= Constants::TIMESTEP * 6)
			CUR_TIMESTEP += Constants::TIMESTEP;
	}

	Cursor::State UIGender::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		auto& combobox = buttons[Buttons::SELECT];

		if (combobox->is_pressed() && combobox->in_combobox(cursorpos))
			if (Cursor::State new_state = combobox->send_cursor(clicked, cursorpos))
				return new_state;

		return UIElement::send_cursor(clicked, cursorpos);
	}

	UIElement::Type UIGender::get_type() const
	{
		return TYPE;
	}

	Button::State UIGender::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			case Buttons::NO:
			{
				deactivate();
				okhandler();

				return Button::State::NORMAL;
			}
			case Buttons::YES:
			{
				UI::get().emplace<UILoginWait>();

				uint16_t selected_value = buttons[Buttons::SELECT]->get_selected();
				GenderPacket(selected_value).dispatch();

				return Button::State::NORMAL;
			}
			case Buttons::SELECT:
			{
				buttons[Buttons::SELECT]->toggle_pressed();

				return Button::State::NORMAL;
			}
			default:
			{
				return Button::State::DISABLED;
			}
		}
	}
}

================
File: IO/UITypes/UIGender.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

namespace ms
{
	class UIGender : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::GENDER;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = false;

		UIGender(std::function<void()> okhandler);

		void draw(float inter) const override;
		void update() override;

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		enum Buttons : uint16_t
		{
			NO,
			YES,
			SELECT
		};

		Texture gender_sprites[3];
		uint16_t CUR_TIMESTEP;
		std::function<void()> okhandler;
	};
}

================
File: IO/UITypes/UIItemInventory.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIItemInventory.h"

#include "UINotice.h"

#include "../UI.h"

#include "../Components/MapleButton.h"
#include "../UITypes/UIKeyConfig.h"

#include "../../Data/EquipData.h"
#include "../../Gameplay/Stage.h"

#include "../../Net/Packets/InventoryPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIItemInventory::UIItemInventory(const Inventory& invent) : UIDragElement<PosINV>(), inventory(invent), ignore_tooltip(false), tab(InventoryType::Id::EQUIP), sort_enabled(true)
	{
		nl::node Item = nl::nx::UI["UIWindow2.img"]["Item"];
		nl::node pos = Item["pos"];

		slot_col = pos["slot_col"];
		slot_pos = pos["slot_pos"];
		slot_row = pos["slot_row"];
		slot_space_x = pos["slot_space_x"];
		slot_space_y = pos["slot_space_y"];

		max_slots = slot_row * slot_col;
		max_full_slots = slot_col * max_slots;

		nl::node AutoBuild = Item["AutoBuild"];
		nl::node FullAutoBuild = Item["FullAutoBuild"];

		backgrnd = Item["productionBackgrnd"];
		backgrnd2 = Item["productionBackgrnd2"];
		backgrnd3 = Item["productionBackgrnd3"];

		full_backgrnd = Item["FullBackgrnd"];
		full_backgrnd2 = Item["FullBackgrnd2"];
		full_backgrnd3 = Item["FullBackgrnd3"];

		bg_dimensions = backgrnd.get_dimensions();
		bg_full_dimensions = full_backgrnd.get_dimensions();

		nl::node New = Item["New"];
		newitemslot = New["inventory"];
		newitemtabdis = New["Tab0"];
		newitemtaben = New["Tab1"];

		projectile = Item["activeIcon"];
		disabled = Item["disabled"];

		Point<int16_t> icon_dimensions = disabled.get_dimensions();
		icon_width = icon_dimensions.x();
		icon_height = icon_dimensions.y();

		nl::node Tab = Item["Tab"];
		nl::node taben = Tab["enabled"];
		nl::node tabdis = Tab["disabled"];

		Point<int16_t> tab_pos0 = Texture(taben["0"]).get_origin() * -1;
		Point<int16_t> tab_pos1 = Texture(taben["1"]).get_origin() * -1;
		Point<int16_t> tab_pos2 = Texture(taben["2"]).get_origin() * -1;
		Point<int16_t> tab_pos3 = Texture(taben["3"]).get_origin() * -1;
		Point<int16_t> tab_pos4 = Texture(taben["4"]).get_origin() * -1;
		Point<int16_t> tab_pos5 = Texture(taben["5"]).get_origin() * -1;
		Point<int16_t> tab_pos_adj = Point<int16_t>(9, 26);

		nl::node close = nl::nx::UI["Basic.img"]["BtClose3"];
		buttons[Buttons::BT_CLOSE] = std::make_unique<MapleButton>(close);

		buttons[Buttons::BT_TAB_EQUIP] = std::make_unique<TwoSpriteButton>(tabdis["0"], taben["0"], tab_pos0 - tab_pos_adj, Point<int16_t>(0, 0));
		buttons[Buttons::BT_TAB_USE] = std::make_unique<TwoSpriteButton>(tabdis["1"], taben["1"], tab_pos1 - tab_pos_adj, Point<int16_t>(0, 0));
		buttons[Buttons::BT_TAB_ETC] = std::make_unique<TwoSpriteButton>(tabdis["2"], taben["2"], tab_pos2 - tab_pos_adj, Point<int16_t>(0, 0));
		buttons[Buttons::BT_TAB_SETUP] = std::make_unique<TwoSpriteButton>(tabdis["3"], taben["3"], tab_pos3 - tab_pos_adj, Point<int16_t>(0, 0));
		buttons[Buttons::BT_TAB_CASH] = std::make_unique<TwoSpriteButton>(tabdis["4"], taben["4"], tab_pos4 - tab_pos_adj, Point<int16_t>(0, 0));
		buttons[Buttons::BT_TAB_DEC] = std::make_unique<TwoSpriteButton>(tabdis["5"], taben["5"], tab_pos5 - tab_pos_adj, Point<int16_t>(0, 0));

		buttons[Buttons::BT_COIN] = std::make_unique<MapleButton>(AutoBuild["button:Coin"]);
		buttons[Buttons::BT_POINT] = std::make_unique<MapleButton>(AutoBuild["button:Point"]);
		buttons[Buttons::BT_GATHER] = std::make_unique<MapleButton>(AutoBuild["button:Gather"]);
		buttons[Buttons::BT_SORT] = std::make_unique<MapleButton>(AutoBuild["button:Sort"]);
		buttons[Buttons::BT_FULL] = std::make_unique<MapleButton>(AutoBuild["button:Full"]);
		buttons[Buttons::BT_UPGRADE] = std::make_unique<MapleButton>(AutoBuild["button:Upgrade"]);
		buttons[Buttons::BT_APPRAISE] = std::make_unique<MapleButton>(AutoBuild["button:Appraise"]);
		buttons[Buttons::BT_EXTRACT] = std::make_unique<MapleButton>(AutoBuild["button:Extract"]);
		buttons[Buttons::BT_DISASSEMBLE] = std::make_unique<MapleButton>(AutoBuild["button:Disassemble"]);
		buttons[Buttons::BT_TOAD] = std::make_unique<MapleButton>(AutoBuild["anibutton:Toad"]);

		buttons[Buttons::BT_SMALL] = std::make_unique<MapleButton>(FullAutoBuild["button:Small"]);
		buttons[Buttons::BT_COIN_SM] = std::make_unique<MapleButton>(FullAutoBuild["button:Coin"]);
		buttons[Buttons::BT_POINT_SM] = std::make_unique<MapleButton>(FullAutoBuild["button:Point"]);
		buttons[Buttons::BT_GATHER_SM] = std::make_unique<MapleButton>(FullAutoBuild["button:Gather"]);
		buttons[Buttons::BT_SORT_SM] = std::make_unique<MapleButton>(FullAutoBuild["button:Sort"]);
		buttons[Buttons::BT_UPGRADE_SM] = std::make_unique<MapleButton>(FullAutoBuild["button:Upgrade"]);
		buttons[Buttons::BT_APPRAISE_SM] = std::make_unique<MapleButton>(FullAutoBuild["button:Appraise"]);
		buttons[Buttons::BT_EXTRACT_SM] = std::make_unique<MapleButton>(FullAutoBuild["button:Extract"]);
		buttons[Buttons::BT_DISASSEMBLE_SM] = std::make_unique<MapleButton>(FullAutoBuild["button:Disassemble"]);
		buttons[Buttons::BT_TOAD_SM] = std::make_unique<MapleButton>(FullAutoBuild["anibutton:Toad"]);
		buttons[Buttons::BT_CASHSHOP] = std::make_unique<MapleButton>(FullAutoBuild["button:Cashshop"]);

		buttons[Buttons::BT_EXTRACT]->set_state(Button::State::DISABLED);
		buttons[Buttons::BT_EXTRACT_SM]->set_state(Button::State::DISABLED);
		buttons[Buttons::BT_DISASSEMBLE]->set_state(Button::State::DISABLED);
		buttons[Buttons::BT_DISASSEMBLE_SM]->set_state(Button::State::DISABLED);
		buttons[button_by_tab(tab)]->set_state(Button::State::PRESSED);

		mesolabel = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::BLACK);
		maplepointslabel = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::BLACK);
		maplepointslabel.change_text("0"); // TODO: Implement

		for (size_t i = 0; i < InventoryType::Id::LENGTH; i++)
		{
			InventoryType::Id id = InventoryType::by_value(i);
			slotrange[id] = std::pair<int16_t, int16_t>(1, 24);
		}

		int16_t second = (icon_height + slot_space_y) * inventory.get_slotmax(tab) / slot_col + 24;
		int16_t x = slot_col * (icon_width + slot_space_x) + 4;
		int16_t unitrows = slot_row - 2;
		int16_t rowmax = inventory.get_slotmax(tab) / slot_col;

		slider = Slider(
			Slider::Type::DEFAULT_SILVER, Range<int16_t>(slot_pos.y(), second), x, unitrows, rowmax,
			[&](bool upwards)
			{
				int16_t shift = upwards ? -slot_col : slot_col;

				slotrange[tab].first += shift;
				slotrange[tab].second += shift;
			}
		);

#if LOG_LEVEL >= LOG_UI
		for (size_t i = 0; i < max_full_slots; i++)
			slot_labels[i] = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::BLACK, std::to_string(i + 1));
#endif

		set_full(false);
		clear_new();
		load_icons();
	}

	void UIItemInventory::draw(float alpha) const
	{
		UIElement::draw_sprites(alpha);

		Point<int16_t> mesolabel_pos = position + Point<int16_t>(144, 305);
		Point<int16_t> maplepointslabel_pos = position + Point<int16_t>(179, 323);

		if (full_enabled)
		{
			full_backgrnd.draw(position);
			full_backgrnd2.draw(position);
			full_backgrnd3.draw(position);

			mesolabel.draw(mesolabel_pos + Point<int16_t>(0, 84));
			maplepointslabel.draw(maplepointslabel_pos + Point<int16_t>(220, 66));
		}
		else
		{
			backgrnd.draw(position);
			backgrnd2.draw(position);
			backgrnd3.draw(position);

			slider.draw(position + Point<int16_t>(0, 1));

			mesolabel.draw(mesolabel_pos);
			maplepointslabel.draw(maplepointslabel_pos);
		}

		auto& range = slotrange.at(tab);

		size_t numslots = inventory.get_slotmax(tab);
		size_t firstslot = full_enabled ? 1 : range.first;
		size_t lastslot = full_enabled ? max_full_slots : range.second;

		for (size_t i = 0; i <= max_full_slots; i++)
		{
			Point<int16_t> slotpos = get_slotpos(i);

			if (icons.find(i) != icons.end())
			{
				auto& icon = icons.at(i);

				if (icon && i >= firstslot && i <= lastslot)
					icon->draw(position + slotpos);
			}
			else
			{
				if (i > numslots && i <= lastslot)
					disabled.draw(position + slotpos);
			}

#if LOG_LEVEL >= LOG_UI
			if (i <= lastslot && i < max_full_slots)
				slot_labels[i].draw(position + get_slotpos(i + 1) - Point<int16_t>(0, 5));
#endif
		}

		int16_t bulletslot = inventory.get_bulletslot();

		if (tab == InventoryType::Id::USE && is_visible(bulletslot))
			projectile.draw(position + get_slotpos(bulletslot));

		UIElement::draw_buttons(alpha);

		if (newtab != InventoryType::Id::NONE)
		{
			if (newtab == tab)
			{
				newitemtaben.draw(position + get_tabpos(newtab) - Point<int16_t>(2, 3), alpha);

				if (is_visible(newslot))
					newitemslot.draw(position + get_slotpos(newslot) + Point<int16_t>(1, 1), alpha);
			}
			else
			{
				newitemtabdis.draw(position + get_tabpos(newtab) - Point<int16_t>(2, 1), alpha);
			}
		}
	}

	void UIItemInventory::update()
	{
		UIElement::update();

		newitemtaben.update(6);
		newitemtabdis.update(6);
		newitemslot.update(6);

		std::string meso_str = std::to_string(inventory.get_meso());
		string_format::split_number(meso_str);

		mesolabel.change_text(meso_str);
	}

	void UIItemInventory::update_slot(int16_t slot)
	{
		if (int32_t item_id = inventory.get_item_id(tab, slot))
		{
			int16_t count;

			if (tab == InventoryType::Id::EQUIP)
				count = -1;
			else
				count = inventory.get_item_count(tab, slot);

			const bool untradable = ItemData::get(item_id).is_untradable();
			const bool cashitem = ItemData::get(item_id).is_cashitem();
			const Texture& texture = ItemData::get(item_id).get_icon(false);
			EquipSlot::Id eqslot = inventory.find_equipslot(item_id);

			icons[slot] = std::make_unique<Icon>(
				std::make_unique<ItemIcon>(*this, tab, eqslot, slot, item_id, count, untradable, cashitem),
				texture, count
			);
		}
		else if (icons.count(slot))
		{
			icons.erase(slot);
		}
	}

	void UIItemInventory::load_icons()
	{
		icons.clear();

		uint8_t numslots = inventory.get_slotmax(tab);

		for (size_t i = 0; i <= max_full_slots; i++)
			if (i <= numslots)
				update_slot(i);
	}

	Button::State UIItemInventory::button_pressed(uint16_t buttonid)
	{
		InventoryType::Id oldtab = tab;

		switch (buttonid)
		{
			case Buttons::BT_CLOSE:
			{
				toggle_active();

				return Button::State::NORMAL;
			}
			case Buttons::BT_TAB_EQUIP:
			{
				tab = InventoryType::Id::EQUIP;
				break;
			}
			case Buttons::BT_TAB_USE:
			{
				tab = InventoryType::Id::USE;
				break;
			}
			case Buttons::BT_TAB_SETUP:
			{
				tab = InventoryType::Id::SETUP;
				break;
			}
			case Buttons::BT_TAB_ETC:
			{
				tab = InventoryType::Id::ETC;
				break;
			}
			case Buttons::BT_TAB_CASH:
			{
				tab = InventoryType::Id::CASH;
				break;
			}
			case Buttons::BT_TAB_DEC:
			{
				tab = InventoryType::Id::DEC;
				break;
			}
			case Buttons::BT_GATHER:
			case Buttons::BT_GATHER_SM:
			{
				GatherItemsPacket(tab).dispatch();
				break;
			}
			case Buttons::BT_SORT:
			case Buttons::BT_SORT_SM:
			{
				SortItemsPacket(tab).dispatch();
				break;
			}
			case Buttons::BT_FULL:
			{
				set_full(true);

				return Button::State::NORMAL;
			}
			case Buttons::BT_SMALL:
			{
				set_full(false);

				return Button::State::NORMAL;
			}
			case Buttons::BT_COIN:
			case Buttons::BT_COIN_SM:
			case Buttons::BT_POINT:
			case Buttons::BT_POINT_SM:
			case Buttons::BT_UPGRADE:
			case Buttons::BT_UPGRADE_SM:
			case Buttons::BT_APPRAISE:
			case Buttons::BT_APPRAISE_SM:
			case Buttons::BT_EXTRACT:
			case Buttons::BT_EXTRACT_SM:
			case Buttons::BT_DISASSEMBLE:
			case Buttons::BT_DISASSEMBLE_SM:
			case Buttons::BT_TOAD:
			case Buttons::BT_TOAD_SM:
			case Buttons::BT_CASHSHOP:
			{
				return Button::State::NORMAL;
			}
		}

		if (tab != oldtab)
		{
			uint16_t row = slotrange.at(tab).first / slot_col;
			slider.setrows(row, 6, inventory.get_slotmax(tab) / slot_col);

			buttons[button_by_tab(oldtab)]->set_state(Button::State::NORMAL);
			buttons[button_by_tab(tab)]->set_state(Button::State::PRESSED);

			load_icons();
			set_sort(false);
		}

		return Button::State::IDENTITY;
	}

	void UIItemInventory::doubleclick(Point<int16_t> cursorpos)
	{
		int16_t slot = slot_by_position(cursorpos - position);

		if (icons.count(slot) && is_visible(slot))
		{
			if (int32_t item_id = inventory.get_item_id(tab, slot))
			{
				switch (tab)
				{
					case InventoryType::Id::EQUIP:
					{
						if (can_wear_equip(slot))
						{
							EquipSlot::Id equipslot = inventory.find_equipslot(item_id);

							if (equipslot == EquipSlot::Id::NONE)
							{
								LOG(LOG_DEBUG, "Could not find appropriate EquipSlot::Id for item [" << item_id << "]. Equip would be dropped.");
								break;
							}

							EquipItemPacket(slot, equipslot).dispatch();
						}

						break;
					}
					case InventoryType::Id::USE:
					{
						UseItemPacket(slot, item_id).dispatch();
						break;
					}
				}
			}
		}
	}

	bool UIItemInventory::send_icon(const Icon& icon, Point<int16_t> cursorpos)
	{
		int16_t slot = slot_by_position(cursorpos - position);

		if (slot > 0)
		{
			int32_t item_id = inventory.get_item_id(tab, slot);
			EquipSlot::Id eqslot;
			bool equip;

			if (item_id && tab == InventoryType::Id::EQUIP)
			{
				eqslot = inventory.find_equipslot(item_id);
				equip = true;
			}
			else
			{
				eqslot = EquipSlot::Id::NONE;
				equip = false;
			}

			ignore_tooltip = true;

			return icon.drop_on_items(tab, eqslot, slot, equip);
		}

		return true;
	}

	Cursor::State UIItemInventory::send_cursor(bool pressed, Point<int16_t> cursorpos)
	{
		Cursor::State dstate = UIDragElement::send_cursor(pressed, cursorpos);

		if (dragged)
		{
			clear_tooltip();

			return dstate;
		}

		Point<int16_t> cursor_relative = cursorpos - position;

		if (!full_enabled && slider.isenabled())
		{
			Cursor::State sstate = slider.send_cursor(cursor_relative, pressed);

			if (sstate != Cursor::State::IDLE)
			{
				clear_tooltip();

				return sstate;
			}
		}

		int16_t slot = slot_by_position(cursor_relative);
		Icon* icon = get_icon(slot);
		bool is_icon = icon && is_visible(slot);

		if (is_icon)
		{
			if (pressed)
			{
				Point<int16_t> slotpos = get_slotpos(slot);
				icon->start_drag(cursor_relative - slotpos);

				UI::get().drag_icon(icon);

				clear_tooltip();

				return Cursor::State::GRABBING;
			}
			else if (!ignore_tooltip)
			{
				show_item(slot);

				return Cursor::State::CANGRAB;
			}
			else
			{
				ignore_tooltip = false;

				return Cursor::State::CANGRAB;
			}
		}
		else
		{
			clear_tooltip();

			return UIElement::send_cursor(pressed, cursorpos);
		}
	}

	void UIItemInventory::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
			{
				toggle_active();
			}
			else if (keycode == KeyAction::Id::TAB)
			{
				clear_tooltip();

				InventoryType::Id newtab;

				switch (tab)
				{
					case InventoryType::Id::EQUIP:
						newtab = InventoryType::Id::USE;
						break;
					case InventoryType::Id::USE:
						newtab = InventoryType::Id::ETC;
						break;
					case InventoryType::Id::ETC:
						newtab = InventoryType::Id::SETUP;
						break;
					case InventoryType::Id::SETUP:
						newtab = InventoryType::Id::CASH;
						break;
					case InventoryType::Id::CASH:
						newtab = InventoryType::Id::DEC;
						break;
					case InventoryType::Id::DEC:
						newtab = InventoryType::Id::EQUIP;
						break;
				}

				button_pressed(button_by_tab(newtab));
			}
		}
	}

	UIElement::Type UIItemInventory::get_type() const
	{
		return TYPE;
	}

	void UIItemInventory::modify(InventoryType::Id type, int16_t slot, int8_t mode, int16_t arg)
	{
		if (slot <= 0)
			return;

		if (type == tab)
		{
			switch (mode)
			{
				case Inventory::Modification::ADD:
				{
					update_slot(slot);

					newtab = type;
					newslot = slot;
					break;
				}
				case Inventory::Modification::CHANGECOUNT:
				case Inventory::Modification::ADDCOUNT:
				{
					if (auto icon = get_icon(slot))
						icon->set_count(arg);

					break;
				}
				case Inventory::Modification::SWAP:
				{
					if (arg != slot)
					{
						update_slot(slot);
						update_slot(arg);
					}

					break;
				}
				case Inventory::Modification::REMOVE:
				{
					update_slot(slot);
					break;
				}
			}
		}

		switch (mode)
		{
			case Inventory::Modification::ADD:
			case Inventory::Modification::ADDCOUNT:
			{
				newtab = type;
				newslot = slot;
				break;
			}
			case Inventory::Modification::CHANGECOUNT:
			case Inventory::Modification::SWAP:
			case Inventory::Modification::REMOVE:
			{
				if (newslot == slot && newtab == type)
					clear_new();

				break;
			}
		}
	}

	void UIItemInventory::set_sort(bool enabled)
	{
		sort_enabled = enabled;

		if (full_enabled)
		{
			if (sort_enabled)
			{
				buttons[Buttons::BT_SORT]->set_active(false);
				buttons[Buttons::BT_SORT_SM]->set_active(true);
				buttons[Buttons::BT_GATHER]->set_active(false);
				buttons[Buttons::BT_GATHER_SM]->set_active(false);
			}
			else
			{
				buttons[Buttons::BT_SORT]->set_active(false);
				buttons[Buttons::BT_SORT_SM]->set_active(false);
				buttons[Buttons::BT_GATHER]->set_active(false);
				buttons[Buttons::BT_GATHER_SM]->set_active(true);
			}
		}
		else
		{
			if (sort_enabled)
			{
				buttons[Buttons::BT_SORT]->set_active(true);
				buttons[Buttons::BT_SORT_SM]->set_active(false);
				buttons[Buttons::BT_GATHER]->set_active(false);
				buttons[Buttons::BT_GATHER_SM]->set_active(false);
			}
			else
			{
				buttons[Buttons::BT_SORT]->set_active(false);
				buttons[Buttons::BT_SORT_SM]->set_active(false);
				buttons[Buttons::BT_GATHER]->set_active(true);
				buttons[Buttons::BT_GATHER_SM]->set_active(false);
			}
		}
	}

	void UIItemInventory::change_tab(InventoryType::Id type)
	{
		button_pressed(button_by_tab(type));
	}

	void UIItemInventory::clear_new()
	{
		newtab = InventoryType::Id::NONE;
		newslot = 0;
	}

	void UIItemInventory::toggle_active()
	{
		UIElement::toggle_active();

		if (!active)
		{
			clear_new();
			clear_tooltip();
		}
	}

	void UIItemInventory::remove_cursor()
	{
		UIDragElement::remove_cursor();

		slider.remove_cursor();
	}

	void UIItemInventory::show_item(int16_t slot)
	{
		if (tab == InventoryType::Id::EQUIP)
		{
			UI::get().show_equip(Tooltip::Parent::ITEMINVENTORY, slot);
		}
		else
		{
			int32_t item_id = inventory.get_item_id(tab, slot);
			UI::get().show_item(Tooltip::Parent::ITEMINVENTORY, item_id);
		}
	}

	void UIItemInventory::clear_tooltip()
	{
		UI::get().clear_tooltip(Tooltip::Parent::ITEMINVENTORY);
	}

	bool UIItemInventory::is_visible(int16_t slot) const
	{
		return !is_not_visible(slot);
	}

	bool UIItemInventory::is_not_visible(int16_t slot) const
	{
		auto& range = slotrange.at(tab);

		if (full_enabled)
			return slot < 1 || slot > max_full_slots;
		else
			return slot < range.first || slot > range.second;
	}

	bool UIItemInventory::can_wear_equip(int16_t slot) const
	{
		const Player& player = Stage::get().get_player();
		const CharStats& stats = player.get_stats();
		const CharLook& look = player.get_look();
		const bool alerted = look.get_alerted();

		if (alerted)
		{
			UI::get().emplace<UIOk>("You cannot complete this action right now.\\nEvade the attack and try again.", [](bool) {});
			return false;
		}

		const int32_t item_id = inventory.get_item_id(InventoryType::Id::EQUIP, slot);
		const EquipData& equipdata = EquipData::get(item_id);
		const ItemData& itemdata = equipdata.get_itemdata();

		const int8_t reqGender = itemdata.get_gender();
		const bool female = stats.get_female();

		switch (reqGender)
		{
			// Male
			case 0:
			{
				if (female)
					return false;

				break;
			}
			// Female
			case 1:
			{
				if (!female)
					return false;

				break;
			}
			// Unisex
			case 2:
			default:
			{
				break;
			}
		}

		const std::string jobname = stats.get_jobname();

		if (jobname == "GM" || jobname == "SuperGM")
			return true;

		// TODO: Remove from EquipTooltip and move into Job?
		bool can_wear = false;

		uint16_t job = stats.get_stat(MapleStat::Id::JOB) / 100;
		int16_t reqJOB = equipdata.get_reqstat(MapleStat::Id::JOB);

		switch (reqJOB)
		{
			case 0: // Common
			{
				can_wear = true;
				break;
			}
			case 1: // Warrior
			{
				if (job == 1 || job >= 20)
					can_wear = true;

				break;
			}
			case 2: // Magician
			{
				if (job == 2)
					can_wear = true;

				break;
			}
			case 3: // Magician, Warrior
			{
				if (job == 1 || job >= 20 || job == 2)
					can_wear = true;

				break;
			}
			case 4: // Bowman
			{
				if (job == 3)
					can_wear = true;

				break;
			}
			case 8: // Thief
			{
				if (job == 4)
					can_wear = true;

				break;
			}
			case 16: // Pirate
			{
				if (job == 5)
					can_wear = true;

				break;
			}
			default:
			{
				can_wear = false;
			}
		}

		if (!can_wear)
		{
			UI::get().emplace<UIOk>("Your current job\\ncannot equip the selected item.", [](bool) {});
			return false;
		}
		// End of TODO

		int16_t reqLevel = equipdata.get_reqstat(MapleStat::Id::LEVEL);
		int16_t reqDEX = equipdata.get_reqstat(MapleStat::Id::DEX);
		int16_t reqSTR = equipdata.get_reqstat(MapleStat::Id::STR);
		int16_t reqLUK = equipdata.get_reqstat(MapleStat::Id::LUK);
		int16_t reqINT = equipdata.get_reqstat(MapleStat::Id::INT);
		int16_t reqFAME = equipdata.get_reqstat(MapleStat::Id::FAME);

		int8_t i = 0;

		if (reqLevel > stats.get_stat(MapleStat::Id::LEVEL))
			i++;
		else if (reqDEX > stats.get_total(EquipStat::Id::DEX))
			i++;
		else if (reqSTR > stats.get_total(EquipStat::Id::STR))
			i++;
		else if (reqLUK > stats.get_total(EquipStat::Id::LUK))
			i++;
		else if (reqINT > stats.get_total(EquipStat::Id::INT))
			i++;
		else if (reqFAME > stats.get_honor())
			i++;

		if (i > 0)
		{
			UI::get().emplace<UIOk>("Your stats are too low to equip this item\\nor you do not meet the job requirement.", [](bool) {});
			return false;
		}

		return true;
	}

	int16_t UIItemInventory::slot_by_position(Point<int16_t> cursorpos) const
	{
		Point<int16_t> cursor_offset = cursorpos - slot_pos;

		int16_t xoff = cursor_offset.x();
		int16_t yoff = cursor_offset.y();

		int16_t cur_x = cursorpos.x();
		int16_t slot_x = slot_pos.x();
		int16_t xmin = slot_x;
		int16_t xmax = (icon_width + slot_space_x) * (full_enabled ? slot_col * 4 : slot_col) - (full_enabled ? slot_space_x : 0);

		int16_t cur_y = cursorpos.y();
		int16_t slot_y = slot_pos.y();
		int16_t ymin = slot_y;
		int16_t ymax = (icon_height + slot_space_y) * (full_enabled ? slot_row + 1 : slot_row - 1) - (full_enabled ? slot_space_y : 0);

		int16_t slot = 0;
		int16_t absslot = full_enabled ? 1 : slotrange.at(tab).first;

		int16_t col = cur_x / (icon_width + slot_space_x);
		int16_t row = cur_y / (icon_height + slot_space_y) - 1;

		div_t div = std::div(col, 4);
		slot = col + absslot + (4 * row) + (div.quot * 28);

		if (cur_x < xmin || cur_x > xmax || cur_y < ymin || cur_y > ymax)
			slot = 0;

		LOG(LOG_UI,
			"Slot: " << slot << " Col: " << col << " Row: " << row << " "
			<< cur_x << " < (" << xmin << ") || "
			<< cur_x << " > (" << xmax << ") || "
			<< cur_y << " < (" << ymin << ") && "
			<< cur_y << " > (" << ymax << ")");

		if (is_visible(slot))
			return slot;

		return 0;
	}

	Point<int16_t> UIItemInventory::get_slotpos(int16_t slot) const
	{
		int16_t absslot = slot - (full_enabled ? 1 : slotrange.at(tab).first);

		div_t div4 = std::div(absslot, 4);
		div_t div32 = std::div(absslot, 32);

		int16_t row = div4.quot - (8 * div32.quot);
		int16_t col = div4.rem + (4 * div32.quot);

		return slot_pos + Point<int16_t>((col * 10) + (col * 32), (row * 10) + (row * 32));
	}

	Point<int16_t> UIItemInventory::get_tabpos(InventoryType::Id tb) const
	{
		int8_t fixed_tab = tb;

		switch (tb)
		{
			case InventoryType::Id::ETC:
				fixed_tab = 3;
				break;
			case InventoryType::Id::SETUP:
				fixed_tab = 4;
				break;
		}

		return Point<int16_t>(10 + ((fixed_tab - 1) * 31), 29);
	}

	uint16_t UIItemInventory::button_by_tab(InventoryType::Id tb) const
	{
		switch (tb)
		{
			case InventoryType::Id::EQUIP:
				return Buttons::BT_TAB_EQUIP;
			case InventoryType::Id::USE:
				return Buttons::BT_TAB_USE;
			case InventoryType::Id::SETUP:
				return Buttons::BT_TAB_SETUP;
			case InventoryType::Id::ETC:
				return Buttons::BT_TAB_ETC;
			case InventoryType::Id::CASH:
				return Buttons::BT_TAB_CASH;
			default:
				return Buttons::BT_TAB_DEC;
		}
	}

	Icon* UIItemInventory::get_icon(int16_t slot)
	{
		auto iter = icons.find(slot);

		if (iter != icons.end())
			return iter->second.get();
		else
			return nullptr;
	}

	void UIItemInventory::set_full(bool enabled)
	{
		full_enabled = enabled;

		if (full_enabled)
		{
			dimension = bg_full_dimensions;

			buttons[Buttons::BT_FULL]->set_active(false);
			buttons[Buttons::BT_SMALL]->set_active(true);
		}
		else
		{
			dimension = bg_dimensions;

			buttons[Buttons::BT_FULL]->set_active(true);
			buttons[Buttons::BT_SMALL]->set_active(false);
		}

		dragarea = Point<int16_t>(dimension.x(), 20);

		buttons[Buttons::BT_CLOSE]->set_position(Point<int16_t>(dimension.x() - 20, 6));

		buttons[Buttons::BT_COIN]->set_active(!enabled);
		buttons[Buttons::BT_POINT]->set_active(!enabled);
		buttons[Buttons::BT_UPGRADE]->set_active(!enabled);
		buttons[Buttons::BT_APPRAISE]->set_active(!enabled);
		buttons[Buttons::BT_EXTRACT]->set_active(!enabled);
		buttons[Buttons::BT_DISASSEMBLE]->set_active(!enabled);
		buttons[Buttons::BT_TOAD]->set_active(!enabled);
		buttons[Buttons::BT_CASHSHOP]->set_active(!enabled);

		buttons[Buttons::BT_COIN_SM]->set_active(enabled);
		buttons[Buttons::BT_POINT_SM]->set_active(enabled);
		buttons[Buttons::BT_UPGRADE_SM]->set_active(enabled);
		buttons[Buttons::BT_APPRAISE_SM]->set_active(enabled);
		buttons[Buttons::BT_EXTRACT_SM]->set_active(enabled);
		buttons[Buttons::BT_DISASSEMBLE_SM]->set_active(enabled);
		buttons[Buttons::BT_TOAD_SM]->set_active(enabled);
		buttons[Buttons::BT_CASHSHOP]->set_active(enabled);

		set_sort(sort_enabled);
		load_icons();
	}

	void UIItemInventory::ItemIcon::set_count(int16_t c)
	{
		count = c;
	}

	Icon::IconType UIItemInventory::ItemIcon::get_type()
	{
		return Icon::IconType::ITEM;
	}

	UIItemInventory::ItemIcon::ItemIcon(const UIItemInventory& parent, InventoryType::Id st, EquipSlot::Id eqs, int16_t s, int32_t iid, int16_t c, bool u, bool cash) : parent(parent)
	{
		sourcetab = st;
		eqsource = eqs;
		source = s;
		item_id = iid;
		count = c;
		untradable = u;
		cashitem = cash;
	}

	void UIItemInventory::ItemIcon::drop_on_stage() const
	{
		constexpr const char* dropmessage = "How many will you drop?";
		constexpr const char* untradablemessage = "This item can't be taken back once thrown away.\\nWill you still drop it?";
		constexpr const char* cashmessage = "You can't drop this item.";

		if (cashitem)
		{
			UI::get().emplace<UIOk>(cashmessage, [](bool) {});
		}
		else
		{
			if (untradable)
			{
				auto onok = [&, dropmessage](bool ok)
				{
					if (ok)
					{
						if (count <= 1)
						{
							MoveItemPacket(sourcetab, source, 0, 1).dispatch();
						}
						else
						{
							auto onenter = [&](int32_t qty)
							{
								MoveItemPacket(sourcetab, source, 0, qty).dispatch();
							};

							UI::get().emplace<UIEnterNumber>(dropmessage, onenter, count, count);
						}
					}
				};

				UI::get().emplace<UIYesNo>(untradablemessage, onok);
			}
			else
			{
				if (count <= 1)
				{
					MoveItemPacket(sourcetab, source, 0, 1).dispatch();
				}
				else
				{
					auto onenter = [&](int32_t qty)
					{
						MoveItemPacket(sourcetab, source, 0, qty).dispatch();
					};

					UI::get().emplace<UIEnterNumber>(dropmessage, onenter, count, count);
				}
			}
		}
	}

	void UIItemInventory::ItemIcon::drop_on_equips(EquipSlot::Id eqslot) const
	{
		switch (sourcetab)
		{
			case InventoryType::Id::EQUIP:
			{
				if (eqsource == eqslot)
					if (parent.can_wear_equip(source))
						EquipItemPacket(source, eqslot).dispatch();

				Sound(Sound::Name::DRAGEND).play();
				break;
			}
			case InventoryType::Id::USE:
			{
				ScrollEquipPacket(source, eqslot).dispatch();
				break;
			}
		}
	}

	bool UIItemInventory::ItemIcon::drop_on_items(InventoryType::Id tab, EquipSlot::Id, int16_t slot, bool) const
	{
		if (tab != sourcetab || slot == source)
			return true;

		MoveItemPacket(tab, source, slot, 1).dispatch();

		return true;
	}

	void UIItemInventory::ItemIcon::drop_on_bindings(Point<int16_t> cursorposition, bool remove) const
	{
		if (sourcetab == InventoryType::Id::USE || sourcetab == InventoryType::Id::SETUP)
		{
			auto keyconfig = UI::get().get_element<UIKeyConfig>();
			Keyboard::Mapping mapping = Keyboard::Mapping(KeyType::ITEM, item_id);

			if (remove)
				keyconfig->unstage_mapping(mapping);
			else
				keyconfig->stage_mapping(cursorposition, mapping);
		}
	}
}

================
File: IO/UITypes/UIItemInventory.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../Components/Slider.h"

namespace ms
{
	// The Item inventory
	class UIItemInventory : public UIDragElement<PosINV>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::ITEMINVENTORY;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIItemInventory(const Inventory& inventory);

		void draw(float inter) const override;
		void update() override;

		void doubleclick(Point<int16_t> position) override;
		bool send_icon(const Icon& icon, Point<int16_t> position) override;
		void toggle_active() override;
		void remove_cursor() override;
		Cursor::State send_cursor(bool pressed, Point<int16_t> position) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		void modify(InventoryType::Id type, int16_t pos, int8_t mode, int16_t arg);
		void set_sort(bool enabled);
		void change_tab(InventoryType::Id type);
		void clear_new();

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void show_item(int16_t slot);
		void clear_tooltip();
		void load_icons();
		void update_slot(int16_t slot);
		bool is_visible(int16_t slot) const;
		bool is_not_visible(int16_t slot) const;
		bool can_wear_equip(int16_t slot) const;
		int16_t slot_by_position(Point<int16_t> position) const;
		uint16_t button_by_tab(InventoryType::Id tab) const;
		Point<int16_t> get_slotpos(int16_t slot) const;
		Point<int16_t> get_tabpos(InventoryType::Id tab) const;
		Icon* get_icon(int16_t slot);
		void set_full(bool enabled);

		class ItemIcon : public Icon::Type
		{
		public:
			ItemIcon(const UIItemInventory& parent, InventoryType::Id sourcetab, EquipSlot::Id eqsource, int16_t source, int32_t item_id, int16_t count, bool untradable, bool cashitem);

			void drop_on_stage() const override;
			void drop_on_equips(EquipSlot::Id eqslot) const override;
			bool drop_on_items(InventoryType::Id tab, EquipSlot::Id eqslot, int16_t slot, bool equip) const override;
			void drop_on_bindings(Point<int16_t> cursorposition, bool remove) const override;
			void set_count(int16_t count) override;
			Icon::IconType get_type() override;

		private:
			InventoryType::Id sourcetab;
			EquipSlot::Id eqsource;
			int16_t source;
			int32_t item_id;
			int16_t count;
			bool untradable;
			bool cashitem;
			const UIItemInventory& parent;
		};

		enum Buttons
		{
			BT_CLOSE,
			BT_TAB_EQUIP,
			BT_TAB_USE,
			BT_TAB_ETC,
			BT_TAB_SETUP,
			BT_TAB_CASH,
			BT_TAB_DEC,
			BT_COIN,
			BT_POINT,
			BT_GATHER,
			BT_SORT,
			BT_FULL,
			BT_SMALL,
			BT_UPGRADE,
			BT_APPRAISE,
			BT_EXTRACT,
			BT_DISASSEMBLE,
			BT_TOAD,
			BT_COIN_SM,
			BT_POINT_SM,
			BT_GATHER_SM,
			BT_SORT_SM,
			BT_UPGRADE_SM,
			BT_APPRAISE_SM,
			BT_EXTRACT_SM,
			BT_DISASSEMBLE_SM,
			BT_TOAD_SM,
			BT_CASHSHOP
		};

		const Inventory& inventory;

		Animation newitemslot;
		Animation newitemtaben;
		Animation newitemtabdis;
		Texture projectile;
		Texture disabled;
		Text mesolabel;
		Text maplepointslabel;
		Slider slider;

		std::map<int16_t, std::unique_ptr<Icon>> icons;
		std::map<InventoryType::Id, std::pair<int16_t, int16_t>> slotrange;

		InventoryType::Id tab;
		InventoryType::Id newtab;
		int16_t newslot;
		int16_t slot_col;
		int16_t slot_row;
		int16_t slot_space_x;
		int16_t slot_space_y;
		int16_t max_slots;
		int16_t max_full_slots;
		int16_t icon_width;
		int16_t icon_height;
		bool ignore_tooltip;

		bool sort_enabled;
		bool full_enabled;
		Texture backgrnd;
		Texture backgrnd2;
		Texture backgrnd3;
		Texture full_backgrnd;
		Texture full_backgrnd2;
		Texture full_backgrnd3;
		Point<int16_t> bg_dimensions;
		Point<int16_t> bg_full_dimensions;
		Point<int16_t> slot_pos;

#if LOG_LEVEL >= LOG_UI
		Text slot_labels[128];
#endif
	};
}

================
File: IO/UITypes/UIJoypad.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIJoypad.h"

#include "../Components/MapleButton.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	// TODO: Add combo boxes nl::nx::ui["Basic.img"]["ComboBox"] / ["ComboBox5"];
	UIJoypad::UIJoypad() : UIDragElement<PosJOYPAD>()
	{
		alternative_settings = false; // TODO: Get user's key settings type

		nl::node JoyPad = nl::nx::UI["UIWindow.img"]["JoyPad"];
		nl::node Basic = nl::nx::UI["Basic.img"];

		backgrnd[true] = JoyPad["backgrnd_alternative"];
		backgrnd[false] = JoyPad["backgrnd_classic"];

		buttons[Buttons::DEFAULT] = std::make_unique<MapleButton>(JoyPad["BtDefault"]);
		buttons[Buttons::CANCEL] = std::make_unique<MapleButton>(Basic["BtCancel4"], Point<int16_t>(124, 303));
		buttons[Buttons::OK] = std::make_unique<MapleButton>(Basic["BtOK4"], Point<int16_t>(82, 303));

		for (Text& text : key_text)
			text = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::BLACK, "None");

		dimension = backgrnd[true].get_dimensions();
	}

	void UIJoypad::draw(float inter) const
	{
		backgrnd[alternative_settings].draw(position);

		int16_t x = 79;
		int16_t y = 24;
		int16_t y_adj = 18;

		for (size_t i = 0; i < Setting::SETTING_NUM; i++)
		{
			if (i == 0)
				key_text[i].draw(position + Point<int16_t>(x, y));
			else if (i > 0 && i < 4)
				key_text[i].draw(position + Point<int16_t>(x - 16, y + 44 + y_adj * (i - 1)));
			else
				key_text[i].draw(position + Point<int16_t>(x - 16, y + 123 + y_adj * (i - 4)));
		}

		UIElement::draw(inter);
	}

	void UIJoypad::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
				cancel();
			else if (keycode == KeyAction::Id::RETURN)
				save();
		}
	}

	UIElement::Type UIJoypad::get_type() const
	{
		return TYPE;
	}

	Button::State UIJoypad::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			case Buttons::DEFAULT:
				break;
			case Buttons::CANCEL:
				cancel();
				break;
			case Buttons::OK:
				save();
				break;
			default:
				break;
		}

		return Button::State::NORMAL;
	}

	void UIJoypad::cancel()
	{
		deactivate();
	}

	void UIJoypad::save()
	{
		cancel();
	}
}

================
File: IO/UITypes/UIJoypad.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../Components/Textfield.h"

#include "../../Template/BoolPair.h"

namespace ms
{
	class UIJoypad : public UIDragElement<PosJOYPAD>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::JOYPAD;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIJoypad();

		void draw(float inter) const override;

		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void cancel();
		void save();

		enum Buttons : uint16_t
		{
			DEFAULT,
			CANCEL,
			OK
		};

		bool alternative_settings;
		BoolPair<Texture> backgrnd;

		enum Setting : uint8_t
		{
			// Joypad name
			NAME,

			// Keys
			ATTACK,
			JUMP,
			PICKUP,

			// Hot keys
			HOTKEY0,
			HOTKEY1,
			HOTKEY2,
			HOTKEY3,
			HOTKEY4,
			HOTKEY5,
			HOTKEY6,
			HOTKEY7,
			SETTING_NUM
		};

		Text key_text[UIJoypad::Setting::SETTING_NUM];
	};
}

================
File: IO/UITypes/UIKeyConfig.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIKeyConfig.h"

#include "../UI.h"

#include "../Components/MapleButton.h"
#include "../UITypes/UILoginNotice.h"
#include "../UITypes/UINotice.h"

#include "../../Data/ItemData.h"
#include "../../Data/SkillData.h"

#include "../../Net/Packets/PlayerPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIKeyConfig::UIKeyConfig(const Inventory& in_inventory, const SkillBook& in_skillbook) : UIDragElement<PosKEYCONFIG>(), inventory(in_inventory), skillbook(in_skillbook), dirty(false)
	{
		keyboard = &UI::get().get_keyboard();
		staged_mappings = keyboard->get_maplekeys();

		nl::node KeyConfig = nl::nx::UI["StatusBar3.img"]["KeyConfig"];

		icon = KeyConfig["icon"];
		key = KeyConfig["key"];

		nl::node backgrnd = KeyConfig["backgrnd"];
		Texture bg = backgrnd;
		Point<int16_t> bg_dimensions = bg.get_dimensions();

		sprites.emplace_back(backgrnd);
		sprites.emplace_back(KeyConfig["backgrnd2"]);
		sprites.emplace_back(KeyConfig["backgrnd3"]);

		nl::node BtClose3 = nl::nx::UI["Basic.img"]["BtClose3"];
		buttons[Buttons::CLOSE] = std::make_unique<MapleButton>(BtClose3, Point<int16_t>(bg_dimensions.x() - 18, 3));
		buttons[Buttons::CANCEL] = std::make_unique<MapleButton>(KeyConfig["button:Cancel"]);
		buttons[Buttons::DEFAULT] = std::make_unique<MapleButton>(KeyConfig["button:Default"]);
		buttons[Buttons::DELETE] = std::make_unique<MapleButton>(KeyConfig["button:Delete"]);
		buttons[Buttons::KEYSETTING] = std::make_unique<MapleButton>(KeyConfig["button:keySetting"]);
		buttons[Buttons::OK] = std::make_unique<MapleButton>(KeyConfig["button:OK"]);

		dimension = bg_dimensions;
		dragarea = Point<int16_t>(bg_dimensions.x(), 20);

		load_keys_pos();
		load_unbound_actions_pos();
		load_key_textures();
		load_actions();
		load_icons();

		bind_staged_action_keys();
	}

	/// Load
	void UIKeyConfig::load_keys_pos()
	{
		int16_t slot_width = 33;
		int16_t slot_width_lg = 98;
		int16_t slot_height = 33;

		int16_t row_y = 126;
		int16_t row_special_y = row_y - slot_height - 5;

		int16_t row_quickslot_x = 535;

		int16_t row_one_x = 31;
		int16_t row_two_x = 80;
		int16_t row_three_x = 96;
		int16_t row_four_x = 55;
		int16_t row_five_x = 39;

		int16_t row_special_x = row_one_x;

		keys_pos[KeyConfig::Key::ESCAPE] = Point<int16_t>(row_one_x, row_special_y);

		row_special_x += slot_width * 2;

		for (size_t i = KeyConfig::Key::F1; i <= KeyConfig::Key::F12; i++)
		{
			KeyConfig::Key id = KeyConfig::actionbyid(i);

			keys_pos[id] = Point<int16_t>(row_special_x, row_special_y);

			row_special_x += slot_width;

			if (id == KeyConfig::Key::F4 || id == KeyConfig::Key::F8)
				row_special_x += 17;
		}

		keys_pos[KeyConfig::Key::SCROLL_LOCK] = Point<int16_t>(row_quickslot_x + (slot_width * 1), row_special_y);

		keys_pos[KeyConfig::Key::GRAVE_ACCENT] = Point<int16_t>(row_one_x + (slot_width * 0), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::NUM1] = Point<int16_t>(row_one_x + (slot_width * 1), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::NUM2] = Point<int16_t>(row_one_x + (slot_width * 2), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::NUM3] = Point<int16_t>(row_one_x + (slot_width * 3), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::NUM4] = Point<int16_t>(row_one_x + (slot_width * 4), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::NUM5] = Point<int16_t>(row_one_x + (slot_width * 5), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::NUM6] = Point<int16_t>(row_one_x + (slot_width * 6), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::NUM7] = Point<int16_t>(row_one_x + (slot_width * 7), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::NUM8] = Point<int16_t>(row_one_x + (slot_width * 8), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::NUM9] = Point<int16_t>(row_one_x + (slot_width * 9), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::NUM0] = Point<int16_t>(row_one_x + (slot_width * 10), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::MINUS] = Point<int16_t>(row_one_x + (slot_width * 11), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::EQUAL] = Point<int16_t>(row_one_x + (slot_width * 12), row_y + (slot_height * 0));

		for (size_t i = KeyConfig::Key::Q; i <= KeyConfig::Key::RIGHT_BRACKET; i++)
		{
			KeyConfig::Key id = KeyConfig::actionbyid(i);

			keys_pos[id] = Point<int16_t>(row_two_x + (slot_width * (i - KeyConfig::Key::Q)), row_y + (slot_height * 1));
		}

		row_two_x += 9;

		keys_pos[KeyConfig::Key::BACKSLASH] = Point<int16_t>(row_two_x + (slot_width * 12), row_y + (slot_height * 1));

		for (size_t i = KeyConfig::Key::A; i <= KeyConfig::Key::APOSTROPHE; i++)
		{
			KeyConfig::Key id = KeyConfig::actionbyid(i);

			keys_pos[id] = Point<int16_t>(row_three_x + (slot_width * (i - KeyConfig::Key::A)), row_y + (slot_height * 2));
		}

		keys_pos[KeyConfig::Key::LEFT_SHIFT] = Point<int16_t>(row_four_x + (slot_width * 0), row_y + (slot_height * 3));

		row_four_x += 24;

		for (size_t i = KeyConfig::Key::Z; i <= KeyConfig::Key::PERIOD; i++)
		{
			KeyConfig::Key id = KeyConfig::actionbyid(i);

			keys_pos[id] = Point<int16_t>(row_four_x + (slot_width * (i - KeyConfig::Key::Z + 1)), row_y + (slot_height * 3));
		}

		row_four_x += 24;

		keys_pos[KeyConfig::Key::RIGHT_SHIFT] = Point<int16_t>(row_four_x + (slot_width * 11), row_y + (slot_height * 3));

		keys_pos[KeyConfig::Key::LEFT_CONTROL] = Point<int16_t>(row_five_x + (slot_width_lg * 0), row_y + (slot_height * 4));
		keys_pos[KeyConfig::Key::LEFT_ALT] = Point<int16_t>(row_five_x + (slot_width_lg * 1), row_y + (slot_height * 4));

		row_five_x += 24;

		keys_pos[KeyConfig::Key::SPACE] = Point<int16_t>(row_five_x + (slot_width_lg * 2), row_y + (slot_height * 4));

		row_five_x += 27;

		keys_pos[KeyConfig::Key::RIGHT_ALT] = Point<int16_t>(row_five_x + (slot_width_lg * 3), row_y + (slot_height * 4));

		row_five_x += 2;

		keys_pos[KeyConfig::Key::RIGHT_CONTROL] = Point<int16_t>(row_five_x + (slot_width_lg * 4), row_y + (slot_height * 4));

		keys_pos[KeyConfig::Key::INSERT] = Point<int16_t>(row_quickslot_x + (slot_width * 0), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::HOME] = Point<int16_t>(row_quickslot_x + (slot_width * 1), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::PAGE_UP] = Point<int16_t>(row_quickslot_x + (slot_width * 2), row_y + (slot_height * 0));
		keys_pos[KeyConfig::Key::DELETE] = Point<int16_t>(row_quickslot_x + (slot_width * 0), row_y + (slot_height * 1));
		keys_pos[KeyConfig::Key::END] = Point<int16_t>(row_quickslot_x + (slot_width * 1), row_y + (slot_height * 1));
		keys_pos[KeyConfig::Key::PAGE_DOWN] = Point<int16_t>(row_quickslot_x + (slot_width * 2), row_y + (slot_height * 1));
	}

	void UIKeyConfig::load_unbound_actions_pos()
	{
		int16_t row_x = 26;
		int16_t row_y = 307;

		int16_t slot_width = 36;
		int16_t slot_height = 36;

		/// Row 1
		unbound_actions_pos[KeyAction::Id::MAPLECHAT] = Point<int16_t>(row_x + (slot_width * 0), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::TOGGLECHAT] = Point<int16_t>(row_x + (slot_width * 1), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::WHISPER] = Point<int16_t>(row_x + (slot_width * 2), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::MEDALS] = Point<int16_t>(row_x + (slot_width * 3), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::BOSSPARTY] = Point<int16_t>(row_x + (slot_width * 4), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::PROFESSION] = Point<int16_t>(row_x + (slot_width * 5), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::EQUIPMENT] = Point<int16_t>(row_x + (slot_width * 6), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::ITEMS] = Point<int16_t>(row_x + (slot_width * 7), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::CHARINFO] = Point<int16_t>(row_x + (slot_width * 8), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::MENU] = Point<int16_t>(row_x + (slot_width * 9), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::QUICKSLOTS] = Point<int16_t>(row_x + (slot_width * 10), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::PICKUP] = Point<int16_t>(row_x + (slot_width * 11), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::SIT] = Point<int16_t>(row_x + (slot_width * 12), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::ATTACK] = Point<int16_t>(row_x + (slot_width * 13), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::JUMP] = Point<int16_t>(row_x + (slot_width * 14), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::INTERACT_HARVEST] = Point<int16_t>(row_x + (slot_width * 15), row_y + (slot_height * 0));
		unbound_actions_pos[KeyAction::Id::SOULWEAPON] = Point<int16_t>(row_x + (slot_width * 16), row_y + (slot_height * 0));

		/// Row 2
		unbound_actions_pos[KeyAction::Id::SAY] = Point<int16_t>(row_x + (slot_width * 0), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::PARTYCHAT] = Point<int16_t>(row_x + (slot_width * 1), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::FRIENDSCHAT] = Point<int16_t>(row_x + (slot_width * 2), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::ITEMPOT] = Point<int16_t>(row_x + (slot_width * 3), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::EVENT] = Point<int16_t>(row_x + (slot_width * 4), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::SILENTCRUSADE] = Point<int16_t>(row_x + (slot_width * 5), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::STATS] = Point<int16_t>(row_x + (slot_width * 6), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::SKILLS] = Point<int16_t>(row_x + (slot_width * 7), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::QUESTLOG] = Point<int16_t>(row_x + (slot_width * 8), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::CHANGECHANNEL] = Point<int16_t>(row_x + (slot_width * 9), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::GUILD] = Point<int16_t>(row_x + (slot_width * 10), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::PARTY] = Point<int16_t>(row_x + (slot_width * 11), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::NOTIFIER] = Point<int16_t>(row_x + (slot_width * 12), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::FRIENDS] = Point<int16_t>(row_x + (slot_width * 13), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::WORLDMAP] = Point<int16_t>(row_x + (slot_width * 14), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::MINIMAP] = Point<int16_t>(row_x + (slot_width * 15), row_y + (slot_height * 1));
		unbound_actions_pos[KeyAction::Id::KEYBINDINGS] = Point<int16_t>(row_x + (slot_width * 16), row_y + (slot_height * 1));

		/// Row 3
		unbound_actions_pos[KeyAction::Id::GUILDCHAT] = Point<int16_t>(row_x + (slot_width * 0), row_y + (slot_height * 2));
		unbound_actions_pos[KeyAction::Id::ALLIANCECHAT] = Point<int16_t>(row_x + (slot_width * 1), row_y + (slot_height * 2));
		unbound_actions_pos[KeyAction::Id::BATTLEANALYSIS] = Point<int16_t>(row_x + (slot_width * 2), row_y + (slot_height * 2));
		unbound_actions_pos[KeyAction::Id::GUIDE] = Point<int16_t>(row_x + (slot_width * 3), row_y + (slot_height * 2));
		unbound_actions_pos[KeyAction::Id::ENHANCEEQUIP] = Point<int16_t>(row_x + (slot_width * 4), row_y + (slot_height * 2));
		unbound_actions_pos[KeyAction::Id::MONSTERCOLLECTION] = Point<int16_t>(row_x + (slot_width * 5), row_y + (slot_height * 2));
		unbound_actions_pos[KeyAction::Id::MANAGELEGION] = Point<int16_t>(row_x + (slot_width * 6), row_y + (slot_height * 2));
		//unbound_actions_pos[KeyAction::Id::LENGTH] = Point<int16_t>(row_x + (slot_width * 7), row_y + (slot_height * 2));
		unbound_actions_pos[KeyAction::Id::MAPLENEWS] = Point<int16_t>(row_x + (slot_width * 8), row_y + (slot_height * 2));
		unbound_actions_pos[KeyAction::Id::CASHSHOP] = Point<int16_t>(row_x + (slot_width * 9), row_y + (slot_height * 2));
		unbound_actions_pos[KeyAction::Id::MAINMENU] = Point<int16_t>(row_x + (slot_width * 10), row_y + (slot_height * 2));
		unbound_actions_pos[KeyAction::Id::SCREENSHOT] = Point<int16_t>(row_x + (slot_width * 11), row_y + (slot_height * 2));
		unbound_actions_pos[KeyAction::Id::PICTUREMODE] = Point<int16_t>(row_x + (slot_width * 12), row_y + (slot_height * 2));
		//unbound_actions_pos[KeyAction::Id::LENGTH] = Point<int16_t>(row_x + (slot_width * 13), row_y + (slot_height * 2));
		unbound_actions_pos[KeyAction::Id::MUTE] = Point<int16_t>(row_x + (slot_width * 14), row_y + (slot_height * 2));
		unbound_actions_pos[KeyAction::Id::MAPLERELAY] = Point<int16_t>(row_x + (slot_width * 15), row_y + (slot_height * 2));
		//unbound_actions_pos[KeyAction::Id::LENGTH] = Point<int16_t>(row_x + (slot_width * 16), row_y + (slot_height * 2));

		/// Row 4
		unbound_actions_pos[KeyAction::Id::FACE1] = Point<int16_t>(row_x + (slot_width * 0), row_y + (slot_height * 3));
		unbound_actions_pos[KeyAction::Id::FACE2] = Point<int16_t>(row_x + (slot_width * 1), row_y + (slot_height * 3));
		unbound_actions_pos[KeyAction::Id::FACE3] = Point<int16_t>(row_x + (slot_width * 2), row_y + (slot_height * 3));
		unbound_actions_pos[KeyAction::Id::FACE4] = Point<int16_t>(row_x + (slot_width * 3), row_y + (slot_height * 3));
		unbound_actions_pos[KeyAction::Id::FACE5] = Point<int16_t>(row_x + (slot_width * 4), row_y + (slot_height * 3));
		unbound_actions_pos[KeyAction::Id::FACE6] = Point<int16_t>(row_x + (slot_width * 5), row_y + (slot_height * 3));
		unbound_actions_pos[KeyAction::Id::FACE7] = Point<int16_t>(row_x + (slot_width * 6), row_y + (slot_height * 3));
		unbound_actions_pos[KeyAction::Id::MAPLEACHIEVEMENT] = Point<int16_t>(row_x + (slot_width * 7), row_y + (slot_height * 3));
		unbound_actions_pos[KeyAction::Id::FAMILIAR] = Point<int16_t>(row_x + (slot_width * 8), row_y + (slot_height * 3));
		unbound_actions_pos[KeyAction::Id::TOSPOUSE] = Point<int16_t>(row_x + (slot_width * 9), row_y + (slot_height * 3));
		unbound_actions_pos[KeyAction::Id::EMOTICON] = Point<int16_t>(row_x + (slot_width * 10), row_y + (slot_height * 3));
		//unbound_actions_pos[KeyAction::Id::LENGTH] = Point<int16_t>(row_x + (slot_width * 11), row_y + (slot_height * 3));
		//unbound_actions_pos[KeyAction::Id::LENGTH] = Point<int16_t>(row_x + (slot_width * 12), row_y + (slot_height * 3));
		//unbound_actions_pos[KeyAction::Id::LENGTH] = Point<int16_t>(row_x + (slot_width * 13), row_y + (slot_height * 3));
		//unbound_actions_pos[KeyAction::Id::LENGTH] = Point<int16_t>(row_x + (slot_width * 14), row_y + (slot_height * 3));
		//unbound_actions_pos[KeyAction::Id::LENGTH] = Point<int16_t>(row_x + (slot_width * 15), row_y + (slot_height * 3));
		//unbound_actions_pos[KeyAction::Id::LENGTH] = Point<int16_t>(row_x + (slot_width * 16), row_y + (slot_height * 3));
	}

	void UIKeyConfig::load_key_textures()
	{
		key_textures[KeyConfig::Key::ESCAPE] = key[1];
		key_textures[KeyConfig::Key::NUM1] = key[2];
		key_textures[KeyConfig::Key::NUM2] = key[3];
		key_textures[KeyConfig::Key::NUM3] = key[4];
		key_textures[KeyConfig::Key::NUM4] = key[5];
		key_textures[KeyConfig::Key::NUM5] = key[6];
		key_textures[KeyConfig::Key::NUM6] = key[7];
		key_textures[KeyConfig::Key::NUM7] = key[8];
		key_textures[KeyConfig::Key::NUM8] = key[9];
		key_textures[KeyConfig::Key::NUM9] = key[10];
		key_textures[KeyConfig::Key::NUM0] = key[11];
		key_textures[KeyConfig::Key::MINUS] = key[12];
		key_textures[KeyConfig::Key::EQUAL] = key[13];

		key_textures[KeyConfig::Key::Q] = key[16];
		key_textures[KeyConfig::Key::W] = key[17];
		key_textures[KeyConfig::Key::E] = key[18];
		key_textures[KeyConfig::Key::R] = key[19];
		key_textures[KeyConfig::Key::T] = key[20];
		key_textures[KeyConfig::Key::Y] = key[21];
		key_textures[KeyConfig::Key::U] = key[22];
		key_textures[KeyConfig::Key::I] = key[23];
		key_textures[KeyConfig::Key::O] = key[24];
		key_textures[KeyConfig::Key::P] = key[25];
		key_textures[KeyConfig::Key::LEFT_BRACKET] = key[26];
		key_textures[KeyConfig::Key::RIGHT_BRACKET] = key[27];

		key_textures[KeyConfig::Key::LEFT_CONTROL] = key[29];
		key_textures[KeyConfig::Key::RIGHT_CONTROL] = key[29];

		key_textures[KeyConfig::Key::A] = key[30];
		key_textures[KeyConfig::Key::S] = key[31];
		key_textures[KeyConfig::Key::D] = key[32];
		key_textures[KeyConfig::Key::F] = key[33];
		key_textures[KeyConfig::Key::G] = key[34];
		key_textures[KeyConfig::Key::H] = key[35];
		key_textures[KeyConfig::Key::J] = key[36];
		key_textures[KeyConfig::Key::K] = key[37];
		key_textures[KeyConfig::Key::L] = key[38];
		key_textures[KeyConfig::Key::SEMICOLON] = key[39];
		key_textures[KeyConfig::Key::APOSTROPHE] = key[40];
		key_textures[KeyConfig::Key::GRAVE_ACCENT] = key[41];

		key_textures[KeyConfig::Key::LEFT_SHIFT] = key[42];
		key_textures[KeyConfig::Key::RIGHT_SHIFT] = key[42];

		key_textures[KeyConfig::Key::BACKSLASH] = key[43];
		key_textures[KeyConfig::Key::Z] = key[44];
		key_textures[KeyConfig::Key::X] = key[45];
		key_textures[KeyConfig::Key::C] = key[46];
		key_textures[KeyConfig::Key::V] = key[47];
		key_textures[KeyConfig::Key::B] = key[48];
		key_textures[KeyConfig::Key::N] = key[49];
		key_textures[KeyConfig::Key::M] = key[50];
		key_textures[KeyConfig::Key::COMMA] = key[51];
		key_textures[KeyConfig::Key::PERIOD] = key[52];

		key_textures[KeyConfig::Key::LEFT_ALT] = key[56];
		key_textures[KeyConfig::Key::RIGHT_ALT] = key[56];

		key_textures[KeyConfig::Key::SPACE] = key[57];

		key_textures[KeyConfig::Key::F1] = key[59];
		key_textures[KeyConfig::Key::F2] = key[60];
		key_textures[KeyConfig::Key::F3] = key[61];
		key_textures[KeyConfig::Key::F4] = key[62];
		key_textures[KeyConfig::Key::F5] = key[63];
		key_textures[KeyConfig::Key::F6] = key[64];
		key_textures[KeyConfig::Key::F7] = key[65];
		key_textures[KeyConfig::Key::F8] = key[66];
		key_textures[KeyConfig::Key::F9] = key[67];
		key_textures[KeyConfig::Key::F10] = key[68];

		key_textures[KeyConfig::Key::SCROLL_LOCK] = key[70];
		key_textures[KeyConfig::Key::HOME] = key[71];

		key_textures[KeyConfig::Key::PAGE_UP] = key[73];

		key_textures[KeyConfig::Key::END] = key[79];

		key_textures[KeyConfig::Key::PAGE_DOWN] = key[81];
		key_textures[KeyConfig::Key::INSERT] = key[82];
		key_textures[KeyConfig::Key::DELETE] = key[83];

		key_textures[KeyConfig::Key::F11] = key[87];
		key_textures[KeyConfig::Key::F12] = key[88];
	}

	void UIKeyConfig::load_actions()
	{
		for (size_t i = KeyAction::Id::EQUIPMENT; i < KeyAction::Id::LENGTH; i++)
		{
			if (i == KeyAction::Id::SAFEMODE || i == KeyAction::Id::MAPLESTORAGE || i == KeyAction::Id::VIEWERSCHAT || i == KeyAction::Id::BITS)
				continue;

			if (icon[i])
			{
				KeyAction::Id action = KeyAction::actionbyid(i);

				action_mappings.push_back(Keyboard::Mapping(get_keytype(action), action));

				action_icons[action] = std::make_unique<Icon>(
					std::make_unique<KeyIcon>(action),
					icon[i],
					-1
					);
			}
		}
	}

	void UIKeyConfig::load_icons()
	{
		for (auto const& it : staged_mappings)
		{
			Keyboard::Mapping mapping = it.second;
			int32_t id = mapping.action;

			if (mapping.type == KeyType::Id::ITEM)
			{
				int16_t count = inventory.get_total_item_count(id);

				item_icons[id] = std::make_unique<Icon>(
					std::make_unique<KeyIcon>(mapping, count),
					get_item_texture(id),
					count
					);
			}
			else if (mapping.type == KeyType::Id::SKILL)
			{
				int16_t count = -1;

				skill_icons[id] = std::make_unique<Icon>(
					std::make_unique<KeyIcon>(mapping, count),
					get_skill_texture(id),
					count
					);
			}
		}
	}

	/// UI: General
	void UIKeyConfig::draw(float inter) const
	{
		UIElement::draw(inter);

		// Bound Keys
		for (auto const& iter : staged_mappings)
		{
			Keyboard::Mapping mapping = iter.second;

			if (mapping.type != KeyType::Id::NONE)
			{
				int32_t id = mapping.action;
				Icon* icon = nullptr;

				if (mapping.type == KeyType::Id::ITEM)
				{
					icon = item_icons.at(id).get();
				}
				else if (mapping.type == KeyType::Id::SKILL)
				{
					icon = skill_icons.at(id).get();
				}
				else if (is_action_mapping(mapping))
				{
					KeyAction::Id action = KeyAction::actionbyid(mapping.action);

					if (action < KeyAction::Id::LENGTH)
						icon = action_icons[action].get();
				}
				else
				{
					LOG(LOG_DEBUG, "Invalid mapping (" << mapping.type << ", " << mapping.action << ") for key [" << iter.first << "].");
				}

				if (icon)
				{
					KeyConfig::Key key = KeyConfig::actionbyid(iter.first);

					if (key < KeyConfig::Key::LENGTH)
					{
						if (key == KeyConfig::Key::SPACE)
						{
							icon->draw(position + keys_pos[key] - Point<int16_t>(0, 3));
						}
						else if (key == KeyConfig::Key::LEFT_CONTROL || key == KeyConfig::Key::RIGHT_CONTROL)
						{
							icon->draw(position + keys_pos[KeyConfig::Key::LEFT_CONTROL] - Point<int16_t>(2, 3));
							icon->draw(position + keys_pos[KeyConfig::Key::RIGHT_CONTROL] - Point<int16_t>(2, 3));
						}
						else if (key == KeyConfig::Key::LEFT_ALT || key == KeyConfig::Key::RIGHT_ALT)
						{
							icon->draw(position + keys_pos[KeyConfig::Key::LEFT_ALT] - Point<int16_t>(2, 3));
							icon->draw(position + keys_pos[KeyConfig::Key::RIGHT_ALT] - Point<int16_t>(2, 3));
						}
						else if (key == KeyConfig::Key::LEFT_SHIFT || key == KeyConfig::Key::RIGHT_SHIFT)
						{
							icon->draw(position + keys_pos[KeyConfig::Key::LEFT_SHIFT] - Point<int16_t>(2, 3));
							icon->draw(position + keys_pos[KeyConfig::Key::RIGHT_SHIFT] - Point<int16_t>(2, 3));
						}
						else
						{
							icon->draw(position + keys_pos[key] - Point<int16_t>(2, 3));
						}
					}
				}
			}
		}

		// Unbound Keys
		for (const auto& icon : action_icons)
			if (icon.second)
				if (std::find(bound_actions.begin(), bound_actions.end(), icon.first) == bound_actions.end())
					icon.second->draw(position + unbound_actions_pos[icon.first]);

		// Keys
		for (const auto& key_texture : key_textures)
		{
			KeyConfig::Key key = key_texture.first;
			Texture texture = key_texture.second;

			texture.draw(position + keys_pos[key]);
		}
	}

	void UIKeyConfig::close()
	{
		clear_tooltip();
		deactivate();
		reset();
	}

	Button::State UIKeyConfig::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			case Buttons::CLOSE:
			case Buttons::CANCEL:
			{
				close();

				return Button::State::NORMAL;
			}
			case Buttons::DEFAULT:
			{
				static const std::string& message = "Would you like to revert to default settings?";

				auto onok = [&](bool ok)
				{
					if (ok)
					{
						auto keysel_onok = [&](bool alternate)
						{
							clear();

							if (alternate)
								staged_mappings = alternate_keys;
							else
								staged_mappings = basic_keys;

							bind_staged_action_keys();
						};

						UI::get().emplace<UIKeySelect>(keysel_onok, false);
					}
				};

				UI::get().emplace<UIOk>(message, onok);

				return Button::State::NORMAL;
			}
			case Buttons::DELETE:
			{
				static const std::string& message = "Would you like to clear all key bindings?";

				auto onok = [&](bool ok)
				{
					if (ok)
						clear();
				};

				UI::get().emplace<UIOk>(message, onok);

				return Button::State::NORMAL;
			}
			case Buttons::OK:
			{
				save_staged_mappings();
				close();

				return Button::State::NORMAL;
			}
			default:
			{
				return Button::State::PRESSED;
			}
		}
	}

	Cursor::State UIKeyConfig::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		Cursor::State dstate = UIDragElement::send_cursor(clicked, cursorpos);

		if (dragged)
			return dstate;

		if (clicked)
		{
			KeyAction::Id action = unbound_action_by_position(cursorpos);

			if (action < KeyAction::Id::LENGTH)
			{
				if (auto icon = action_icons[action].get())
				{
					icon->start_drag(cursorpos - position - unbound_actions_pos[action]);

					UI::get().drag_icon(icon);

					return Cursor::State::GRABBING;
				}
			}

			KeyConfig::Key key = key_by_position(cursorpos);

			if (key < KeyConfig::Key::LENGTH)
			{
				Keyboard::Mapping mapping = get_staged_mapping(key);

				if (mapping.type != KeyType::Id::NONE)
				{
					int32_t id = mapping.action;
					Icon* icon = nullptr;

					if (mapping.type == KeyType::Id::ITEM)
					{
						icon = item_icons[id].get();
					}
					else if (mapping.type == KeyType::Id::SKILL)
					{
						icon = skill_icons[id].get();
					}
					else if (is_action_mapping(mapping))
					{
						KeyAction::Id action = KeyAction::actionbyid(mapping.action);

						if (action < KeyAction::Id::LENGTH)
							icon = action_icons[action].get();
					}
					else
					{
						LOG(LOG_DEBUG, "Invalid mapping (" << mapping.type << ", " << mapping.action << ") for key [" << key << "].");
					}

					if (icon)
					{
						clear_tooltip();

						icon->start_drag(cursorpos - position - keys_pos[key]);

						UI::get().drag_icon(icon);

						return Cursor::State::GRABBING;
					}
				}
			}
		}
		else
		{
			KeyConfig::Key key = key_by_position(cursorpos);

			if (key < KeyConfig::Key::LENGTH)
			{
				Keyboard::Mapping mapping = get_staged_mapping(key);

				if (mapping.type == KeyType::Id::ITEM || mapping.type == KeyType::Id::SKILL)
				{
					int32_t id = mapping.action;

					if (mapping.type == KeyType::Id::ITEM)
						show_item(id);
					else
						show_skill(id);
				}
			}
		}

		return UIElement::send_cursor(clicked, cursorpos);
	}

	bool UIKeyConfig::send_icon(const Icon& icon, Point<int16_t> cursorpos)
	{
		for (auto iter : unbound_actions_pos)
		{
			Rectangle<int16_t> icon_rect = Rectangle<int16_t>(
				position + iter.second,
				position + iter.second + Point<int16_t>(32, 32)
				);

			if (icon_rect.contains(cursorpos))
				icon.drop_on_bindings(cursorpos, true);
		}

		KeyConfig::Key fkey = key_by_position(cursorpos);

		if (fkey != KeyConfig::Key::LENGTH)
			icon.drop_on_bindings(cursorpos, false);

		return true;
	}

	void UIKeyConfig::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed && escape)
			safe_close();
	}

	UIElement::Type UIKeyConfig::get_type() const
	{
		return TYPE;
	}

	void UIKeyConfig::safe_close()
	{
		if (dirty)
		{
			static const std::string& message = "Do you want to save your changes?";

			auto onok = [&](bool ok)
			{
				if (ok)
				{
					save_staged_mappings();
					close();
				}
				else
				{
					close();
				}
			};

			UI::get().emplace<UIOk>(message, onok);
		}
		else
		{
			close();
		}
	}

	/// UI: Tooltip
	void UIKeyConfig::show_item(int32_t item_id)
	{
		UI::get().show_item(Tooltip::Parent::KEYCONFIG, item_id);
	}

	void UIKeyConfig::show_skill(int32_t skill_id)
	{
		int32_t level = skillbook.get_level(skill_id);
		int32_t masterlevel = skillbook.get_masterlevel(skill_id);
		int64_t expiration = skillbook.get_expiration(skill_id);

		UI::get().show_skill(Tooltip::Parent::KEYCONFIG, skill_id, level, masterlevel, expiration);
	}

	void UIKeyConfig::clear_tooltip()
	{
		UI::get().clear_tooltip(Tooltip::Parent::KEYCONFIG);
	}

	/// Keymap Staging
	void UIKeyConfig::stage_mapping(Point<int16_t> cursorposition, Keyboard::Mapping mapping)
	{
		KeyConfig::Key key = key_by_position(cursorposition);
		Keyboard::Mapping prior_staged = staged_mappings[key];

		if (prior_staged == mapping)
			return;

		unstage_mapping(prior_staged);

		int32_t id = mapping.action;

		if (is_action_mapping(mapping))
		{
			KeyAction::Id action = KeyAction::actionbyid(id);

			if (std::find(bound_actions.begin(), bound_actions.end(), action) == bound_actions.end())
				bound_actions.emplace_back(action);
		}

		for (auto const& it : staged_mappings)
		{
			Keyboard::Mapping staged_mapping = it.second;

			if (staged_mapping == mapping)
			{
				if (it.first == KeyConfig::Key::LEFT_CONTROL || it.first == KeyConfig::Key::RIGHT_CONTROL)
				{
					staged_mappings.erase(KeyConfig::Key::LEFT_CONTROL);
					staged_mappings.erase(KeyConfig::Key::RIGHT_CONTROL);
				}
				else if (it.first == KeyConfig::Key::LEFT_ALT || it.first == KeyConfig::Key::RIGHT_ALT)
				{
					staged_mappings.erase(KeyConfig::Key::LEFT_ALT);
					staged_mappings.erase(KeyConfig::Key::RIGHT_ALT);
				}
				else if (it.first == KeyConfig::Key::LEFT_SHIFT || it.first == KeyConfig::Key::RIGHT_SHIFT)
				{
					staged_mappings.erase(KeyConfig::Key::LEFT_SHIFT);
					staged_mappings.erase(KeyConfig::Key::RIGHT_SHIFT);
				}
				else
				{
					staged_mappings.erase(it.first);
				}

				break;
			}
		}

		if (key == KeyConfig::Key::LEFT_CONTROL || key == KeyConfig::Key::RIGHT_CONTROL)
		{
			staged_mappings[KeyConfig::Key::LEFT_CONTROL] = mapping;
			staged_mappings[KeyConfig::Key::RIGHT_CONTROL] = mapping;
		}
		else if (key == KeyConfig::Key::LEFT_ALT || key == KeyConfig::Key::RIGHT_ALT)
		{
			staged_mappings[KeyConfig::Key::LEFT_ALT] = mapping;
			staged_mappings[KeyConfig::Key::RIGHT_ALT] = mapping;
		}
		else if (key == KeyConfig::Key::LEFT_SHIFT || key == KeyConfig::Key::RIGHT_SHIFT)
		{
			staged_mappings[KeyConfig::Key::LEFT_SHIFT] = mapping;
			staged_mappings[KeyConfig::Key::RIGHT_SHIFT] = mapping;
		}
		else
		{
			staged_mappings[key] = mapping;
		}

		if (mapping.type == KeyType::Id::ITEM)
		{
			if (item_icons.find(id) == item_icons.end())
			{
				int16_t count = inventory.get_total_item_count(id);

				item_icons[id] = std::make_unique<Icon>(
					std::make_unique<KeyIcon>(mapping, count),
					get_item_texture(id),
					count
					);
			}
		}
		else if (mapping.type == KeyType::Id::SKILL)
		{
			if (skill_icons.find(id) == skill_icons.end())
			{
				int16_t count = -1;

				skill_icons[id] = std::make_unique<Icon>(
					std::make_unique<KeyIcon>(mapping, count),
					get_skill_texture(id),
					count
					);
			}
		}

		dirty = true;
	}

	void UIKeyConfig::unstage_mapping(Keyboard::Mapping mapping)
	{
		if (is_action_mapping(mapping))
		{
			KeyAction::Id action = KeyAction::actionbyid(mapping.action);
			auto iter = std::find(bound_actions.begin(), bound_actions.end(), action);

			if (iter != bound_actions.end())
				bound_actions.erase(iter);
		}

		for (auto const& it : staged_mappings)
		{
			Keyboard::Mapping staged_mapping = it.second;

			if (staged_mapping == mapping)
			{
				if (it.first == KeyConfig::Key::LEFT_CONTROL || it.first == KeyConfig::Key::RIGHT_CONTROL)
				{
					staged_mappings.erase(KeyConfig::Key::LEFT_CONTROL);
					staged_mappings.erase(KeyConfig::Key::RIGHT_CONTROL);
				}
				else if (it.first == KeyConfig::Key::LEFT_ALT || it.first == KeyConfig::Key::RIGHT_ALT)
				{
					staged_mappings.erase(KeyConfig::Key::LEFT_ALT);
					staged_mappings.erase(KeyConfig::Key::RIGHT_ALT);
				}
				else if (it.first == KeyConfig::Key::LEFT_SHIFT || it.first == KeyConfig::Key::RIGHT_SHIFT)
				{
					staged_mappings.erase(KeyConfig::Key::LEFT_SHIFT);
					staged_mappings.erase(KeyConfig::Key::RIGHT_SHIFT);
				}
				else
				{
					staged_mappings.erase(it.first);
				}

				if (staged_mapping.type == KeyType::Id::ITEM)
				{
					int32_t item_id = staged_mapping.action;
					item_icons.erase(item_id);
				}
				else if (staged_mapping.type == KeyType::Id::SKILL)
				{
					int32_t skill_id = staged_mapping.action;
					skill_icons.erase(skill_id);
				}

				dirty = true;

				break;
			}
		}
	}

	void UIKeyConfig::save_staged_mappings()
	{
		std::vector<std::tuple<KeyConfig::Key, KeyType::Id, int32_t>> updated_actions;

		for (auto& key : staged_mappings)
		{
			KeyConfig::Key k = KeyConfig::actionbyid(key.first);
			Keyboard::Mapping mapping = key.second;
			Keyboard::Mapping saved_mapping = keyboard->get_maple_mapping(key.first);

			if (mapping != saved_mapping)
				updated_actions.emplace_back(std::make_tuple(k, mapping.type, mapping.action));
		}

		auto maplekeys = keyboard->get_maplekeys();

		for (auto& key : maplekeys)
		{
			bool keyFound = false;
			KeyConfig::Key keyConfig = KeyConfig::actionbyid(key.first);

			for (auto& tkey : staged_mappings)
			{
				KeyConfig::Key tKeyConfig = KeyConfig::actionbyid(tkey.first);

				if (keyConfig == tKeyConfig)
				{
					keyFound = true;
					break;
				}
			}

			if (!keyFound)
				updated_actions.emplace_back(std::make_tuple(keyConfig, KeyType::Id::NONE, KeyAction::Id::LENGTH));
		}

		if (updated_actions.size() > 0)
			ChangeKeyMapPacket(updated_actions).dispatch();

		for (auto& action : updated_actions)
		{
			KeyConfig::Key key = std::get<0>(action);
			KeyType::Id type = std::get<1>(action);
			int32_t keyAction = std::get<2>(action);

			if (type == KeyType::Id::NONE)
				keyboard->remove(key);
			else
				keyboard->assign(key, type, keyAction);
		}

		dirty = false;
	}

	void UIKeyConfig::bind_staged_action_keys()
	{
		for (auto fkey : key_textures)
		{
			Keyboard::Mapping mapping = get_staged_mapping(fkey.first);

			if (mapping.type != KeyType::Id::NONE)
			{
				KeyAction::Id action = KeyAction::actionbyid(mapping.action);

				if (action < KeyAction::Id::LENGTH)
				{
					KeyType::Id type = get_keytype(action);

					if (type == KeyType::Id::NONE || mapping.type != type)
						continue;

					bound_actions.emplace_back(action);
				}
			}
		}
	}

	void UIKeyConfig::clear()
	{
		item_icons.clear();
		skill_icons.clear();
		bound_actions.clear();
		staged_mappings = {};
		dirty = true;
	}

	void UIKeyConfig::reset()
	{
		clear();

		staged_mappings = keyboard->get_maplekeys();

		load_icons();
		bind_staged_action_keys();

		dirty = false;
	}

	/// Helpers
	Texture UIKeyConfig::get_item_texture(int32_t item_id) const
	{
		const ItemData& data = ItemData::get(item_id);
		return data.get_icon(false);
	}

	Texture UIKeyConfig::get_skill_texture(int32_t skill_id) const
	{
		const SkillData& data = SkillData::get(skill_id);
		return data.get_icon(SkillData::Icon::NORMAL);
	}

	KeyConfig::Key UIKeyConfig::key_by_position(Point<int16_t> cursorpos) const
	{
		for (auto iter : keys_pos)
		{
			Rectangle<int16_t> icon_rect = Rectangle<int16_t>(
				position + iter.second,
				position + iter.second + Point<int16_t>(32, 32)
				);

			if (icon_rect.contains(cursorpos))
				return iter.first;
		}

		return KeyConfig::Key::LENGTH;
	}

	KeyAction::Id UIKeyConfig::unbound_action_by_position(Point<int16_t> cursorpos) const
	{
		for (auto iter : unbound_actions_pos)
		{
			if (std::find(bound_actions.begin(), bound_actions.end(), iter.first) != bound_actions.end())
				continue;

			Rectangle<int16_t> icon_rect = Rectangle<int16_t>(
				position + iter.second,
				position + iter.second + Point<int16_t>(32, 32)
				);

			if (icon_rect.contains(cursorpos))
				return iter.first;
		}

		return KeyAction::Id::LENGTH;
	}

	Keyboard::Mapping UIKeyConfig::get_staged_mapping(int32_t keycode) const
	{
		auto iter = staged_mappings.find(keycode);

		if (iter == staged_mappings.end())
			return {};

		return iter->second;
	}

	bool UIKeyConfig::is_action_mapping(Keyboard::Mapping mapping) const
	{
		return std::find(action_mappings.begin(), action_mappings.end(), mapping) != action_mappings.end();
	}

	KeyType::Id UIKeyConfig::get_keytype(KeyAction::Id action)
	{
		if (action == KeyAction::Id::PICKUP || action == KeyAction::Id::SIT || action == KeyAction::Id::ATTACK || action == KeyAction::Id::JUMP || action == KeyAction::Id::INTERACT_HARVEST)
			return KeyType::Id::ACTION;
		else if (action < KeyAction::Id::FACE1 || action > KeyAction::Id::FACE7 && action < KeyAction::Id::LEFT)
			return KeyType::Id::MENU;
		else if (action >= KeyAction::Id::FACE1 && action <= KeyAction::Id::FACE7)
			return KeyType::Id::FACE;
		else
			return KeyType::Id::NONE;
	}

	/// Item count
	void UIKeyConfig::update_item_count(InventoryType::Id type, int16_t slot, int16_t change)
	{
		int32_t item_id = inventory.get_item_id(type, slot);

		if (item_icons.find(item_id) == item_icons.end())
			return;

		int16_t item_count = item_icons[item_id]->get_count();
		item_icons[item_id]->set_count(item_count + change);
	}

	/// MappingIcon
	UIKeyConfig::KeyIcon::KeyIcon(Keyboard::Mapping mapping, int16_t count) : mapping(mapping), count(count) {}

	UIKeyConfig::KeyIcon::KeyIcon(KeyAction::Id action)
	{
		KeyType::Id type = UIKeyConfig::get_keytype(action);
		mapping = Keyboard::Mapping(type, action);
	}

	void UIKeyConfig::KeyIcon::drop_on_stage() const
	{
		if (mapping.type == KeyType::Id::ITEM || mapping.type == KeyType::Id::SKILL)
		{
			auto keyconfig = UI::get().get_element<UIKeyConfig>();
			keyconfig->unstage_mapping(mapping);
		}
	}

	void UIKeyConfig::KeyIcon::drop_on_bindings(Point<int16_t> cursorposition, bool remove) const
	{
		auto keyconfig = UI::get().get_element<UIKeyConfig>();

		if (remove)
			keyconfig->unstage_mapping(mapping);
		else
			keyconfig->stage_mapping(cursorposition, mapping);
	}

	void UIKeyConfig::KeyIcon::set_count(int16_t c)
	{
		count = c;
	}

	Icon::IconType UIKeyConfig::KeyIcon::get_type()
	{
		return Icon::IconType::KEY;
	}
}

================
File: IO/UITypes/UIKeyConfig.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Keyboard.h"
#include "../KeyConfig.h"
#include "../UIDragElement.h"

#include "../../Character/SkillBook.h"

namespace ms
{
	class UIKeyConfig : public UIDragElement<PosKEYCONFIG>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::KEYCONFIG;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIKeyConfig(const Inventory& inventory, const SkillBook& skillbook);

		void draw(float inter) const override;

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;
		bool send_icon(const Icon& icon, Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		void close();

		void stage_mapping(Point<int16_t> cursorposition, Keyboard::Mapping mapping);
		void unstage_mapping(Keyboard::Mapping mapping);

		void update_item_count(InventoryType::Id type, int16_t slot, int16_t change);

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void load_keys_pos();
		void load_unbound_actions_pos();
		void load_key_textures();
		void load_actions();
		void load_icons();

		void safe_close();

		void show_item(int32_t item_id);
		void show_skill(int32_t skill_id);
		void clear_tooltip();

		void save_staged_mappings();
		void bind_staged_action_keys();
		void clear();
		void reset();

		Texture get_item_texture(int32_t item_id) const;
		Texture get_skill_texture(int32_t skill_id) const;
		KeyConfig::Key key_by_position(Point<int16_t> position) const;
		KeyAction::Id unbound_action_by_position(Point<int16_t> position) const;
		Keyboard::Mapping get_staged_mapping(int32_t keycode) const;
		bool is_action_mapping(Keyboard::Mapping mapping) const;
		static KeyType::Id get_keytype(KeyAction::Id action);

		enum Buttons : uint16_t
		{
			CLOSE,
			CANCEL,
			DEFAULT,
			DELETE,
			KEYSETTING,
			OK
		};

		class KeyIcon : public Icon::Type
		{
		public:
			KeyIcon(Keyboard::Mapping mapping, int16_t count);
			KeyIcon(KeyAction::Id action);

			void drop_on_stage() const override;
			void drop_on_equips(EquipSlot::Id) const override {}
			bool drop_on_items(InventoryType::Id, EquipSlot::Id, int16_t, bool) const override { return true; }
			void drop_on_bindings(Point<int16_t> cursorposition, bool remove) const override;
			void set_count(int16_t count) override;
			Icon::IconType get_type() override;

		private:
			int16_t count;
			Keyboard::Mapping mapping;
		};

		const Inventory& inventory;
		const SkillBook& skillbook;

		bool dirty;

		Keyboard* keyboard = nullptr;

		nl::node key;
		nl::node icon;

		EnumMap<KeyConfig::Key, Texture> key_textures;
		EnumMap<KeyConfig::Key, Point<int16_t>> keys_pos;

		EnumMap<KeyAction::Id, std::unique_ptr<Icon>> action_icons;
		EnumMap<KeyAction::Id, Point<int16_t>> unbound_actions_pos;

		std::map<int32_t, std::unique_ptr<Icon>> item_icons;
		std::map<int32_t, std::unique_ptr<Icon>> skill_icons;

		// Used to determine if mapping belongs to predefined action, e.g. attack, pick up, faces, etc.
		std::vector<Keyboard::Mapping> action_mappings;

		std::vector<KeyAction::Id> bound_actions;
		std::map<int32_t, Keyboard::Mapping> staged_mappings;

		std::map<int32_t, Keyboard::Mapping> alternate_keys =
		{
		   { KeyConfig::Key::ESCAPE,		Keyboard::Mapping(get_keytype(KeyAction::Id::MAINMENU),			KeyAction::Id::MAINMENU)			},
		   { KeyConfig::Key::F1,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE1),			KeyAction::Id::FACE1)				},
		   { KeyConfig::Key::F2,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE2),			KeyAction::Id::FACE2)				},
		   { KeyConfig::Key::F3,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE3),			KeyAction::Id::FACE3)				},
		   { KeyConfig::Key::F5,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE4),			KeyAction::Id::FACE4)				},
		   { KeyConfig::Key::F6,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE5),			KeyAction::Id::FACE5)				},
		   { KeyConfig::Key::F7,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE6),			KeyAction::Id::FACE6)				},
		   { KeyConfig::Key::F8,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE7),			KeyAction::Id::FACE7)				},
		   { KeyConfig::Key::SCROLL_LOCK,	Keyboard::Mapping(get_keytype(KeyAction::Id::SCREENSHOT),		KeyAction::Id::SCREENSHOT)			},
		   { KeyConfig::Key::GRAVE_ACCENT,	Keyboard::Mapping(get_keytype(KeyAction::Id::CASHSHOP),			KeyAction::Id::CASHSHOP)			},
		   { KeyConfig::Key::INSERT,		Keyboard::Mapping(get_keytype(KeyAction::Id::SAY),				KeyAction::Id::SAY)					},
		   { KeyConfig::Key::HOME,			Keyboard::Mapping(get_keytype(KeyAction::Id::PARTYCHAT),		KeyAction::Id::PARTYCHAT)			},
		   { KeyConfig::Key::PAGE_UP,		Keyboard::Mapping(get_keytype(KeyAction::Id::FRIENDSCHAT),		KeyAction::Id::FRIENDSCHAT)			},
		   { KeyConfig::Key::T,				Keyboard::Mapping(get_keytype(KeyAction::Id::BOSSPARTY),		KeyAction::Id::BOSSPARTY)			},
		   { KeyConfig::Key::Y,				Keyboard::Mapping(get_keytype(KeyAction::Id::ITEMPOT),			KeyAction::Id::ITEMPOT)				},
		   { KeyConfig::Key::U,				Keyboard::Mapping(get_keytype(KeyAction::Id::EQUIPMENT),		KeyAction::Id::EQUIPMENT)			},
		   { KeyConfig::Key::I,				Keyboard::Mapping(get_keytype(KeyAction::Id::ITEMS),			KeyAction::Id::ITEMS)				},
		   { KeyConfig::Key::P,				Keyboard::Mapping(get_keytype(KeyAction::Id::PARTY),			KeyAction::Id::PARTY)				},
		   { KeyConfig::Key::LEFT_BRACKET,	Keyboard::Mapping(get_keytype(KeyAction::Id::MENU),				KeyAction::Id::MENU)				},
		   { KeyConfig::Key::RIGHT_BRACKET,	Keyboard::Mapping(get_keytype(KeyAction::Id::QUICKSLOTS),		KeyAction::Id::QUICKSLOTS)			},
		   { KeyConfig::Key::BACKSLASH,		Keyboard::Mapping(get_keytype(KeyAction::Id::KEYBINDINGS),		KeyAction::Id::KEYBINDINGS)			},
		   { KeyConfig::Key::DELETE,		Keyboard::Mapping(get_keytype(KeyAction::Id::GUILDCHAT),		KeyAction::Id::GUILDCHAT)			},
		   { KeyConfig::Key::END,			Keyboard::Mapping(get_keytype(KeyAction::Id::ALLIANCECHAT),		KeyAction::Id::ALLIANCECHAT)		},
		   { KeyConfig::Key::G,				Keyboard::Mapping(get_keytype(KeyAction::Id::GUILD),			KeyAction::Id::GUILD)				},
		   { KeyConfig::Key::H,				Keyboard::Mapping(get_keytype(KeyAction::Id::WHISPER),			KeyAction::Id::WHISPER)				},
		   { KeyConfig::Key::J,				Keyboard::Mapping(get_keytype(KeyAction::Id::QUESTLOG),			KeyAction::Id::QUESTLOG)			},
		   { KeyConfig::Key::K,				Keyboard::Mapping(get_keytype(KeyAction::Id::SKILLS),			KeyAction::Id::SKILLS)				},
		   { KeyConfig::Key::L,				Keyboard::Mapping(get_keytype(KeyAction::Id::NOTIFIER),			KeyAction::Id::NOTIFIER)			},
		   { KeyConfig::Key::SEMICOLON,		Keyboard::Mapping(get_keytype(KeyAction::Id::MEDALS),			KeyAction::Id::MEDALS)				},
		   { KeyConfig::Key::APOSTROPHE,	Keyboard::Mapping(get_keytype(KeyAction::Id::TOGGLECHAT),		KeyAction::Id::TOGGLECHAT)			},
		   { KeyConfig::Key::Z,				Keyboard::Mapping(get_keytype(KeyAction::Id::PICKUP),			KeyAction::Id::PICKUP)				},
		   { KeyConfig::Key::X,				Keyboard::Mapping(get_keytype(KeyAction::Id::SIT),				KeyAction::Id::SIT)					},
		   { KeyConfig::Key::C,				Keyboard::Mapping(get_keytype(KeyAction::Id::STATS),			KeyAction::Id::STATS)				},
		   { KeyConfig::Key::V,				Keyboard::Mapping(get_keytype(KeyAction::Id::EVENT),			KeyAction::Id::EVENT)				},
		   { KeyConfig::Key::B,				Keyboard::Mapping(get_keytype(KeyAction::Id::PROFESSION),		KeyAction::Id::PROFESSION)			},
		   { KeyConfig::Key::N,				Keyboard::Mapping(get_keytype(KeyAction::Id::WORLDMAP),			KeyAction::Id::WORLDMAP)			},
		   { KeyConfig::Key::M,				Keyboard::Mapping(get_keytype(KeyAction::Id::MINIMAP),			KeyAction::Id::MINIMAP)				},
		   { KeyConfig::Key::PERIOD,		Keyboard::Mapping(get_keytype(KeyAction::Id::FRIENDS),			KeyAction::Id::FRIENDS)				},
		   { KeyConfig::Key::LEFT_CONTROL,	Keyboard::Mapping(get_keytype(KeyAction::Id::ATTACK),			KeyAction::Id::ATTACK)				},
		   { KeyConfig::Key::LEFT_ALT,		Keyboard::Mapping(get_keytype(KeyAction::Id::JUMP),				KeyAction::Id::JUMP)				},
		   { KeyConfig::Key::SPACE,			Keyboard::Mapping(get_keytype(KeyAction::Id::INTERACT_HARVEST),	KeyAction::Id::INTERACT_HARVEST)	},
		   { KeyConfig::Key::RIGHT_ALT,		Keyboard::Mapping(get_keytype(KeyAction::Id::JUMP),				KeyAction::Id::JUMP)				},
		   { KeyConfig::Key::RIGHT_CONTROL,	Keyboard::Mapping(get_keytype(KeyAction::Id::ATTACK),			KeyAction::Id::ATTACK)				}
		};

		std::map<int32_t, Keyboard::Mapping> basic_keys =
		{
		   { KeyConfig::Key::ESCAPE,		Keyboard::Mapping(get_keytype(KeyAction::Id::MAINMENU),			KeyAction::Id::MAINMENU)			},
		   { KeyConfig::Key::F1,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE1),			KeyAction::Id::FACE1)				},
		   { KeyConfig::Key::F2,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE2),			KeyAction::Id::FACE2)				},
		   { KeyConfig::Key::F3,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE3),			KeyAction::Id::FACE3)				},
		   { KeyConfig::Key::F5,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE4),			KeyAction::Id::FACE4)				},
		   { KeyConfig::Key::F6,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE5),			KeyAction::Id::FACE5)				},
		   { KeyConfig::Key::F7,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE6),			KeyAction::Id::FACE6)				},
		   { KeyConfig::Key::F8,			Keyboard::Mapping(get_keytype(KeyAction::Id::FACE7),			KeyAction::Id::FACE7)				},
		   { KeyConfig::Key::SCROLL_LOCK,	Keyboard::Mapping(get_keytype(KeyAction::Id::SCREENSHOT),		KeyAction::Id::SCREENSHOT)			},
		   { KeyConfig::Key::GRAVE_ACCENT,	Keyboard::Mapping(get_keytype(KeyAction::Id::CASHSHOP),			KeyAction::Id::CASHSHOP)			},
		   { KeyConfig::Key::NUM1,			Keyboard::Mapping(get_keytype(KeyAction::Id::SAY),				KeyAction::Id::SAY)					},
		   { KeyConfig::Key::NUM2,			Keyboard::Mapping(get_keytype(KeyAction::Id::PARTYCHAT),		KeyAction::Id::PARTYCHAT)			},
		   { KeyConfig::Key::NUM3,			Keyboard::Mapping(get_keytype(KeyAction::Id::FRIENDSCHAT),		KeyAction::Id::FRIENDSCHAT)			},
		   { KeyConfig::Key::NUM4,			Keyboard::Mapping(get_keytype(KeyAction::Id::GUILDCHAT),		KeyAction::Id::GUILDCHAT)			},
		   { KeyConfig::Key::NUM5,			Keyboard::Mapping(get_keytype(KeyAction::Id::ALLIANCECHAT),		KeyAction::Id::ALLIANCECHAT)		},
		   { KeyConfig::Key::Q,				Keyboard::Mapping(get_keytype(KeyAction::Id::QUESTLOG),			KeyAction::Id::QUESTLOG)			},
		   { KeyConfig::Key::W,				Keyboard::Mapping(get_keytype(KeyAction::Id::WORLDMAP),			KeyAction::Id::WORLDMAP)			},
		   { KeyConfig::Key::E,				Keyboard::Mapping(get_keytype(KeyAction::Id::EQUIPMENT),		KeyAction::Id::EQUIPMENT)			},
		   { KeyConfig::Key::R,				Keyboard::Mapping(get_keytype(KeyAction::Id::FRIENDS),			KeyAction::Id::FRIENDS)				},
		   { KeyConfig::Key::T,				Keyboard::Mapping(get_keytype(KeyAction::Id::BOSSPARTY),		KeyAction::Id::BOSSPARTY)			},
		   { KeyConfig::Key::Y,				Keyboard::Mapping(get_keytype(KeyAction::Id::ITEMPOT),			KeyAction::Id::ITEMPOT)				},
		   { KeyConfig::Key::U,				Keyboard::Mapping(get_keytype(KeyAction::Id::GUIDE),			KeyAction::Id::GUIDE)				},
		   { KeyConfig::Key::I,				Keyboard::Mapping(get_keytype(KeyAction::Id::ITEMS),			KeyAction::Id::ITEMS)				},
		   { KeyConfig::Key::O,				Keyboard::Mapping(get_keytype(KeyAction::Id::ENHANCEEQUIP),		KeyAction::Id::ENHANCEEQUIP)		},
		   { KeyConfig::Key::P,				Keyboard::Mapping(get_keytype(KeyAction::Id::PARTY),			KeyAction::Id::PARTY)				},
		   { KeyConfig::Key::LEFT_BRACKET,	Keyboard::Mapping(get_keytype(KeyAction::Id::MENU),				KeyAction::Id::MENU)				},
		   { KeyConfig::Key::RIGHT_BRACKET,	Keyboard::Mapping(get_keytype(KeyAction::Id::QUICKSLOTS),		KeyAction::Id::QUICKSLOTS)			},
		   { KeyConfig::Key::BACKSLASH,		Keyboard::Mapping(get_keytype(KeyAction::Id::KEYBINDINGS),		KeyAction::Id::KEYBINDINGS)			},
		   { KeyConfig::Key::S,				Keyboard::Mapping(get_keytype(KeyAction::Id::STATS),			KeyAction::Id::STATS)				},
		   { KeyConfig::Key::G,				Keyboard::Mapping(get_keytype(KeyAction::Id::GUILD),			KeyAction::Id::GUILD)				},
		   { KeyConfig::Key::H,				Keyboard::Mapping(get_keytype(KeyAction::Id::WHISPER),			KeyAction::Id::WHISPER)				},
		   { KeyConfig::Key::K,				Keyboard::Mapping(get_keytype(KeyAction::Id::SKILLS),			KeyAction::Id::SKILLS)				},
		   { KeyConfig::Key::L,				Keyboard::Mapping(get_keytype(KeyAction::Id::NOTIFIER),			KeyAction::Id::NOTIFIER)			},
		   { KeyConfig::Key::SEMICOLON,		Keyboard::Mapping(get_keytype(KeyAction::Id::MEDALS),			KeyAction::Id::MEDALS)				},
		   { KeyConfig::Key::APOSTROPHE,	Keyboard::Mapping(get_keytype(KeyAction::Id::TOGGLECHAT),		KeyAction::Id::TOGGLECHAT)			},
		   { KeyConfig::Key::Z,				Keyboard::Mapping(get_keytype(KeyAction::Id::PICKUP),			KeyAction::Id::PICKUP)				},
		   { KeyConfig::Key::X,				Keyboard::Mapping(get_keytype(KeyAction::Id::SIT),				KeyAction::Id::SIT)					},
		   { KeyConfig::Key::C,				Keyboard::Mapping(get_keytype(KeyAction::Id::MAPLECHAT),		KeyAction::Id::MAPLECHAT)			},
		   { KeyConfig::Key::V,				Keyboard::Mapping(get_keytype(KeyAction::Id::EVENT),			KeyAction::Id::EVENT)				},
		   { KeyConfig::Key::B,				Keyboard::Mapping(get_keytype(KeyAction::Id::PROFESSION),		KeyAction::Id::PROFESSION)			},
		   { KeyConfig::Key::M,				Keyboard::Mapping(get_keytype(KeyAction::Id::MINIMAP),			KeyAction::Id::MINIMAP)				},
		   { KeyConfig::Key::LEFT_CONTROL,	Keyboard::Mapping(get_keytype(KeyAction::Id::ATTACK),			KeyAction::Id::ATTACK)				},
		   { KeyConfig::Key::LEFT_ALT,		Keyboard::Mapping(get_keytype(KeyAction::Id::JUMP),				KeyAction::Id::JUMP)				},
		   { KeyConfig::Key::SPACE,			Keyboard::Mapping(get_keytype(KeyAction::Id::INTERACT_HARVEST),	KeyAction::Id::INTERACT_HARVEST)	},
		   { KeyConfig::Key::RIGHT_ALT,		Keyboard::Mapping(get_keytype(KeyAction::Id::JUMP),				KeyAction::Id::JUMP)				},
		   { KeyConfig::Key::RIGHT_CONTROL,	Keyboard::Mapping(get_keytype(KeyAction::Id::ATTACK),			KeyAction::Id::ATTACK)				}
		};
	};
}

================
File: IO/UITypes/UILogin.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UILogin.h"

#include "UILoginNotice.h"
#include "UILoginWait.h"

#include "../UI.h"
#include "../Window.h"

#include "../Components/MapleButton.h"
#include "../Components/TwoSpriteButton.h"

#include "../../Audio/Audio.h"

#include "../../Net/Packets/LoginPackets.h"
#include "../../Util/AssetRegistry.h"
#include "../../Util/Assets.h"

#include <windows.h>
#include <iostream>
#include "../../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UILogin::UILogin() : UIElement(Point<int16_t>(0, 0), Point<int16_t>(1024, 768)), title_pos(Point<int16_t>(344, 246)), nexon(false)
	{
		// UILogin constructor
		std::string LoginMusicNewtro = Configuration::get().get_login_music_newtro();

		Music(LoginMusicNewtro).play();

		std::string version_text = Configuration::get().get_version();
		version = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::LEMONGRASS, "Ver. " + version_text);
		
		// Use AssetRegistry for version position
		version_pos = GetAsset(AssetID::UI_Login_Version_Position);

		// Get base login nodes through AssetRegistry
		nl::node Login = nl::nx::UI["Login.img"];  // Keep this for backward compatibility during transition

		nl::node Title = Login["Title"];  // CORRECTED: v83 uses "Title" not "Title_new"
		
		
		// Use AssetRegistry for UI elements
		capslock = GetAsset(AssetID::UI_Login_Capslock_Warning);
		check[false] = GetAsset(AssetID::UI_Login_Checkbox_Unchecked);
		check[true] = GetAsset(AssetID::UI_Login_Checkbox_Checked);

		// Use AssetRegistry for login background
		
		AssetRegistry& registry = AssetRegistry::get();
		nl::node login_bg = registry.resolve(AssetID::UI_Login_Background);
		
		// Debug what we're actually loading
		GDEBUG("login_bg name: '" << login_bg.name() << "', empty: " << login_bg.name().empty());
		
		// Validate login background node
		if (login_bg.name().empty()) {
			login_bg = GetAsset(AssetID::UI_Login_Title_Background);
			GDEBUG("login_bg was empty, using title background instead");
		}
		
		// Create login background sprite - read origin from the actual bitmap node
		nl::node bg_bitmap_node = login_bg;
		
		// If login_bg is a container, find the bitmap child (similar to Texture.cpp logic)
		if (login_bg && login_bg.data_type() == nl::node::type::none && login_bg.size() > 0) {
			nl::node child_zero = login_bg["0"];
			if (child_zero && child_zero.data_type() == nl::node::type::bitmap) {
				bg_bitmap_node = child_zero;
			} else {
				for (const auto& child : login_bg) {
					if (child.data_type() == nl::node::type::bitmap) {
						bg_bitmap_node = child;
						break;
					}
				}
			}
		}
		
		// The Texture class automatically handles origin offset, so just use (0,0)
		GDEBUG("Creating login background sprite at (0,0) - Texture handles origin internally");
		sprites.emplace_back(login_bg, Point<int16_t>(0, 0));
		
		nl::node title_bg = GetAsset(AssetID::UI_Login_Title_Background);
		GDEBUG("title_bg name: '" << title_bg.name() << "', empty: " << title_bg.name().empty());
		
		// Creating title background sprite 
		sprites.emplace_back(title_bg, title_pos);

		// Get tab nodes through AssetRegistry
		nl::node TabD = GetAsset(AssetID::UI_Login_Tab_Disabled);
		nl::node TabE = GetAsset(AssetID::UI_Login_Tab_Enabled);

		// Create buttons using AssetRegistry
		buttons[Buttons::BtLogin] = std::make_unique<MapleButton>(GetAsset(AssetID::UI_Login_Button_Login), title_pos);
		buttons[Buttons::BtEmailSave] = std::make_unique<MapleButton>(GetAsset(AssetID::UI_Login_Button_EmailSave), title_pos);
		buttons[Buttons::BtEmailLost] = std::make_unique<MapleButton>(GetAsset(AssetID::UI_Login_Button_EmailLost), title_pos);
		buttons[Buttons::BtPasswdLost] = std::make_unique<MapleButton>(GetAsset(AssetID::UI_Login_Button_PasswdLost), title_pos);
		buttons[Buttons::BtNew] = std::make_unique<MapleButton>(GetAsset(AssetID::UI_Login_Button_New), title_pos);
		buttons[Buttons::BtHomePage] = std::make_unique<MapleButton>(GetAsset(AssetID::UI_Login_Button_Homepage), title_pos);
		buttons[Buttons::BtQuit] = std::make_unique<MapleButton>(GetAsset(AssetID::UI_Login_Button_Quit), title_pos);
		buttons[Buttons::BtMapleID] = std::make_unique<TwoSpriteButton>(TabD["0"], TabE["0"], Point<int16_t>(344, 246));
		buttons[Buttons::BtNexonID] = std::make_unique<TwoSpriteButton>(TabD["1"], TabE["1"], Point<int16_t>(344, 246));

		if (nexon)
		{
			buttons[Buttons::BtNexonID]->set_state(Button::State::PRESSED);
			buttons[Buttons::BtMapleID]->set_state(Button::State::NORMAL);
		}
		else
		{
			buttons[Buttons::BtNexonID]->set_state(Button::State::NORMAL);
			buttons[Buttons::BtMapleID]->set_state(Button::State::PRESSED);
		}

		background = ColorBox(dimension.x(), dimension.y(), Color::Name::BLACK, 1.0f);

		Point<int16_t> textfield_pos = title_pos + Point<int16_t>(27, 69);

#pragma region Account
		Texture account_src = Texture(GetAsset(AssetID::UI_Login_Field_MapleID));
		account_src_dim = account_src.get_dimensions();

		account = Textfield(Text::Font::A13M, Text::Alignment::LEFT, Color::Name::JAMBALAYA, Rectangle<int16_t>(textfield_pos, textfield_pos + account_src_dim), TEXTFIELD_LIMIT);

		account.set_key_callback
		(
			KeyAction::Id::TAB, [&]
			{
				account.set_state(Textfield::State::NORMAL);
				password.set_state(Textfield::State::FOCUSED);
			}
		);

		account.set_enter_callback
		(
			[&](std::string msg)
			{
				login();
			}
		);

		account_bg[false] = account_src;
		account_bg[true] = GetAsset(AssetID::UI_Login_Field_NexonID);
#pragma endregion

#pragma region Password
		textfield_pos.shift_y(account_src_dim.y() + 1);

		Texture password_src = GetAsset(AssetID::UI_Login_Field_Password);
		password_src_dim = password_src.get_dimensions();

		password = Textfield(Text::Font::A13M, Text::Alignment::LEFT, Color::Name::JAMBALAYA, Rectangle<int16_t>(textfield_pos, textfield_pos + password_src_dim), TEXTFIELD_LIMIT);

		password.set_key_callback
		(
			KeyAction::Id::TAB, [&]
			{
				account.set_state(Textfield::State::FOCUSED);
				password.set_state(Textfield::State::NORMAL);
			}
		);

		password.set_enter_callback
		(
			[&](std::string msg)
			{
				login();
			}
		);

		password.set_cryptchar('*');
		password_bg = password_src;
#pragma endregion

		saveid = Setting<SaveLogin>::get().load();

		if (saveid)
		{
			account.change_text(Setting<DefaultAccount>::get().load());
			password.set_state(Textfield::State::FOCUSED);
		}
		else
		{
			account.set_state(Textfield::State::FOCUSED);
		}

		if (Configuration::get().get_auto_login())
		{
			UI::get().emplace<UILoginWait>([]() {});

			auto loginwait = UI::get().get_element<UILoginWait>();

			if (loginwait && loginwait->is_active())
				LoginPacket(
					Configuration::get().get_auto_acc(),
					Configuration::get().get_auto_pass()
				).dispatch();
		}
	}

	void UILogin::draw(float alpha) const
	{
		// Drawing login screen
		background.draw(position + Point<int16_t>(0, 7));

		// Draw sprites with debug info to identify which sprite is the large texture
		for (size_t i = 0; i < sprites.size(); i++) {
			GDEBUG("About to draw sprite " << i << " at position (" << position.x() << "," << position.y() << ")");
			sprites[i].draw(position, alpha);
		}

		// Draw buttons
		draw_buttons(alpha);

		version.draw(position + version_pos - Point<int16_t>(0, 5));
		account.draw(position + Point<int16_t>(5, 10));
		password.draw(position + Point<int16_t>(5, 13));

		if (account.get_state() == Textfield::State::NORMAL && account.empty())
			account_bg[nexon].draw(position + title_pos);

		if (password.get_state() == Textfield::State::NORMAL && password.empty())
			password_bg.draw(position + title_pos);

		bool has_capslocks = UI::get().has_capslocks();

		check[saveid].draw(position + title_pos);

		if (has_capslocks && account.get_state() == Textfield::State::FOCUSED)
			capslock.draw(position + title_pos - Point<int16_t>(0, account_src_dim.y()));

		if (has_capslocks && password.get_state() == Textfield::State::FOCUSED)
			capslock.draw(position + title_pos + Point<int16_t>(password_src_dim.x() - account_src_dim.x(), 0));
	}

	void UILogin::update()
	{
		UIElement::update();

		account.update();
		password.update();
	}

	void UILogin::login()
	{
		account.set_state(Textfield::State::DISABLED);
		password.set_state(Textfield::State::DISABLED);

		std::string account_text = account.get_text();
		std::string password_text = password.get_text();

		std::function<void()> okhandler = [&, password_text]()
		{
			account.set_state(Textfield::State::NORMAL);
			password.set_state(Textfield::State::NORMAL);

			if (!password_text.empty())
				password.set_state(Textfield::State::FOCUSED);
			else
				account.set_state(Textfield::State::FOCUSED);
		};

		if (account_text.empty())
		{
			UI::get().emplace<UILoginNotice>(UILoginNotice::Message::NOT_REGISTERED, okhandler);
			return;
		}

		if (password_text.length() <= 4)
		{
			UI::get().emplace<UILoginNotice>(UILoginNotice::Message::WRONG_PASSWORD, okhandler);
			return;
		}

		UI::get().emplace<UILoginWait>(okhandler);

		auto loginwait = UI::get().get_element<UILoginWait>();

		if (loginwait && loginwait->is_active())
		{
			// TODO: Implement login with email
			if (nexon)
				LoginEmailPacket(account_text, password_text).dispatch();
			else
				LoginPacket(account_text, password_text).dispatch();
		}
	}

	void UILogin::open_url(uint16_t id)
	{
		std::string url;

		switch (id)
		{
			case Buttons::BtNew:
				url = Configuration::get().get_joinlink();
				break;
			case Buttons::BtHomePage:
				url = Configuration::get().get_website();
				break;
			case Buttons::BtPasswdLost:
				url = Configuration::get().get_findpass();
				break;
			case Buttons::BtEmailLost:
				url = Configuration::get().get_findid();
				break;
			default:
				return;
		}

		ShellExecuteA(NULL, "open", url.c_str(), NULL, NULL, SW_SHOWNORMAL);
	}

	Button::State UILogin::button_pressed(uint16_t id)
	{
		switch (id)
		{
			case Buttons::BtLogin:
			{
				login();

				return Button::State::NORMAL;
			}
			case Buttons::BtNew:
			case Buttons::BtHomePage:
			case Buttons::BtPasswdLost:
			case Buttons::BtEmailLost:
			{
				open_url(id);

				return Button::State::NORMAL;
			}
			case Buttons::BtEmailSave:
			{
				saveid = !saveid;

				Setting<SaveLogin>::get().save(saveid);

				return Button::State::MOUSEOVER;
			}
			case Buttons::BtQuit:
			{
				UI::get().quit();

				return Button::State::PRESSED;
			}
			case Buttons::BtMapleID:
			{
				nexon = false;

				buttons[Buttons::BtNexonID]->set_state(Button::State::NORMAL);

				account.change_text("");
				password.change_text("");

				account.set_limit(TEXTFIELD_LIMIT);

				return Button::State::PRESSED;
			}
			case Buttons::BtNexonID:
			{
				nexon = true;

				buttons[Buttons::BtMapleID]->set_state(Button::State::NORMAL);

				account.change_text("");
				password.change_text("");
				
				account.set_limit(72);

				return Button::State::PRESSED;
			}
			default:
			{
				return Button::State::DISABLED;
			}
		}
	}

	Cursor::State UILogin::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		if (Cursor::State new_state = account.send_cursor(cursorpos, clicked))
			return new_state;

		if (Cursor::State new_state = password.send_cursor(cursorpos, clicked))
			return new_state;

		return UIElement::send_cursor(clicked, cursorpos);
	}

	UIElement::Type UILogin::get_type() const
	{
		return TYPE;
	}
}

================
File: IO/UITypes/UILogin.cpp.backup
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UILogin.h"

#include "UILoginNotice.h"
#include "UILoginWait.h"

#include "../UI.h"

#include "../Components/MapleButton.h"
#include "../Components/TwoSpriteButton.h"

#include "../../Audio/Audio.h"

#include "../../Net/Packets/LoginPackets.h"

#include <windows.h>
#include <iostream>

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UILogin::UILogin() : UIElement(Point<int16_t>(0, 0), Point<int16_t>(1024, 768)), title_pos(Point<int16_t>(344, 246)), nexon(false)
	{
		std::cout << "=========================" << std::endl;
		std::cout << "[DEBUG] UILogin constructor started - REBUILT VERSION!" << std::endl;
		std::cout << "=========================" << std::endl;
		std::string LoginMusicNewtro = Configuration::get().get_login_music_newtro();

		Music(LoginMusicNewtro).play();

		std::string version_text = Configuration::get().get_version();
		version = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::LEMONGRASS, "Ver. " + version_text);
		version_pos = nl::nx::UI["Login.img"]["Common"]["version"]["pos"];

		nl::node Login = nl::nx::UI["Login.img"];
		version_pos = Login["Common"]["version"]["pos"];

		nl::node Title_new = Login["Title_new"];
		capslock = Title_new["capslock"];

		nl::node check_src = Title_new["check"];
		check[false] = check_src["0"];
		check[true] = check_src["1"];

		// Try multiple paths for v83 compatibility with debug logging
		nl::node login_bg;
		
		std::cout << "[DEBUG] Loading login background assets..." << std::endl;
		std::cout << "[DEBUG] Map.name(): '" << nl::nx::Map.name() << "'" << std::endl;
		std::cout << "[DEBUG] Map001.name(): '" << nl::nx::Map001.name() << "'" << std::endl;
		std::cout << "[DEBUG] UI.name(): '" << nl::nx::UI.name() << "'" << std::endl;
		
		// Try Map001 fallback (should work if our fallback system works)
		login_bg = nl::nx::Map001["Back"]["UI_login.img"]["back"]["0"];
		std::cout << "[DEBUG] Map001[Back][UI_login.img][back][0] result: '" << login_bg.name() << "'" << std::endl;
		
		if (login_bg.name().empty()) {
			// Try direct Map path (v83)
			login_bg = nl::nx::Map["Back"]["UI_login.img"]["back"]["0"];
			std::cout << "[DEBUG] Map[Back][UI_login.img][back][0] result: '" << login_bg.name() << "'" << std::endl;
		}
		if (login_bg.name().empty()) {
			// Try UI Login.img path (alternative v83 location)
			login_bg = nl::nx::UI["Login.img"]["back"]["0"];
			std::cout << "[DEBUG] UI[Login.img][back][0] result: '" << login_bg.name() << "'" << std::endl;
		}
		if (login_bg.name().empty()) {
			// Try Title_new backgrd as fallback
			login_bg = Title_new["backgrd"];
			std::cout << "[DEBUG] Using Title_new[backgrd] fallback: '" << login_bg.name() << "'" << std::endl;
		}
		
		std::cout << "[DEBUG] Final login_bg node: '" << login_bg.name() << "'" << std::endl;
		
		sprites.emplace_back(login_bg, Point<int16_t>(512, 384));
		sprites.emplace_back(Title_new["backgrd"], title_pos);

		nl::node Tab = Title_new["Tab"];
		nl::node TabD = Tab["disabled"];
		nl::node TabE = Tab["enabled"];

		buttons[Buttons::BtLogin] = std::make_unique<MapleButton>(Title_new["BtLogin"], title_pos);
		buttons[Buttons::BtEmailSave] = std::make_unique<MapleButton>(Title_new["BtEmailSave"], title_pos);
		buttons[Buttons::BtEmailLost] = std::make_unique<MapleButton>(Title_new["BtEmailLost"], title_pos);
		buttons[Buttons::BtPasswdLost] = std::make_unique<MapleButton>(Title_new["BtPasswdLost"], title_pos);
		buttons[Buttons::BtNew] = std::make_unique<MapleButton>(Title_new["BtNew"], title_pos);
		buttons[Buttons::BtHomePage] = std::make_unique<MapleButton>(Title_new["BtHomePage"], title_pos);
		buttons[Buttons::BtQuit] = std::make_unique<MapleButton>(Title_new["BtQuit"], title_pos);
		buttons[Buttons::BtMapleID] = std::make_unique<TwoSpriteButton>(TabD["0"], TabE["0"], Point<int16_t>(344, 246));
		buttons[Buttons::BtNexonID] = std::make_unique<TwoSpriteButton>(TabD["1"], TabE["1"], Point<int16_t>(344, 246));

		if (nexon)
		{
			buttons[Buttons::BtNexonID]->set_state(Button::State::PRESSED);
			buttons[Buttons::BtMapleID]->set_state(Button::State::NORMAL);
		}
		else
		{
			buttons[Buttons::BtNexonID]->set_state(Button::State::NORMAL);
			buttons[Buttons::BtMapleID]->set_state(Button::State::PRESSED);
		}

		background = ColorBox(dimension.x(), dimension.y(), Color::Name::BLACK, 1.0f);

		Point<int16_t> textfield_pos = title_pos + Point<int16_t>(27, 69);

#pragma region Account
		Texture account_src = Texture(Title_new["mapleID"]);
		account_src_dim = account_src.get_dimensions();

		account = Textfield(Text::Font::A13M, Text::Alignment::LEFT, Color::Name::JAMBALAYA, Rectangle<int16_t>(textfield_pos, textfield_pos + account_src_dim), TEXTFIELD_LIMIT);

		account.set_key_callback
		(
			KeyAction::Id::TAB, [&]
			{
				account.set_state(Textfield::State::NORMAL);
				password.set_state(Textfield::State::FOCUSED);
			}
		);

		account.set_enter_callback
		(
			[&](std::string msg)
			{
				login();
			}
		);

		account_bg[false] = account_src;
		account_bg[true] = Title_new["nexonID"];
#pragma endregion

#pragma region Password
		textfield_pos.shift_y(account_src_dim.y() + 1);

		Texture password_src = Title_new["PW"];
		password_src_dim = password_src.get_dimensions();

		password = Textfield(Text::Font::A13M, Text::Alignment::LEFT, Color::Name::JAMBALAYA, Rectangle<int16_t>(textfield_pos, textfield_pos + password_src_dim), TEXTFIELD_LIMIT);

		password.set_key_callback
		(
			KeyAction::Id::TAB, [&]
			{
				account.set_state(Textfield::State::FOCUSED);
				password.set_state(Textfield::State::NORMAL);
			}
		);

		password.set_enter_callback
		(
			[&](std::string msg)
			{
				login();
			}
		);

		password.set_cryptchar('*');
		password_bg = password_src;
#pragma endregion

		saveid = Setting<SaveLogin>::get().load();

		if (saveid)
		{
			account.change_text(Setting<DefaultAccount>::get().load());
			password.set_state(Textfield::State::FOCUSED);
		}
		else
		{
			account.set_state(Textfield::State::FOCUSED);
		}

		if (Configuration::get().get_auto_login())
		{
			UI::get().emplace<UILoginWait>([]() {});

			auto loginwait = UI::get().get_element<UILoginWait>();

			if (loginwait && loginwait->is_active())
				LoginPacket(
					Configuration::get().get_auto_acc(),
					Configuration::get().get_auto_pass()
				).dispatch();
		}
	}

	void UILogin::draw(float alpha) const
	{
		background.draw(position + Point<int16_t>(0, 7));

		UIElement::draw(alpha);

		version.draw(position + version_pos - Point<int16_t>(0, 5));
		account.draw(position + Point<int16_t>(5, 10));
		password.draw(position + Point<int16_t>(5, 13));

		if (account.get_state() == Textfield::State::NORMAL && account.empty())
			account_bg[nexon].draw(position + title_pos);

		if (password.get_state() == Textfield::State::NORMAL && password.empty())
			password_bg.draw(position + title_pos);

		bool has_capslocks = UI::get().has_capslocks();

		check[saveid].draw(position + title_pos);

		if (has_capslocks && account.get_state() == Textfield::State::FOCUSED)
			capslock.draw(position + title_pos - Point<int16_t>(0, account_src_dim.y()));

		if (has_capslocks && password.get_state() == Textfield::State::FOCUSED)
			capslock.draw(position + title_pos + Point<int16_t>(password_src_dim.x() - account_src_dim.x(), 0));
	}

	void UILogin::update()
	{
		UIElement::update();

		account.update();
		password.update();
	}

	void UILogin::login()
	{
		account.set_state(Textfield::State::DISABLED);
		password.set_state(Textfield::State::DISABLED);

		std::string account_text = account.get_text();
		std::string password_text = password.get_text();

		std::function<void()> okhandler = [&, password_text]()
		{
			account.set_state(Textfield::State::NORMAL);
			password.set_state(Textfield::State::NORMAL);

			if (!password_text.empty())
				password.set_state(Textfield::State::FOCUSED);
			else
				account.set_state(Textfield::State::FOCUSED);
		};

		if (account_text.empty())
		{
			UI::get().emplace<UILoginNotice>(UILoginNotice::Message::NOT_REGISTERED, okhandler);
			return;
		}

		if (password_text.length() <= 4)
		{
			UI::get().emplace<UILoginNotice>(UILoginNotice::Message::WRONG_PASSWORD, okhandler);
			return;
		}

		UI::get().emplace<UILoginWait>(okhandler);

		auto loginwait = UI::get().get_element<UILoginWait>();

		if (loginwait && loginwait->is_active())
		{
			// TODO: Implement login with email
			if (nexon)
				LoginEmailPacket(account_text, password_text).dispatch();
			else
				LoginPacket(account_text, password_text).dispatch();
		}
	}

	void UILogin::open_url(uint16_t id)
	{
		std::string url;

		switch (id)
		{
			case Buttons::BtNew:
				url = Configuration::get().get_joinlink();
				break;
			case Buttons::BtHomePage:
				url = Configuration::get().get_website();
				break;
			case Buttons::BtPasswdLost:
				url = Configuration::get().get_findpass();
				break;
			case Buttons::BtEmailLost:
				url = Configuration::get().get_findid();
				break;
			default:
				return;
		}

		ShellExecuteA(NULL, "open", url.c_str(), NULL, NULL, SW_SHOWNORMAL);
	}

	Button::State UILogin::button_pressed(uint16_t id)
	{
		switch (id)
		{
			case Buttons::BtLogin:
			{
				login();

				return Button::State::NORMAL;
			}
			case Buttons::BtNew:
			case Buttons::BtHomePage:
			case Buttons::BtPasswdLost:
			case Buttons::BtEmailLost:
			{
				open_url(id);

				return Button::State::NORMAL;
			}
			case Buttons::BtEmailSave:
			{
				saveid = !saveid;

				Setting<SaveLogin>::get().save(saveid);

				return Button::State::MOUSEOVER;
			}
			case Buttons::BtQuit:
			{
				UI::get().quit();

				return Button::State::PRESSED;
			}
			case Buttons::BtMapleID:
			{
				nexon = false;

				buttons[Buttons::BtNexonID]->set_state(Button::State::NORMAL);

				account.change_text("");
				password.change_text("");

				account.set_limit(TEXTFIELD_LIMIT);

				return Button::State::PRESSED;
			}
			case Buttons::BtNexonID:
			{
				nexon = true;

				buttons[Buttons::BtMapleID]->set_state(Button::State::NORMAL);

				account.change_text("");
				password.change_text("");
				
				account.set_limit(72);

				return Button::State::PRESSED;
			}
			default:
			{
				return Button::State::DISABLED;
			}
		}
	}

	Cursor::State UILogin::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		if (Cursor::State new_state = account.send_cursor(cursorpos, clicked))
			return new_state;

		if (Cursor::State new_state = password.send_cursor(cursorpos, clicked))
			return new_state;

		return UIElement::send_cursor(clicked, cursorpos);
	}

	UIElement::Type UILogin::get_type() const
	{
		return TYPE;
	}
}

================
File: IO/UITypes/UILogin.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../Components/Textfield.h"

#include "../../Graphics/Geometry.h"
#include "../../Template/BoolPair.h"

namespace ms
{
	class UILogin : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::LOGIN;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = false;

		UILogin();

		void draw(float alpha) const override;
		void update() override;

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursor_pos) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t id) override;

	private:
		static constexpr int16_t TEXTFIELD_LIMIT = 12;

		void login();
		void open_url(uint16_t id);

		enum Buttons
		{
			BtLogin,
			BtNew,
			BtHomePage,
			BtPasswdLost,
			BtEmailLost,
			BtEmailSave,
			BtQuit,
			BtMapleID,
			BtNexonID,
			NUM_BUTTONS
		};

		Text version;
		Point<int16_t> version_pos;
		Textfield account;
		Point<int16_t> account_src_dim;
		BoolPair<Texture> account_bg;
		Textfield password;
		Point<int16_t> password_src_dim;
		Texture password_bg;
		BoolPair<Texture> check;
		Texture capslock;
		ColorBox background;
		Point<int16_t> title_pos;

		bool saveid;
		bool nexon;
	};
}

================
File: IO/UITypes/UILoginNotice.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UILoginNotice.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#include "../../Audio/Audio.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UILoginNotice::UILoginNotice(uint16_t message, std::function<void()> okhandler, std::function<void()> cancelhandler) : okhandler(okhandler), cancelhandler(cancelhandler)
	{
		multiple = false;

		nl::node Notice = nl::nx::UI["Login.img"]["Notice"];
		nl::node backgrnd;

		switch (message)
		{
			case Message::NAME_IN_USE:
			case Message::ILLEGAL_NAME:
			case Message::BLOCKED_ID:
			case Message::INCORRECT_PIC:
				backgrnd = Notice["backgrnd"]["1"];
				break;
			default:
				backgrnd = Notice["backgrnd"]["0"];
				break;
		}

		sprites.emplace_back(backgrnd);
		sprites.emplace_back(Notice["text"][message], Point<int16_t>(17, 13));

		if (message == Message::DELETE_CONFIRMATION || message == Message::CASH_ITEMS_CONFIRM_DELETION)
		{
			multiple = true;

			buttons[Buttons::YES] = std::make_unique<MapleButton>(Notice["BtYes"], Point<int16_t>(70, 106));
			buttons[Buttons::NO] = std::make_unique<MapleButton>(Notice["BtNo"], Point<int16_t>(130, 106));
		}
		else
		{
			buttons[Buttons::YES] = std::make_unique<MapleButton>(Notice["BtYes"], Point<int16_t>(100, 106));
		}

		position = Point<int16_t>(388, 313);
		dimension = Texture(backgrnd).get_dimensions();
	}

	UILoginNotice::UILoginNotice(uint16_t message, std::function<void()> okhandler) : UILoginNotice(message, okhandler, []() {}) {}
	UILoginNotice::UILoginNotice(uint16_t message) : UILoginNotice(message, []() {}) {}

	void UILoginNotice::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
			{
				if (!multiple)
					okhandler();
				else
					cancelhandler();

				deactivate();
			}
			else if (keycode == KeyAction::RETURN)
			{
				okhandler();
				deactivate();
			}
		}
	}

	UIElement::Type UILoginNotice::get_type() const
	{
		return TYPE;
	}

	Button::State UILoginNotice::button_pressed(uint16_t buttonid)
	{
		if (buttonid == Buttons::YES)
			okhandler();
		else if (buttonid == Buttons::NO)
			cancelhandler();

		deactivate();

		return Button::State::NORMAL;
	}

	UIQuitConfirm::UIQuitConfirm()
	{
		nl::node notice = nl::nx::UI["Login.img"]["Notice"];
		nl::node backgrnd = notice["backgrnd"]["0"];

		sprites.emplace_back(backgrnd);
		sprites.emplace_back(notice["text"][UILoginNotice::Message::CONFIRM_EXIT], Point<int16_t>(17, 13));

		buttons[Buttons::BT_OK] = std::make_unique<MapleButton>(notice["BtYes"], Point<int16_t>(68, 106));
		buttons[Buttons::BT_CANCEL] = std::make_unique<MapleButton>(notice["BtNo"], Point<int16_t>(129, 106));

		position = Point<int16_t>(387, 293);
		dimension = Texture(backgrnd).get_dimensions();
	}

	void UIQuitConfirm::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
			{
				deactivate();
			}
			else if (keycode == KeyAction::RETURN)
			{
				UI::get().quit();
				deactivate();
			}
		}
	}

	UIElement::Type UIQuitConfirm::get_type() const
	{
		return TYPE;
	}

	Button::State UIQuitConfirm::button_pressed(uint16_t buttonid)
	{
		if (buttonid == BT_OK)
			UI::get().quit();

		deactivate();

		return Button::PRESSED;
	}

	UIClassConfirm::UIClassConfirm(uint16_t selected_class, bool unavailable, std::function<void()> okhandler) : okhandler(okhandler)
	{
		nl::node RaceSelect = nl::nx::UI["Login.img"]["RaceSelect_new"];
		nl::node type = unavailable ? RaceSelect["deny"] : RaceSelect["confirm"];
		nl::node backgrnd = type["backgrnd"];
		nl::node race = type["race"][selected_class];

		int16_t backgrnd_x = Texture(backgrnd).get_dimensions().x();
		int16_t race_x = Texture(race).get_dimensions().x();

		int16_t pos_x = (backgrnd_x - race_x) / 2;

		sprites.emplace_back(backgrnd);
		sprites.emplace_back(race, Point<int16_t>(pos_x, 10) + (Point<int16_t>)race["origin"]);

		if (unavailable)
		{
			buttons[Buttons::OK] = std::make_unique<MapleButton>(type["BtOK"]);
		}
		else
		{
			buttons[Buttons::OK] = std::make_unique<MapleButton>(type["BtOK"], Point<int16_t>(62, 107));
			buttons[Buttons::CANCEL] = std::make_unique<MapleButton>(type["BtCancel"], Point<int16_t>(137, 107));
		}

		position = Point<int16_t>(398, 273);
		dimension = Texture(backgrnd).get_dimensions();
	}

	Cursor::State UIClassConfirm::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		for (auto& btit : buttons)
		{
			if (btit.second->is_active() && btit.second->bounds(position).contains(cursorpos))
			{
				if (btit.second->get_state() == Button::State::NORMAL)
				{
					Sound(Sound::Name::BUTTONOVER).play();

					btit.second->set_state(Button::State::MOUSEOVER);
				}
				else if (btit.second->get_state() == Button::State::MOUSEOVER)
				{
					if (clicked)
					{
						Sound(Sound::Name::BUTTONCLICK).play();

						btit.second->set_state(button_pressed(btit.first));
					}
				}
			}
			else if (btit.second->get_state() == Button::State::MOUSEOVER)
			{
				btit.second->set_state(Button::State::NORMAL);
			}
		}

		return Cursor::State::LEAF;
	}

	void UIClassConfirm::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
				deactivate();
			else if (keycode == KeyAction::Id::RETURN)
				button_pressed(Buttons::OK);
		}
	}

	UIElement::Type UIClassConfirm::get_type() const
	{
		return TYPE;
	}

	Button::State UIClassConfirm::button_pressed(uint16_t buttonid)
	{
		deactivate();

		if (buttonid == Buttons::OK)
			okhandler();

		return Button::State::NORMAL;
	}

	UIKeySelect::UIKeySelect(std::function<void(bool)> oh, bool l) : okhandler(oh), login(l)
	{
		nl::node KeyType = nl::nx::UI["UIWindow2.img"]["KeyConfig"]["KeyType"];
		nl::node backgrnd = KeyType["backgrnd"];

		sprites.emplace_back(backgrnd);

		buttons[Buttons::CLOSE] = std::make_unique<MapleButton>(KeyType["btClose"]);
		buttons[Buttons::TYPEA] = std::make_unique<MapleButton>(KeyType["btTypeA"]);
		buttons[Buttons::TYPEB] = std::make_unique<MapleButton>(KeyType["btTypeB"], Point<int16_t>(1, 1));

		if (login)
			buttons[Buttons::CLOSE]->set_active(false);

		position = Point<int16_t>(293, 229);
		dimension = Texture(backgrnd).get_dimensions();
	}

	void UIKeySelect::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed && !login)
			if (escape || keycode == KeyAction::Id::RETURN)
				deactivate();
	}

	UIElement::Type UIKeySelect::get_type() const
	{
		return TYPE;
	}

	Button::State UIKeySelect::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			default:
			case Buttons::CLOSE:
				deactivate();
				break;
			case Buttons::TYPEA:
			case Buttons::TYPEB:
			{
				bool alternate = (buttonid == Buttons::TYPEA) ? false : true;

				if (alternate)
					buttons[Buttons::TYPEA]->set_state(Button::State::DISABLED);
				else
					buttons[Buttons::TYPEB]->set_state(Button::State::DISABLED);

				auto onok = [&, alternate]()
				{
					okhandler(alternate);
					deactivate();
				};

				UI::get().emplace<UIKeyConfirm>(alternate, onok, login);
				break;
			}
		}

		return Button::State::DISABLED;
	}

	UIKeyConfirm::UIKeyConfirm(bool alternate, std::function<void()> oh, bool l) : okhandler(oh), login(l)
	{
		nl::node alert = nl::nx::UI["UIWindow2.img"]["KeyConfig"]["KeyType"]["alert"];
		nl::node background = alternate ? alert["alternate"] : alert["default"];

		sprites.emplace_back(background);

		buttons[Buttons::OK] = std::make_unique<MapleButton>(alert["btOk"]);

		position = Point<int16_t>(388, 313);
		dimension = Texture(background).get_dimensions();
	}

	void UIKeyConfirm::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (keycode == KeyAction::Id::RETURN)
			{
				confirm();
			}
			else if (!login && escape)
			{
				deactivate();

				UI::get().remove(UIElement::Type::LOGINNOTICE);
			}
		}
	}

	UIElement::Type UIKeyConfirm::get_type() const
	{
		return TYPE;
	}

	Button::State UIKeyConfirm::button_pressed(uint16_t buttonid)
	{
		confirm();

		return Button::State::NORMAL;
	}

	void UIKeyConfirm::confirm()
	{
		okhandler();
		deactivate();

		UI::get().remove(UIElement::Type::LOGINNOTICE);
	}
}

================
File: IO/UITypes/UILoginNotice.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

namespace ms
{
	class UIKeyConfirm : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::LOGINNOTICE_CONFIRM;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = false;

		UIKeyConfirm(bool alternate, std::function<void()> oh, bool login);

		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void confirm();

		enum Buttons
		{
			OK
		};

		std::function<void()> okhandler;
		bool login;
	};

	class UIKeySelect : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::LOGINNOTICE;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = false;

		UIKeySelect(std::function<void(bool)> okhandler, bool login);

		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		enum Buttons
		{
			CLOSE,
			TYPEA,
			TYPEB
		};

		std::function<void(bool)> okhandler;
		bool login;
	};

	class UIClassConfirm : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::LOGINNOTICE;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = false;

		UIClassConfirm(uint16_t selected_class, bool unavailable, std::function<void()> okhandler);

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		enum Buttons : uint16_t
		{
			OK,
			CANCEL
		};

		std::function<void()> okhandler;
	};

	class UIQuitConfirm : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::LOGINNOTICE;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = false;

		UIQuitConfirm();

		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		enum Buttons
		{
			BT_OK,
			BT_CANCEL
		};
	};

	class UILoginNotice : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::LOGINNOTICE;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = false;

		enum Message : uint16_t
		{
			VULGAR_NAME,
			DELETE_CHAR_ENTER_BIRTHDAY,
			WRONG_EMAIL,
			WRONG_PASSWORD,
			INCORRECT_EMAIL,
			NAME_IN_USE,
			NAME_OK,
			RETURN_TO_FIRST_PAGE,
			NAME_IN_USE2,
			FULL_CHARACTER_SLOTS,
			ILLEGAL_NAME,
			BIRTHDAY_INCORRECT,
			PRESS_CHECK_BUTTON,
			DELETE_CONFIRMATION,
			MATURE_CHANNEL,
			TROUBLE_LOGGING_IN,
			BLOCKED_ID,
			ALREADY_LOGGED_IN,
			UNKNOWN_ERROR,
			TOO_MANY_REQUESTS,
			NOT_REGISTERED,
			UNABLE_TO_LOGIN_WITH_IP,
			UNABLE_TO_LOGIN,
			UNABLE_TO_CONNECT,
			AN_ERROR_OCCURED,
			AN_ERROR_OCCURED_DETAILED,
			CANNOT_ACCESS_ACCOUNT,
			WRONG_GATEWAY,
			INCORRECT_LOGINID,
			INCORRECT_FORM,
			VERIFICATION_NOTICE_7,
			VERIFICATION_NOTICE_30,
			KOREAN,
			VERIFY_EMAIL,
			CANNOT_DELETE_GUILD_LEADER,
			SUSPICIOUS_PROGRAMS,
			POPULATION_TOO_HIGH,
			SELECT_A_CHANNEL,
			GAME_GUARD_UPDATED,
			CANNOT_DELETE_ENGAGED,
			PLEASE_SIGN_UP,
			PASSWORD_IS_INCORRECT,
			SECOND_PASSWORD_INCORRECT,
			TEMPORARY_IP_BAN,
			DISABLE_SAFETY_MEASURE,
			SECOND_PASSWORD_NOT_DIFFERENT,
			CANNOT_DELETE_ENGAGED2,
			KOREAN2,
			KOREAN3,
			KOREAN4,
			KOREAN5,
			KOREAN6,
			KOREAN7,
			CONFIRM_EXIT,
			CANNOT_DELETE_FAMILY_LEADER,
			CASH_ITEMS_CONFIRM_DELETION,
			KOREAN8,
			FAMILY_CONFIRM_DELETION,
			FAMILY_AND_CASH_ITEMS_CONFIRM_DELETION,
			KOREAN9,
			KOREAN10,
			IDENTITY_VERIFICATION_REQ_ERROR,
			KOREAN11,
			LOGIN_FAIL_SERVER_OVERBURDEN,
			KOREAN12,
			KOREAN13,
			KOREAN14,
			KOREAN15,
			IDENTITY_VERIFICATION_REQ,
			PART_TIME_JOB_ACTIVE,
			DEL_CHAR_FAIL_HIRED_MERCH_ACTIVE,
			SET_SEC_PASS,
			SEC_PASS_AUTH_FAIL,
			EMAIL_ID_FAIL_USE_MAPLE_ID,
			LOGIN_USING_EMAIL_ID,
			MAPLE_ID_REQ,
			MAPLE_ID_SUCCESS,
			MAPLE_ID_FAIL,
			LOGIN_USING_MAPLE_ID_OR_EMAIL_ID,
			DEL_CHAR_FAIL_ACTIVE_ITEM_GUARD,
			MAPLE_ID_SUCCESS_BOLD,
			CHARACTER_RANGE_FAILED,
			MAPLE_ID_ALREADY_EXISTS,
			MAPLE_ID_ONLY_LETTERS_AND_NUMS,
			MAPLE_ID_EMAIL_ID_NOT_AUTH,
			MAPLE_ID_ALREADY_CREATED_TODAY,
			MAPLE_ID_MAX_LIMIT_REACHED_BLOCK,
			MAPLE_ID_MAX_LIMIT_REACHED_CREATE,
			KOREAN16,
			UNDER_AGE,
			UNDER_AGE2,
			PIC_SAME_AS_PASSWORD,
			PIC_CONTAINS_PIN,
			INCORRECT_PIC,
			CHAR_DEL_FAIL_NO_PIC,
			PIC_REQ,
			OTP_SERVICE_IN_USE,
			CHAR_DEL_FAIL_OTP_SERVICE,
			SEC_PASS_CHANGE_FAIL_OTP_SERVICE,
			CLIENT_ALREADY_RUNNING,
			CHAR_TRANS_SUCCESS = 105,
			CHAR_DEL_FAIL_MAX_LIMIT_REACHED,
			OVERSEAS_LOGIN_BLOCKED,
			DEL_CHAR_FAIL_ITEMS_IN_AUC_HOUSE,
			ENTER_STAR_PLANET_CONF_SEL_CHAR,
			ENTER_STAR_PLANET_CONF_STAR_PLANET_CHAR,
			CREATE_SHINING_STAR_CHAR_CONF,
			CLASS_UNAVAILABLE,
			START_PLANET_FAIL_LV_33_REQ,
			PIC_ACTIVATED = 902,
			PIC_DEACTIVATED,
			CHANNEL_SEL_REQ,
			GAMEGUARD_UPDATE_REQ,
			IP_BLOCK_GMS,
			PIC_USED_TOO_FREQ,
			PIC_CHANGES_REQ_FROM_WEB,
			PIC_UNSECURE,
			PIC_STALE,
			PIC_REPITIVE,
			NEW_PIC_REQ,
			JAPANESE = 10000,
			JAPANESE2
		};

		UILoginNotice(uint16_t message, std::function<void()> okhandler, std::function<void()> cancelhandler);
		UILoginNotice(uint16_t message, std::function<void()> okhandler);
		UILoginNotice(uint16_t message);

		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		enum Buttons : uint16_t
		{
			YES,
			NO
		};

		bool saveid;
		bool multiple;
		std::function<void()> okhandler;
		std::function<void()> cancelhandler;
	};
}

================
File: IO/UITypes/UILoginWait.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UILoginWait.h"

#include "../Components/MapleButton.h"

#include "../../Net/Session.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UILoginWait::UILoginWait() : UILoginWait([]() {}) {}

	UILoginWait::UILoginWait(std::function<void()> okhandler) : okhandler(okhandler)
	{
		nl::node Loading = nl::nx::UI["Login.img"]["Notice"]["Loading"];
		nl::node backgrnd = Loading["backgrnd"];

		sprites.emplace_back(backgrnd, Point<int16_t>(112, 84));
		sprites.emplace_back(Loading["circle"], Point<int16_t>(239, 154));

		buttons[Buttons::BtCancel] = std::make_unique<MapleButton>(Loading["BtCancel"], Point<int16_t>(110, 80));

		position = Point<int16_t>(276, 229);
		dimension = Texture(backgrnd).get_dimensions();
	}

	UIElement::Type UILoginWait::get_type() const
	{
		return TYPE;
	}

	void UILoginWait::close()
	{
		deactivate();
		okhandler();
	}

	std::function<void()> UILoginWait::get_handler()
	{
		return okhandler;
	}

	Button::State UILoginWait::button_pressed(uint16_t id)
	{
		Session::get().reconnect();

		close();

		return Button::State::NORMAL;
	}
}

================
File: IO/UITypes/UILoginWait.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

namespace ms
{
	class UILoginWait : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::LOGINWAIT;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = false;

		UILoginWait();
		UILoginWait(std::function<void()> okhandler);

		UIElement::Type get_type() const override;

		void close();
		std::function<void()> get_handler();

	protected:
		Button::State button_pressed(uint16_t id) override;

	private:
		enum Buttons : uint16_t
		{
			BtCancel
		};

		std::function<void()> okhandler;
	};
}

================
File: IO/UITypes/UILogo.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UILogo.h"

#include "UILogin.h"

#include "../../Configuration.h"

#include "../../Audio/Audio.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UILogo::UILogo() : UIElement(Point<int16_t>(0, 0), Point<int16_t>(800, 600))
	{
		Music("BgmUI.img/NxLogo").play_once();

		if (Configuration::get().get_auto_login())
			wizet_ended = true;
		else
			wizet_ended = false;

		user_clicked = false;

		nl::node Logo = nl::nx::UI["Logo.img"];

		Wizet = Logo["Wizet"];
		WizetEnd = Logo["Wizet"]["28"];
	}

	void UILogo::draw(float inter) const
	{
		if (!user_clicked)
		{
			if (!wizet_ended)
				Wizet.draw(position, inter);
			else
				WizetEnd.draw(position);
		}
		else
		{
			WizetEnd.draw(position);
		}
	}

	void UILogo::update()
	{
		if (!wizet_ended)
		{
			wizet_ended = Wizet.update(3);
		}
		else
		{
			Configuration::get().set_start_shown(true);

			UI::get().remove(UIElement::Type::START);
			UI::get().emplace<UILogin>();
		}
	}

	Cursor::State UILogo::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		Cursor::State ret = clicked ? Cursor::State::CLICKING : Cursor::State::IDLE;

		if (clicked && !user_clicked)
			user_clicked = true;

		return ret;
	}

	UIElement::Type UILogo::get_type() const
	{
		return TYPE;
	}
}

================
File: IO/UITypes/UILogo.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UI.h"

namespace ms
{
	class UILogo : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::START;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = false;

		UILogo();

		void draw(float inter) const override;
		void update() override;

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;

		UIElement::Type get_type() const override;

	private:
		Animation Wizet;
		Texture WizetEnd;

		bool wizet_ended;
		bool user_clicked;
	};
}

================
File: IO/UITypes/UIMiniMap.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIMiniMap.h"

#include "UIWorldMap.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#include "../../Gameplay/MapleMap/Npc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIMiniMap::UIMiniMap(const CharStats& stats) : UIDragElement<PosMINIMAP>(Point<int16_t>(128, 20)), stats(stats)
	{
		big_map = true;
		has_map = false;
		listNpc_enabled = false;
		listNpc_dimensions = Point<int16_t>(150, 170);
		listNpc_offset = 0;
		selected = -1;

		type = Setting<MiniMapType>::get().load();
		user_type = type;
		simpleMode = Setting<MiniMapSimpleMode>::get().load();

		nl::node UIWindow2 = nl::nx::UI["UIWindow2.img"];

		std::string node = simpleMode ? "MiniMapSimpleMode" : "MiniMap";
		MiniMap = UIWindow2[node];
		listNpc = UIWindow2["MiniMap"]["ListNpc"];
		MapHelper = nl::nx::Map["MapHelper.img"];

		buttons[Buttons::BT_MIN] = std::make_unique<MapleButton>(MiniMap["BtMin"], Point<int16_t>(195, -6));
		buttons[Buttons::BT_MAX] = std::make_unique<MapleButton>(MiniMap["BtMax"], Point<int16_t>(209, -6));
		buttons[Buttons::BT_SMALL] = std::make_unique<MapleButton>(MiniMap["BtSmall"], Point<int16_t>(223, -6));
		buttons[Buttons::BT_BIG] = std::make_unique<MapleButton>(MiniMap["BtBig"], Point<int16_t>(223, -6));
		buttons[Buttons::BT_MAP] = std::make_unique<MapleButton>(MiniMap["BtMap"], Point<int16_t>(237, -6));
		buttons[Buttons::BT_NPC] = std::make_unique<MapleButton>(MiniMap["BtNpc"], Point<int16_t>(276, -6));

		region_text = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::WHITE);
		town_text = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::WHITE);
		combined_text = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::WHITE);

		marker = Setting<MiniMapDefaultHelpers>::get().load() ? UIWindow2["MiniMapSimpleMode"]["DefaultHelper"] : MapHelper["minimap"];

		player_marker = Animation(marker["user"]);
		selected_marker = Animation(MiniMap["iconNpc"]);
	}

	void UIMiniMap::draw(float alpha) const
	{
		if (type == Type::MIN)
		{
			for (Sprite sprite : min_sprites)
				sprite.draw(position, alpha);

			combined_text.draw(position + Point<int16_t>(7, -3));
		}
		else if (type == Type::NORMAL)
		{
			for (Sprite sprite : normal_sprites)
				sprite.draw(position, alpha);

			if (has_map)
			{
				Animation portal_marker = Animation(marker["portal"]);

				for (auto& sprite : static_marker_info)
					portal_marker.draw(position + sprite.second, alpha);

				draw_movable_markers(position, alpha);

				if (listNpc_enabled)
					draw_npclist(normal_dimensions, alpha);
			}
		}
		else
		{
			for (Sprite sprite : max_sprites)
				sprite.draw(position, alpha);

			region_text.draw(position + Point<int16_t>(48, 14));
			town_text.draw(position + Point<int16_t>(48, 28));

			if (has_map)
			{
				Animation portal_marker(marker["portal"]);

				for (auto& sprite : static_marker_info)
					portal_marker.draw(position + sprite.second + Point<int16_t>(0, MAX_ADJ), alpha);

				draw_movable_markers(position + Point<int16_t>(0, MAX_ADJ), alpha);

				if (listNpc_enabled)
					draw_npclist(max_dimensions, alpha);
			}
		}

		UIElement::draw(alpha);
	}

	void UIMiniMap::update()
	{
		int32_t mid = Stage::get().get_mapid();

		if (mid != mapid)
		{
			mapid = mid;
			Map = NxHelper::Map::get_map_node_name(mapid);

			nl::node town = Map["info"]["town"];
			nl::node miniMap = Map["miniMap"];

			if (!miniMap)
			{
				has_map = false;
				type = Type::MIN;
			}
			else
			{
				has_map = true;

				if (town && town.get_bool())
					type = Type::MAX;
				else
					type = user_type;
			}

			scale = std::pow(2, (int)miniMap["mag"]);
			center_offset = Point<int16_t>(miniMap["centerX"], miniMap["centerY"]);

			update_text();
			update_buttons();
			update_canvas();
			update_static_markers();
			toggle_buttons();
			update_npclist();
		}

		if (type == Type::MIN)
		{
			for (Sprite sprite : min_sprites)
				sprite.update();
		}
		else if (type == Type::NORMAL)
		{
			for (Sprite sprite : normal_sprites)
				sprite.update();
		}
		else
		{
			for (Sprite sprite : max_sprites)
				sprite.update();
		}

		if (listNpc_enabled)
			for (Sprite sprite : listNpc_sprites)
				sprite.update();

		if (selected >= 0)
			selected_marker.update();

		UIElement::update();
	}

	void UIMiniMap::remove_cursor()
	{
		UIDragElement::remove_cursor();

		listNpc_slider.remove_cursor();

		UI::get().clear_tooltip(Tooltip::Parent::MINIMAP);
	}

	Cursor::State UIMiniMap::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		Cursor::State dstate = UIDragElement::send_cursor(clicked, cursorpos);

		if (dragged)
			return dstate;

		Point<int16_t> cursor_relative = cursorpos - position;

		if (listNpc_slider.isenabled())
			if (Cursor::State new_state = listNpc_slider.send_cursor(cursor_relative, clicked))
				return new_state;

		if (listNpc_enabled)
		{
			Point<int16_t> relative_point = cursor_relative - Point<int16_t>(10 + (type == Type::MAX ? max_dimensions : normal_dimensions).x(), 23);
			Rectangle<int16_t> list_bounds = Rectangle<int16_t>(0, LISTNPC_ITEM_WIDTH, 0, LISTNPC_ITEM_HEIGHT * 8);

			if (list_bounds.contains(relative_point))
			{
				int16_t list_index = listNpc_offset + relative_point.y() / LISTNPC_ITEM_HEIGHT;
				bool in_list = list_index < listNpc_names.size();

				if (clicked)
					select_npclist(in_list ? list_index : -1);
				else if (in_list)
					UI::get().show_text(Tooltip::Parent::MINIMAP, listNpc_full_names[list_index]);

				return Cursor::State::IDLE;
			}
		}

		bool found = false;
		auto npcs = Stage::get().get_npcs().get_npcs();

		for (auto npc = npcs->begin(); npc != npcs->end(); npc++)
		{
			Point<int16_t> npc_pos = (npc->second->get_position() + center_offset) / scale + Point<int16_t>(map_draw_origin_x, map_draw_origin_y);
			Rectangle<int16_t> marker_spot = Rectangle<int16_t>(npc_pos - Point<int16_t>(4, 8), npc_pos);

			if (type == Type::MAX)
				marker_spot.shift(Point<int16_t>(0, MAX_ADJ));

			if (marker_spot.contains(cursor_relative))
			{
				found = true;

				auto n = static_cast<Npc*>(npc->second.get());
				std::string name = n->get_name();
				std::string func = n->get_func();

				UI::get().show_map(Tooltip::Parent::MINIMAP, name, func, {}, false, false);
				break;
			}
		}

		if (!found)
		{
			for (auto& sprite : static_marker_info)
			{
				Rectangle<int16_t> marker_spot = Rectangle<int16_t>(sprite.second, sprite.second + 8);

				if (type == Type::MAX)
					marker_spot.shift(Point<int16_t>(0, MAX_ADJ));

				if (marker_spot.contains(cursor_relative))
				{
					nl::node portal_tm = Map["portal"][sprite.first]["tm"];
					std::string portal_cat = NxHelper::Map::get_map_category(portal_tm);
					nl::node portal_name = nl::nx::String["Map.img"][portal_cat][portal_tm]["mapName"];

					if (portal_name)
					{
						found = true;

						UI::get().show_map(Tooltip::Parent::MINIMAP, portal_name, "", portal_tm, false, true);
						break;
					}
				}
			}
		}

		return Cursor::State::IDLE;
	}

	void UIMiniMap::send_scroll(double yoffset)
	{
		if (listNpc_enabled && listNpc_slider.isenabled())
			listNpc_slider.send_scroll(yoffset);
	}

	void UIMiniMap::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (has_map)
		{
			if (type < Type::MAX)
				type++;
			else
				type = Type::MIN;

			user_type = type;

			toggle_buttons();
		}
	}

	Button::State UIMiniMap::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			case BT_MIN:
			{
				type -= 1;
				toggle_buttons();

				return type == Type::MIN ? Button::State::DISABLED : Button::State::NORMAL;
			}
			case BT_MAX:
			{
				type += 1;
				toggle_buttons();

				return type == Type::MAX ? Button::State::DISABLED : Button::State::NORMAL;
			}
			case BT_SMALL:
			case BT_BIG:
			{
				big_map = !big_map;
				// TODO: Toggle scrolling map
				toggle_buttons();
				break;
			}
			case BT_MAP:
			{
				UI::get().emplace<UIWorldMap>();
				break;
			}
			case BT_NPC:
			{
				set_npclist_active(!listNpc_enabled);
				break;
			}
		}

		return Button::State::NORMAL;
	}

	UIElement::Type UIMiniMap::get_type() const
	{
		return TYPE;
	}

	void UIMiniMap::update_buttons()
	{
		// Add one pixel for a space to the right of each button
		bt_min_width = buttons[Buttons::BT_MIN]->width() + 1;
		bt_max_width = buttons[Buttons::BT_MAX]->width() + 1;
		bt_map_width = buttons[Buttons::BT_MAP]->width() + 1;

		combined_text_width = combined_text.width();
	}

	void UIMiniMap::toggle_buttons()
	{
		int16_t bt_min_x;

		if (type == Type::MIN)
		{
			buttons[Buttons::BT_MAP]->set_active(true);
			buttons[Buttons::BT_MAX]->set_active(true);
			buttons[Buttons::BT_MIN]->set_active(true);
			buttons[Buttons::BT_NPC]->set_active(false);
			buttons[Buttons::BT_SMALL]->set_active(false);
			buttons[Buttons::BT_BIG]->set_active(false);

			buttons[Buttons::BT_MIN]->set_state(Button::State::DISABLED);

			if (has_map)
				buttons[Buttons::BT_MAX]->set_state(Button::State::NORMAL);
			else
				buttons[Buttons::BT_MAX]->set_state(Button::State::DISABLED);

			bt_min_x = combined_text_width + 11;

			buttons[Buttons::BT_MIN]->set_position(Point<int16_t>(bt_min_x, BTN_MIN_Y));

			bt_min_x += bt_min_width;

			buttons[Buttons::BT_MAX]->set_position(Point<int16_t>(bt_min_x, BTN_MIN_Y));

			bt_min_x += bt_max_width;

			buttons[Buttons::BT_MAP]->set_position(Point<int16_t>(bt_min_x, BTN_MIN_Y));

			min_dimensions = Point<int16_t>(bt_min_x + bt_map_width + 7, 20);

			update_dimensions();

			dragarea = dimension;

			set_npclist_active(false);
		}
		else
		{
			bool has_npcs = Stage::get().get_npcs().get_npcs()->size() > 0;

			buttons[Buttons::BT_MAP]->set_active(true);
			buttons[Buttons::BT_MAX]->set_active(true);
			buttons[Buttons::BT_MIN]->set_active(true);
			buttons[Buttons::BT_NPC]->set_active(has_npcs);

			if (big_map)
			{
				buttons[Buttons::BT_BIG]->set_active(false);
				buttons[Buttons::BT_SMALL]->set_active(true);
			}
			else
			{
				buttons[Buttons::BT_BIG]->set_active(true);
				buttons[Buttons::BT_SMALL]->set_active(false);
			}

			buttons[Buttons::BT_MIN]->set_state(Button::State::NORMAL);

			bt_min_x = middle_right_x - (bt_min_width + buttons[Buttons::BT_SMALL]->width() + 1 + bt_max_width + bt_map_width + (has_npcs ? buttons[Buttons::BT_NPC]->width() : 0));

			buttons[Buttons::BT_MIN]->set_position(Point<int16_t>(bt_min_x, BTN_MIN_Y));

			bt_min_x += bt_max_width;

			buttons[Buttons::BT_MAX]->set_position(Point<int16_t>(bt_min_x, BTN_MIN_Y));

			bt_min_x += bt_max_width;

			buttons[Buttons::BT_SMALL]->set_position(Point<int16_t>(bt_min_x, BTN_MIN_Y));
			buttons[Buttons::BT_BIG]->set_position(Point<int16_t>(bt_min_x, BTN_MIN_Y));

			bt_min_x += bt_max_width;

			buttons[Buttons::BT_MAP]->set_position(Point<int16_t>(bt_min_x, BTN_MIN_Y));

			bt_min_x += bt_map_width;

			buttons[Buttons::BT_NPC]->set_position(Point<int16_t>(bt_min_x, BTN_MIN_Y));

			if (type == Type::MAX)
				buttons[Buttons::BT_MAX]->set_state(Button::State::DISABLED);
			else
				buttons[Buttons::BT_MAX]->set_state(Button::State::NORMAL);

			set_npclist_active(listNpc_enabled && has_npcs);

			dragarea = Point<int16_t>(dimension.x(), 20);
		}
	}

	void UIMiniMap::update_text()
	{
		NxHelper::Map::MapInfo map_info = NxHelper::Map::get_map_info_by_id(mapid);
		combined_text.change_text(map_info.full_name);
		region_text.change_text(map_info.name);
		town_text.change_text(map_info.street_name);
	}

	void UIMiniMap::update_canvas()
	{
		min_sprites.clear();
		normal_sprites.clear();
		max_sprites.clear();

		nl::node Min, Normal, Max;

		if (simpleMode)
		{
			Min = MiniMap["Window"]["Min"];
			Normal = MiniMap["Window"]["Normal"];
			Max = MiniMap["Window"]["Max"];
		}
		else
		{
			Min = MiniMap["Min"];
			Normal = MiniMap["MinMap"];
			Max = MiniMap["MaxMap"];
		}

		map_sprite = Texture(Map["miniMap"]["canvas"]);
		Point<int16_t> map_dimensions = map_sprite.get_dimensions();

		// 48 (offset for text) + longer text's width + 10 (space for right side border)
		int16_t mark_text_width = 48 + std::max(region_text.width(), town_text.width()) + 10;
		int16_t c_stretch, ur_x_offset, m_stretch, down_y_offset;
		int16_t window_width = std::max(178, std::max((int)mark_text_width, map_dimensions.x() + 20));

		c_stretch = std::max(0, window_width - 128);
		ur_x_offset = CENTER_START_X + c_stretch;
		map_draw_origin_x = std::max(10, window_width / 2 - map_dimensions.x() / 2);

		if (map_dimensions.y() <= 20)
		{
			m_stretch = 5;
			down_y_offset = 17 + m_stretch;
			map_draw_origin_y = 10 + m_stretch - map_dimensions.y();
		}
		else
		{
			m_stretch = map_dimensions.y() - 17;
			down_y_offset = 17 + m_stretch;
			map_draw_origin_y = 20;
		}

		middle_right_x = ur_x_offset + 55;

		std::string Left = simpleMode ? "Left" : "w";
		std::string Center = simpleMode ? "Center" : "c";
		std::string Right = simpleMode ? "Right" : "e";

		std::string DownCenter = simpleMode ? "DownCenter" : "s";
		std::string DownLeft = simpleMode ? "DownLeft" : "sw";
		std::string DownRight = simpleMode ? "DownRight" : "se";
		std::string MiddleLeft = simpleMode ? "MiddleLeft" : "w";
		std::string MiddleRight = simpleMode ? "MiddleRight" : "e";
		std::string UpCenter = simpleMode ? "UpCenter" : "n";
		std::string UpLeft = simpleMode ? "UpLeft" : "nw";
		std::string UpRight = simpleMode ? "UpRight" : "ne";

		// SimpleMode's backdrop is opaque, the other is transparent but lightly colored
		// UI.wz v208 has normal center sprite in-linked to bottom right window frame, not sure why.
		nl::node MiddleCenter = simpleMode ? MiniMap["Window"]["Max"]["MiddleCenter"] : MiniMap["MaxMap"]["c"];

		int16_t dl_dr_y = std::max(map_dimensions.y(), (int16_t)10);

		// combined_text_width + 14 (7px buffer on both sides) + 4 (buffer between name and buttons) + 3 buttons' widths - 128 (length of left and right window borders)
		int16_t min_c_stretch = combined_text_width + 18 + bt_min_width + bt_max_width + bt_map_width - 128;

		// Min sprites queue
		min_sprites.emplace_back(Min[Center], DrawArgument(WINDOW_UL_POS + Point<int16_t>(CENTER_START_X, 0), Point<int16_t>(min_c_stretch, 0)));
		min_sprites.emplace_back(Min[Left], DrawArgument(WINDOW_UL_POS));
		min_sprites.emplace_back(Min[Right], DrawArgument(WINDOW_UL_POS + Point<int16_t>(min_c_stretch + CENTER_START_X, 0)));

		// Normal sprites queue
		// (7, 10) is the top left corner of the inner window
		// 114 = 128 (width of left and right borders) - 14 (width of middle borders * 2).
		// 27 = height of inner frame drawn on up and down borders
		normal_sprites.emplace_back(MiddleCenter, DrawArgument(Point<int16_t>(7, 10), Point<int16_t>(c_stretch + 114, m_stretch + 27)));

		if (has_map)
			normal_sprites.emplace_back(Map["miniMap"]["canvas"], DrawArgument(Point<int16_t>(map_draw_origin_x, map_draw_origin_y)));

		normal_sprites.emplace_back(Normal[MiddleLeft], DrawArgument(Point<int16_t>(0, ML_MR_Y), Point<int16_t>(0, m_stretch)));
		normal_sprites.emplace_back(Normal[MiddleRight], DrawArgument(Point<int16_t>(middle_right_x, ML_MR_Y), Point<int16_t>(0, m_stretch)));
		normal_sprites.emplace_back(Normal[UpCenter], DrawArgument(Point<int16_t>(CENTER_START_X, 0) + WINDOW_UL_POS, Point<int16_t>(c_stretch, 0)));
		normal_sprites.emplace_back(Normal[UpLeft], WINDOW_UL_POS);
		normal_sprites.emplace_back(Normal[UpRight], DrawArgument(Point<int16_t>(ur_x_offset, 0) + WINDOW_UL_POS));
		normal_sprites.emplace_back(Normal[DownCenter], DrawArgument(Point<int16_t>(CENTER_START_X, down_y_offset + 18), Point<int16_t>(c_stretch, 0)));
		normal_sprites.emplace_back(Normal[DownLeft], Point<int16_t>(0, down_y_offset));
		normal_sprites.emplace_back(Normal[DownRight], Point<int16_t>(ur_x_offset, down_y_offset));

		normal_dimensions = Point<int16_t>(ur_x_offset + 64, down_y_offset + 27);

		// Max sprites queue
		max_sprites.emplace_back(MiddleCenter, DrawArgument(Point<int16_t>(7, 50), Point<int16_t>(c_stretch + 114, m_stretch + 27)));

		if (has_map)
			max_sprites.emplace_back(Map["miniMap"]["canvas"], DrawArgument(Point<int16_t>(map_draw_origin_x, map_draw_origin_y + MAX_ADJ)));

		max_sprites.emplace_back(Max[MiddleLeft], DrawArgument(Point<int16_t>(0, ML_MR_Y + MAX_ADJ), Point<int16_t>(0, m_stretch)));
		max_sprites.emplace_back(Max[MiddleRight], DrawArgument(Point<int16_t>(middle_right_x, ML_MR_Y + MAX_ADJ), Point<int16_t>(0, m_stretch)));
		max_sprites.emplace_back(Max[UpCenter], DrawArgument(Point<int16_t>(CENTER_START_X, 0) + WINDOW_UL_POS, Point<int16_t>(c_stretch, 0)));
		max_sprites.emplace_back(Max[UpLeft], WINDOW_UL_POS);
		max_sprites.emplace_back(Max[UpRight], DrawArgument(Point<int16_t>(ur_x_offset, 0) + WINDOW_UL_POS));
		max_sprites.emplace_back(Max[DownCenter], DrawArgument(Point<int16_t>(CENTER_START_X, down_y_offset + MAX_ADJ + 18), Point<int16_t>(c_stretch, 0)));
		max_sprites.emplace_back(Max[DownLeft], Point<int16_t>(0, down_y_offset + MAX_ADJ));
		max_sprites.emplace_back(Max[DownRight], Point<int16_t>(ur_x_offset, down_y_offset + MAX_ADJ));
		max_sprites.emplace_back(MapHelper["mark"][Map["info"]["mapMark"]], DrawArgument(Point<int16_t>(7, 17)));

		max_dimensions = normal_dimensions + Point<int16_t>(0, MAX_ADJ);
	}

	void UIMiniMap::draw_movable_markers(Point<int16_t> init_pos, float alpha) const
	{
		if (!has_map)
			return;

		Animation marker_sprite;
		Point<int16_t> sprite_offset;

		/// NPCs
		MapObjects* npcs = Stage::get().get_npcs().get_npcs();
		marker_sprite = Animation(marker["npc"]);
		sprite_offset = marker_sprite.get_dimensions() / Point<int16_t>(2, 0);

		for (auto npc = npcs->begin(); npc != npcs->end(); ++npc)
		{
			Point<int16_t> npc_pos = npc->second.get()->get_position();
			marker_sprite.draw((npc_pos + center_offset) / scale - sprite_offset + Point<int16_t>(map_draw_origin_x, map_draw_origin_y) + init_pos, alpha);
		}

		/// Other characters
		MapObjects* chars = Stage::get().get_chars().get_chars();
		marker_sprite = Animation(marker["another"]);
		sprite_offset = marker_sprite.get_dimensions() / Point<int16_t>(2, 0);

		for (auto chr = chars->begin(); chr != chars->end(); ++chr)
		{
			Point<int16_t> chr_pos = chr->second.get()->get_position();
			marker_sprite.draw((chr_pos + center_offset) / scale - sprite_offset + Point<int16_t>(map_draw_origin_x, map_draw_origin_y) + init_pos, alpha);
		}

		/// Player
		Point<int16_t> player_pos = Stage::get().get_player().get_position();
		sprite_offset = player_marker.get_dimensions() / Point<int16_t>(2, 0);
		player_marker.draw((player_pos + center_offset) / scale - sprite_offset + Point<int16_t>(map_draw_origin_x, map_draw_origin_y) + init_pos, alpha);
	}

	void UIMiniMap::update_static_markers()
	{
		static_marker_info.clear();

		if (!has_map)
			return;

		Animation marker_sprite;

		/// Portals
		nl::node portals = Map["portal"];
		marker_sprite = Animation(marker["portal"]);
		Point<int16_t> marker_offset = marker_sprite.get_dimensions() / Point<int16_t>(2, 0);

		for (nl::node portal = portals.begin(); portal != portals.end(); ++portal)
		{
			int portal_type = portal["pt"];

			if (portal_type == 2)
			{
				Point<int16_t> marker_pos = (Point<int16_t>(portal["x"], portal["y"]) + center_offset) / scale - marker_offset + Point<int16_t>(map_draw_origin_x, map_draw_origin_y);
				static_marker_info.emplace_back(portal.name(), marker_pos);
			}
		}
	}

	void UIMiniMap::set_npclist_active(bool active)
	{
		listNpc_enabled = active;

		if (!active)
			select_npclist(-1);

		update_dimensions();
	}

	void UIMiniMap::update_dimensions()
	{
		if (type == Type::MIN)
		{
			dimension = min_dimensions;
		}
		else
		{
			Point<int16_t> base_dims = type == Type::MAX ? max_dimensions : normal_dimensions;
			dimension = base_dims;

			if (listNpc_enabled)
			{
				dimension += listNpc_dimensions;
				dimension.set_y(std::max(base_dims.y(), listNpc_dimensions.y()));
			}
		}
	}

	void UIMiniMap::update_npclist()
	{
		listNpc_sprites.clear();
		listNpc_names.clear();
		listNpc_full_names.clear();
		listNpc_list.clear();
		selected = -1;
		listNpc_offset = 0;

		if (simpleMode)
			return;

		auto npcs = Stage::get().get_npcs().get_npcs();

		for (auto npc = npcs->begin(); npc != npcs->end(); ++npc)
		{
			listNpc_list.emplace_back(npc->second.get());

			auto n = static_cast<Npc*>(npc->second.get());
			std::string name = n->get_name();
			std::string func = n->get_func();

			if (func != "")
				name += " (" + func + ")";

			Text name_text = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, name);

			listNpc_names.emplace_back(name_text);
			listNpc_full_names.emplace_back(name);
		}

		for (size_t i = 0; i < listNpc_names.size(); i++)
			string_format::format_with_ellipsis(listNpc_names[i], LISTNPC_TEXT_WIDTH - (listNpc_names.size() > 8 ? 0 : 20));

		const Point<int16_t> listNpc_pos = Point<int16_t>(type == Type::MAX ? max_dimensions.x() : normal_dimensions.x(), 0);
		int16_t c_stretch = 20;
		int16_t m_stretch = 102;

		if (listNpc_names.size() > 8)
		{
			listNpc_slider = Slider(
				Slider::DEFAULT_SILVER, Range<int16_t>(23, 11 + LISTNPC_ITEM_HEIGHT * 8), listNpc_pos.x() + LISTNPC_ITEM_WIDTH + 1, 8, listNpc_names.size(),
				[&](bool upwards)
				{
					int16_t shift = upwards ? -1 : 1;
					bool above = listNpc_offset + shift >= 0;
					bool below = listNpc_offset + 8 + shift <= listNpc_names.size();

					if (above && below)
						listNpc_offset += shift;
				}
			);

			c_stretch += 12;
		}
		else
		{
			listNpc_slider.setenabled(false);
			m_stretch = LISTNPC_ITEM_HEIGHT * listNpc_names.size() - 34;
			c_stretch -= 17;
		}

		listNpc_sprites.emplace_back(listNpc["c"], DrawArgument(listNpc_pos + Point<int16_t>(CENTER_START_X, M_START), Point<int16_t>(c_stretch, m_stretch)));
		listNpc_sprites.emplace_back(listNpc["w"], DrawArgument(listNpc_pos + Point<int16_t>(0, M_START), Point<int16_t>(0, m_stretch)));
		listNpc_sprites.emplace_back(listNpc["e"], DrawArgument(listNpc_pos + Point<int16_t>(CENTER_START_X + c_stretch, M_START), Point<int16_t>(0, m_stretch)));
		listNpc_sprites.emplace_back(listNpc["n"], DrawArgument(listNpc_pos + Point<int16_t>(CENTER_START_X, 0), Point<int16_t>(c_stretch, 0)));
		listNpc_sprites.emplace_back(listNpc["s"], DrawArgument(listNpc_pos + Point<int16_t>(CENTER_START_X, M_START + m_stretch), Point<int16_t>(c_stretch, 0)));
		listNpc_sprites.emplace_back(listNpc["nw"], DrawArgument(listNpc_pos + Point<int16_t>(0, 0)));
		listNpc_sprites.emplace_back(listNpc["ne"], DrawArgument(listNpc_pos + Point<int16_t>(CENTER_START_X + c_stretch, 0)));
		listNpc_sprites.emplace_back(listNpc["sw"], DrawArgument(listNpc_pos + Point<int16_t>(0, M_START + m_stretch)));
		listNpc_sprites.emplace_back(listNpc["se"], DrawArgument(listNpc_pos + Point<int16_t>(CENTER_START_X + c_stretch, M_START + m_stretch)));

		listNpc_dimensions = Point<int16_t>(CENTER_START_X * 2 + c_stretch, M_START + m_stretch + 30);

		update_dimensions();
	}

	void UIMiniMap::draw_npclist(Point<int16_t> minimap_dims, float alpha) const
	{
		Animation npc_marker = Animation(marker["npc"]);

		for (Sprite sprite : listNpc_sprites)
			sprite.draw(position, alpha);

		Point<int16_t> listNpc_pos = position + Point<int16_t>(minimap_dims.x() + 10, 23);

		for (int8_t i = 0; i + listNpc_offset < listNpc_list.size() && i < 8; i++)
		{
			if (selected - listNpc_offset == i)
			{
				ColorBox highlight = ColorBox(LISTNPC_ITEM_WIDTH - (listNpc_slider.isenabled() ? 0 : 30), LISTNPC_ITEM_HEIGHT, Color::Name::YELLOW, 1.0f);
				highlight.draw(listNpc_pos);
			}

			npc_marker.draw(DrawArgument(listNpc_pos + Point<int16_t>(0, 2), false, npc_marker.get_dimensions() / 2), alpha);
			listNpc_names[listNpc_offset + i].draw(DrawArgument(listNpc_pos + Point<int16_t>(14, -2)));

			listNpc_pos.shift_y(LISTNPC_ITEM_HEIGHT);
		}

		if (listNpc_slider.isenabled())
			listNpc_slider.draw(position);

		if (selected >= 0)
		{
			Point<int16_t> npc_pos =
				(listNpc_list[selected]->get_position() + center_offset) / scale +
				Point<int16_t>(map_draw_origin_x, map_draw_origin_y - npc_marker.get_dimensions().y() + (type == Type::MAX ? MAX_ADJ : 0));

			selected_marker.draw(position + npc_pos, 0.5f);
		}
	}

	void UIMiniMap::select_npclist(int16_t choice)
	{
		if (selected == choice)
			return;

		if (selected >= 0 && selected < listNpc_names.size())
			listNpc_names[selected].change_color(Color::Name::WHITE);

		if (choice > listNpc_names.size() || choice < 0)
		{
			selected = -1;
		}
		else
		{
			selected = choice != selected ? choice : -1;

			if (selected >= 0)
				listNpc_names[selected].change_color(Color::Name::BLACK);
		}
	}
}

================
File: IO/UITypes/UIMiniMap.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../Components/Slider.h"

#include "../../Gameplay/Stage.h"

namespace ms
{
	class UIMiniMap : public UIDragElement<PosMINIMAP>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::MINIMAP;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIMiniMap(const CharStats& stats);

		void draw(float alpha) const override;
		void update() override;

		void remove_cursor() override;
		Cursor::State send_cursor(bool clicked, Point<int16_t> pos) override;
		void send_scroll(double yoffset) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		static constexpr int16_t CENTER_START_X = 64;
		static constexpr int16_t BTN_MIN_Y = 4;
		static constexpr int16_t ML_MR_Y = 17;
		static constexpr int16_t MAX_ADJ = 40;
		static constexpr int16_t M_START = 36;
		static constexpr int16_t LISTNPC_ITEM_HEIGHT = 17;
		static constexpr int16_t LISTNPC_ITEM_WIDTH = 140;
		static constexpr int16_t LISTNPC_TEXT_WIDTH = 114;
		static constexpr Point<int16_t> WINDOW_UL_POS = Point<int16_t>(0, 0);

		void update_buttons();
		void toggle_buttons();
		void update_text();
		void update_canvas();
		void draw_movable_markers(Point<int16_t> init_pos, float alpha) const;
		void update_static_markers();
		void set_npclist_active(bool active);
		void update_dimensions();
		void update_npclist();
		void draw_npclist(Point<int16_t> minimap_dims, float alpha) const;
		void select_npclist(int16_t choice);

		enum Buttons
		{
			BT_MIN,
			BT_MAX,
			BT_SMALL,
			BT_BIG,
			BT_MAP,
			BT_NPC
		};

		enum Type
		{
			MIN,
			NORMAL,
			MAX
		};

		/// Constants
		int32_t mapid;
		int8_t type;
		int8_t user_type;
		bool simpleMode;
		bool big_map;
		bool has_map;
		int16_t scale;
		nl::node Map;
		nl::node MiniMap;
		nl::node marker;
		Texture map_sprite;
		Animation player_marker;
		int16_t combined_text_width;
		int16_t middle_right_x;
		int16_t bt_min_width;
		int16_t bt_max_width;
		int16_t bt_map_width;
		std::vector<Sprite> min_sprites;
		std::vector<Sprite> normal_sprites;
		std::vector<Sprite> max_sprites;
		std::vector<std::pair<std::string, Point<int16_t>>> static_marker_info;
		int16_t map_draw_origin_x, map_draw_origin_y;
		Point<int16_t> center_offset;
		Point<int16_t> min_dimensions;
		Point<int16_t> normal_dimensions;
		Point<int16_t> max_dimensions;
		Text combined_text;
		Text region_text;
		Text town_text;

		bool listNpc_enabled;
		nl::node listNpc;
		nl::node MapHelper;
		std::vector<Sprite> listNpc_sprites;
		std::vector<MapObject*> listNpc_list;
		std::vector<Text> listNpc_names;
		std::vector<std::string> listNpc_full_names;

		Point<int16_t> listNpc_dimensions;

		Slider listNpc_slider;
		int16_t listNpc_offset;
		int16_t selected;
		Animation selected_marker;

		const CharStats& stats;
	};
}

================
File: IO/UITypes/UINotice.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UINotice.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#include "../../Audio/Audio.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UINotice::UINotice(std::string message, NoticeType t, Text::Alignment a) : UIDragElement<PosNOTICE>(), type(t), alignment(a)
	{
		nl::node src = nl::nx::UI["Basic.img"]["Notice6"];

		top = src["t"];
		center = src["c"];
		centerbox = src["c_box"];
		box = src["box"];
		box2 = src["box2"];
		bottom = src["s"];
		bottombox = src["s_box"];

		if (type == NoticeType::YESNO)
		{
			position.shift_y(-8);
			question = Text(Text::Font::A11M, alignment, Color::Name::WHITE, message, 200);
		}
		else if (type == NoticeType::ENTERNUMBER)
		{
			position.shift_y(-16);
			question = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::WHITE, message, 200);
		}
		else if (type == NoticeType::OK)
		{
			uint16_t maxwidth = top.width() - 6;

			position.shift_y(-8);
			question = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::WHITE, message, maxwidth);
		}

		height = question.height();
		dimension = Point<int16_t>(top.width(), top.height() + height + bottom.height());
		position = Point<int16_t>(position.x() - dimension.x() / 2, position.y() - dimension.y() / 2);
		dragarea = Point<int16_t>(dimension.x(), 20);

		if (type != NoticeType::ENTERNUMBER)
			Sound(Sound::Name::DLGNOTICE).play();
	}

	UINotice::UINotice(std::string message, NoticeType t) : UINotice(message, t, Text::Alignment::CENTER) {}

	void UINotice::draw(bool textfield) const
	{
		Point<int16_t> start = position;

		top.draw(start);
		start.shift_y(top.height());

		if (textfield)
		{
			center.draw(start);
			start.shift_y(center.height());
			centerbox.draw(start);
			start.shift_y(centerbox.height() - 1);
			box2.draw(start);
			start.shift_y(box2.height());
			box.draw(DrawArgument(start, Point<int16_t>(0, 29)));
			start.shift_y(29);

			question.draw(position + Point<int16_t>(13, 13));
		}
		else
		{
			int16_t pos_y = height >= 32 ? height : 32;

			center.draw(DrawArgument(start, Point<int16_t>(0, pos_y)));
			start.shift_y(pos_y);
			centerbox.draw(start);
			start.shift_y(centerbox.height());
			box.draw(start);
			start.shift_y(box.height());

			if (type == NoticeType::YESNO && alignment == Text::Alignment::LEFT)
				question.draw(position + Point<int16_t>(31, 14));
			else
				question.draw(position + Point<int16_t>(131, 14));
		}

		bottombox.draw(start);
	}

	int16_t UINotice::box2offset(bool textfield) const
	{
		int16_t offset = top.height() + centerbox.height() + box.height() + height - (textfield ? 0 : 16);

		if (type == NoticeType::OK)
			if (height < 34)
				offset += 15;

		return offset;
	}

	UIYesNo::UIYesNo(std::string message, std::function<void(bool yes)> yh, Text::Alignment alignment) : UINotice(message, NoticeType::YESNO, alignment)
	{
		yesnohandler = yh;

		int16_t belowtext = box2offset(false);

		nl::node src = nl::nx::UI["Basic.img"];

		buttons[Buttons::YES] = std::make_unique<MapleButton>(src["BtOK4"], Point<int16_t>(156, belowtext));
		buttons[Buttons::NO] = std::make_unique<MapleButton>(src["BtCancel4"], Point<int16_t>(198, belowtext));
	}

	UIYesNo::UIYesNo(std::string message, std::function<void(bool yes)> yesnohandler) : UIYesNo(message, yesnohandler, Text::Alignment::CENTER) {}

	void UIYesNo::draw(float alpha) const
	{
		UINotice::draw(false);
		UIElement::draw(alpha);
	}

	void UIYesNo::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (keycode == KeyAction::Id::RETURN)
		{
			yesnohandler(true);
			deactivate();
		}
		else if (escape)
		{
			yesnohandler(false);
			deactivate();
		}
	}

	UIElement::Type UIYesNo::get_type() const
	{
		return TYPE;
	}

	Button::State UIYesNo::button_pressed(uint16_t buttonid)
	{
		deactivate();

		switch (buttonid)
		{
			case Buttons::YES:
				yesnohandler(true);
				break;
			case Buttons::NO:
				yesnohandler(false);
				break;
		}

		return Button::State::PRESSED;
	}

	UIEnterNumber::UIEnterNumber(std::string message, std::function<void(int32_t)> nh, int32_t m, int32_t quantity) : UINotice(message, NoticeType::ENTERNUMBER)
	{
		numhandler = nh;
		max = m;

		int16_t belowtext = box2offset(true) - 21;
		int16_t pos_y = belowtext + 35;

		nl::node src = nl::nx::UI["Basic.img"];

		buttons[Buttons::OK] = std::make_unique<MapleButton>(src["BtOK4"], 156, pos_y);
		buttons[Buttons::CANCEL] = std::make_unique<MapleButton>(src["BtCancel4"], 198, pos_y);

		Point<int16_t> numfield_pos = position + Point<int16_t>(22, belowtext + 5);
		Point<int16_t> numfield_dim = Point<int16_t>(217, 16);

		int16_t numfield_limit = 10;

		numfield = Textfield(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::LIGHTGREY, Rectangle<int16_t>(numfield_pos, numfield_pos + numfield_dim), numfield_limit);
		numfield.change_text(std::to_string(quantity));

		numfield.set_enter_callback(
			[&](std::string numstr)
			{
				handlestring(numstr);
			}
		);

		numfield.set_key_callback(
			KeyAction::Id::ESCAPE,
			[&]()
			{
				deactivate();
			}
		);

		numfield.set_state(Textfield::State::FOCUSED);
	}

	void UIEnterNumber::draw(float alpha) const
	{
		UINotice::draw(true);
		UIElement::draw(alpha);

		numfield.draw(Point<int16_t>(2, -4));
	}

	void UIEnterNumber::update()
	{
		UIElement::update();

		numfield.update();
	}

	Cursor::State UIEnterNumber::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		if (numfield.get_state() == Textfield::State::NORMAL)
		{
			Cursor::State nstate = numfield.send_cursor(cursorpos, clicked);

			if (nstate != Cursor::State::IDLE)
				return nstate;
		}

		return UIElement::send_cursor(clicked, cursorpos);
	}

	void UIEnterNumber::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (keycode == KeyAction::Id::RETURN)
		{
			handlestring(numfield.get_text());
			deactivate();
		}
		else if (escape)
		{
			deactivate();
		}
	}

	UIElement::Type UIEnterNumber::get_type() const
	{
		return TYPE;
	}

	Button::State UIEnterNumber::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			case Buttons::OK:
				handlestring(numfield.get_text());
				break;
			case Buttons::CANCEL:
				deactivate();
				break;
		}

		return Button::State::NORMAL;
	}

	void UIEnterNumber::handlestring(std::string numstr)
	{
		int num = -1;
		bool has_only_digits = (numstr.find_first_not_of("0123456789") == std::string::npos);

		auto okhandler = [&](bool)
		{
			numfield.set_state(Textfield::State::FOCUSED);
			buttons[Buttons::OK]->set_state(Button::State::NORMAL);
		};

		if (!has_only_digits)
		{
			numfield.set_state(Textfield::State::DISABLED);
			UI::get().emplace<UIOk>("Only numbers are allowed.", okhandler);
			return;
		}
		else
		{
			num = std::stoi(numstr);
		}

		if (num < 1)
		{
			numfield.set_state(Textfield::State::DISABLED);
			UI::get().emplace<UIOk>("You may only enter a number equal to or higher than 1.", okhandler);
			return;
		}
		else if (num > max)
		{
			numfield.set_state(Textfield::State::DISABLED);
			UI::get().emplace<UIOk>("You may only enter a number equal to or lower than " + std::to_string(max) + ".", okhandler);
			return;
		}
		else
		{
			numhandler(num);
			deactivate();
		}

		buttons[Buttons::OK]->set_state(Button::State::NORMAL);
	}

	UIOk::UIOk(std::string message, std::function<void(bool ok)> oh) : UINotice(message, NoticeType::OK)
	{
		okhandler = oh;

		nl::node src = nl::nx::UI["Basic.img"];

		buttons[Buttons::OK] = std::make_unique<MapleButton>(src["BtOK4"], 197, box2offset(false));
	}

	void UIOk::draw(float alpha) const
	{
		UINotice::draw(false);
		UIElement::draw(alpha);
	}

	void UIOk::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (keycode == KeyAction::Id::RETURN)
			{
				okhandler(true);
				deactivate();
			}
			else if (escape)
			{
				okhandler(false);
				deactivate();
			}
		}
	}

	UIElement::Type UIOk::get_type() const
	{
		return TYPE;
	}

	Button::State UIOk::button_pressed(uint16_t buttonid)
	{
		deactivate();

		switch (buttonid)
		{
			case Buttons::OK:
				okhandler(true);
				break;
		}

		return Button::State::NORMAL;
	}
}

================
File: IO/UITypes/UINotice.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../Components/Textfield.h"

namespace ms
{
	class UINotice : public UIDragElement<PosNOTICE>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::NOTICE;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = false;

	protected:
		enum NoticeType : uint8_t
		{
			YESNO,
			ENTERNUMBER,
			OK
		};

		UINotice(std::string message, NoticeType type, Text::Alignment alignment);
		UINotice(std::string message, NoticeType type);

		void draw(bool textfield) const;

		int16_t box2offset(bool textfield) const;

	private:
		Texture top;
		Texture center;
		Texture centerbox;
		Texture box;
		Texture box2;
		Texture bottom;
		Texture bottombox;
		Text question;
		int16_t height;
		NoticeType type;
		Text::Alignment alignment;
	};

	class UIYesNo : public UINotice
	{
	public:
		UIYesNo(std::string message, std::function<void(bool yes)> yesnohandler, Text::Alignment alignment);
		UIYesNo(std::string message, std::function<void(bool yes)> yesnohandler);

		void draw(float alpha) const override;

		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		enum Buttons : int16_t
		{
			YES, NO
		};

		std::function<void(bool yes)> yesnohandler;
	};

	class UIEnterNumber : public UINotice
	{
	public:
		UIEnterNumber(std::string message, std::function<void(int32_t number)> numhandler, int32_t max, int32_t quantity);

		void draw(float alpha) const override;
		void update() override;

		Cursor::State send_cursor(bool pressed, Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void handlestring(std::string numstr);

		enum Buttons : int16_t
		{
			OK, CANCEL
		};

		std::function<void(int32_t number)> numhandler;
		Textfield numfield;
		int32_t max;
	};

	class UIOk : public UINotice
	{
	public:
		UIOk(std::string message, std::function<void(bool ok)> okhandler);

		void draw(float alpha) const override;

		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		enum Buttons : int16_t
		{
			OK
		};

		std::function<void(bool ok)> okhandler;
	};
}

================
File: IO/UITypes/UINpcTalk.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UINpcTalk.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#include "../../Gameplay/Stage.h"

#include "../../Net/Packets/NpcInteractionPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UINpcTalk::UINpcTalk() : offset(0), unitrows(0), rowmax(0), show_slider(false), draw_text(false), formatted_text(""), formatted_text_pos(0), timestep(0)
	{
		nl::node UtilDlgEx = nl::nx::UI["UIWindow2.img"]["UtilDlgEx"];

		top = UtilDlgEx["t"];
		fill = UtilDlgEx["c"];
		bottom = UtilDlgEx["s"];
		nametag = UtilDlgEx["bar"];

		min_height = 8 * fill.height() + 14;

		buttons[Buttons::ALLLEVEL] = std::make_unique<MapleButton>(UtilDlgEx["BtAllLevel"]);
		buttons[Buttons::CLOSE] = std::make_unique<MapleButton>(UtilDlgEx["BtClose"]);
		buttons[Buttons::MYLEVEL] = std::make_unique<MapleButton>(UtilDlgEx["BtMyLevel"]);
		buttons[Buttons::NEXT] = std::make_unique<MapleButton>(UtilDlgEx["BtNext"]);
		buttons[Buttons::NO] = std::make_unique<MapleButton>(UtilDlgEx["BtNo"]);
		buttons[Buttons::OK] = std::make_unique<MapleButton>(UtilDlgEx["BtOK"]);
		buttons[Buttons::PREV] = std::make_unique<MapleButton>(UtilDlgEx["BtPrev"]);
		buttons[Buttons::QAFTER] = std::make_unique<MapleButton>(UtilDlgEx["BtQAfter"]);
		buttons[Buttons::QCNO] = std::make_unique<MapleButton>(UtilDlgEx["BtQCNo"]);
		buttons[Buttons::QCYES] = std::make_unique<MapleButton>(UtilDlgEx["BtQCYes"]);
		buttons[Buttons::QGIVEUP] = std::make_unique<MapleButton>(UtilDlgEx["BtQGiveup"]);
		buttons[Buttons::QNO] = std::make_unique<MapleButton>(UtilDlgEx["BtQNo"]);
		buttons[Buttons::QSTART] = std::make_unique<MapleButton>(UtilDlgEx["BtQStart"]);
		buttons[Buttons::QYES] = std::make_unique<MapleButton>(UtilDlgEx["BtQYes"]);
		buttons[Buttons::YES] = std::make_unique<MapleButton>(UtilDlgEx["BtYes"]);

		name = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::WHITE);

		onmoved = [&](bool upwards)
		{
			int16_t shift = upwards ? -unitrows : unitrows;
			bool above = offset + shift >= 0;
			bool below = offset + shift <= rowmax - unitrows;

			if (above && below)
				offset += shift;
		};

		UI::get().remove_textfield();
	}

	void UINpcTalk::draw(float inter) const
	{
		Point<int16_t> drawpos = position;
		top.draw(drawpos);
		drawpos.shift_y(top.height());
		fill.draw(DrawArgument(drawpos, Point<int16_t>(0, height)));
		drawpos.shift_y(height);
		bottom.draw(drawpos);
		drawpos.shift_y(bottom.height());

		UIElement::draw(inter);

		int16_t speaker_y = (top.height() + height + bottom.height()) / 2;
		Point<int16_t> speaker_pos = position + Point<int16_t>(22, 11 + speaker_y);
		Point<int16_t> center_pos = speaker_pos + Point<int16_t>(nametag.width() / 2, 0);

		speaker.draw(DrawArgument(center_pos, true));
		nametag.draw(speaker_pos);
		name.draw(center_pos + Point<int16_t>(0, -4));

		if (show_slider)
		{
			int16_t text_min_height = position.y() + top.height() - 1;
			text.draw(position + Point<int16_t>(162, 19 - offset * 400), Range<int16_t>(text_min_height, text_min_height + height - 18));
			slider.draw(position);
		}
		else
		{
			int16_t y_adj = height - min_height;
			text.draw(position + Point<int16_t>(166, 48 - y_adj));
		}
	}

	void UINpcTalk::update()
	{
		UIElement::update();

		if (draw_text)
		{
			if (timestep > 4)
			{
				if (formatted_text_pos < formatted_text.size())
				{
					std::string t = text.get_text();
					char c = formatted_text[formatted_text_pos];

					text.change_text(t + c);

					formatted_text_pos++;
					timestep = 0;
				}
				else
				{
					draw_text = false;
				}
			}
			else
			{
				timestep++;
			}
		}
	}

	Button::State UINpcTalk::button_pressed(uint16_t buttonid)
	{
		deactivate();

		switch (type)
		{
			case TalkType::SENDNEXT:
			case TalkType::SENDOK:
			{
				// Type = 0
				switch (buttonid)
				{
					case Buttons::CLOSE:
						NpcTalkMorePacket(type, -1).dispatch();
						break;
					case Buttons::NEXT:
					case Buttons::OK:
						NpcTalkMorePacket(type, 1).dispatch();
						break;
				}

				break;
			}
			case TalkType::SENDNEXTPREV:
			{
				// Type = 0
				switch (buttonid)
				{
					case Buttons::CLOSE:
						NpcTalkMorePacket(type, -1).dispatch();
						break;
					case Buttons::NEXT:
						NpcTalkMorePacket(type, 1).dispatch();
						break;
					case Buttons::PREV:
						NpcTalkMorePacket(type, 0).dispatch();
						break;
				}

				break;
			}
			case TalkType::SENDYESNO:
			{
				// Type = 1
				switch (buttonid)
				{
					case Buttons::CLOSE:
						NpcTalkMorePacket(type, -1).dispatch();
						break;
					case Buttons::NO:
						NpcTalkMorePacket(type, 0).dispatch();
						break;
					case Buttons::YES:
						NpcTalkMorePacket(type, 1).dispatch();
						break;
				}

				break;
			}
			case TalkType::SENDACCEPTDECLINE:
			{
				// Type = 1
				switch (buttonid)
				{
					case Buttons::CLOSE:
						NpcTalkMorePacket(type, -1).dispatch();
						break;
					case Buttons::QNO:
						NpcTalkMorePacket(type, 0).dispatch();
						break;
					case Buttons::QYES:
						NpcTalkMorePacket(type, 1).dispatch();
						break;
				}

				break;
			}
			case TalkType::SENDGETTEXT:
			{
				// TODO: What is this?
				break;
			}
			case TalkType::SENDGETNUMBER:
			{
				// Type = 3
				switch (buttonid)
				{
					case Buttons::CLOSE:
						NpcTalkMorePacket(type, 0).dispatch();
						break;
					case Buttons::OK:
						NpcTalkMorePacket(type, 1).dispatch();
						break;
				}

				break;
			}
			case TalkType::SENDSIMPLE:
			{
				// Type = 4
				switch (buttonid)
				{
					case Buttons::CLOSE:
						NpcTalkMorePacket(type, 0).dispatch();
						break;
					default:
						NpcTalkMorePacket(0).dispatch(); // TODO: Selection
						break;
				}

				break;
			}
			default:
			{
				break;
			}
		}

		return Button::State::NORMAL;
	}

	Cursor::State UINpcTalk::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		Point<int16_t> cursor_relative = cursorpos - position;

		if (show_slider && slider.isenabled())
			if (Cursor::State sstate = slider.send_cursor(cursor_relative, clicked))
				return sstate;

		Cursor::State estate = UIElement::send_cursor(clicked, cursorpos);

		if (estate == Cursor::State::CLICKING && clicked && draw_text)
		{
			draw_text = false;
			text.change_text(formatted_text);
		}

		return estate;
	}

	void UINpcTalk::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed && escape)
		{
			deactivate();

			NpcTalkMorePacket(type, 0).dispatch();
		}
	}

	UIElement::Type UINpcTalk::get_type() const
	{
		return TYPE;
	}

	UINpcTalk::TalkType UINpcTalk::get_by_value(int8_t value)
	{
		if (value > TalkType::NONE && value < TalkType::LENGTH)
			return static_cast<TalkType>(value);

		return TalkType::NONE;
	}

	// TODO: Move this to GraphicsGL?
	std::string UINpcTalk::format_text(const std::string& tx, const int32_t& npcid)
	{
		std::string formatted_text = tx;
		size_t begin = formatted_text.find("#p");

		if (begin != std::string::npos)
		{
			size_t end = formatted_text.find("#", begin + 1);

			if (end != std::string::npos)
			{
				std::string namestr = nl::nx::String["Npc.img"][std::to_string(npcid)]["name"];
				formatted_text.replace(begin, end - begin, namestr);
			}
		}

		begin = formatted_text.find("#h");

		if (begin != std::string::npos)
		{
			size_t end = formatted_text.find("#", begin + 1);

			if (end != std::string::npos)
			{
				std::string charstr = Stage::get().get_player().get_name();
				formatted_text.replace(begin, end - begin, charstr);
			}
		}

		begin = formatted_text.find("#t");

		if (begin != std::string::npos)
		{
			size_t end = formatted_text.find("#", begin + 1);

			if (end != std::string::npos)
			{
				size_t b = begin + 2;
				int32_t itemid = std::stoi(formatted_text.substr(b, end - b));
				std::string itemname = nl::nx::String["Consume.img"][itemid]["name"];

				formatted_text.replace(begin, end - begin, itemname);
			}
		}

		return formatted_text;
	}

	void UINpcTalk::change_text(int32_t npcid, int8_t msgtype, int16_t, int8_t speakerbyte, const std::string& tx)
	{
		type = get_by_value(msgtype);

		timestep = 0;
		draw_text = true;
		formatted_text_pos = 0;
		formatted_text = format_text(tx, npcid);

		text = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::DARKGREY, formatted_text, 320);

		int16_t text_height = text.height();

		text.change_text("");

		if (speakerbyte == 0)
		{
			std::string strid = std::to_string(npcid);
			strid.insert(0, 7 - strid.size(), '0');
			strid.append(".img");

			speaker = nl::nx::Npc[strid]["stand"]["0"];

			std::string namestr = nl::nx::String["Npc.img"][std::to_string(npcid)]["name"];
			name.change_text(namestr);
		}
		else
		{
			speaker = Texture();
			name.change_text("");
		}

		height = min_height;
		show_slider = false;

		if (text_height > height)
		{
			if (text_height > MAX_HEIGHT)
			{
				height = MAX_HEIGHT;
				show_slider = true;
				rowmax = text_height / 400 + 1;
				unitrows = 1;

				int16_t slider_y = top.height() - 7;
				slider = Slider(Slider::Type::DEFAULT_SILVER, Range<int16_t>(slider_y, slider_y + height - 20), top.width() - 26, unitrows, rowmax, onmoved);
			}
			else
			{
				height = text_height;
			}
		}

		for (auto& button : buttons)
		{
			button.second->set_active(false);
			button.second->set_state(Button::State::NORMAL);
		}

		int16_t y_cord = height + 48;

		buttons[Buttons::CLOSE]->set_position(Point<int16_t>(9, y_cord));
		buttons[Buttons::CLOSE]->set_active(true);

		switch (type)
		{
			case TalkType::SENDOK:
			{
				buttons[Buttons::OK]->set_position(Point<int16_t>(471, y_cord));
				buttons[Buttons::OK]->set_active(true);
				break;
			}
			case TalkType::SENDYESNO:
			{
				Point<int16_t> yes_position = Point<int16_t>(389, y_cord);

				buttons[Buttons::YES]->set_position(yes_position);
				buttons[Buttons::YES]->set_active(true);

				buttons[Buttons::NO]->set_position(yes_position + Point<int16_t>(65, 0));
				buttons[Buttons::NO]->set_active(true);
				break;
			}
			case TalkType::SENDNEXT:
			case TalkType::SENDNEXTPREV:
			case TalkType::SENDACCEPTDECLINE:
			case TalkType::SENDGETTEXT:
			case TalkType::SENDGETNUMBER:
			case TalkType::SENDSIMPLE:
			default:
			{
				break;
			}
		}

		position = Point<int16_t>(400 - top.width() / 2, 240 - height / 2);
		dimension = Point<int16_t>(top.width(), height + 120);
	}
}

================
File: IO/UITypes/UINpcTalk.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../Components/Slider.h"

#include "../../Graphics/Text.h"

namespace ms
{
	class UINpcTalk : public UIElement
	{
	public:
		enum TalkType : int8_t
		{
			NONE = -1,
			SENDOK,
			SENDYESNO,

			// TODO: Unconfirmed
			SENDNEXT,
			SENDNEXTPREV,
			SENDACCEPTDECLINE,
			SENDGETTEXT,
			SENDGETNUMBER,
			SENDSIMPLE,
			LENGTH
		};

		static constexpr Type TYPE = UIElement::Type::NPCTALK;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = false;

		UINpcTalk();

		void draw(float inter) const override;
		void update() override;

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		void change_text(int32_t npcid, int8_t msgtype, int16_t style, int8_t speaker, const std::string& text);

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		TalkType get_by_value(int8_t value);
		std::string format_text(const std::string& tx, const int32_t& npcid);

		static constexpr int16_t MAX_HEIGHT = 248;

		enum Buttons
		{
			ALLLEVEL,
			CLOSE,
			MYLEVEL,
			NEXT,
			NO,
			OK,
			PREV,
			QAFTER,
			QCNO,
			QCYES,
			QGIVEUP,
			QNO,
			QSTART,
			QYES,
			YES
		};

		Texture top;
		Texture fill;
		Texture bottom;
		Texture nametag;
		Texture speaker;

		Text text;
		Text name;

		int16_t height;
		int16_t offset;
		int16_t unitrows;
		int16_t rowmax;
		int16_t min_height;

		bool show_slider;
		bool draw_text;
		Slider slider;
		TalkType type;
		std::string formatted_text;
		size_t formatted_text_pos;
		uint16_t timestep;

		std::function<void(bool)> onmoved;
	};
}

================
File: IO/UITypes/UIOptionMenu.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIOptionMenu.h"

#include "../KeyAction.h"

#include "../Components/MapleButton.h"
#include "../Components/TwoSpriteButton.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIOptionMenu::UIOptionMenu() : UIDragElement<PosOPTIONMENU>(), selected_tab(0)
	{
		nl::node OptionMenu = nl::nx::UI["StatusBar3.img"]["OptionMenu"];
		nl::node backgrnd = OptionMenu["backgrnd"];

		sprites.emplace_back(backgrnd);
		sprites.emplace_back(OptionMenu["backgrnd2"]);

		nl::node graphic = OptionMenu["graphic"];

		tab_background[Buttons::TAB0] = graphic["layer:backgrnd"];
		tab_background[Buttons::TAB1] = OptionMenu["sound"]["layer:backgrnd"];
		tab_background[Buttons::TAB2] = OptionMenu["game"]["layer:backgrnd"];
		tab_background[Buttons::TAB3] = OptionMenu["invite"]["layer:backgrnd"];
		tab_background[Buttons::TAB4] = OptionMenu["screenshot"]["layer:backgrnd"];

		buttons[Buttons::CANCEL] = std::make_unique<MapleButton>(OptionMenu["button:Cancel"]);
		buttons[Buttons::OK] = std::make_unique<MapleButton>(OptionMenu["button:OK"]);
		buttons[Buttons::UIRESET] = std::make_unique<MapleButton>(OptionMenu["button:UIReset"]);

		nl::node tab = OptionMenu["tab"];
		nl::node tab_disabled = tab["disabled"];
		nl::node tab_enabled = tab["enabled"];

		for (size_t i = Buttons::TAB0; i < Buttons::CANCEL; i++)
			buttons[i] = std::make_unique<TwoSpriteButton>(tab_disabled[i], tab_enabled[i]);

		std::string sButtonUOL = graphic["combo:resolution"]["sButtonUOL"].get_string();
		std::string ctype = std::string(1, sButtonUOL.back());
		MapleComboBox::Type type = static_cast<MapleComboBox::Type>(std::stoi(ctype));

		std::vector<std::string> resolutions =
		{
			"800 x 600 ( 4 : 3 )",
			"1024 x 768 ( 4 : 3 )",
			"1280 x 720 ( 16 : 9 )",
			"1366 x 768 ( 16 : 9 )",
			"1920 x 1080 ( 16 : 9 ) - Beta"
		};

		int16_t max_width = Configuration::get().get_max_width();
		int16_t max_height = Configuration::get().get_max_height();

		if (max_width >= 1920 && max_height >= 1200)
			resolutions.emplace_back("1920 x 1200 ( 16 : 10 ) - Beta");

		uint16_t default_option = 0;
		int16_t screen_width = Constants::Constants::get().get_viewwidth();
		int16_t screen_height = Constants::Constants::get().get_viewheight();

		switch (screen_width)
		{
		case 800:
			default_option = 0;
			break;
		case 1024:
			default_option = 1;
			break;
		case 1280:
			default_option = 2;
			break;
		case 1366:
			default_option = 3;
			break;
		case 1920:
			switch (screen_height)
			{
			case 1080:
				default_option = 4;
				break;
			case 1200:
				default_option = 5;
				break;
			}

			break;
		}

		int64_t combobox_width = graphic["combo:resolution"]["boxWidth"].get_integer();
		Point<int16_t> lt = Point<int16_t>(graphic["combo:resolution"]["lt"]);

		buttons[Buttons::SELECT_RES] = std::make_unique<MapleComboBox>(type, resolutions, default_option, position, lt, combobox_width);

		Point<int16_t> bg_dimensions = Texture(backgrnd).get_dimensions();

		dimension = bg_dimensions;
		dragarea = Point<int16_t>(bg_dimensions.x(), 20);

		change_tab(Buttons::TAB2);
	}

	void UIOptionMenu::draw(float inter) const
	{
		UIElement::draw_sprites(inter);

		tab_background[selected_tab].draw(position);

		UIElement::draw_buttons(inter);
	}

	Button::State UIOptionMenu::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
		case Buttons::TAB0:
		case Buttons::TAB1:
		case Buttons::TAB2:
		case Buttons::TAB3:
		case Buttons::TAB4:
			change_tab(buttonid);
			return Button::State::IDENTITY;
		case Buttons::CANCEL:
			deactivate();
			return Button::State::NORMAL;
		case Buttons::OK:
			switch (selected_tab)
			{
			case Buttons::TAB0:
			{
				uint16_t selected_value = buttons[Buttons::SELECT_RES]->get_selected();

				int16_t width = Constants::Constants::get().get_viewwidth();
				int16_t height = Constants::Constants::get().get_viewheight();

				switch (selected_value)
				{
				case 0:
					width = 800;
					height = 600;
					break;
				case 1:
					width = 1024;
					height = 768;
					break;
				case 2:
					width = 1280;
					height = 720;
					break;
				case 3:
					width = 1366;
					height = 768;
					break;
				case 4:
					width = 1920;
					height = 1080;
					break;
				case 5:
					width = 1920;
					height = 1200;
					break;
				}

				Setting<Width>::get().save(width);
				Setting<Height>::get().save(height);

				Constants::Constants::get().set_viewwidth(width);
				Constants::Constants::get().set_viewheight(height);
			}
			break;
			case Buttons::TAB1:
			case Buttons::TAB2:
			case Buttons::TAB3:
			case Buttons::TAB4:
			default:
				break;
			}

			deactivate();
			return Button::State::NORMAL;
		case Buttons::UIRESET:
			return Button::State::DISABLED;
		case Buttons::SELECT_RES:
			buttons[Buttons::SELECT_RES]->toggle_pressed();
			return Button::State::NORMAL;
		default:
			return Button::State::DISABLED;
		}
	}

	Cursor::State UIOptionMenu::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		Cursor::State dstate = UIDragElement::send_cursor(clicked, cursorpos);

		if (dragged)
			return dstate;

		auto& button = buttons[Buttons::SELECT_RES];

		if (button->is_pressed())
		{
			if (button->in_combobox(cursorpos))
			{
				if (Cursor::State new_state = button->send_cursor(clicked, cursorpos))
					return new_state;
			}
			else
			{
				remove_cursor();
			}
		}

		return UIElement::send_cursor(clicked, cursorpos);
	}

	void UIOptionMenu::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
				deactivate();
			else if (keycode == KeyAction::Id::RETURN)
				button_pressed(Buttons::OK);
		}
	}

	UIElement::Type UIOptionMenu::get_type() const
	{
		return TYPE;
	}

	void UIOptionMenu::change_tab(uint16_t tabid)
	{
		buttons[selected_tab]->set_state(Button::State::NORMAL);
		buttons[tabid]->set_state(Button::State::PRESSED);

		selected_tab = tabid;

		switch (tabid)
		{
		case Buttons::TAB0:
			buttons[Buttons::SELECT_RES]->set_active(true);
			break;
		case Buttons::TAB1:
		case Buttons::TAB2:
		case Buttons::TAB3:
		case Buttons::TAB4:
			buttons[Buttons::SELECT_RES]->set_active(false);
			break;
		default:
			break;
		}
	}
}

================
File: IO/UITypes/UIOptionMenu.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../Components/MapleComboBox.h"

namespace ms
{
	class UIOptionMenu : public UIDragElement<PosOPTIONMENU>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::OPTIONMENU;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = false;

		UIOptionMenu();

		void draw(float inter) const override;

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void change_tab(uint16_t tabid);

		enum Buttons : uint16_t
		{
			TAB0,
			TAB1,
			TAB2,
			TAB3,
			TAB4,
			CANCEL,
			OK,
			UIRESET,
			SELECT_RES
		};

		uint16_t selected_tab;
		Texture tab_background[Buttons::CANCEL];
	};
}

================
File: IO/UITypes/UIQuestLog.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIQuestLog.h"

#include "../Components/MapleButton.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIQuestLog::UIQuestLog(const QuestLog& ql) : UIDragElement<PosQUEST>(), questlog(ql)
	{
		tab = Buttons::TAB0;

		nl::node close = nl::nx::UI["Basic.img"]["BtClose3"];
		nl::node quest = nl::nx::UI["UIWindow2.img"]["Quest"];
		nl::node list = quest["list"];

		nl::node backgrnd = list["backgrnd"];

		sprites.emplace_back(backgrnd);
		sprites.emplace_back(list["backgrnd2"]);

		notice_sprites.emplace_back(list["notice0"]);
		notice_sprites.emplace_back(list["notice1"]);
		notice_sprites.emplace_back(list["notice2"]);

		nl::node taben = list["Tab"]["enabled"];
		nl::node tabdis = list["Tab"]["disabled"];

		buttons[Buttons::TAB0] = std::make_unique<TwoSpriteButton>(tabdis["0"], taben["0"]);
		buttons[Buttons::TAB1] = std::make_unique<TwoSpriteButton>(tabdis["1"], taben["1"]);
		buttons[Buttons::TAB2] = std::make_unique<TwoSpriteButton>(tabdis["2"], taben["2"]);
		buttons[Buttons::CLOSE] = std::make_unique<MapleButton>(close, Point<int16_t>(275, 6));
		buttons[Buttons::SEARCH] = std::make_unique<MapleButton>(list["BtSearch"]);
		buttons[Buttons::ALL_LEVEL] = std::make_unique<MapleButton>(list["BtAllLevel"]);
		buttons[Buttons::MY_LOCATION] = std::make_unique<MapleButton>(list["BtMyLocation"]);

		search_area = list["searchArea"];

		int16_t search_limit = 19;

		search = Textfield(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::BOULDER, Rectangle<int16_t>(get_search_pos(), get_search_pos() + get_search_dim()), search_limit);
		placeholder = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::BOULDER, "Enter the quest name.");

		slider = Slider(Slider::Type::DEFAULT_SILVER, Range<int16_t>(0, 279), 150, 20, 5, [](bool) {});

		change_tab(tab);

		dimension = Texture(backgrnd).get_dimensions();
		dragarea = Point<int16_t>(dimension.x(), 20);
	}

	void UIQuestLog::draw(float alpha) const
	{
		UIElement::draw_sprites(alpha);

		Point<int16_t> notice_position = Point<int16_t>(0, 26);

		if (tab == Buttons::TAB0)
			notice_sprites[tab].draw(position + notice_position + Point<int16_t>(9, 0), alpha);
		else if (tab == Buttons::TAB1)
			notice_sprites[tab].draw(position + notice_position + Point<int16_t>(0, 0), alpha);
		else
			notice_sprites[tab].draw(position + notice_position + Point<int16_t>(-10, 0), alpha);

		if (tab != Buttons::TAB2)
		{
			search_area.draw(position);
			search.draw(Point<int16_t>(4, -4), Point<int16_t>(2, -2));

			if (search.get_state() == Textfield::State::NORMAL && search.empty())
				placeholder.draw(position + Point<int16_t>(39, 51));
		}

		slider.draw(position + Point<int16_t>(126, 75));

		UIElement::draw_buttons(alpha);
	}

	void UIQuestLog::update()
	{
		search.update(get_search_pos(), get_search_dim());
	}

	void UIQuestLog::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
			{
				deactivate();
			}
			else if (keycode == KeyAction::Id::TAB)
			{
				uint16_t new_tab = tab;

				if (new_tab < Buttons::TAB2)
					new_tab++;
				else
					new_tab = Buttons::TAB0;

				change_tab(new_tab);
			}
		}
	}

	Cursor::State UIQuestLog::send_cursor(bool clicking, Point<int16_t> cursorpos)
	{
		if (Cursor::State new_state = search.send_cursor(cursorpos, clicking))
			return new_state;

		return UIDragElement::send_cursor(clicking, cursorpos);
	}

	UIElement::Type UIQuestLog::get_type() const
	{
		return TYPE;
	}

	Button::State UIQuestLog::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			case Buttons::TAB0:
			case Buttons::TAB1:
			case Buttons::TAB2:
				change_tab(buttonid);

				return Button::State::IDENTITY;
			case Buttons::CLOSE:
				deactivate();
				return Button::State::NORMAL;
			default:
				return Button::State::DISABLED;
		}
	}

	void UIQuestLog::change_tab(uint16_t tabid)
	{
		uint16_t oldtab = tab;
		tab = tabid;

		if (oldtab != tab)
		{
			buttons[Buttons::TAB0 + oldtab]->set_state(Button::State::NORMAL);
			buttons[Buttons::MY_LOCATION]->set_active(tab == Buttons::TAB0);
			buttons[Buttons::ALL_LEVEL]->set_active(tab == Buttons::TAB0);
			buttons[Buttons::SEARCH]->set_active(tab != Buttons::TAB2);

			if (tab == Buttons::TAB2)
				search.set_state(Textfield::State::DISABLED);
			else
				search.set_state(Textfield::State::NORMAL);
		}

		buttons[Buttons::TAB0 + tab]->set_state(Button::State::PRESSED);
	}

	Point<int16_t> UIQuestLog::get_search_pos()
	{
		Point<int16_t> search_area_origin = search_area.get_origin().abs();
		Point<int16_t> search_pos_adj = Point<int16_t>(25, 4);

		return position + search_area_origin + search_pos_adj;
	}

	Point<int16_t> UIQuestLog::get_search_dim()
	{
		Point<int16_t> adjust = Point<int16_t>(-75, -8);

		return search_area.get_dimensions() + adjust;
	}
}

================
File: IO/UITypes/UIQuestLog.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../Components/Slider.h"
#include "../Components/Textfield.h"

#include "../../Character/QuestLog.h"

namespace ms
{
	class UIQuestLog : public UIDragElement<PosQUEST>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::QUESTLOG;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIQuestLog(const QuestLog& questLog);

		void draw(float inter) const override;
		void update() override;

		void send_key(int32_t keycode, bool pressed, bool escape) override;
		Cursor::State send_cursor(bool clicking, Point<int16_t> cursorpos) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void change_tab(uint16_t tabid);

		Point<int16_t> get_search_pos();
		Point<int16_t> get_search_dim();

		enum Buttons : uint16_t
		{
			TAB0,
			TAB1,
			TAB2,
			CLOSE,
			SEARCH,
			ALL_LEVEL,
			MY_LOCATION
		};

		const QuestLog& questlog;

		uint16_t tab;
		std::vector<Sprite> notice_sprites;
		Textfield search;
		Text placeholder;
		Slider slider;
		Texture search_area;
	};
}

================
File: IO/UITypes/UIQuit.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIQuit.h"

#include "../UI.h"
#include "../Window.h"

#include "../Components/MapleButton.h"

#include "../../Character/ExpTable.h"
#include "../../Gameplay/Stage.h"
#include "../../Net/Session.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIQuit::UIQuit(const CharStats& st) : screen_adj(212, 104), stats(st)
	{
		nl::node askReward = nl::nx::UI["UIWindow6.img"]["askReward"];
		nl::node userLog = askReward["userLog"];
		nl::node exp = userLog["exp"];
		nl::node level = userLog["level"];
		nl::node time = userLog["time"];
		nl::node backgrnd = userLog["backgrnd"];

		sprites.emplace_back(backgrnd, -screen_adj);

		buttons[Buttons::NO] = std::make_unique<MapleButton>(askReward["btNo"], Point<int16_t>(0, 47));
		buttons[Buttons::YES] = std::make_unique<MapleButton>(askReward["btYes"], Point<int16_t>(0, 47));

		Stage& stage = Stage::get();

		/// Time
		int64_t uptime = stage.get_uptime() / 1000 / 1000;
		minutes = uptime / 60;
		hours = minutes / 60;

		minutes -= hours * 60;

		time_minutes = Charset(time["number"], Charset::Alignment::LEFT);
		time_minutes_pos = time["posM"];
		time_minutes_text = pad_time(minutes);

		time_hours = Charset(time["number"], Charset::Alignment::LEFT);
		time_hours_pos = time["posH"];
		time_hours_text = pad_time(hours);

		time_number_width = time["numberWidth"];

		time_lt = time["tooltip"]["lt"];
		time_rb = time["tooltip"]["rb"];

		/// Level
		levelupEffect = level["levelupEffect"];

		uplevel = stage.get_uplevel();

		levelBefore = Charset(level["number"], Charset::Alignment::LEFT);
		levelBeforePos = level["posBefore"];
		levelBeforeText = std::to_string(uplevel);

		cur_level = stats.get_stat(MapleStat::Id::LEVEL);

		levelAfter = Charset(level["number"], Charset::Alignment::LEFT);
		levelAfterPos = Point<int16_t>(level["posAfter"]) - Point<int16_t>(10, 0);
		levelAfterText = std::to_string(cur_level);

		levelNumberWidth = level["numberWidth"];

		level_adj = Point<int16_t>(50, 0);

		/// Experience
		int64_t upexp = stage.get_upexp();
		float expPercentBefore = getexppercent(uplevel, upexp);
		std::string expBeforeString = std::to_string(100 * expPercentBefore);
		std::string expBeforeText = expBeforeString.substr(0, expBeforeString.find('.') + 3) + '%';

		expBefore = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, expBeforeText);
		expBeforePos = exp["posBefore"];

		int64_t cur_exp = stats.get_exp();
		float expPercentAfter = getexppercent(cur_level, cur_exp);
		std::string expAfterString = std::to_string(100 * expPercentAfter);
		std::string expAfterText = expAfterString.substr(0, expAfterString.find('.') + 3) + '%';

		expAfter = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::ELECTRICLIME, expAfterText);
		expAfterPos = exp["posAfter"];

		exp_adj = Point<int16_t>(0, 4);

		int16_t width = Constants::Constants::get().get_viewwidth();
		int16_t height = Constants::Constants::get().get_viewheight();

		background = ColorBox(width, height, Color::Name::BLACK, 0.5f);
		position = Point<int16_t>(width / 2, height / 2);
		dimension = Texture(backgrnd).get_dimensions();
	}

	void UIQuit::draw(float inter) const
	{
		background.draw(Point<int16_t>(0, 0));

		UIElement::draw(inter);

		Point<int16_t> time_adj = Point<int16_t>(188, -2);

		time_minutes.draw(time_minutes_text, time_number_width, position + time_minutes_pos - time_adj + Point<int16_t>(50, 0));
		time_hours.draw(time_hours_text + "dot", time_number_width, position + time_hours_pos - time_adj);

		levelBefore.draw(levelBeforeText, levelNumberWidth, position + levelBeforePos + level_adj - screen_adj);
		levelAfter.draw(levelAfterText, levelNumberWidth, position + levelAfterPos + level_adj - screen_adj);

		if (cur_level > uplevel)
			levelupEffect.draw(position - screen_adj, inter);

		expBefore.draw(position + expBeforePos - exp_adj - screen_adj);
		expAfter.draw(position + expAfterPos - exp_adj - screen_adj);
	}

	void UIQuit::update()
	{
		UIElement::update();

		levelupEffect.update();
	}

	Cursor::State UIQuit::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		auto lt = position + time_lt - screen_adj;
		auto rb = position + time_rb - screen_adj;

		auto bounds = Rectangle<int16_t>(lt, rb);

		if (bounds.contains(cursorpos))
			UI::get().show_text(Tooltip::Parent::TEXT, std::to_string(hours) + "Hour " + std::to_string(minutes) + "Minute");
		else
			UI::get().clear_tooltip(Tooltip::Parent::TEXT);

		return UIElement::send_cursor(clicked, cursorpos);
	}

	void UIQuit::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
				close();
			else if (keycode == KeyAction::Id::RETURN)
				button_pressed(Buttons::YES);
		}
	}

	UIElement::Type UIQuit::get_type() const
	{
		return TYPE;
	}

	Button::State UIQuit::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
		case Buttons::NO:
			close();
			break;
		case Buttons::YES:
		{
			Constants::Constants::get().set_viewwidth(1024);
			Constants::Constants::get().set_viewheight(768);

			float fadestep = 0.025f;

			Window::get().fadeout(
				fadestep,
				[]()
				{
					GraphicsGL::get().clear();

					UI::get().change_state(UI::State::LOGIN);
					UI::get().set_scrollnotice("");
					Session::get().reconnect();

					UI::get().enable();
					Timer::get().start();
					GraphicsGL::get().unlock();
				}
			);

			GraphicsGL::get().lock();
			Stage::get().clear();
			Timer::get().start();
		}
		break;
		default:
			break;
		}

		return Button::State::NORMAL;
	}

	std::string UIQuit::pad_time(int64_t time)
	{
		std::string ctime = std::to_string(time);
		size_t length = ctime.length();

		if (length > 2)
			return "99";

		return std::string(2 - length, '0') + ctime;
	}

	float UIQuit::getexppercent(uint16_t level, int64_t exp) const
	{
		if (level >= ExpTable::LEVELCAP)
			return 0.0f;

		return static_cast<float>(
			static_cast<double>(exp) / ExpTable::values[level]
			);
	}

	void UIQuit::close()
	{
		deactivate();

		UI::get().clear_tooltip(Tooltip::Parent::TEXT);
	}
}

================
File: IO/UITypes/UIQuit.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../Components/Charset.h"

#include "../../Character/CharStats.h"
#include "../../Graphics/Geometry.h"

namespace ms
{
	class UIQuit : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::QUIT;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = false;

		UIQuit(const CharStats& stats);

		void draw(float inter) const override;
		void update() override;

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		const CharStats& stats;

		std::string pad_time(int64_t time);
		float getexppercent(uint16_t level, int64_t exp) const;
		void close();

		enum Buttons : uint16_t
		{
			NO,
			YES
		};

		Point<int16_t> screen_adj;
		ColorBox background;

		/// Time
		int64_t minutes;
		int64_t hours;

		Charset time_minutes;
		Point<int16_t> time_minutes_pos;
		std::string time_minutes_text;

		Charset time_hours;
		Point<int16_t> time_hours_pos;
		std::string time_hours_text;

		int64_t time_number_width;

		Point<int16_t> time_lt;
		Point<int16_t> time_rb;

		/// Level
		Sprite levelupEffect;

		uint16_t uplevel;

		Charset levelBefore;
		Point<int16_t> levelBeforePos;
		std::string levelBeforeText;

		uint16_t cur_level;

		Charset levelAfter;
		Point<int16_t> levelAfterPos;
		std::string levelAfterText;

		int64_t levelNumberWidth;
		Point<int16_t> level_adj;

		/// Experience
		Text expBefore;
		Point<int16_t> expBeforePos;

		Text expAfter;
		Point<int16_t> expAfterPos;

		Point<int16_t> exp_adj;
	};
}

================
File: IO/UITypes/UIRaceSelect.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIRaceSelect.h"

#include "UIAranCreation.h"
#include "UICharSelect.h"
#include "UICygnusCreation.h"
#include "UIExplorerCreation.h"
#include "UILoginNotice.h"
#include "UIWorldSelect.h"

#include "../UI.h"

#include "../Components/AreaButton.h"
#include "../Components/MapleButton.h"

#include "../../Configuration.h"

#include "../../Audio/Audio.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIRaceSelect::UIRaceSelect() : UIElement(Point<int16_t>(0, 0), Point<int16_t>(800, 600))
	{
		std::string version_text = Configuration::get().get_version();
		version = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::LEMONGRASS, "Ver. " + version_text);
		version_pos = nl::nx::UI["Login.img"]["Common"]["version"]["pos"];

		nl::node Login = nl::nx::UI["Login.img"];
		nl::node Common = Login["Common"];
		nl::node RaceSelect = Login["RaceSelect_new"];

		Point<int16_t> make_pos = RaceSelect["make"]["pos"];
		Point<int16_t> make_posZero = RaceSelect["make"]["posZero"];

		pos = Point<int16_t>(std::abs(make_pos.x()), std::abs(make_pos.y()));
		posZero = Point<int16_t>(std::abs(make_posZero.x()), std::abs(make_posZero.y()));

		nl::node tempOrder = RaceSelect["order"][SELECTED_LIST];

		for (size_t i = 0; i < tempOrder.size(); i++)
			if (tempOrder[i].get_integer() != Classes::PINKBEAN)
				order.push_back(tempOrder[i]);

		hotlist = RaceSelect["hotList"][SELECTED_LIST];
		newlist = RaceSelect["newList"][SELECTED_LIST];
		bgm = RaceSelect["bgm"];

		hotlabel = RaceSelect["hotLabel"];
		hotlabelZero = RaceSelect["hotLabel2"];
		newlabel = RaceSelect["newLabel"];
		newlabelPos = RaceSelect["newLabel"]["pos"];
		hotbtn = RaceSelect["hot"];
		hotbtnPos = RaceSelect["hot"]["offset"];
		newbtn = RaceSelect["new"];
		newbtnPos = RaceSelect["new"]["offset"];

		class_index[0] = order[0];
		class_index[1] = order[1];
		class_index[2] = order[2];
		class_index[3] = order[3];
		class_index[4] = order[4];
		class_index[5] = order[5];

		mouseover[0] = true;
		mouseover[1] = false;
		mouseover[2] = false;
		mouseover[3] = false;
		mouseover[4] = false;
		mouseover[5] = false;

		nl::node button = RaceSelect["button"];
		nl::node buttonDisabled = RaceSelect["buttonDisabled"];
		buttonIntervalX = button["intervalX"];
		buttonPos = button["pos"];

		class_count = order.size();
		class_isdisabled = std::vector<bool>(class_count, true);
		class_disabled = std::vector<BoolPair<Texture>>(class_count);
		class_normal = std::vector<BoolPair<Texture>>(class_count);
		class_background = std::vector<Texture>(class_count);
		class_details = std::vector<Texture>(class_count);
		class_title = std::vector<Texture>(class_count);
		class_map = std::vector<uint16_t>(class_count);

		class_isdisabled[Classes::EXPLORERS] = false;
		class_isdisabled[Classes::CYGNUSKNIGHTS] = false;
		class_isdisabled[Classes::ARAN] = false;

		back = RaceSelect["Back"]["1"]["0"];
		backZero = RaceSelect["Back"]["2"]["0"];
		back_ani = RaceSelect["BackAni"];
		class_details_background = RaceSelect["Back1"]["0"]["0"];
		class_details_backgroundZero = RaceSelect["Back1"]["1"]["0"];

		Back2 = RaceSelect["Back2"];
		dot = Back2["dot"]["dot"];

		uint16_t node_index = 0;

		for (nl::node node : button)
		{
			std::string name = node.name();

			if (name == "intervalX" || name == "pos" || name == std::to_string(Classes::PINKBEAN) || name == std::to_string(Classes::YETI))
				continue;

			class_map[node_index++] = std::stoi(name);
		}

		std::sort(class_map.begin(), class_map.begin() + class_count);

		for (uint16_t i = 0; i < class_count; i++)
		{
			uint16_t corrected_index = class_map[i];

			class_normal[i][false] = button[corrected_index]["normal"]["0"];
			class_normal[i][true] = button[corrected_index]["mouseOver"]["0"];

			class_disabled[i][false] = buttonDisabled[corrected_index]["normal"]["0"];
			class_disabled[i][true] = buttonDisabled[corrected_index]["mouseOver"]["0"];

			if (i == 9)
				class_background[i] = RaceSelect["Back0"][corrected_index]["99"];
			else
				class_background[i] = RaceSelect["Back0"][corrected_index]["0"];

			class_details[i] = Back2[corrected_index]["0"];
			class_title[i] = RaceSelect["Back3"][corrected_index]["0"];
		}

		buttons[Buttons::BtStart] = std::make_unique<MapleButton>(Common["BtStart"], Point<int16_t>(0, 1));
		buttons[Buttons::BtPreview] = std::make_unique<MapleButton>(Common["BtPreview"]);
		buttons[Buttons::BtMake] = std::make_unique<MapleButton>(RaceSelect["make"]);
		buttons[Buttons::BtLeftArrow] = std::make_unique<MapleButton>(RaceSelect["leftArrow"]);
		buttons[Buttons::BtRightArrow] = std::make_unique<MapleButton>(RaceSelect["rightArrow"]);

		for (size_t i = 0; i <= Buttons::CLASS0; i++)
			buttons[Buttons::CLASS0 + i] = std::make_unique<AreaButton>(get_class_pos(i), class_normal[0][true].get_dimensions());

		index_shift = 0;
		selected_index = 0;
		selected_class = class_index[selected_index];

		buttons[Buttons::BtLeftArrow]->set_state(Button::State::DISABLED);

		Sound(Sound::Name::RACESELECT).play();
	}

	void UIRaceSelect::draw(float inter) const
	{
		uint16_t corrected_index = get_corrected_class_index(selected_class);

		if (selected_class == Classes::ZERO)
			backZero.draw(position);
		else
			back.draw(position);

		UIElement::draw_sprites(inter);

		version.draw(position + version_pos - Point<int16_t>(0, 5));

		class_background[corrected_index].draw(position);

		if (selected_class == Classes::ZERO)
			class_details_backgroundZero.draw(position);
		else
			class_details_background.draw(position);

		class_details[corrected_index].draw(position);
		class_title[corrected_index].draw(position);

		for (nl::node node : hotlist)
		{
			if (node.get_integer() == selected_class)
			{
				if (selected_class == Classes::ZERO)
					hotlabelZero.draw(position, inter);
				else
					hotlabel.draw(position, inter);

				break;
			}
		}

		for (nl::node node : newlist)
		{
			if (node.get_integer() == selected_class)
			{
				newlabel.draw(position - Point<int16_t>(1, 0), inter);
				break;
			}
		}

		for (uint16_t i = 0; i < INDEX_COUNT; i++)
		{
			uint16_t cur_index = class_index[i];
			uint16_t cur_class = get_corrected_class_index(cur_index);

			bool selected = mouseover[i];
			bool disabled = class_isdisabled[cur_class];
			auto& found_class = disabled ? class_disabled : class_normal;
			Point<int16_t> button_pos = get_class_pos(i);
			Point<int16_t> pos_adj = (disabled && !selected) ? Point<int16_t>(0, 2) : Point<int16_t>(0, 0);
			found_class[cur_class][selected].draw(position + button_pos + pos_adj);

			for (nl::node node : hotlist)
			{
				if (node.get_integer() == cur_index)
				{
					hotbtn.draw(position + button_pos + hotbtnPos, inter);
					break;
				}
			}

			for (nl::node node : newlist)
			{
				if (node.get_integer() == cur_index)
				{
					newbtn.draw(position + button_pos + newbtnPos, inter);
					break;
				}
			}
		}

		nl::node dot_pos = Back2[corrected_index]["dot"];

		if (dot_pos)
		{
			dot.draw(DrawArgument(dot_pos["pos_ctrl"][dot_pos["ctrl"]]));
			dot.draw(DrawArgument(dot_pos["pos_def"][dot_pos["def"]]));
			dot.draw(DrawArgument(dot_pos["pos_pow"][dot_pos["pow"]]));
			dot.draw(DrawArgument(dot_pos["pos_spd"][dot_pos["spd"]]));
		}

		UIElement::draw_buttons(inter);

		back_ani.draw(position, inter);
	}

	void UIRaceSelect::update()
	{
		UIElement::update();

		hotlabel.update();
		hotlabelZero.update();
		newlabel.update();
		hotbtn.update();
		newbtn.update();

		if (selected_class == Classes::ZERO)
			buttons[Buttons::BtMake]->set_position(position + posZero);
		else
			buttons[Buttons::BtMake]->set_position(position + pos);

		back_ani.update();
	}

	Cursor::State UIRaceSelect::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		for (auto& btit : buttons)
		{
			if (btit.second->is_active() && btit.second->bounds(position).contains(cursorpos))
			{
				if (btit.second->get_state() == Button::State::NORMAL)
				{
					Sound(Sound::Name::BUTTONOVER).play();

					if (btit.first >= Buttons::CLASS0)
						mouseover[btit.first - Buttons::CLASS0] = true;

					btit.second->set_state(Button::State::MOUSEOVER);
				}
				else if (btit.second->get_state() == Button::State::MOUSEOVER)
				{
					if (clicked)
					{
						Sound(Sound::Name::BUTTONCLICK).play();

						btit.second->set_state(button_pressed(btit.first));
					}
					else
					{
						if (btit.first >= Buttons::CLASS0)
							mouseover[btit.first - Buttons::CLASS0] = true;
					}
				}
			}
			else if (btit.second->get_state() == Button::State::MOUSEOVER)
			{
				if (btit.first >= Buttons::CLASS0)
					mouseover[btit.first - Buttons::CLASS0] = false;

				btit.second->set_state(Button::State::NORMAL);
			}
		}

		return Cursor::State::LEAF;
	}

	void UIRaceSelect::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
			{
				show_charselect();
			}
			else if (keycode == KeyAction::Id::LEFT || keycode == KeyAction::Id::DOWN)
			{
				if (buttons[Buttons::BtLeftArrow]->get_state() == Button::State::NORMAL)
					button_pressed(Buttons::BtLeftArrow);
			}
			else if (keycode == KeyAction::Id::RIGHT || keycode == KeyAction::Id::UP)
			{
				if (buttons[Buttons::BtRightArrow]->get_state() == Button::State::NORMAL)
					button_pressed(Buttons::BtRightArrow);
			}
			else if (keycode == KeyAction::Id::RETURN)
			{
				button_pressed(Buttons::BtMake);
			}
		}
	}

	UIElement::Type UIRaceSelect::get_type() const
	{
		return TYPE;
	}

	bool UIRaceSelect::check_name(std::string name) const
	{
		nl::node ForbiddenName = nl::nx::Etc["ForbiddenName.img"];

		for (std::string forbiddenName : ForbiddenName)
		{
			std::string lName = to_lower(name);
			std::string fName = to_lower(forbiddenName);

			if (lName.find(fName) != std::string::npos)
				return false;
		}

		return true;
	}

	void UIRaceSelect::send_naming_result(bool nameused)
	{
		if (selected_class == Classes::EXPLORERS)
		{
			if (auto explorercreation = UI::get().get_element<UIExplorerCreation>())
				explorercreation->send_naming_result(nameused);
		}
		else if (selected_class == Classes::CYGNUSKNIGHTS)
		{
			if (auto cygnuscreation = UI::get().get_element<UICygnusCreation>())
				cygnuscreation->send_naming_result(nameused);
		}
		else if (selected_class == Classes::ARAN)
		{
			if (auto arancreation = UI::get().get_element<UIAranCreation>())
				arancreation->send_naming_result(nameused);
		}
	}

	Button::State UIRaceSelect::button_pressed(uint16_t buttonid)
	{
		if (buttonid == Buttons::BtStart)
		{
			show_worldselect();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtPreview)
		{
			show_charselect();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtMake)
		{
			uint16_t corrected_index = get_corrected_class_index(selected_class);

			std::function<void()> okhandler = [&, corrected_index]()
			{
				if (!class_isdisabled[corrected_index])
				{
					Sound(Sound::Name::SCROLLUP).play();

					deactivate();

					if (selected_class == Classes::EXPLORERS)
						UI::get().emplace<UIExplorerCreation>();
					else if (selected_class == Classes::CYGNUSKNIGHTS)
						UI::get().emplace<UICygnusCreation>();
					else if (selected_class == Classes::ARAN)
						UI::get().emplace<UIAranCreation>();
				}
			};

			UI::get().emplace<UIClassConfirm>(selected_class, class_isdisabled[corrected_index], okhandler);

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtLeftArrow)
		{
			uint16_t new_index = selected_index - 1;

			if (selected_index - index_shift == 0)
			{
				index_shift--;

				class_index[0] = order[new_index + 5 - Buttons::CLASS0];
				class_index[1] = order[new_index + 6 - Buttons::CLASS0];
				class_index[2] = order[new_index + 7 - Buttons::CLASS0];
				class_index[3] = order[new_index + 8 - Buttons::CLASS0];
				class_index[4] = order[new_index + 9 - Buttons::CLASS0];
				class_index[5] = order[new_index + 10 - Buttons::CLASS0];
			}

			select_class(new_index);

			return Button::State::IDENTITY;
		}
		else if (buttonid == Buttons::BtRightArrow)
		{
			uint16_t new_index = selected_index + 1;
			uint16_t selected = class_index[selected_index - index_shift];

			if (selected == class_index[5])
			{
				index_shift++;

				class_index[0] = order[new_index + 0 - Buttons::CLASS0];
				class_index[1] = order[new_index + 1 - Buttons::CLASS0];
				class_index[2] = order[new_index + 2 - Buttons::CLASS0];
				class_index[3] = order[new_index + 3 - Buttons::CLASS0];
				class_index[4] = order[new_index + 4 - Buttons::CLASS0];
				class_index[5] = order[new_index + 5 - Buttons::CLASS0];
			}

			select_class(new_index);

			return Button::State::IDENTITY;
		}
		else if (buttonid >= Buttons::CLASS0)
		{
			uint16_t index = buttonid - Buttons::CLASS0 + index_shift;

			select_class(index);

			return Button::State::IDENTITY;
		}
		else
		{
			return Button::State::DISABLED;
		}
	}

	void UIRaceSelect::select_class(uint16_t index)
	{
		uint16_t previous_index = selected_index;
		selected_index = index;

		if (previous_index != selected_index)
		{
			Sound(Sound::Name::RACESELECT).play();

			uint16_t previous = previous_index - index_shift;

			mouseover[previous] = false;
			buttons[previous + Buttons::CLASS0]->set_state(Button::State::NORMAL);

			uint16_t selected = selected_index - index_shift;

			selected_class = class_index[selected];
			mouseover[selected] = true;

			if (selected_class == Classes::KINESIS)
			{
				nl::node node = bgm[selected_class];
				std::string found_bgm = node["bgm"];
				std::size_t found_img = found_bgm.find(".img");

				if (found_img == std::string::npos)
				{
					std::size_t found_slash = found_bgm.find('/');

					if (found_slash != std::string::npos)
					{
						found_bgm.insert(found_slash, ".img");

						Music(found_bgm).play();
					}
				}
			}
			else if (class_index[previous] == Classes::KINESIS)
			{
				std::string LoginMusicNewtro = Configuration::get().get_login_music_newtro();

				Music(LoginMusicNewtro).play();
			}
		}
		else
		{
			button_pressed(Buttons::BtMake);
		}

		if (selected_index > 0)
			buttons[Buttons::BtLeftArrow]->set_state(Button::State::NORMAL);
		else
			buttons[Buttons::BtLeftArrow]->set_state(Button::State::DISABLED);

		if (selected_index < order.size() - 1)
			buttons[Buttons::BtRightArrow]->set_state(Button::State::NORMAL);
		else
			buttons[Buttons::BtRightArrow]->set_state(Button::State::DISABLED);
	}

	void UIRaceSelect::show_charselect()
	{
		Sound(Sound::Name::SCROLLUP).play();

		UI::get().remove(UIElement::Type::RACESELECT);

		if (auto charselect = UI::get().get_element<UICharSelect>())
			charselect->makeactive();
	}

	void UIRaceSelect::show_worldselect()
	{
		Sound(Sound::Name::SCROLLUP).play();

		UI::get().remove(UIElement::Type::RACESELECT);
		UI::get().remove(UIElement::Type::CHARSELECT);

		if (auto worldselect = UI::get().get_element<UIWorldSelect>())
			worldselect->makeactive();
	}

	Point<int16_t> UIRaceSelect::get_class_pos(size_t index) const
	{
		uint16_t x_adj = index * buttonIntervalX;

		return buttonPos + Point<int16_t>(x_adj, 0);
	}

	std::string UIRaceSelect::to_lower(std::string value) const
	{
		std::transform(value.begin(), value.end(), value.begin(), ::tolower);

		return value;
	}

	uint16_t UIRaceSelect::get_corrected_class_index(uint16_t index) const
	{
		for (uint16_t i = 0; i < class_count; i++)
			if (index == class_map[i])
				return i;

		LOG(LOG_DEBUG, "Failed to find corrected class index");

		return index;
	}
}

================
File: IO/UITypes/UIRaceSelect.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../Components/Textfield.h"

#include "../../Template/BoolPair.h"

namespace ms
{
	// Race selection screen
	class UIRaceSelect : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::RACESELECT;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = false;

		UIRaceSelect();

		void draw(float inter) const override;
		void update() override;

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		bool check_name(std::string name) const;
		void send_naming_result(bool nameused);

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void select_class(uint16_t index);
		void show_charselect();
		void show_worldselect();
		Point<int16_t> get_class_pos(size_t index) const;
		std::string to_lower(std::string value) const;
		uint16_t get_corrected_class_index(uint16_t index) const;

		static constexpr uint16_t INDEX_COUNT = 6;
		static constexpr uint16_t SELECTED_LIST = 35;

		enum Buttons : uint16_t
		{
			BtStart,
			BtPreview,
			BtMake,
			BtLeftArrow,
			BtRightArrow,
			CLASS0,
			CLASS1,
			CLASS2,
			CLASS3,
			CLASS4
		};

		enum Classes : uint16_t
		{
			RESISTANCE,
			EXPLORERS,
			CYGNUSKNIGHTS,
			ARAN,
			EVAN,
			MERCEDES,
			DEMON,
			PHANTOM,
			DUALBLADE,
			MIHILE,
			LUMINOUS,
			KAISER,
			ANGELICBUSTER,
			CANNONEER,
			XENON,
			ZERO,
			SHADE,
			PINKBEAN,
			KINESIS,
			CADENA,
			ILLIUM,
			ARK,
			PATHFINDER,
			HOYOUNG,
			ADELE,
			KAIN,
			YETI,
			LARA,
			JETT = 1000,
			HAYATO,
			KANNA,
			CHASE
		};

		Text version;
		Point<int16_t> version_pos;
		Point<int16_t> pos;
		Point<int16_t> posZero;
		std::vector<uint16_t> order;
		nl::node hotlist;
		nl::node newlist;
		nl::node bgm;
		nl::node Back2;
		Sprite hotlabel;
		Sprite hotlabelZero;
		Sprite newlabel;
		Point<int16_t> newlabelPos;
		Sprite hotbtn;
		Point<int16_t> hotbtnPos;
		Sprite newbtn;
		Point<int16_t> newbtnPos;
		uint16_t class_index[INDEX_COUNT];
		bool mouseover[INDEX_COUNT];
		uint16_t selected_class;
		uint16_t index_shift;
		uint16_t selected_index;
		uint16_t class_count;
		std::vector<bool> class_isdisabled;
		std::vector<BoolPair<Texture>> class_disabled;
		std::vector<BoolPair<Texture>> class_normal;
		std::vector<Texture> class_background;
		std::vector<Texture> class_details;
		std::vector<Texture> class_title;
		std::vector<uint16_t> class_map;
		Texture back;
		Texture backZero;
		Sprite back_ani;
		Texture class_details_background;
		Texture class_details_backgroundZero;
		Texture dot;
		int16_t buttonIntervalX;
		Point<int16_t> buttonPos;
	};
}

================
File: IO/UITypes/UIRegion.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIRegion.h"

#include "UIWorldSelect.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIRegion::UIRegion() : UIElement(Point<int16_t>(0, 0), Point<int16_t>(800, 600))
	{
		nl::node Gateway = nl::nx::UI["Gateway.img"]["WorldSelect"];
		nl::node na = Gateway["BtButton0"];
		nl::node eu = Gateway["BtButton1"];

		sprites.emplace_back(Gateway["backgrnd2"]);

		int16_t pos_y = 254;
		Point<int16_t> na_pos = Point<int16_t>(190, pos_y);
		Point<int16_t> eu_pos = Point<int16_t>(579, pos_y);

		buttons[Buttons::NA] = std::make_unique<MapleButton>(na, na_pos);
		buttons[Buttons::EU] = std::make_unique<MapleButton>(eu, eu_pos);
		buttons[Buttons::EXIT] = std::make_unique<MapleButton>(nl::nx::UI["Login.img"]["Common"]["BtExit"]);

		Point<int16_t> na_dim = Texture(na["normal"]["0"]).get_dimensions();
		Point<int16_t> eu_dim = Texture(eu["normal"]["0"]).get_dimensions();

		na_rect = Rectangle<int16_t>(na_pos, na_pos + na_dim);
		eu_rect = Rectangle<int16_t>(eu_pos, eu_pos + eu_dim);
	}

	Cursor::State UIRegion::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		clear_tooltip();

		if (na_rect.contains(cursorpos))
			UI::get().show_text(Tooltip::Parent::TEXT, "Warning: You may experience latency and connection issues when connecting to the NA server from Europe.");

		if (eu_rect.contains(cursorpos))
			UI::get().show_text(Tooltip::Parent::TEXT, "Warning: You may experience latency and connection issues when connecting to the EU server from North America.");

		return UIElement::send_cursor(clicked, cursorpos);
	}

	UIElement::Type UIRegion::get_type() const
	{
		return TYPE;
	}

	Button::State UIRegion::button_pressed(uint16_t buttonid)
	{
		clear_tooltip();

		switch (buttonid)
		{
			case Buttons::NA:
			case Buttons::EU:
			{
				// TODO: Update UIWorldSelect after selecting new region
				//uint8_t region = (buttonid == Buttons::NA) ? 5 : 6;

				if (auto worldselect = UI::get().get_element<UIWorldSelect>())
				{
					UI::get().remove(UIElement::Type::REGION);

					//worldselect->set_region(region);
					worldselect->makeactive();
				}

				break;
			}
			case Buttons::EXIT:
			{
				UI::get().quit();
				break;
			}
			default:
			{
				break;
			}
		}

		return Button::State::NORMAL;
	}

	void UIRegion::clear_tooltip()
	{
		UI::get().clear_tooltip(Tooltip::Parent::TEXT);
	}
}

================
File: IO/UITypes/UIRegion.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

namespace ms
{
	class UIRegion : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::REGION;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = false;

		UIRegion();

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void clear_tooltip();

		enum Buttons : uint16_t
		{
			NA,
			EU,
			EXIT
		};

		Rectangle<int16_t> na_rect;
		Rectangle<int16_t> eu_rect;
	};
}

================
File: IO/UITypes/UIShop.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIShop.h"

#include "UINotice.h"

#include "../UI.h"

#include "../Components/AreaButton.h"
#include "../Components/Charset.h"
#include "../Components/MapleButton.h"

#include "../../Audio/Audio.h"
#include "../../Data/ItemData.h"

#include "../../Net/Packets/NpcInteractionPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIShop::UIShop(const CharLook& in_charlook, const Inventory& in_inventory) : UIDragElement<PosSHOP>(), charlook(in_charlook), inventory(in_inventory)
	{
		nl::node src = nl::nx::UI["UIWindow2.img"]["Shop2"];

		nl::node background = src["backgrnd"];
		Texture bg = background;

		auto bg_dimensions = bg.get_dimensions();

		sprites.emplace_back(background);
		sprites.emplace_back(src["backgrnd2"]);
		sprites.emplace_back(src["backgrnd3"]);
		sprites.emplace_back(src["backgrnd4"]);

		buttons[Buttons::BUY_ITEM] = std::make_unique<MapleButton>(src["BtBuy"]);
		buttons[Buttons::SELL_ITEM] = std::make_unique<MapleButton>(src["BtSell"]);
		buttons[Buttons::EXIT] = std::make_unique<MapleButton>(src["BtExit"]);

		Texture cben = src["checkBox"][0];
		Texture cbdis = src["checkBox"][1];

		Point<int16_t> cb_origin = cben.get_origin();
		int16_t cb_x = cb_origin.x();
		int16_t cb_y = cb_origin.y();

		checkBox[0] = cbdis;
		checkBox[1] = cben;

		buttons[Buttons::CHECKBOX] = std::make_unique<AreaButton>(Point<int16_t>(std::abs(cb_x), std::abs(cb_y)), cben.get_dimensions());

		nl::node buyen = src["TabBuy"]["enabled"];
		nl::node buydis = src["TabBuy"]["disabled"];

		buttons[Buttons::OVERALL] = std::make_unique<TwoSpriteButton>(buydis[0], buyen[0]);

		nl::node sellen = src["TabSell"]["enabled"];
		nl::node selldis = src["TabSell"]["disabled"];

		for (uint16_t i = Buttons::EQUIP; i <= Buttons::CASH; i++)
		{
			std::string tabnum = std::to_string(i - Buttons::EQUIP);
			buttons[i] = std::make_unique<TwoSpriteButton>(selldis[tabnum], sellen[tabnum]);
		}

		int16_t item_y = 124;
		int16_t item_height = 36;

		buy_x = 8;
		buy_width = 257;

		for (uint16_t i = Buttons::BUY0; i <= Buttons::BUY8; i++)
		{
			Point<int16_t> pos(buy_x, item_y + 42 * (i - Buttons::BUY0));
			Point<int16_t> dim(buy_width, item_height);
			buttons[i] = std::make_unique<AreaButton>(pos, dim);
		}

		sell_x = 284;
		sell_width = 200;

		for (uint16_t i = Buttons::SELL0; i <= Buttons::SELL8; i++)
		{
			Point<int16_t> pos(sell_x, item_y + 42 * (i - Buttons::SELL0));
			Point<int16_t> dim(sell_width, item_height);
			buttons[i] = std::make_unique<AreaButton>(pos, dim);
		}

		buy_selection = src["select"];
		sell_selection = src["select2"];
		meso = src["meso"];

		mesolabel = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::MINESHAFT);

		buyslider = Slider(
			Slider::Type::DEFAULT_SILVER, Range<int16_t>(123, 484), 257, 5, 1,
			[&](bool upwards)
			{
				int16_t shift = upwards ? -1 : 1;
				bool above = buystate.offset + shift >= 0;
				bool below = buystate.offset + shift <= buystate.lastslot - 5;

				if (above && below)
					buystate.offset += shift;
			}
		);

		sellslider = Slider(
			Slider::Type::DEFAULT_SILVER, Range<int16_t>(123, 484), 488, 5, 1,
			[&](bool upwards)
			{
				int16_t shift = upwards ? -1 : 1;
				bool above = sellstate.offset + shift >= 0;
				bool below = sellstate.offset + shift <= sellstate.lastslot - 5;

				if (above && below)
					sellstate.offset += shift;
			}
		);

		active = false;
		dimension = bg_dimensions;
		dragarea = Point<int16_t>(bg_dimensions.x(), 10);
	}

	void UIShop::draw(float alpha) const
	{
		UIElement::draw(alpha);

		npc.draw(DrawArgument(position + Point<int16_t>(58, 85), true));
		charlook.draw(position + Point<int16_t>(338, 85), false, Stance::Id::STAND1, Expression::Id::DEFAULT);

		mesolabel.draw(position + Point<int16_t>(493, 51));

		buystate.draw(position, buy_selection);
		sellstate.draw(position, sell_selection);

		buyslider.draw(position);
		sellslider.draw(position);

		checkBox[rightclicksell].draw(position);
	}

	void UIShop::update()
	{
		int64_t num_mesos = inventory.get_meso();
		std::string mesostr = std::to_string(num_mesos);
		string_format::split_number(mesostr);
		mesolabel.change_text(mesostr);
	}

	Button::State UIShop::button_pressed(uint16_t buttonid)
	{
		clear_tooltip();

		constexpr Range<uint16_t> buy(Buttons::BUY0, Buttons::BUY8);
		constexpr Range<uint16_t> sell(Buttons::SELL0, Buttons::SELL8);

		if (buy.contains(buttonid))
		{
			int16_t selected = buttonid - Buttons::BUY0;
			buystate.select(selected);
			sellstate.selection = -1;

			return Button::State::NORMAL;
		}
		else if (sell.contains(buttonid))
		{
			int16_t selected = buttonid - Buttons::SELL0;
			sellstate.select(selected);
			buystate.selection = -1;

			return Button::State::NORMAL;
		}
		else
		{
			switch (buttonid)
			{
			case Buttons::BUY_ITEM:
				buystate.buy();

				return Button::State::NORMAL;
			case Buttons::SELL_ITEM:
				sellstate.sell(false);

				return Button::State::NORMAL;
			case Buttons::EXIT:
				exit_shop();

				return Button::State::PRESSED;
			case Buttons::CHECKBOX:
				rightclicksell = !rightclicksell;
				Configuration::get().set_rightclicksell(rightclicksell);

				return Button::State::NORMAL;
			case Buttons::EQUIP:
				changeselltab(InventoryType::Id::EQUIP);

				return Button::State::IDENTITY;
			case Buttons::USE:
				changeselltab(InventoryType::Id::USE);

				return Button::State::IDENTITY;
			case Buttons::ETC:
				changeselltab(InventoryType::Id::ETC);

				return Button::State::IDENTITY;
			case Buttons::SETUP:
				changeselltab(InventoryType::Id::SETUP);

				return Button::State::IDENTITY;
			case Buttons::CASH:
				changeselltab(InventoryType::Id::CASH);

				return Button::State::IDENTITY;
			}
		}

		return Button::State::PRESSED;
	}

	void UIShop::remove_cursor()
	{
		UIDragElement::remove_cursor();

		buyslider.remove_cursor();
		sellslider.remove_cursor();
	}

	Cursor::State UIShop::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		Point<int16_t> cursoroffset = cursorpos - position;
		lastcursorpos = cursoroffset;

		if (buyslider.isenabled())
		{
			Cursor::State bstate = buyslider.send_cursor(cursoroffset, clicked);

			if (bstate != Cursor::State::IDLE)
			{
				clear_tooltip();

				return bstate;
			}
		}

		if (sellslider.isenabled())
		{
			Cursor::State sstate = sellslider.send_cursor(cursoroffset, clicked);

			if (sstate != Cursor::State::IDLE)
			{
				clear_tooltip();

				return sstate;
			}
		}

		int16_t xoff = cursoroffset.x();
		int16_t yoff = cursoroffset.y();
		int16_t slot = slot_by_position(yoff);

		if (slot >= 0 && slot <= 8)
		{
			if (xoff >= buy_x && xoff <= buy_width)
				show_item(slot, true);
			else if (xoff >= sell_x && xoff <= sell_x + sell_width)
				show_item(slot, false);
			else
				clear_tooltip();
		}
		else
		{
			clear_tooltip();
		}

		Cursor::State ret = clicked ? Cursor::State::CLICKING : Cursor::State::IDLE;

		for (size_t i = 0; i < Buttons::NUM_BUTTONS; i++)
		{
			if (buttons[i]->is_active() && buttons[i]->bounds(position).contains(cursorpos))
			{
				if (buttons[i]->get_state() == Button::State::NORMAL)
				{
					if (i >= Buttons::BUY_ITEM && i <= Buttons::EXIT)
					{
						Sound(Sound::Name::BUTTONOVER).play();

						buttons[i]->set_state(Button::State::MOUSEOVER);
						ret = Cursor::State::CANCLICK;
					}
					else
					{
						buttons[i]->set_state(Button::State::MOUSEOVER);
						ret = Cursor::State::IDLE;
					}
				}
				else if (buttons[i]->get_state() == Button::State::MOUSEOVER)
				{
					if (clicked)
					{
						if (i >= Buttons::BUY_ITEM && i <= Buttons::CASH)
						{
							if (i >= Buttons::OVERALL && i <= Buttons::CASH)
							{
								Sound(Sound::Name::TAB).play();
							}
							else
							{
								if (i != Buttons::CHECKBOX)
									Sound(Sound::Name::BUTTONCLICK).play();
							}

							buttons[i]->set_state(button_pressed(i));

							ret = Cursor::State::IDLE;
						}
						else
						{
							buttons[i]->set_state(button_pressed(i));

							ret = Cursor::State::IDLE;
						}
					}
					else
					{
						if (i >= Buttons::BUY_ITEM && i <= Buttons::EXIT)
							ret = Cursor::State::CANCLICK;
						else
							ret = Cursor::State::IDLE;
					}
				}
				else if (buttons[i]->get_state() == Button::State::PRESSED)
				{
					if (clicked)
					{
						if (i >= Buttons::OVERALL && i <= Buttons::CASH)
						{
							Sound(Sound::Name::TAB).play();

							ret = Cursor::State::IDLE;
						}
					}
				}
			}
			else if (buttons[i]->get_state() == Button::State::MOUSEOVER)
			{
				buttons[i]->set_state(Button::State::NORMAL);
			}
		}

		return ret;
	}

	void UIShop::send_scroll(double yoffset)
	{
		int16_t xoff = lastcursorpos.x();
		int16_t slider_width = 10;

		if (buyslider.isenabled())
			if (xoff >= buy_x && xoff <= buy_width + slider_width)
				buyslider.send_scroll(yoffset);

		if (sellslider.isenabled())
			if (xoff >= sell_x && xoff <= sell_x + sell_width + slider_width)
				sellslider.send_scroll(yoffset);
	}

	void UIShop::rightclick(Point<int16_t> cursorpos)
	{
		if (rightclicksell)
		{
			Point<int16_t> cursoroffset = cursorpos - position;

			int16_t xoff = cursoroffset.x();
			int16_t yoff = cursoroffset.y();
			int16_t slot = slot_by_position(yoff);

			if (slot >= 0 && slot <= 8)
			{
				if (xoff >= sell_x && xoff <= sell_x + sell_width)
				{
					clear_tooltip();

					sellstate.selection = slot;
					sellstate.sell(true);
					buystate.selection = -1;
				}
			}
		}
	}

	void UIShop::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed && escape)
			exit_shop();
	}

	UIElement::Type UIShop::get_type() const
	{
		return TYPE;
	}

	void UIShop::clear_tooltip()
	{
		UI::get().clear_tooltip(Tooltip::Parent::SHOP);
	}

	void UIShop::show_item(int16_t slot, bool buy)
	{
		if (buy)
			buystate.show_item(slot);
		else
			sellstate.show_item(slot);
	}

	void UIShop::changeselltab(InventoryType::Id type)
	{
		uint16_t oldtab = tabbyinventory(sellstate.tab);

		if (oldtab > 0)
			buttons[oldtab]->set_state(Button::State::NORMAL);

		uint16_t newtab = tabbyinventory(type);

		if (newtab > 0)
			buttons[newtab]->set_state(Button::State::PRESSED);

		sellstate.change_tab(inventory, type, meso);

		sellslider.setrows(5, sellstate.lastslot);

		for (size_t i = Buttons::SELL0; i < Buttons::SELL8; i++)
		{
			if (i - Buttons::SELL0 < sellstate.lastslot)
				buttons[i]->set_state(Button::State::NORMAL);
			else
				buttons[i]->set_state(Button::State::DISABLED);
		}
	}

	void UIShop::reset(int32_t npcid)
	{
		std::string strid = string_format::extend_id(npcid, 7);
		npc = nl::nx::Npc[strid + ".img"]["stand"]["0"];

		for (auto& button : buttons)
			button.second->set_state(Button::State::NORMAL);

		buttons[Buttons::OVERALL]->set_state(Button::State::PRESSED);
		buttons[Buttons::EQUIP]->set_state(Button::State::PRESSED);

		buystate.reset();
		sellstate.reset();

		changeselltab(InventoryType::Id::EQUIP);

		makeactive();
		rightclicksell = Configuration::get().get_rightclicksell();
	}

	void UIShop::modify(InventoryType::Id type)
	{
		if (type == sellstate.tab)
			changeselltab(type);
	}

	void UIShop::add_item(int32_t id, int32_t price, int32_t pitch, int32_t time, int16_t buyable)
	{
		add_rechargable(id, price, pitch, time, 0, buyable);
	}

	void UIShop::add_rechargable(int32_t id, int32_t price, int32_t pitch, int32_t time, int16_t chargeprice, int16_t buyable)
	{
		auto buyitem = BuyItem(meso, id, price, pitch, time, chargeprice, buyable);
		buystate.add(buyitem);

		buyslider.setrows(5, buystate.lastslot);
	}

	int16_t UIShop::slot_by_position(int16_t y)
	{
		int16_t yoff = y - 123;

		if (yoff > 0 && yoff < 38)
			return 0;
		else if (yoff > 42 && yoff < 80)
			return 1;
		else if (yoff > 84 && yoff < 122)
			return 2;
		else if (yoff > 126 && yoff < 164)
			return 3;
		else if (yoff > 168 && yoff < 206)
			return 4;
		else if (yoff > 210 && yoff < 248)
			return 5;
		else if (yoff > 252 && yoff < 290)
			return 6;
		else if (yoff > 294 && yoff < 332)
			return 7;
		else if (yoff > 336 && yoff < 374)
			return 8;
		else
			return -1;
	}

	uint16_t UIShop::tabbyinventory(InventoryType::Id type)
	{
		switch (type)
		{
		case InventoryType::Id::EQUIP:
			return Buttons::EQUIP;
		case InventoryType::Id::USE:
			return Buttons::USE;
		case InventoryType::Id::ETC:
			return Buttons::ETC;
		case InventoryType::Id::SETUP:
			return Buttons::SETUP;
		case InventoryType::Id::CASH:
			return Buttons::CASH;
		default:
			return 0;
		}
	}

	void UIShop::exit_shop()
	{
		clear_tooltip();

		deactivate();
		NpcShopActionPacket().dispatch();
	}

	UIShop::BuyItem::BuyItem(Texture cur, int32_t i, int32_t p, int32_t pt, int32_t t, int16_t cp, int16_t b) : currency(cur), id(i), price(p), pitch(pt), time(t), chargeprice(cp), buyable(b)
	{
		namelabel = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::MINESHAFT);
		pricelabel = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::MINESHAFT);

		const ItemData& item = ItemData::get(id);

		if (item.is_valid())
		{
			icon = item.get_icon(false);
			namelabel.change_text(item.get_name());
		}

		std::string mesostr = std::to_string(price);
		string_format::split_number(mesostr);
		pricelabel.change_text(mesostr + "meso");
	}

	void UIShop::BuyItem::draw(Point<int16_t> pos) const
	{
		icon.draw(pos + Point<int16_t>(0, 42));
		namelabel.draw(pos + Point<int16_t>(40, 6));
		currency.draw(pos + Point<int16_t>(38, 29));
		pricelabel.draw(pos + Point<int16_t>(55, 24));
	}

	int32_t UIShop::BuyItem::get_id() const
	{
		return id;
	}

	int16_t UIShop::BuyItem::get_buyable() const
	{
		return buyable;
	}

	UIShop::SellItem::SellItem(int32_t item_id, int16_t count, int16_t s, bool sc, Texture cur)
	{
		const ItemData& idata = ItemData::get(item_id);

		icon = idata.get_icon(false);
		id = item_id;
		sellable = count;
		slot = s;
		showcount = sc;

		namelabel = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::MINESHAFT);
		pricelabel = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::MINESHAFT);

		std::string name = idata.get_name();

		if (name.length() >= 28)
			name = name.substr(0, 28) + "..";

		namelabel.change_text(name);

		int32_t price = idata.get_price();
		std::string mesostr = std::to_string(price);
		string_format::split_number(mesostr);
		pricelabel.change_text(mesostr + "meso");
	}

	void UIShop::SellItem::draw(Point<int16_t> pos) const
	{
		icon.draw(pos + Point<int16_t>(43, 42));

		if (showcount)
		{
			static const Charset countset = Charset(nl::nx::UI["Basic.img"]["ItemNo"], Charset::Alignment::LEFT);
			countset.draw(std::to_string(sellable), pos + Point<int16_t>(41, 28));
		}

		namelabel.draw(pos + Point<int16_t>(84, 6));
		pricelabel.draw(pos + Point<int16_t>(84, 24));
	}

	int32_t UIShop::SellItem::get_id() const
	{
		return id;
	}

	int16_t UIShop::SellItem::get_slot() const
	{
		return slot;
	}

	int16_t UIShop::SellItem::get_sellable() const
	{
		return sellable;
	}

	void UIShop::BuyState::reset()
	{
		items.clear();

		offset = 0;
		lastslot = 0;
		selection = -1;
	}

	void UIShop::BuyState::draw(Point<int16_t> parentpos, const Texture& selected) const
	{
		for (int16_t i = 0; i < 9; i++)
		{
			int16_t slot = i + offset;

			if (slot >= lastslot)
				break;

			auto itempos = Point<int16_t>(12, 116 + 42 * i);

			if (slot == selection)
				selected.draw(parentpos + itempos + Point<int16_t>(35, 8));

			items[slot].draw(parentpos + itempos);
		}
	}

	void UIShop::BuyState::show_item(int16_t slot)
	{
		int16_t absslot = slot + offset;

		if (absslot < 0 || absslot >= lastslot)
			return;

		int32_t itemid = items[absslot].get_id();
		UI::get().show_item(Tooltip::Parent::SHOP, itemid);
	}

	void UIShop::BuyState::add(BuyItem item)
	{
		items.push_back(item);

		lastslot++;
	}

	void UIShop::BuyState::buy() const
	{
		if (selection < 0 || selection >= lastslot)
			return;

		const BuyItem& item = items[selection];
		int16_t buyable = item.get_buyable();
		int16_t slot = selection;
		int32_t itemid = item.get_id();

		if (buyable > 1)
		{
			constexpr const char* question = "How many are you willing to buy?";

			auto onenter = [slot, itemid](int32_t qty)
			{
				auto shortqty = static_cast<int16_t>(qty);

				NpcShopActionPacket(slot, itemid, shortqty, true).dispatch();
			};

			UI::get().emplace<UIEnterNumber>(question, onenter, buyable, 1);
		}
		else if (buyable > 0)
		{
			constexpr const char* question = "Are you sure you want to buy it?";

			auto ondecide = [slot, itemid](bool yes)
			{
				if (yes)
					NpcShopActionPacket(slot, itemid, 1, true).dispatch();
			};

			UI::get().emplace<UIYesNo>(question, ondecide);
		}
	}

	void UIShop::BuyState::select(int16_t selected)
	{
		int16_t slot = selected + offset;

		if (slot == selection)
			buy();
		else
			selection = slot;
	}

	void UIShop::SellState::reset()
	{
		items.clear();

		offset = 0;
		lastslot = 0;
		selection = -1;
		tab = InventoryType::Id::NONE;
	}

	void UIShop::SellState::change_tab(const Inventory& inventory, InventoryType::Id newtab, Texture meso)
	{
		tab = newtab;

		offset = 0;

		items.clear();

		int16_t slots = inventory.get_slotmax(tab);

		for (int16_t i = 1; i <= slots; i++)
		{
			if (int32_t item_id = inventory.get_item_id(tab, i))
			{
				int16_t count = inventory.get_item_count(tab, i);
				items.emplace_back(item_id, count, i, tab != InventoryType::Id::EQUIP, meso);
			}
		}

		lastslot = static_cast<int16_t>(items.size());
	}

	void UIShop::SellState::draw(Point<int16_t> parentpos, const Texture& selected) const
	{
		for (int16_t i = 0; i <= 8; i++)
		{
			int16_t slot = i + offset;

			if (slot >= lastslot)
				break;

			Point<int16_t> itempos(243, 116 + 42 * i);

			if (slot == selection)
				selected.draw(parentpos + itempos + Point<int16_t>(78, 8));

			items[slot].draw(parentpos + itempos);
		}
	}

	void UIShop::SellState::show_item(int16_t slot)
	{
		int16_t absslot = slot + offset;

		if (absslot < 0 || absslot >= lastslot)
			return;

		if (tab == InventoryType::Id::EQUIP)
		{
			int16_t realslot = items[absslot].get_slot();
			UI::get().show_equip(Tooltip::Parent::SHOP, realslot);
		}
		else
		{
			int32_t itemid = items[absslot].get_id();
			UI::get().show_item(Tooltip::Parent::SHOP, itemid);
		}
	}

	void UIShop::SellState::sell(bool skip_confirmation) const
	{
		if (selection < 0 || selection >= lastslot)
			return;

		const SellItem& item = items[selection];
		int32_t itemid = item.get_id();
		int16_t sellable = item.get_sellable();
		int16_t slot = item.get_slot();

		if (sellable > 1)
		{
			constexpr const char* question = "How many are you willing to sell?";

			auto onenter = [itemid, slot](int32_t qty)
			{
				auto shortqty = static_cast<int16_t>(qty);

				NpcShopActionPacket(slot, itemid, shortqty, false).dispatch();
			};

			UI::get().emplace<UIEnterNumber>(question, onenter, sellable, 1);
		}
		else if (sellable > 0)
		{
			if (skip_confirmation)
			{
				NpcShopActionPacket(slot, itemid, 1, false).dispatch();
				return;
			}

			constexpr const char* question = "Are you sure you want to sell it?";

			auto ondecide = [itemid, slot](bool yes)
			{
				if (yes)
					NpcShopActionPacket(slot, itemid, 1, false).dispatch();
			};

			UI::get().emplace<UIYesNo>(question, ondecide);
		}
	}

	void UIShop::SellState::select(int16_t selected)
	{
		int16_t slot = selected + offset;

		if (slot == selection)
			sell(false);
		else
			selection = slot;
	}
}

================
File: IO/UITypes/UIShop.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../Components/Slider.h"

#include "../../Character/Look/CharLook.h"

namespace ms
{
	class UIShop : public UIDragElement<PosSHOP>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::SHOP;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = true;

		UIShop(const CharLook& charlook, const Inventory& inventory);

		void draw(float alpha) const override;
		void update() override;

		void remove_cursor() override;
		Cursor::State send_cursor(bool clicked, Point<int16_t> position) override;
		void send_scroll(double yoffset) override;
		void rightclick(Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		void reset(int32_t npcid);
		void add_item(int32_t id, int32_t price, int32_t pitch, int32_t time, int16_t buyable);
		void add_rechargable(int32_t id, int32_t price, int32_t pitch, int32_t time, int16_t chargeprice, int16_t buyable);

		void modify(InventoryType::Id type);

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void clear_tooltip();
		void show_item(int16_t slot, bool sale);
		void changeselltab(InventoryType::Id tab);
		int16_t slot_by_position(int16_t y);
		uint16_t tabbyinventory(InventoryType::Id type);
		void exit_shop();

		enum Buttons : int16_t
		{
			BUY_ITEM,
			SELL_ITEM,
			EXIT,
			CHECKBOX,
			OVERALL,
			EQUIP,
			USE,
			ETC,
			SETUP,
			CASH,
			BUY0,
			BUY1,
			BUY2,
			BUY3,
			BUY4,
			BUY5,
			BUY6,
			BUY7,
			BUY8,
			SELL0,
			SELL1,
			SELL2,
			SELL3,
			SELL4,
			SELL5,
			SELL6,
			SELL7,
			SELL8,
			NUM_BUTTONS
		};

		const CharLook& charlook;
		const Inventory& inventory;

		Texture npc;
		Texture buy_selection;
		Texture sell_selection;
		Texture meso;
		Text mesolabel;

		Slider buyslider;
		Slider sellslider;

		int16_t buy_x;
		int16_t buy_width;
		int16_t sell_x;
		int16_t sell_width;

		BoolPair<Texture> checkBox;

		bool rightclicksell;

		Point<int16_t> lastcursorpos;

		class BuyItem
		{
		public:
			BuyItem(Texture cur, int32_t i, int32_t p, int32_t pt, int32_t t, int16_t cp, int16_t b);

			void draw(Point<int16_t> position) const;

			int32_t get_id() const;
			int16_t get_buyable() const;

		private:
			Texture icon;
			Texture currency;
			int32_t id;
			int32_t price;
			int32_t pitch;
			int32_t time;
			int16_t chargeprice;
			int16_t buyable;
			Text namelabel;
			Text pricelabel;
		};

		class SellItem
		{
		public:
			SellItem(int32_t item_id, int16_t count, int16_t slot, bool showcount, Texture cur);

			void draw(Point<int16_t> position) const;

			int32_t get_id() const;
			int16_t get_slot() const;
			int16_t get_sellable() const;

		private:
			Texture icon;
			int32_t id;
			int16_t slot;
			int16_t sellable;
			bool showcount;
			Text namelabel;
			Text pricelabel;
		};

		struct BuyState
		{
			std::vector<BuyItem> items;
			int16_t offset;
			int16_t lastslot;
			int16_t selection;

			void reset();
			void draw(Point<int16_t> position, const Texture& selected) const;
			void show_item(int16_t slot);
			void add(BuyItem item);
			void buy() const;
			void select(int16_t selected);
		};

		BuyState buystate;

		struct SellState
		{
			std::vector<SellItem> items;
			int16_t offset;
			InventoryType::Id tab;
			int16_t lastslot;
			int16_t selection;

			void reset();
			void change_tab(const Inventory& inventory, InventoryType::Id type, Texture meso);
			void draw(Point<int16_t> position, const Texture& selected) const;
			void show_item(int16_t slot);
			void sell(bool skip_confirmation) const;
			void select(int16_t selected);
		};

		SellState sellstate;
	};
}

================
File: IO/UITypes/UISkillBook.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UISkillBook.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#include "../../Character/SkillId.h"
#include "../../Data/JobData.h"
#include "../../Data/SkillData.h"
#include "../../Gameplay/Stage.h"

#include "../../Net/Packets/PlayerPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UISkillBook::SkillIcon::SkillIcon(int32_t id) : skill_id(id) {}

	void UISkillBook::SkillIcon::drop_on_bindings(Point<int16_t> cursorposition, bool remove) const
	{
		auto keyconfig = UI::get().get_element<UIKeyConfig>();
		Keyboard::Mapping mapping = Keyboard::Mapping(KeyType::SKILL, skill_id);

		if (remove)
			keyconfig->unstage_mapping(mapping);
		else
			keyconfig->stage_mapping(cursorposition, mapping);
	}

	Icon::IconType UISkillBook::SkillIcon::get_type()
	{
		return Icon::IconType::SKILL;
	}

	UISkillBook::SkillDisplayMeta::SkillDisplayMeta(int32_t i, int32_t l) : id(i), level(l)
	{
		const SkillData& data = SkillData::get(id);

		Texture ntx = data.get_icon(SkillData::Icon::NORMAL);
		Texture dtx = data.get_icon(SkillData::Icon::DISABLED);
		Texture motx = data.get_icon(SkillData::Icon::MOUSEOVER);
		icon = std::make_unique<StatefulIcon>(std::make_unique<SkillIcon>(id), ntx, dtx, motx);

		std::string namestr = data.get_name();
		std::string levelstr = std::to_string(level);

		name_text = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::EMPEROR, namestr);
		level_text = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::EMPEROR, levelstr);

		constexpr uint16_t MAX_NAME_WIDTH = 97;
		size_t overhang = 3;

		while (name_text.width() > MAX_NAME_WIDTH)
		{
			namestr.replace(namestr.end() - overhang, namestr.end(), "..");
			overhang += 1;

			name_text.change_text(namestr);
		}
	}

	void UISkillBook::SkillDisplayMeta::draw(const DrawArgument& args) const
	{
		icon->draw(args.getpos());
		name_text.draw(args + Point<int16_t>(38, -5));
		level_text.draw(args + Point<int16_t>(38, 13));
	}

	int32_t UISkillBook::SkillDisplayMeta::get_id() const
	{
		return id;
	}

	int32_t UISkillBook::SkillDisplayMeta::get_level() const
	{
		return level;
	}

	StatefulIcon* UISkillBook::SkillDisplayMeta::get_icon() const
	{
		return icon.get();
	}

	UISkillBook::UISkillBook(const CharStats& in_stats, const SkillBook& in_skillbook) : UIDragElement<PosSKILL>(), stats(in_stats), skillbook(in_skillbook), grabbing(false), tab(0), macro_enabled(false), sp_enabled(false)
	{
		nl::node Skill = nl::nx::UI["UIWindow2.img"]["Skill"];
		nl::node main = Skill["main"];
		nl::node ui_backgrnd = main["backgrnd"];

		bg_dimensions = Texture(ui_backgrnd).get_dimensions();

		skilld = main["skill0"];
		skille = main["skill1"];
		skillb = main["skillBlank"];
		line = main["line"];

		buttons[Buttons::BT_HYPER] = std::make_unique<MapleButton>(main["BtHyper"]);
		buttons[Buttons::BT_GUILDSKILL] = std::make_unique<MapleButton>(main["BtGuildSkill"]);
		buttons[Buttons::BT_RIDE] = std::make_unique<MapleButton>(main["BtRide"]);
		buttons[Buttons::BT_MACRO] = std::make_unique<MapleButton>(main["BtMacro"]);

		buttons[Buttons::BT_HYPER]->set_state(Button::State::DISABLED);
		buttons[Buttons::BT_GUILDSKILL]->set_state(Button::State::DISABLED);
		buttons[Buttons::BT_RIDE]->set_state(Button::State::DISABLED);

		nl::node skillPoint = nl::nx::UI["UIWindow4.img"]["Skill"]["skillPoint"];

		sp_backgrnd = skillPoint["backgrnd"];
		sp_backgrnd2 = skillPoint["backgrnd2"];
		sp_backgrnd3 = skillPoint["backgrnd3"];

		buttons[Buttons::BT_CANCLE] = std::make_unique<MapleButton>(skillPoint["BtCancle"], Point<int16_t>(bg_dimensions.x(), 0));
		buttons[Buttons::BT_OKAY] = std::make_unique<MapleButton>(skillPoint["BtOkay"], Point<int16_t>(bg_dimensions.x(), 0));
		buttons[Buttons::BT_SPDOWN] = std::make_unique<MapleButton>(skillPoint["BtSpDown"], Point<int16_t>(bg_dimensions.x(), 0));
		buttons[Buttons::BT_SPMAX] = std::make_unique<MapleButton>(skillPoint["BtSpMax"], Point<int16_t>(bg_dimensions.x(), 0));
		buttons[Buttons::BT_SPUP] = std::make_unique<MapleButton>(skillPoint["BtSpUp"], Point<int16_t>(bg_dimensions.x(), 0));

		buttons[Buttons::BT_SPDOWN]->set_state(Button::State::DISABLED);

		sp_before = Charset(skillPoint["num"], Charset::Alignment::RIGHT);
		sp_after = Charset(skillPoint["num"], Charset::Alignment::RIGHT);
		sp_used = Text(Text::Font::A12B, Text::Alignment::RIGHT, Color::Name::WHITE);
		sp_remaining = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::SUPERNOVA);
		sp_name = Text(Text::Font::A12B, Text::Alignment::CENTER, Color::Name::WHITE);

		sprites.emplace_back(ui_backgrnd, Point<int16_t>(1, 0));
		sprites.emplace_back(main["backgrnd2"]);
		sprites.emplace_back(main["backgrnd3"]);

		nl::node macro = Skill["macro"];

		macro_backgrnd = macro["backgrnd"];
		macro_backgrnd2 = macro["backgrnd2"];
		macro_backgrnd3 = macro["backgrnd3"];

		buttons[Buttons::BT_MACRO_OK] = std::make_unique<MapleButton>(macro["BtOK"], Point<int16_t>(bg_dimensions.x(), 0));

		buttons[Buttons::BT_MACRO_OK]->set_state(Button::State::DISABLED);

		nl::node close = nl::nx::UI["Basic.img"]["BtClose3"];

		buttons[Buttons::BT_CLOSE] = std::make_unique<MapleButton>(close, Point<int16_t>(bg_dimensions.x() - 23, 6));

		nl::node Tab = main["Tab"];
		nl::node enabled = Tab["enabled"];
		nl::node disabled = Tab["disabled"];

		for (uint16_t i = Buttons::BT_TAB0; i <= Buttons::BT_TAB4; ++i)
		{
			uint16_t tabid = i - Buttons::BT_TAB0;
			buttons[i] = std::make_unique<TwoSpriteButton>(disabled[tabid], enabled[tabid]);
		}

		uint16_t y_adj = 0;

		for (uint16_t i = Buttons::BT_SPUP0; i <= Buttons::BT_SPUP11; ++i)
		{
			uint16_t x_adj = 0;
			uint16_t spupid = i - Buttons::BT_SPUP0;

			if (spupid % 2)
				x_adj = ROW_WIDTH;

			Point<int16_t> spup_position = SKILL_OFFSET + Point<int16_t>(124 + x_adj, 20 + y_adj);
			buttons[i] = std::make_unique<MapleButton>(main["BtSpUp"], spup_position);

			if (spupid % 2)
				y_adj += ROW_HEIGHT;
		}

		booktext = Text(Text::Font::A11M, Text::Alignment::CENTER, Color::Name::WHITE, "", 150);
		splabel = Text(Text::Font::A12M, Text::Alignment::RIGHT, Color::Name::BLACK);

		slider = Slider(
			Slider::Type::DEFAULT_SILVER, Range<int16_t>(93, 317), 295, ROWS, 1,
			[&](bool upwards)
			{
				int16_t shift = upwards ? -1 : 1;
				bool above = offset + shift >= 0;
				bool below = offset + 4 + shift <= skillcount;

				if (above && below)
					change_offset(offset + shift);
			}
		);

		change_job(stats.get_stat(MapleStat::Id::JOB));

		set_macro(false);
		set_skillpoint(false);

		dimension = bg_dimensions;
		dragarea = Point<int16_t>(dimension.x(), 20);
	}

	void UISkillBook::draw(float alpha) const
	{
		UIElement::draw_sprites(alpha);

		bookicon.draw(position + Point<int16_t>(11, 85));
		booktext.draw(position + Point<int16_t>(173, 59));
		splabel.draw(position + Point<int16_t>(304, 23));

		Point<int16_t> skill_position_l = position + SKILL_OFFSET + Point<int16_t>(-1, 0);
		Point<int16_t> skill_position_r = position + SKILL_OFFSET + Point<int16_t>(-1 + ROW_WIDTH, 0);

		for (size_t i = 0; i < ROWS; i++)
		{
			Point<int16_t> pos = skill_position_l;

			if (i % 2)
				pos = skill_position_r;

			if (i < skills.size())
			{
				if (check_required(skills[i].get_id()))
				{
					skille.draw(pos);
				}
				else
				{
					skilld.draw(pos);
					skills[i].get_icon()->set_state(StatefulIcon::State::DISABLED);
				}

				skills[i].draw(pos + SKILL_META_OFFSET);
			}
			else
			{
				skillb.draw(pos);
			}

			if (i < ROWS - 2)
				line.draw(pos + LINE_OFFSET);

			if (i % 2)
			{
				skill_position_l.shift_y(ROW_HEIGHT);
				skill_position_r.shift_y(ROW_HEIGHT);
			}
		}

		slider.draw(position);

		if (macro_enabled)
		{
			Point<int16_t> macro_pos = position + Point<int16_t>(bg_dimensions.x(), 0);

			macro_backgrnd.draw(macro_pos + Point<int16_t>(1, 0));
			macro_backgrnd2.draw(macro_pos);
			macro_backgrnd3.draw(macro_pos);
		}

		if (sp_enabled)
		{
			Point<int16_t> sp_pos = position + Point<int16_t>(bg_dimensions.x(), 0);

			sp_backgrnd.draw(sp_pos);
			sp_backgrnd2.draw(sp_pos);
			sp_backgrnd3.draw(sp_pos);

			Point<int16_t> sp_level_pos = sp_pos + Point<int16_t>(78, 149);

			sp_before.draw(sp_before_text, 12, sp_level_pos);
			sp_after.draw(sp_after_text, 11, sp_level_pos + Point<int16_t>(78, 0));
			sp_used.draw(sp_pos + Point<int16_t>(82, 87));
			sp_remaining.draw(sp_pos + Point<int16_t>(76, 65));
			sp_name.draw(sp_pos + Point<int16_t>(97, 35));
			sp_skill.draw(sp_pos + Point<int16_t>(13, 31));
		}

		UIElement::draw_buttons(alpha);
	}

	Button::State UISkillBook::button_pressed(uint16_t id)
	{
		int16_t cur_sp = std::stoi(splabel.get_text());

		switch (id)
		{
		case Buttons::BT_CLOSE:
			close();
			break;
		case Buttons::BT_MACRO:
			set_macro(!macro_enabled);
			break;
		case Buttons::BT_CANCLE:
			set_skillpoint(false);
			break;
		case Buttons::BT_OKAY:
		{
			int32_t used = std::stoi(sp_used.get_text());

			while (used > 0)
			{
				spend_sp(sp_id);
				used--;
			}

			change_sp();
			set_skillpoint(false);
		}
		break;
		case Buttons::BT_SPDOWN:
		{
			int32_t used = std::stoi(sp_used.get_text());
			int32_t sp_after = std::stoi(sp_after_text);
			int32_t sp_before = std::stoi(sp_before_text);
			used--;
			sp_after--;

			sp_after_text = std::to_string(sp_after);
			sp_used.change_text(std::to_string(used));
			sp_remaining.change_text(std::to_string(cur_sp - used));

			buttons[Buttons::BT_SPUP]->set_state(Button::State::NORMAL);
			buttons[Buttons::BT_SPMAX]->set_state(Button::State::NORMAL);

			if (sp_after - 1 == sp_before)
				return Button::State::DISABLED;

			return Button::State::NORMAL;
		}
		break;
		case Buttons::BT_SPMAX:
		{
			int32_t used = std::stoi(sp_used.get_text());
			int32_t sp_before = std::stoi(sp_before_text);
			int32_t sp_touse = sp_masterlevel - sp_before - used;

			used += sp_touse;

			sp_after_text = std::to_string(sp_masterlevel);
			sp_used.change_text(std::to_string(used));
			sp_remaining.change_text(std::to_string(cur_sp - used));

			buttons[Buttons::BT_SPUP]->set_state(Button::State::DISABLED);
			buttons[Buttons::BT_SPDOWN]->set_state(Button::State::NORMAL);

			return Button::State::DISABLED;
		}
		break;
		case Buttons::BT_SPUP:
		{
			int32_t used = std::stoi(sp_used.get_text());
			int32_t sp_after = std::stoi(sp_after_text);
			used++;
			sp_after++;

			sp_after_text = std::to_string(sp_after);
			sp_used.change_text(std::to_string(used));
			sp_remaining.change_text(std::to_string(cur_sp - used));

			buttons[Buttons::BT_SPDOWN]->set_state(Button::State::NORMAL);

			if (sp_after == sp_masterlevel)
			{
				buttons[Buttons::BT_SPMAX]->set_state(Button::State::DISABLED);

				return Button::State::DISABLED;
			}

			return Button::State::NORMAL;
		}
		break;
		case Buttons::BT_TAB0:
		case Buttons::BT_TAB1:
		case Buttons::BT_TAB2:
		case Buttons::BT_TAB3:
		case Buttons::BT_TAB4:
			change_tab(id - Buttons::BT_TAB0);

			return Button::State::PRESSED;
		case Buttons::BT_SPUP0:
		case Buttons::BT_SPUP1:
		case Buttons::BT_SPUP2:
		case Buttons::BT_SPUP3:
		case Buttons::BT_SPUP4:
		case Buttons::BT_SPUP5:
		case Buttons::BT_SPUP6:
		case Buttons::BT_SPUP7:
		case Buttons::BT_SPUP8:
		case Buttons::BT_SPUP9:
		case Buttons::BT_SPUP10:
		case Buttons::BT_SPUP11:
			send_spup(id - Buttons::BT_SPUP0 + offset);
			break;
		case Buttons::BT_HYPER:
		case Buttons::BT_GUILDSKILL:
		case Buttons::BT_RIDE:
		case Buttons::BT_MACRO_OK:
		default:
			break;
		}

		return Button::State::NORMAL;
	}

	void UISkillBook::toggle_active()
	{
		if (!is_skillpoint_enabled())
		{
			UIElement::toggle_active();

			clear_tooltip();
		}
	}

	void UISkillBook::doubleclick(Point<int16_t> cursorpos)
	{
		const SkillDisplayMeta* skill = skill_by_position(cursorpos - position);

		if (skill)
		{
			int32_t skill_id = skill->get_id();
			int32_t skill_level = skillbook.get_level(skill_id);

			if (skill_level > 0)
				Stage::get().get_combat().use_move(skill_id);
		}
	}

	void UISkillBook::remove_cursor()
	{
		UIDragElement::remove_cursor();

		slider.remove_cursor();
	}

	Cursor::State UISkillBook::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		Cursor::State dstate = UIDragElement::send_cursor(clicked, cursorpos);

		if (dragged)
			return dstate;

		Point<int16_t> cursor_relative = cursorpos - position;

		if (slider.isenabled())
		{
			if (Cursor::State new_state = slider.send_cursor(cursor_relative, clicked))
			{
				clear_tooltip();

				return new_state;
			}
		}

		Point<int16_t> skill_position_l = position + SKILL_OFFSET + Point<int16_t>(-1, 0);
		Point<int16_t> skill_position_r = position + SKILL_OFFSET + Point<int16_t>(-1 + ROW_WIDTH, 0);

		if (!grabbing)
		{
			for (size_t i = 0; i < skills.size(); i++)
			{
				Point<int16_t> skill_position = skill_position_l;

				if (i % 2)
					skill_position = skill_position_r;

				constexpr Rectangle<int16_t> bounds = Rectangle<int16_t>(0, 32, 0, 32);
				bool inrange = bounds.contains(cursorpos - skill_position);

				if (inrange)
				{
					if (clicked)
					{
						clear_tooltip();
						grabbing = true;

						int32_t skill_id = skills[i].get_id();
						int32_t skill_level = skillbook.get_level(skill_id);

						if (skill_level > 0 && !SkillData::get(skill_id).is_passive())
						{
							skills[i].get_icon()->start_drag(cursorpos - skill_position);
							UI::get().drag_icon(skills[i].get_icon());

							return Cursor::State::GRABBING;
						}
						else
						{
							return Cursor::State::IDLE;
						}
					}
					else
					{
						skills[i].get_icon()->set_state(StatefulIcon::State::MOUSEOVER);
						show_skill(skills[i].get_id());

						return Cursor::State::IDLE;
					}
				}

				if (i % 2)
				{
					skill_position_l.shift_y(ROW_HEIGHT);
					skill_position_r.shift_y(ROW_HEIGHT);
				}
			}

			for (size_t i = 0; i < skills.size(); i++)
			{
				skills[i].get_icon()->set_state(StatefulIcon::State::NORMAL);
			}
			clear_tooltip();
		}
		else
		{
			grabbing = false;
		}

		return UIElement::send_cursor(clicked, cursorpos);
	}

	void UISkillBook::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
			{
				if (sp_enabled)
					set_skillpoint(false);
				else
					close();
			}
			else if (keycode == KeyAction::Id::TAB)
			{
				clear_tooltip();

				Job::Level level = job.get_level();
				uint16_t id = tab + 1;
				uint16_t new_tab = tab + Buttons::BT_TAB0;

				if (new_tab < Buttons::BT_TAB4 && id <= level)
					new_tab++;
				else
					new_tab = Buttons::BT_TAB0;

				change_tab(new_tab - Buttons::BT_TAB0);
			}
		}
	}

	UIElement::Type UISkillBook::get_type() const
	{
		return TYPE;
	}

	void UISkillBook::update_stat(MapleStat::Id stat, int16_t value)
	{
		switch (stat)
		{
		case MapleStat::Id::JOB:
			change_job(value);
			break;
		case MapleStat::Id::SP:
			change_sp();
			break;
		}
	}

	void UISkillBook::update_skills(int32_t skill_id)
	{
		change_tab(tab);
	}

	void UISkillBook::change_job(uint16_t id)
	{
		job.change_job(id);

		Job::Level level = job.get_level();

		for (uint16_t i = 0; i <= Job::Level::FOURTH; i++)
			buttons[Buttons::BT_TAB0 + i]->set_active(i <= level);

		change_tab(level - Job::Level::BEGINNER);
	}

	void UISkillBook::change_sp()
	{
		Job::Level joblevel = joblevel_by_tab(tab);
		uint16_t level = stats.get_stat(MapleStat::Id::LEVEL);

		if (joblevel == Job::Level::BEGINNER)
		{
			int16_t remaining_beginner_sp = 0;

			if (level >= 7)
				remaining_beginner_sp = 6;
			else
				remaining_beginner_sp = level - 1;

			for (size_t i = 0; i < skills.size(); i++)
			{
				int32_t skillid = skills[i].get_id();

				if (skillid == SkillId::Id::THREE_SNAILS || skillid == SkillId::Id::HEAL || skillid == SkillId::Id::FEATHER)
					remaining_beginner_sp -= skills[i].get_level();
			}

			beginner_sp = remaining_beginner_sp;
			splabel.change_text(std::to_string(beginner_sp));
		}
		else
		{
			sp = stats.get_stat(MapleStat::Id::SP);
			splabel.change_text(std::to_string(sp));
		}

		change_offset(offset);
		set_skillpoint(false);
	}

	void UISkillBook::change_tab(uint16_t new_tab)
	{
		buttons[Buttons::BT_TAB0 + tab]->set_state(Button::NORMAL);
		buttons[Buttons::BT_TAB0 + new_tab]->set_state(Button::PRESSED);
		tab = new_tab;

		skills.clear();
		skillcount = 0;

		Job::Level joblevel = joblevel_by_tab(tab);
		uint16_t subid = job.get_subjob(joblevel);

		const JobData& data = JobData::get(subid);

		bookicon = data.get_icon();
		booktext.change_text(data.get_name());

		for (int32_t skill_id : data.get_skills())
		{
			int32_t level = skillbook.get_level(skill_id);
			int32_t masterlevel = skillbook.get_masterlevel(skill_id);

			bool invisible = SkillData::get(skill_id).is_invisible();

			if (invisible && masterlevel == 0)
				continue;

			skills.emplace_back(skill_id, level);
			skillcount++;
		}

		slider.setrows(ROWS, skillcount);
		change_offset(0);
		change_sp();
	}

	void UISkillBook::change_offset(uint16_t new_offset)
	{
		offset = new_offset;

		for (int16_t i = 0; i < ROWS; i++)
		{
			uint16_t index = Buttons::BT_SPUP0 + i;
			uint16_t row = offset + i;
			buttons[index]->set_active(row < skillcount);

			if (row < skills.size())
			{
				int32_t skill_id = skills[row].get_id();
				bool canraise = can_raise(skill_id);
				buttons[index]->set_state(canraise ? Button::State::NORMAL : Button::State::DISABLED);
			}
		}
	}

	void UISkillBook::show_skill(int32_t id)
	{
		int32_t skill_id = id;
		int32_t level = skillbook.get_level(id);
		int32_t masterlevel = skillbook.get_masterlevel(id);
		int64_t expiration = skillbook.get_expiration(id);

		UI::get().show_skill(Tooltip::Parent::SKILLBOOK, skill_id, level, masterlevel, expiration);
	}

	void UISkillBook::clear_tooltip()
	{
		UI::get().clear_tooltip(Tooltip::Parent::SKILLBOOK);
	}

	bool UISkillBook::can_raise(int32_t skill_id) const
	{
		Job::Level joblevel = joblevel_by_tab(tab);

		if (joblevel == Job::Level::BEGINNER && beginner_sp <= 0)
			return false;

		if (tab + Buttons::BT_TAB0 != Buttons::BT_TAB0 && sp <= 0)
			return false;

		int32_t level = skillbook.get_level(skill_id);
		int32_t masterlevel = skillbook.get_masterlevel(skill_id);

		if (masterlevel == 0)
			masterlevel = SkillData::get(skill_id).get_masterlevel();

		if (level >= masterlevel)
			return false;

		switch (skill_id)
		{
		case SkillId::Id::ANGEL_BLESSING:
			return false;
		default:
			return check_required(skill_id);
		}
	}

	void UISkillBook::send_spup(uint16_t row)
	{
		if (row >= skills.size())
			return;

		int32_t id = skills[row].get_id();

		if (sp_enabled && id == sp_id)
		{
			set_skillpoint(false);
			return;
		}

		int32_t level = skills[row].get_level();
		int32_t used = 1;

		const SkillData& skillData = SkillData::get(id);
		std::string name = skillData.get_name();
		int16_t cur_sp = std::stoi(splabel.get_text());

		sp_before_text = std::to_string(level);
		sp_after_text = std::to_string(level + used);
		sp_used.change_text(std::to_string(used));
		sp_remaining.change_text(std::to_string(cur_sp - used));
		sp_name.change_text(name);
		sp_skill = skills[row].get_icon()->get_texture();
		sp_id = id;
		sp_masterlevel = skillData.get_masterlevel();

		if (sp_masterlevel == 1)
		{
			buttons[Buttons::BT_SPDOWN]->set_state(Button::State::DISABLED);
			buttons[Buttons::BT_SPMAX]->set_state(Button::State::DISABLED);
			buttons[Buttons::BT_SPUP]->set_state(Button::State::DISABLED);
		}
		else
		{
			buttons[Buttons::BT_SPDOWN]->set_state(Button::State::DISABLED);
			buttons[Buttons::BT_SPMAX]->set_state(Button::State::NORMAL);
			buttons[Buttons::BT_SPUP]->set_state(Button::State::NORMAL);
		}

		if (!sp_enabled)
			set_skillpoint(true);
	}

	void UISkillBook::spend_sp(int32_t skill_id)
	{
		SpendSpPacket(skill_id).dispatch();

		UI::get().disable();
	}

	Job::Level UISkillBook::joblevel_by_tab(uint16_t t) const
	{
		switch (t)
		{
		case 1:
			return Job::Level::FIRST;
		case 2:
			return Job::Level::SECOND;
		case 3:
			return Job::Level::THIRD;
		case 4:
			return Job::Level::FOURTH;
		default:
			return Job::Level::BEGINNER;
		}
	}

	const UISkillBook::SkillDisplayMeta* UISkillBook::skill_by_position(Point<int16_t> cursorpos) const
	{
		int16_t x = cursorpos.x();

		if (x < SKILL_OFFSET.x() || x > SKILL_OFFSET.x() + 2 * ROW_WIDTH)
			return nullptr;

		int16_t y = cursorpos.y();

		if (y < SKILL_OFFSET.y())
			return nullptr;

		uint16_t row = (y - SKILL_OFFSET.y()) / ROW_HEIGHT;

		if (row < 0 || row >= ROWS)
			return nullptr;

		uint16_t offset_row = offset + row;

		if (offset_row >= ROWS)
			return nullptr;

		uint16_t col = (x - SKILL_OFFSET.x()) / ROW_WIDTH;

		uint16_t skill_idx = 2 * offset_row + col;

		if (skill_idx >= skills.size())
			return nullptr;

		auto iter = skills.data() + skill_idx;

		return iter;
	}

	void UISkillBook::close()
	{
		clear_tooltip();
		deactivate();
	}

	bool UISkillBook::check_required(int32_t id) const
	{
		std::unordered_map<int32_t, int32_t> required = skillbook.collect_required(id);

		if (required.size() <= 0)
			required = SkillData::get(id).get_reqskills();

		for (auto reqskill : required)
		{
			int32_t reqskill_level = skillbook.get_level(reqskill.first);
			int32_t req_level = reqskill.second;

			if (reqskill_level < req_level)
				return false;
		}

		return true;
	}

	void UISkillBook::set_macro(bool enabled)
	{
		macro_enabled = enabled;

		if (macro_enabled)
			dimension = bg_dimensions + Point<int16_t>(macro_backgrnd.get_dimensions().x(), 0);
		else if (!sp_enabled)
			dimension = bg_dimensions;

		buttons[Buttons::BT_MACRO_OK]->set_active(macro_enabled);

		if (macro_enabled && sp_enabled)
			set_skillpoint(false);
	}

	void UISkillBook::set_skillpoint(bool enabled)
	{
		sp_enabled = enabled;

		if (sp_enabled)
			dimension = bg_dimensions + Point<int16_t>(sp_backgrnd.get_dimensions().x(), 0);
		else if (!macro_enabled)
			dimension = bg_dimensions;

		buttons[Buttons::BT_CANCLE]->set_active(sp_enabled);
		buttons[Buttons::BT_OKAY]->set_active(sp_enabled);
		buttons[Buttons::BT_SPDOWN]->set_active(sp_enabled);
		buttons[Buttons::BT_SPMAX]->set_active(sp_enabled);
		buttons[Buttons::BT_SPUP]->set_active(sp_enabled);

		if (sp_enabled && macro_enabled)
			set_macro(false);
	}

	bool UISkillBook::is_skillpoint_enabled()
	{
		return sp_enabled;
	}
}

================
File: IO/UITypes/UISkillBook.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../Components/Charset.h"
#include "../Components/Slider.h"
#include "../Components/StatefulIcon.h"

#include "../../Character/CharStats.h"
#include "../../Character/SkillBook.h"

namespace ms
{
	class UISkillBook : public UIDragElement<PosSKILL>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::SKILLBOOK;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UISkillBook(const CharStats& stats, const SkillBook& skillbook);

		void draw(float alpha) const override;

		void toggle_active() override;
		void doubleclick(Point<int16_t> cursorpos) override;
		void remove_cursor() override;
		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		void update_stat(MapleStat::Id stat, int16_t value);
		void update_skills(int32_t skill_id);
		bool is_skillpoint_enabled();

	protected:
		Button::State button_pressed(uint16_t id) override;

	private:
		class SkillIcon : public StatefulIcon::Type
		{
		public:
			SkillIcon(int32_t skill_id);

			void drop_on_stage() const override {}
			void drop_on_equips(EquipSlot::Id) const override {}
			bool drop_on_items(InventoryType::Id, EquipSlot::Id, int16_t, bool) const override { return true; }
			void drop_on_bindings(Point<int16_t> cursorposition, bool remove) const override;
			void set_count(int16_t) override {}
			void set_state(StatefulIcon::State) override {}
			Icon::IconType get_type() override;

		private:
			int32_t skill_id;
		};

		class SkillDisplayMeta
		{
		public:
			SkillDisplayMeta(int32_t id, int32_t level);

			void draw(const DrawArgument& args) const;

			int32_t get_id() const;
			int32_t get_level() const;
			StatefulIcon* get_icon() const;

		private:
			int32_t id;
			int32_t level;
			std::unique_ptr<StatefulIcon> icon;
			Text name_text;
			Text level_text;
		};

		void change_job(uint16_t id);
		void change_sp();
		void change_tab(uint16_t new_tab);
		void change_offset(uint16_t new_offset);

		void show_skill(int32_t skill_id);
		void clear_tooltip();

		bool can_raise(int32_t skill_id) const;
		void send_spup(uint16_t row);
		void spend_sp(int32_t skill_id);

		Job::Level joblevel_by_tab(uint16_t tab) const;
		const UISkillBook::SkillDisplayMeta* skill_by_position(Point<int16_t> cursorpos) const;

		void close();
		bool check_required(int32_t id) const;

		void set_macro(bool enabled);
		void set_skillpoint(bool enabled);

		enum Buttons : uint16_t
		{
			BT_CLOSE,
			BT_HYPER,
			BT_GUILDSKILL,
			BT_RIDE,
			BT_MACRO,
			BT_MACRO_OK,
			BT_CANCLE,
			BT_OKAY,
			BT_SPDOWN,
			BT_SPMAX,
			BT_SPUP,
			BT_TAB0,
			BT_TAB1,
			BT_TAB2,
			BT_TAB3,
			BT_TAB4,
			BT_SPUP0,
			BT_SPUP1,
			BT_SPUP2,
			BT_SPUP3,
			BT_SPUP4,
			BT_SPUP5,
			BT_SPUP6,
			BT_SPUP7,
			BT_SPUP8,
			BT_SPUP9,
			BT_SPUP10,
			BT_SPUP11
		};

		static constexpr int16_t ROWS = 12;
		static constexpr int16_t ROW_HEIGHT = 40;
		static constexpr int16_t ROW_WIDTH = 143;
		static constexpr Point<int16_t> SKILL_OFFSET = Point<int16_t>(11, 93);
		static constexpr Point<int16_t> SKILL_META_OFFSET = Point<int16_t>(2, 2);
		static constexpr Point<int16_t> LINE_OFFSET = Point<int16_t>(0, 37);

		const CharStats& stats;
		const SkillBook& skillbook;

		Slider slider;
		Texture skille;
		Texture skilld;
		Texture skillb;
		Texture line;
		Texture bookicon;
		Text booktext;
		Text splabel;

		Job job;
		int16_t sp;
		int16_t beginner_sp;

		uint16_t tab;
		uint16_t skillcount;
		uint16_t offset;

		std::vector<SkillDisplayMeta> skills;
		bool grabbing;

		Point<int16_t> bg_dimensions;

		bool macro_enabled;
		Texture macro_backgrnd;
		Texture macro_backgrnd2;
		Texture macro_backgrnd3;

		bool sp_enabled;
		Texture sp_backgrnd;
		Texture sp_backgrnd2;
		Texture sp_backgrnd3;
		Charset sp_before;
		Charset sp_after;
		std::string sp_before_text;
		std::string sp_after_text;
		Text sp_used;
		Text sp_remaining;
		Text sp_name;
		Texture sp_skill;
		int32_t sp_id;
		int32_t sp_masterlevel;
	};
}

================
File: IO/UITypes/UISoftKey.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UISoftKey.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#include "../../Audio/Audio.h"
#include "../../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UISoftKey::UISoftKey(OkCallback ok_callback, CancelCallback cancel_callback, std::string tooltip_text, Point<int16_t> tooltip_pos) : UIElement(Point<int16_t>(216, 224), Point<int16_t>(0, 0)), ok_callback(ok_callback), cancel_callback(cancel_callback), tooltip_pos(tooltip_pos), highCase(false)
	{
		nl::node SoftKey = nl::nx::UI["Login.img"]["Common"]["SoftKey"];
		nl::node backgrnd = SoftKey["backgrnd"];

		sprites.emplace_back(backgrnd);

		Point<int16_t> button_adj = Point<int16_t>(1, 0);

		buttons[Buttons::BtCancel] = std::make_unique<MapleButton>(SoftKey["BtCancel"], button_adj);
		buttons[Buttons::BtDel] = std::make_unique<MapleButton>(SoftKey["BtDel"], button_adj);
		buttons[Buttons::BtOK] = std::make_unique<MapleButton>(SoftKey["BtOK"], button_adj);
		buttons[Buttons::BtShift] = std::make_unique<MapleButton>(SoftKey["BtShift"], button_adj);

#pragma region BtNum
#pragma region Row 1
		std::string row1KeysMap[ROW1_KEYS];

		row1KeysMap[0] = "1";
		row1KeysMap[1] = "2";
		row1KeysMap[2] = "3";
		row1KeysMap[3] = "4";
		row1KeysMap[4] = "5";
		row1KeysMap[5] = "6";
		row1KeysMap[6] = "7";
		row1KeysMap[7] = "8";
		row1KeysMap[8] = "9";
		row1KeysMap[9] = "0";

		uint16_t row1r1 = random.next_int(ROW_MAX);
		uint16_t row1r2 = random.next_int(ROW_MAX);

		while (row1r1 == row1r2)
			row1r2 = random.next_int(ROW_MAX);

		row1keys[row1r1] = "Blank";
		row1keys[row1r2] = "Blank";

		uint16_t keyIndex = 0;

		for (std::string& key : row1keys)
		{
			if (key != "Blank" && keyIndex < ROW1_KEYS)
			{
				key = row1KeysMap[keyIndex];
				keyIndex++;
			}
		}

		for (uint16_t i = 0; i < ROW_MAX; i++)
		{
			const std::string& key = row1keys[i];

			if (key == "Blank")
				buttons[Buttons::BtNum0 + i] = std::make_unique<MapleButton>(SoftKey["BtblankNum"], keypos(i, 0));
			else
				buttons[Buttons::BtNum0 + i] = std::make_unique<MapleButton>(SoftKey["BtNum"][key], keypos(i, 0));
		}
#pragma endregion
#pragma endregion

#pragma region BtLowCase / BtHighCase
#pragma region Row 2
		std::string row2KeysMap[ROW2_KEYS];

		row2KeysMap[0] = get_key_map_index("Q");
		row2KeysMap[1] = get_key_map_index("W");
		row2KeysMap[2] = get_key_map_index("E");
		row2KeysMap[3] = get_key_map_index("R");
		row2KeysMap[4] = get_key_map_index("T");
		row2KeysMap[5] = get_key_map_index("Y");
		row2KeysMap[6] = get_key_map_index("U");
		row2KeysMap[7] = get_key_map_index("I");
		row2KeysMap[8] = get_key_map_index("O");
		row2KeysMap[9] = get_key_map_index("P");

		uint16_t row2r1 = random.next_int(ROW_MAX);
		uint16_t row2r2 = random.next_int(ROW_MAX);

		while (row2r1 == row2r2)
			row2r2 = random.next_int(ROW_MAX);

		row2keys[row2r1] = "Blank";
		row2keys[row2r2] = "Blank";

		keyIndex = 0;

		for (std::string& key : row2keys)
		{
			if (key != "Blank" && keyIndex < ROW2_KEYS)
			{
				key = row2KeysMap[keyIndex];
				keyIndex++;
			}
		}

		uint16_t caseKeyIndex = 0;

		for (uint16_t i = 0; i < ROW_MAX; i++, caseKeyIndex++)
		{
			const std::string& key = row2keys[i];

			if (key == "Blank")
			{
				BtCaseKeys[caseKeyIndex][true] = std::make_unique<MapleButton>(SoftKey["BtblankCase"], keypos(i, 1));
				BtCaseKeys[caseKeyIndex][false] = std::make_unique<MapleButton>(SoftKey["BtblankCase"], keypos(i, 1));
			}
			else
			{
				BtCaseKeys[caseKeyIndex][true] = std::make_unique<MapleButton>(SoftKey["BtHighCase"][key], keypos(i, 1));
				BtCaseKeys[caseKeyIndex][false] = std::make_unique<MapleButton>(SoftKey["BtLowCase"][key], keypos(i, 1));
			}
		}
#pragma endregion

#pragma region Row 3
		std::string row3KeysMap[ROW3_KEYS];

		row3KeysMap[0] = get_key_map_index("A");
		row3KeysMap[1] = get_key_map_index("S");
		row3KeysMap[2] = get_key_map_index("D");
		row3KeysMap[3] = get_key_map_index("F");
		row3KeysMap[4] = get_key_map_index("G");
		row3KeysMap[5] = get_key_map_index("H");
		row3KeysMap[6] = get_key_map_index("J");
		row3KeysMap[7] = get_key_map_index("K");
		row3KeysMap[8] = get_key_map_index("L");

		uint16_t row3r1 = random.next_int(ROW_MAX);
		uint16_t row3r2 = random.next_int(ROW_MAX);

		while (row3r1 == row3r2)
			row3r2 = random.next_int(ROW_MAX);

		uint16_t row3r3 = random.next_int(ROW_MAX);

		while (row3r1 == row3r3 || row3r2 == row3r3)
			row3r3 = random.next_int(ROW_MAX);

		row3keys[row3r1] = "Blank";
		row3keys[row3r2] = "Blank";
		row3keys[row3r3] = "Blank";

		keyIndex = 0;

		for (std::string& key : row3keys)
		{
			if (key != "Blank" && keyIndex < ROW3_KEYS)
			{
				key = row3KeysMap[keyIndex];
				keyIndex++;
			}
		}

		for (uint16_t i = 0; i < ROW_MAX; i++, caseKeyIndex++)
		{
			const std::string& key = row3keys[i];

			if (key == "Blank")
			{
				BtCaseKeys[caseKeyIndex][true] = std::make_unique<MapleButton>(SoftKey["BtblankCase"], keypos(i, 2));
				BtCaseKeys[caseKeyIndex][false] = std::make_unique<MapleButton>(SoftKey["BtblankCase"], keypos(i, 2));
			}
			else
			{
				BtCaseKeys[caseKeyIndex][true] = std::make_unique<MapleButton>(SoftKey["BtHighCase"][key], keypos(i, 2));
				BtCaseKeys[caseKeyIndex][false] = std::make_unique<MapleButton>(SoftKey["BtLowCase"][key], keypos(i, 2));
			}
		}
#pragma endregion

#pragma region Row 4
		std::string row4KeysMap[ROW4_KEYS];

		row4KeysMap[0] = get_key_map_index("Z");
		row4KeysMap[1] = get_key_map_index("X");
		row4KeysMap[2] = get_key_map_index("C");
		row4KeysMap[3] = get_key_map_index("V");
		row4KeysMap[4] = get_key_map_index("B");
		row4KeysMap[5] = get_key_map_index("N");
		row4KeysMap[6] = get_key_map_index("M");

		uint16_t row4r1 = random.next_int(ROW4_MAX);

		row4keys[row4r1] = "Blank";

		keyIndex = 0;

		for (std::string& key : row4keys)
		{
			if (key != "Blank" && keyIndex < ROW4_KEYS)
			{
				key = row4KeysMap[keyIndex];
				keyIndex++;
			}
		}

		for (uint16_t i = 0; i < ROW4_MAX; i++, caseKeyIndex++)
		{
			const std::string& key = row4keys[i];

			if (key == "Blank")
			{
				BtCaseKeys[caseKeyIndex][true] = std::make_unique<MapleButton>(SoftKey["BtblankCase"], keypos(i, 3));
				BtCaseKeys[caseKeyIndex][false] = std::make_unique<MapleButton>(SoftKey["BtblankCase"], keypos(i, 3));
			}
			else
			{
				BtCaseKeys[caseKeyIndex][true] = std::make_unique<MapleButton>(SoftKey["BtHighCase"][key], keypos(i, 3));
				BtCaseKeys[caseKeyIndex][false] = std::make_unique<MapleButton>(SoftKey["BtLowCase"][key], keypos(i, 3));
			}
		}
#pragma endregion
#pragma endregion

		Point<int16_t> textfield_topleft = position + Point<int16_t>(202, 61);

		textfield = Textfield(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::BLACK, Rectangle<int16_t>(textfield_topleft, textfield_topleft + Point<int16_t>(188, 21)), MAX_TEXT_LEN);
		textfield.set_cryptchar('*');

		textfield.set_enter_callback(
			[&](std::string)
			{
				button_pressed(Buttons::BtOK);
			}
		);

		textfield.set_key_callback(
			KeyAction::Id::ESCAPE,
			[&]() {
				button_pressed(Buttons::BtCancel);
			}
		);

		textfield.set_text_callback(
			[&]()
			{
				clear_tooltip();
				show_text("and the numbers and letters can only be entered using a mouse.", 175, true, 1);
			}
		);

		show_text(tooltip_text);

		dimension = Texture(backgrnd).get_dimensions();
	}

	UISoftKey::UISoftKey(OkCallback ok_callback, CancelCallback cancel_callback, std::string tooltip_text) : UISoftKey(ok_callback, cancel_callback, tooltip_text, Point<int16_t>(0, 0)) {}
	UISoftKey::UISoftKey(OkCallback ok_callback, CancelCallback cancel_callback) : UISoftKey(ok_callback, cancel_callback, "") {}
	UISoftKey::UISoftKey(OkCallback ok_callback) : UISoftKey(ok_callback, []() {}) {}

	void UISoftKey::draw(float inter) const
	{
		UIElement::draw(inter);

		for (uint16_t i = 0; i < CASE_KEYS; i++)
		{
			const Button* btn = BtCaseKeys[i][highCase].get();
			btn->draw(position);
		}

		textfield.draw(Point<int16_t>(44, 0));

		if (tooltip)
			tooltip->draw(position + Point<int16_t>(419, 50) + tooltip_pos);
	}

	void UISoftKey::update()
	{
		UIElement::update();

		textfield.update();
		textfield.set_state(Textfield::State::FOCUSED);

		if (tooltip)
		{
			if (tooltip_timestep > 0)
				tooltip_timestep -= Constants::TIMESTEP;
			else
				clear_tooltip();
		}
	}

	void UISoftKey::deactivate()
	{
		UI::get().remove(UIElement::Type::SOFTKEYBOARD);
	}

	Cursor::State UISoftKey::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		if (Cursor::State new_state = textfield.send_cursor(cursorpos, clicked))
			return new_state;

		for (uint16_t i = 0; i < CASE_KEYS; i++)
		{
			auto& btn = BtCaseKeys[i][highCase];

			if (btn->is_active() && btn->bounds(position).contains(cursorpos))
			{
				if (btn->get_state() == Button::State::NORMAL)
				{
					Sound(Sound::Name::BUTTONOVER).play();

					btn->set_state(Button::State::MOUSEOVER);
					return Cursor::State::CANCLICK;
				}
				else if (btn->get_state() == Button::State::MOUSEOVER)
				{
					if (clicked)
					{
						Sound(Sound::Name::BUTTONCLICK).play();

						btn->set_state(case_pressed(i));

						return Cursor::State::IDLE;
					}
					else
					{
						return Cursor::State::CANCLICK;
					}
				}
			}
			else if (btn->get_state() == Button::State::MOUSEOVER)
			{
				btn->set_state(Button::State::NORMAL);
			}
		}

		return UIElement::send_cursor(clicked, cursorpos);
	}

	void UISoftKey::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
				button_pressed(Buttons::BtCancel);
			else if (keycode == KeyAction::Id::RETURN)
				button_pressed(Buttons::BtOK);
		}
	}

	UIElement::Type UISoftKey::get_type() const
	{
		return TYPE;
	}

	Button::State UISoftKey::button_pressed(uint16_t buttonid)
	{
		std::string pic = textfield.get_text();
		size_t size = pic.size();

		if (buttonid == Buttons::BtCancel)
		{
			deactivate();

			if (cancel_callback)
				cancel_callback();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtDel)
		{
			if (size > 0)
			{
				pic.pop_back();
				textfield.change_text(pic);
			}

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtOK)
		{
			if (size >= MIN_TEXT_LEN)
			{
				if (check_pic())
				{
					deactivate();

					if (ok_callback)
						ok_callback(pic);
				}
			}
			else
			{
				clear_tooltip();
				show_text("The PIC needs to be at least 6 characters long.");
			}

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtShift)
		{
			highCase = !highCase;

			return Button::State::NORMAL;
		}
		else if (buttonid >= Buttons::BtNum0)
		{
			std::string key = row1keys[buttonid - Buttons::BtNum0];

			if (key != "Blank")
				append_key(key);

			return Button::State::NORMAL;
		}
		else
		{
			return Button::State::DISABLED;
		}
	}

	void UISoftKey::show_text(std::string text, uint16_t maxwidth, bool formatted, int16_t line_adj)
	{
		tetooltip.set_text(text, maxwidth, formatted, line_adj);

		if (!text.empty())
		{
			tooltip = tetooltip;
			tooltip_timestep = 7 * 1000;
		}
	}

	void UISoftKey::clear_tooltip()
	{
		tooltip_pos = Point<int16_t>(0, 0);
		tetooltip.set_text("");
		tooltip = Optional<Tooltip>();
	}

	void UISoftKey::append_key(std::string key)
	{
		std::string pic = textfield.get_text();
		size_t size = pic.size();

		if (size < MAX_TEXT_LEN)
		{
			pic.append(key);
			textfield.change_text(pic);
		}
	}

	Point<int16_t> UISoftKey::keypos(uint16_t index, uint16_t row) const
	{
		int16_t x = index * 45;
		int16_t y = row * 43;

		// Third row starts at the third character position
		if (row == 3)
			x += 45 * 2;

		return Point<int16_t>(27 + x, 95 + y);
	}

	Button::State UISoftKey::case_pressed(uint16_t buttonid)
	{
		// Row 2
		if (buttonid >= 0 && buttonid < ROW_MAX)
		{
			std::string string_index = row2keys[buttonid];

			if (string_index != "Blank")
			{
				uint16_t index = std::stoi(string_index);
				std::string key = get_key_from_index(index);

				append_key(key);
			}

			return Button::State::NORMAL;
		}
		// Row 3
		else if (buttonid >= ROW_MAX && buttonid < ROW_MAX * 2)
		{
			std::string string_index = row3keys[buttonid - ROW_MAX];

			if (string_index != "Blank")
			{
				uint16_t index = std::stoi(string_index);
				std::string key = get_key_from_index(index);

				append_key(key);
			}

			return Button::State::NORMAL;
		}
		// Row 4
		else if (buttonid >= ROW_MAX * 2 && buttonid < ROW_MAX * 2 + ROW4_MAX)
		{
			std::string string_index = row4keys[buttonid - ROW_MAX * 2];

			if (string_index != "Blank")
			{
				uint16_t index = std::stoi(string_index);
				std::string key = get_key_from_index(index);

				append_key(key);
			}

			return Button::State::NORMAL;
		}

		return Button::State::DISABLED;
	}

	std::string UISoftKey::get_key_map_index(std::string key)
	{
		for (auto map : KeyMap)
			if (map.second == key)
				return std::to_string(map.first);

		LOG(LOG_DEBUG, "Could not find index for key [" << key << "] in KeyMap.");

		return "Blank";
	}

	std::string UISoftKey::get_key_from_index(uint16_t index)
	{
		auto iter = KeyMap.find(index);

		if (iter != KeyMap.end())
		{
			std::string key = KeyMap.at(index);

			return highCase ? key : string_format::tolower(key);
		}

		LOG(LOG_DEBUG, "Could not find key at index [" << index << "] in KeyMap.");

		return "Blank";
	}

	bool UISoftKey::check_pic()
	{
		const char* pStr = textfield.get_text().c_str();

		if (pStr == NULL)
			return false;

		int count = 0;
		char m = ' ';
		bool reptitive = false;

		while (*pStr)
		{
			if (*pStr == m)
			{
				count++;
			}
			else
			{
				count = 0;
				m = *pStr;
			}

			if (count > 2)
			{
				reptitive = true;
				break;
			}

			pStr++;
		}

		if (reptitive)
		{
			clear_tooltip();
			show_text("Your 2nd password cannot contain three of the same character in a row.", 220, true, 1);

			return false;
		}

		bool requirements = false;

		// TODO: Add check for required amount of characters

		if (requirements)
		{
			clear_tooltip();
			show_text("Your 2nd password must have at least two of the following: uppercase letters, lowercase letters, numbers, and special characters.", 242, true, 1);

			return false;
		}

		return true;
	}
}

================
File: IO/UITypes/UISoftKey.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../Components/Textfield.h"
#include "../Components/TextTooltip.h"

#include "../../Template/BoolPair.h"
#include "../../Util/Randomizer.h"

namespace ms
{
	// Keyboard which is used via the mouse
	// The game uses this for PIC/PIN input
	class UISoftKey : public UIElement
	{
	public:
		using OkCallback = std::function<void(const std::string& entered)>;
		using CancelCallback = std::function<void()>;

		static constexpr Type TYPE = UIElement::Type::SOFTKEYBOARD;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = false;

		UISoftKey(OkCallback ok_callback, CancelCallback cancel_callback, std::string tooltip_text, Point<int16_t> tooltip_pos);
		UISoftKey(OkCallback ok_callback, CancelCallback cancel_callback, std::string tooltip_text);
		UISoftKey(OkCallback ok_callback, CancelCallback cancel_callback);
		UISoftKey(OkCallback ok_callback);

		void draw(float inter) const override;
		void update() override;

		void deactivate();

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void show_text(std::string text, uint16_t maxwidth = 0, bool formatted = true, int16_t line_adj = 0);
		void clear_tooltip();
		void append_key(std::string key);

		Point<int16_t> keypos(uint16_t index, uint16_t row) const;
		Button::State case_pressed(uint16_t buttonid);
		std::string get_key_map_index(std::string key);
		std::string get_key_from_index(uint16_t index);
		bool check_pic();

		enum Buttons : uint16_t
		{
			BtCancel,
			BtDel,
			BtOK,
			BtShift,
			BtNum0
		};

		static constexpr size_t MIN_TEXT_LEN = 6;
		static constexpr size_t MAX_TEXT_LEN = 16;

		static constexpr uint16_t ROW_MAX = 12;

		static constexpr uint16_t ROW1_KEYS = 10;
		static constexpr uint16_t ROW2_KEYS = 10;
		static constexpr uint16_t ROW3_KEYS = 9;
		static constexpr uint16_t ROW4_KEYS = 7;

		static constexpr uint16_t ROW4_MAX = ROW4_KEYS + 1;
		static constexpr uint16_t CASE_KEYS = ROW_MAX * 2 + ROW4_MAX;

		bool highCase;
		std::string row1keys[ROW_MAX];
		std::string row2keys[ROW_MAX];
		std::string row3keys[ROW_MAX];
		std::string row4keys[ROW4_MAX];
		BoolPair<std::unique_ptr<Button>> BtCaseKeys[CASE_KEYS];

		OkCallback ok_callback;
		CancelCallback cancel_callback;

		Textfield textfield;

		int16_t tooltip_timestep;
		TextTooltip tetooltip;
		Optional<Tooltip> tooltip;
		Point<int16_t> tooltip_pos;

		Randomizer random;

		std::map<uint16_t, std::string> KeyMap =
		{
			{  0, "A" },
			{  1, "B" },
			{  2, "C" },
			{  3, "D" },
			{  4, "E" },
			{  5, "F" },
			{  6, "G" },
			{  7, "H" },
			{  8, "I" },
			{  9, "J" },
			{ 10, "K" },
			{ 11, "L" },
			{ 12, "M" },
			{ 13, "N" },
			{ 14, "O" },
			{ 15, "P" },
			{ 16, "Q" },
			{ 17, "R" },
			{ 18, "S" },
			{ 19, "T" },
			{ 20, "U" },
			{ 21, "V" },
			{ 22, "W" },
			{ 23, "X" },
			{ 24, "Y" },
			{ 25, "Z" }
		};
	};
}

================
File: IO/UITypes/UIStatsInfo.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIStatsInfo.h"

#include "UINotice.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#include "../../Gameplay/Stage.h"

#include "../../Net/Packets/PlayerPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIStatsInfo::UIStatsInfo(const CharStats& st) : UIDragElement<PosSTATS>(Point<int16_t>(212, 20)), stats(st)
	{
		nl::node close = nl::nx::UI["Basic.img"]["BtClose3"];
		nl::node Stat = nl::nx::UI["UIWindow4.img"]["Stat"];
		nl::node main = Stat["main"];
		nl::node detail = Stat["detail"];
		nl::node abilityTitle = detail["abilityTitle"];
		nl::node metierLine = detail["metierLine"];

		sprites.emplace_back(main["backgrnd"]);
		sprites.emplace_back(main["backgrnd2"]);
		sprites.emplace_back(main["backgrnd3"]);

		cover0 = Sprite(main["cover0"]);
		cover1 = Sprite(main["cover1"]);

		textures_detail.emplace_back(detail["backgrnd"]);
		textures_detail.emplace_back(detail["backgrnd2"]);
		textures_detail.emplace_back(detail["backgrnd3"]);
		textures_detail.emplace_back(detail["backgrnd4"]);

		abilities[Ability::RARE] = abilityTitle["rare"]["0"];
		abilities[Ability::EPIC] = abilityTitle["epic"]["0"];
		abilities[Ability::UNIQUE] = abilityTitle["unique"]["0"];
		abilities[Ability::LEGENDARY] = abilityTitle["legendary"]["0"];
		abilities[Ability::NONE] = abilityTitle["normal"]["0"];

		inner_ability[true] = metierLine["activated"]["0"];
		inner_ability[false] = metierLine["disabled"]["0"];

		buttons[Buttons::BT_CLOSE] = std::make_unique<MapleButton>(close, Point<int16_t>(190, 6));
		buttons[Buttons::BT_HP] = std::make_unique<MapleButton>(main["BtHpUp"]);
		buttons[Buttons::BT_MP] = std::make_unique<MapleButton>(main["BtMpUp"]);
		buttons[Buttons::BT_STR] = std::make_unique<MapleButton>(main["BtStrUp"]);
		buttons[Buttons::BT_DEX] = std::make_unique<MapleButton>(main["BtDexUp"]);
		buttons[Buttons::BT_INT] = std::make_unique<MapleButton>(main["BtIntUp"]);
		buttons[Buttons::BT_LUK] = std::make_unique<MapleButton>(main["BtLukUp"]);
		buttons[Buttons::BT_AUTO] = std::make_unique<MapleButton>(main["BtAuto"]);
		buttons[Buttons::BT_HYPERSTATOPEN] = std::make_unique<MapleButton>(main["BtHyperStatOpen"]);
		buttons[Buttons::BT_HYPERSTATCLOSE] = std::make_unique<MapleButton>(main["BtHyperStatClose"]);
		buttons[Buttons::BT_DETAILOPEN] = std::make_unique<MapleButton>(main["BtDetailOpen"]);
		buttons[Buttons::BT_DETAILCLOSE] = std::make_unique<MapleButton>(main["BtDetailClose"]);
		buttons[Buttons::BT_ABILITY] = std::make_unique<MapleButton>(detail["BtAbility"], Point<int16_t>(212, 0));
		buttons[Buttons::BT_DETAIL_DETAILCLOSE] = std::make_unique<MapleButton>(detail["BtHpUp"], Point<int16_t>(212, 0));

		buttons[Buttons::BT_HYPERSTATOPEN]->set_active(false);
		buttons[Buttons::BT_DETAILCLOSE]->set_active(false);
		buttons[Buttons::BT_ABILITY]->set_active(false);
		buttons[Buttons::BT_ABILITY]->set_state(Button::State::DISABLED);
		buttons[Buttons::BT_DETAIL_DETAILCLOSE]->set_active(false);

		jobId = stats.get_stat(MapleStat::Id::JOB);

		if (jobId == Job::Level::BEGINNER)
		{
			buttons[Buttons::BT_HP]->set_active(false);
			buttons[Buttons::BT_MP]->set_active(false);
			buttons[Buttons::BT_STR]->set_active(false);
			buttons[Buttons::BT_DEX]->set_active(false);
			buttons[Buttons::BT_INT]->set_active(false);
			buttons[Buttons::BT_LUK]->set_active(false);
			buttons[Buttons::BT_AUTO]->set_active(false);
		}

		update_ap();

		// Normal
		for (size_t i = StatLabel::NAME; i <= LUK; i++)
			statlabels[i] = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::EMPEROR);

		statlabels[StatLabel::AP] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);

		Point<int16_t> statoffset = Point<int16_t>(73, 29);
		int16_t statoffset_y = 18;

		statoffsets[StatLabel::NAME] = statoffset;
		statoffsets[StatLabel::JOB] = statoffset + Point<int16_t>(1, statoffset_y * 1);
		statoffsets[StatLabel::GUILD] = statoffset + Point<int16_t>(1, statoffset_y * 2);
		statoffsets[StatLabel::FAME] = statoffset + Point<int16_t>(1, statoffset_y * 3);
		statoffsets[StatLabel::MIN_DAMAGE] = statoffset + Point<int16_t>(15, statoffset_y * 4);
		statoffsets[StatLabel::MAX_DAMAGE] = statoffset + Point<int16_t>(19, statoffset_y * 5);
		statoffsets[StatLabel::HP] = statoffset + Point<int16_t>(1, statoffset_y * 6);
		statoffsets[StatLabel::MP] = statoffset + Point<int16_t>(1, statoffset_y * 7);
		statoffsets[StatLabel::AP] = statoffset + Point<int16_t>(19, 167);
		statoffsets[StatLabel::STR] = statoffset + Point<int16_t>(1, 196);
		statoffsets[StatLabel::DEX] = statoffset + Point<int16_t>(1, 214);
		statoffsets[StatLabel::INT] = statoffset + Point<int16_t>(1, 232);
		statoffsets[StatLabel::LUK] = statoffset + Point<int16_t>(1, 250);

		// Detailed
		statlabels[StatLabel::MIN_DAMAGE_DETAILED] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::MAX_DAMAGE_DETAILED] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::DAMAGE_BONUS] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::BOSS_DAMAGE] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::FINAL_DAMAGE] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::BUFF_DURATION] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::IGNORE_DEFENSE] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::ITEM_DROP_RATE] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::CRITICAL_RATE] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::MESOS_OBTAINED] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::CRITICAL_DAMAGE] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::STATUS_RESISTANCE] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::KNOCKBACK_RESISTANCE] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::DEFENSE] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::SPEED] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::JUMP] = Text(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::EMPEROR);
		statlabels[StatLabel::HONOR] = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::EMPEROR);

		Point<int16_t> statoffset_detailed = Point<int16_t>(0, 77);
		int16_t statoffset_detailed_lx = 116;
		int16_t statoffset_detailed_rx = 227;

		statoffsets[StatLabel::MIN_DAMAGE_DETAILED] = Point<int16_t>(94, 41);
		statoffsets[StatLabel::MAX_DAMAGE_DETAILED] = Point<int16_t>(105, 59);

		statoffsets[StatLabel::DAMAGE_BONUS] = statoffset_detailed + Point<int16_t>(statoffset_detailed_lx, statoffset_y * 0);
		statoffsets[StatLabel::BOSS_DAMAGE] = statoffset_detailed + Point<int16_t>(statoffset_detailed_rx, statoffset_y * 0);

		statoffsets[StatLabel::FINAL_DAMAGE] = statoffset_detailed + Point<int16_t>(statoffset_detailed_lx, statoffset_y * 1);
		statoffsets[StatLabel::BUFF_DURATION] = statoffset_detailed + Point<int16_t>(statoffset_detailed_rx, statoffset_y * 1);

		statoffsets[StatLabel::IGNORE_DEFENSE] = statoffset_detailed + Point<int16_t>(statoffset_detailed_lx, statoffset_y * 2);
		statoffsets[StatLabel::ITEM_DROP_RATE] = statoffset_detailed + Point<int16_t>(statoffset_detailed_rx, statoffset_y * 2);

		statoffsets[StatLabel::CRITICAL_RATE] = statoffset_detailed + Point<int16_t>(statoffset_detailed_lx, statoffset_y * 3);
		statoffsets[StatLabel::MESOS_OBTAINED] = statoffset_detailed + Point<int16_t>(statoffset_detailed_rx, statoffset_y * 3);

		statoffsets[StatLabel::CRITICAL_DAMAGE] = statoffset_detailed + Point<int16_t>(statoffset_detailed_lx + 3, statoffset_y * 4);

		statoffsets[StatLabel::STATUS_RESISTANCE] = statoffset_detailed + Point<int16_t>(statoffset_detailed_lx, statoffset_y * 5);
		statoffsets[StatLabel::KNOCKBACK_RESISTANCE] = statoffset_detailed + Point<int16_t>(statoffset_detailed_rx, statoffset_y * 5);

		statoffsets[StatLabel::DEFENSE] = statoffset_detailed + Point<int16_t>(statoffset_detailed_lx, statoffset_y * 6);

		statoffsets[StatLabel::SPEED] = statoffset_detailed + Point<int16_t>(statoffset_detailed_lx, statoffset_y * 7);
		statoffsets[StatLabel::JUMP] = statoffset_detailed + Point<int16_t>(statoffset_detailed_lx, statoffset_y * 8);

		statoffsets[StatLabel::HONOR] = statoffset_detailed + Point<int16_t>(73, 263);

		update_all_stats();
		update_stat(MapleStat::Id::JOB);
		update_stat(MapleStat::Id::FAME);

		dimension = Point<int16_t>(212, 318);
		showdetail = false;
	}

	void UIStatsInfo::draw(float alpha) const
	{
		UIElement::draw_sprites(alpha);

		if (jobId == Job::Level::BEGINNER)
		{
			cover0.draw(position, alpha);
			cover1.draw(position, alpha);
		}

		if (showdetail)
		{
			Point<int16_t> detail_pos(position + Point<int16_t>(212, 0));

			textures_detail[0].draw(detail_pos + Point<int16_t>(0, -1));
			textures_detail[1].draw(detail_pos);
			textures_detail[2].draw(detail_pos);
			textures_detail[3].draw(detail_pos);

			abilities[Ability::NONE].draw(DrawArgument(detail_pos));

			inner_ability[false].draw(detail_pos);
			inner_ability[false].draw(detail_pos + Point<int16_t>(0, 19));
			inner_ability[false].draw(detail_pos + Point<int16_t>(0, 38));
		}

		size_t last = showdetail ? StatLabel::NUM_LABELS : StatLabel::NUM_NORMAL;

		for (size_t i = 0; i < last; i++)
		{
			Point<int16_t> labelpos = position + statoffsets[i];

			if (i >= StatLabel::NUM_NORMAL)
				labelpos.shift_x(213);

			if (jobId == Job::Level::BEGINNER)
			{
				if (i < AP || i > NUM_NORMAL)
					statlabels[i].draw(labelpos);
			}
			else
			{
				statlabels[i].draw(labelpos);
			}
		}

		UIElement::draw_buttons(alpha);
	}

	void UIStatsInfo::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed && escape)
			deactivate();
	}

	bool UIStatsInfo::is_in_range(Point<int16_t> cursorpos) const
	{
		Point<int16_t> pos_adj;

		if (showdetail)
			pos_adj = Point<int16_t>(211, 25);
		else
			pos_adj = Point<int16_t>(0, 0);

		auto bounds = Rectangle<int16_t>(position, position + dimension + pos_adj);
		return bounds.contains(cursorpos);
	}

	UIElement::Type UIStatsInfo::get_type() const
	{
		return TYPE;
	}

	void UIStatsInfo::update_all_stats()
	{
		update_simple(AP, MapleStat::Id::AP);

		if (hasap ^ (stats.get_stat(MapleStat::Id::AP) > 0))
			update_ap();

		statlabels[StatLabel::NAME].change_text(stats.get_name());
		statlabels[StatLabel::GUILD].change_text("-");
		statlabels[StatLabel::HP].change_text(std::to_string(stats.get_stat(MapleStat::Id::HP)) + " / " + std::to_string(stats.get_total(EquipStat::Id::HP)));
		statlabels[StatLabel::MP].change_text(std::to_string(stats.get_stat(MapleStat::Id::MP)) + " / " + std::to_string(stats.get_total(EquipStat::Id::MP)));

		update_basevstotal(StatLabel::STR, MapleStat::Id::STR, EquipStat::Id::STR);
		update_basevstotal(StatLabel::DEX, MapleStat::Id::DEX, EquipStat::Id::DEX);
		update_basevstotal(StatLabel::INT, MapleStat::Id::INT, EquipStat::Id::INT);
		update_basevstotal(StatLabel::LUK, MapleStat::Id::LUK, EquipStat::Id::LUK);

		statlabels[StatLabel::MIN_DAMAGE].change_text(std::to_string(stats.get_mindamage()));
		statlabels[StatLabel::MAX_DAMAGE].change_text(" ~ " + std::to_string(stats.get_maxdamage()));

		if (stats.is_damage_buffed())
		{
			statlabels[StatLabel::MIN_DAMAGE].change_color(Color::Name::RED);
			statlabels[StatLabel::MIN_DAMAGE].change_color(Color::Name::RED);
		}
		else
		{
			statlabels[StatLabel::MAX_DAMAGE].change_color(Color::Name::EMPEROR);
			statlabels[StatLabel::MAX_DAMAGE].change_color(Color::Name::EMPEROR);
		}

		statlabels[StatLabel::MIN_DAMAGE_DETAILED].change_text(std::to_string(stats.get_mindamage()));
		statlabels[StatLabel::MAX_DAMAGE_DETAILED].change_text(" ~ " + std::to_string(stats.get_maxdamage()));
		statlabels[StatLabel::DAMAGE_BONUS].change_text("0%");
		statlabels[StatLabel::BOSS_DAMAGE].change_text(std::to_string(static_cast<int32_t>(stats.get_bossdmg() * 100)) + "%");
		statlabels[StatLabel::FINAL_DAMAGE].change_text("0.00%");
		statlabels[StatLabel::BUFF_DURATION].change_text("0%");
		statlabels[StatLabel::IGNORE_DEFENSE].change_text(std::to_string(static_cast<int32_t>(stats.get_ignoredef())) + "%");
		statlabels[StatLabel::ITEM_DROP_RATE].change_text("0%");
		statlabels[StatLabel::CRITICAL_RATE].change_text(std::to_string(static_cast<int32_t>(stats.get_critical() * 100)) + "%");
		statlabels[StatLabel::MESOS_OBTAINED].change_text("0%");
		statlabels[StatLabel::CRITICAL_DAMAGE].change_text("0.00%");
		statlabels[StatLabel::STATUS_RESISTANCE].change_text(std::to_string(static_cast<int32_t>(stats.get_resistance())));
		statlabels[StatLabel::KNOCKBACK_RESISTANCE].change_text("0%");

		update_buffed(StatLabel::DEFENSE, EquipStat::Id::WDEF);

		statlabels[StatLabel::SPEED].change_text(std::to_string(stats.get_total(EquipStat::Id::SPEED)) + "%");
		statlabels[StatLabel::JUMP].change_text(std::to_string(stats.get_total(EquipStat::Id::JUMP)) + "%");
		statlabels[StatLabel::HONOR].change_text(std::to_string(stats.get_honor()));
	}

	void UIStatsInfo::update_stat(MapleStat::Id stat)
	{
		switch (stat)
		{
			case MapleStat::Id::JOB:
			{
				jobId = stats.get_stat(MapleStat::Id::JOB);

				statlabels[StatLabel::JOB].change_text(stats.get_jobname());

				buttons[Buttons::BT_HP]->set_active(jobId != Job::Level::BEGINNER);
				buttons[Buttons::BT_MP]->set_active(jobId != Job::Level::BEGINNER);
				buttons[Buttons::BT_STR]->set_active(jobId != Job::Level::BEGINNER);
				buttons[Buttons::BT_DEX]->set_active(jobId != Job::Level::BEGINNER);
				buttons[Buttons::BT_INT]->set_active(jobId != Job::Level::BEGINNER);
				buttons[Buttons::BT_LUK]->set_active(jobId != Job::Level::BEGINNER);
				buttons[Buttons::BT_AUTO]->set_active(jobId != Job::Level::BEGINNER);

				break;
			}
			case MapleStat::Id::FAME:
			{
				update_simple(StatLabel::FAME, MapleStat::Id::FAME);
				break;
			}
		}
	}

	Button::State UIStatsInfo::button_pressed(uint16_t id)
	{
		const Player& player = Stage::get().get_player();

		switch (id)
		{
			case Buttons::BT_CLOSE:
			{
				deactivate();
				break;
			}
			case Buttons::BT_HP:
			{
				send_apup(MapleStat::Id::HP);
				break;
			}
			case Buttons::BT_MP:
			{
				send_apup(MapleStat::Id::MP);
				break;
			}
			case Buttons::BT_STR:
			{
				send_apup(MapleStat::Id::STR);
				break;
			}
			case Buttons::BT_DEX:
			{
				send_apup(MapleStat::Id::DEX);
				break;
			}
			case Buttons::BT_INT:
			{
				send_apup(MapleStat::Id::INT);
				break;
			}
			case Buttons::BT_LUK:
			{
				send_apup(MapleStat::Id::LUK);
				break;
			}
			case Buttons::BT_AUTO:
			{
				uint16_t autostr = 0;
				uint16_t autodex = 0;
				uint16_t autoint = 0;
				uint16_t autoluk = 0;
				uint16_t nowap = stats.get_stat(MapleStat::Id::AP);
				EquipStat::Id id = player.get_stats().get_job().get_primary(player.get_weapontype());

				switch (id)
				{
					case EquipStat::Id::STR:
						autostr = nowap;
						break;
					case EquipStat::Id::DEX:
						autodex = nowap;
						break;
					case EquipStat::Id::INT:
						autoint = nowap;
						break;
					case EquipStat::Id::LUK:
						autoluk = nowap;
						break;
				}

				std::string message =
					"Your AP will be distributed as follows:\\r"
					"\\nSTR : +" + std::to_string(autostr) +
					"\\nDEX : +" + std::to_string(autodex) +
					"\\nINT : +" + std::to_string(autoint) +
					"\\nLUK : +" + std::to_string(autoluk) +
					"\\r\\n";

				std::function<void(bool)> yesnohandler = [&, autostr, autodex, autoint, autoluk](bool yes)
				{
					if (yes)
					{
						if (autostr > 0)
							for (size_t i = 0; i < autostr; i++)
								send_apup(MapleStat::Id::STR);

						if (autodex > 0)
							for (size_t i = 0; i < autodex; i++)
								send_apup(MapleStat::Id::DEX);

						if (autoint > 0)
							for (size_t i = 0; i < autoint; i++)
								send_apup(MapleStat::Id::INT);

						if (autoluk > 0)
							for (size_t i = 0; i < autoluk; i++)
								send_apup(MapleStat::Id::LUK);
					}
				};

				UI::get().emplace<UIYesNo>(message, yesnohandler, Text::Alignment::LEFT);
				break;
			}
			case Buttons::BT_HYPERSTATOPEN:
			{
				break;
			}
			case Buttons::BT_HYPERSTATCLOSE:
			{
				if (player.get_level() < 140)
					UI::get().emplace<UIOk>("You can use the Hyper Stat at Lv. 140 and above.", [](bool) {});

				break;
			}
			case Buttons::BT_DETAILOPEN:
			{
				set_detail(true);
				break;
			}
			case Buttons::BT_DETAILCLOSE:
			case Buttons::BT_DETAIL_DETAILCLOSE:
			{
				set_detail(false);
				break;
			}
			case Buttons::BT_ABILITY:
			default:
			{
				break;
			}
		}

		return Button::State::NORMAL;
	}

	void UIStatsInfo::send_apup(MapleStat::Id stat) const
	{
		SpendApPacket(stat).dispatch();
		UI::get().disable();
	}

	void UIStatsInfo::set_detail(bool enabled)
	{
		showdetail = enabled;

		buttons[Buttons::BT_DETAILOPEN]->set_active(!enabled);
		buttons[Buttons::BT_DETAILCLOSE]->set_active(enabled);
		buttons[Buttons::BT_ABILITY]->set_active(enabled);
		buttons[Buttons::BT_DETAIL_DETAILCLOSE]->set_active(enabled);
	}

	void UIStatsInfo::update_ap()
	{
		bool nowap = stats.get_stat(MapleStat::Id::AP) > 0;
		Button::State newstate = nowap ? Button::State::NORMAL : Button::State::DISABLED;

		for (int i = Buttons::BT_HP; i <= Buttons::BT_AUTO; i++)
			buttons[i]->set_state(newstate);

		hasap = nowap;
	}

	void UIStatsInfo::update_simple(StatLabel label, MapleStat::Id stat)
	{
		statlabels[label].change_text(std::to_string(stats.get_stat(stat)));
	}

	void UIStatsInfo::update_basevstotal(StatLabel label, MapleStat::Id bstat, EquipStat::Id tstat)
	{
		int32_t base = stats.get_stat(bstat);
		int32_t total = stats.get_total(tstat);
		int32_t delta = total - base;

		std::string stattext = std::to_string(total);

		if (delta)
		{
			stattext += " (" + std::to_string(base);

			if (delta > 0)
				stattext += "+" + std::to_string(delta);
			else if (delta < 0)
				stattext += "-" + std::to_string(-delta);

			stattext += ")";
		}

		statlabels[label].change_text(stattext);
	}

	void UIStatsInfo::update_buffed(StatLabel label, EquipStat::Id stat)
	{
		int32_t total = stats.get_total(stat);
		int32_t delta = stats.get_buffdelta(stat);

		std::string stattext = std::to_string(total);

		if (delta)
		{
			stattext += " (" + std::to_string(total - delta);

			if (delta > 0)
			{
				stattext += "+" + std::to_string(delta);

				statlabels[label].change_color(Color::Name::RED);
			}
			else if (delta < 0)
			{
				stattext += "-" + std::to_string(-delta);

				statlabels[label].change_color(Color::Name::BLUE);
			}

			stattext += ")";
		}

		statlabels[label].change_text(stattext);
	}
}

================
File: IO/UITypes/UIStatsInfo.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../../Character/CharStats.h"
#include "../../Template/BoolPair.h"

namespace ms
{
	class UIStatsInfo : public UIDragElement<PosSTATS>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::STATSINFO;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIStatsInfo(const CharStats& stats);

		void draw(float alpha) const override;

		void send_key(int32_t keycode, bool pressed, bool escape) override;
		bool is_in_range(Point<int16_t> cursorpos) const override;

		UIElement::Type get_type() const override;

		void update_all_stats();
		void update_stat(MapleStat::Id stat);

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		enum StatLabel
		{
			// Normal
			NAME,
			JOB,
			GUILD,
			FAME,
			MIN_DAMAGE,
			MAX_DAMAGE,
			HP,
			MP,
			AP,
			STR,
			DEX,
			INT,
			LUK,
			NUM_NORMAL,
			// Detailed
			MIN_DAMAGE_DETAILED,
			MAX_DAMAGE_DETAILED,
			DAMAGE_BONUS,
			BOSS_DAMAGE,
			FINAL_DAMAGE,
			BUFF_DURATION,
			IGNORE_DEFENSE,
			ITEM_DROP_RATE,
			CRITICAL_RATE,
			MESOS_OBTAINED,
			CRITICAL_DAMAGE,
			STATUS_RESISTANCE,
			KNOCKBACK_RESISTANCE,
			DEFENSE,
			SPEED,
			JUMP,
			HONOR,
			// Total
			NUM_LABELS
		};

		void update_ap();
		void update_simple(StatLabel label, MapleStat::Id stat);
		void update_basevstotal(StatLabel label, MapleStat::Id bstat, EquipStat::Id tstat);
		void update_buffed(StatLabel label, EquipStat::Id stat);
		void send_apup(MapleStat::Id stat) const;
		void set_detail(bool enabled);

		enum Buttons
		{
			BT_CLOSE,
			BT_HP,
			BT_MP,
			BT_STR,
			BT_DEX,
			BT_INT,
			BT_LUK,
			BT_AUTO,
			BT_HYPERSTATOPEN,
			BT_HYPERSTATCLOSE,
			BT_DETAILOPEN,
			BT_DETAILCLOSE,
			BT_ABILITY,
			BT_DETAIL_DETAILCLOSE
		};

		const CharStats& stats;

		enum Ability
		{
			RARE,
			EPIC,
			UNIQUE,
			LEGENDARY,
			NONE,
			NUM_ABILITIES
		};

		std::array<Texture, Ability::NUM_ABILITIES> abilities;
		BoolPair<Texture> inner_ability;

		std::vector<Texture> textures_detail;
		bool showdetail;

		bool hasap;
		uint16_t jobId;

		Sprite cover0;
		Sprite cover1;

		Text statlabels[StatLabel::NUM_LABELS];
		Point<int16_t> statoffsets[StatLabel::NUM_LABELS];
	};
}

================
File: IO/UITypes/UIStatusBar.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIStatusBar.h"

#include "UIChannel.h"
#include "UICharInfo.h"
#include "UIChat.h"
#include "UIEquipInventory.h"
#include "UIEvent.h"
#include "UIItemInventory.h"
#include "UIJoypad.h"
#include "UIKeyConfig.h"
#include "UIOptionMenu.h"
#include "UIQuestLog.h"
#include "UIQuit.h"
#include "UISkillBook.h"
#include "UIStatsInfo.h"
#include "UIUserList.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#include "../../Character/ExpTable.h"
#include "../../Gameplay/Stage.h"

#include "../../Net/Packets/GameplayPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIStatusBar::UIStatusBar(const CharStats& st) : stats(st)
	{
		quickslot_active = false;
		quickslot_adj = Point<int16_t>(QUICKSLOT_MAX, 0);
		VWIDTH = Constants::Constants::get().get_viewwidth();
		VHEIGHT = Constants::Constants::get().get_viewheight();

		menu_active = false;
		setting_active = false;
		community_active = false;
		character_active = false;
		event_active = false;

		std::string stat = "status";

		if (VWIDTH == 800)
			stat += "800";

		nl::node mainBar = nl::nx::UI["StatusBar3.img"]["mainBar"];
		nl::node status = mainBar[stat];
		nl::node EXPBar = mainBar["EXPBar"];
		nl::node EXPBarRes = EXPBar[VWIDTH];
		nl::node menu = mainBar["menu"];
		nl::node quickSlot = mainBar["quickSlot"];
		nl::node submenu = mainBar["submenu"];

		exp_pos = Point<int16_t>(0, 87);

		sprites.emplace_back(EXPBar["backgrnd"], DrawArgument(Point<int16_t>(0, 87), Point<int16_t>(VWIDTH, 0)));
		sprites.emplace_back(EXPBarRes["layer:back"], exp_pos);

		int16_t exp_max = VWIDTH - 16;

		expbar = Gauge(
			Gauge::Type::DEFAULT,
			EXPBarRes.resolve("layer:gauge"),
			EXPBarRes.resolve("layer:cover"),
			EXPBar.resolve("layer:effect"),
			exp_max, 0.0f
		);

		int16_t pos_adj = 0;

		if (VWIDTH == 1280)
			pos_adj = 87;
		else if (VWIDTH == 1366)
			pos_adj = 171;
		else if (VWIDTH == 1920)
			pos_adj = 448;

		if (VWIDTH == 1024)
			quickslot_min = 1;
		else
			quickslot_min = 0;

		if (VWIDTH == 800)
		{
			hpmp_pos = Point<int16_t>(412, 40);
			hpset_pos = Point<int16_t>(530, 70);
			mpset_pos = Point<int16_t>(528, 86);
			statset_pos = Point<int16_t>(427, 111);
			levelset_pos = Point<int16_t>(461, 48);
			namelabel_pos = Point<int16_t>(487, 40);
			quickslot_pos = Point<int16_t>(579, 0);

			// Menu
			menu_pos = Point<int16_t>(682, -280);
			setting_pos = menu_pos + Point<int16_t>(0, 168);
			community_pos = menu_pos + Point<int16_t>(-26, 196);
			character_pos = menu_pos + Point<int16_t>(-61, 168);
			event_pos = menu_pos + Point<int16_t>(-94, 252);
		}
		else
		{
			hpmp_pos = Point<int16_t>(416 + pos_adj, 40);
			hpset_pos = Point<int16_t>(550 + pos_adj, 70);
			mpset_pos = Point<int16_t>(546 + pos_adj, 86);
			statset_pos = Point<int16_t>(539 + pos_adj, 111);
			levelset_pos = Point<int16_t>(465 + pos_adj, 48);
			namelabel_pos = Point<int16_t>(493 + pos_adj, 40);
			quickslot_pos = Point<int16_t>(628 + pos_adj, 37);

			// Menu
			menu_pos = Point<int16_t>(720 + pos_adj, -280);
			setting_pos = menu_pos + Point<int16_t>(0, 168);
			community_pos = menu_pos + Point<int16_t>(-26, 196);
			character_pos = menu_pos + Point<int16_t>(-61, 168);
			event_pos = menu_pos + Point<int16_t>(-94, 252);
		}

		if (VWIDTH == 1280)
		{
			statset_pos = Point<int16_t>(580 + pos_adj, 111);
			quickslot_pos = Point<int16_t>(622 + pos_adj, 37);

			// Menu
			menu_pos += Point<int16_t>(-7, 0);
			setting_pos += Point<int16_t>(-7, 0);
			community_pos += Point<int16_t>(-7, 0);
			character_pos += Point<int16_t>(-7, 0);
			event_pos += Point<int16_t>(-7, 0);
		}
		else if (VWIDTH == 1366)
		{
			quickslot_pos = Point<int16_t>(623 + pos_adj, 37);

			// Menu
			menu_pos += Point<int16_t>(-5, 0);
			setting_pos += Point<int16_t>(-5, 0);
			community_pos += Point<int16_t>(-5, 0);
			character_pos += Point<int16_t>(-5, 0);
			event_pos += Point<int16_t>(-5, 0);
		}
		else if (VWIDTH == 1920)
		{
			quickslot_pos = Point<int16_t>(900 + pos_adj, 37);

			// Menu
			menu_pos += Point<int16_t>(272, 0);
			setting_pos += Point<int16_t>(272, 0);
			community_pos += Point<int16_t>(272, 0);
			character_pos += Point<int16_t>(272, 0);
			event_pos += Point<int16_t>(272, 0);
		}

		hpmp_sprites.emplace_back(status["backgrnd"], hpmp_pos - Point<int16_t>(1, 0));
		hpmp_sprites.emplace_back(status["layer:cover"], hpmp_pos - Point<int16_t>(1, 0));

		if (VWIDTH == 800)
			hpmp_sprites.emplace_back(status["layer:Lv"], hpmp_pos);
		else
			hpmp_sprites.emplace_back(status["layer:Lv"], hpmp_pos - Point<int16_t>(1, 0));

		int16_t hpmp_max = 139;

		if (VWIDTH > 800)
			hpmp_max += 30;

		hpbar = Gauge(Gauge::Type::DEFAULT, status.resolve("gauge/hp/layer:0"), hpmp_max, 0.0f);
		mpbar = Gauge(Gauge::Type::DEFAULT, status.resolve("gauge/mp/layer:0"), hpmp_max, 0.0f);

		statset = Charset(EXPBar["number"], Charset::Alignment::RIGHT);
		hpmpset = Charset(status["gauge"]["number"], Charset::Alignment::RIGHT);
		levelset = Charset(status["lvNumber"], Charset::Alignment::LEFT);

		namelabel = OutlinedText(Text::Font::A13M, Text::Alignment::LEFT, Color::Name::GALLERY, Color::Name::TUNA);

		quickslot[0] = quickSlot["backgrnd"];
		quickslot[1] = quickSlot["layer:cover"];

		Point<int16_t> buttonPos = Point<int16_t>(591 + pos_adj, 73);

		if (VWIDTH == 1024)
			buttonPos += Point<int16_t>(38, 0);
		else if (VWIDTH == 1280)
			buttonPos += Point<int16_t>(31, 0);
		else if (VWIDTH == 1366)
			buttonPos += Point<int16_t>(33, 0);
		else if (VWIDTH == 1920)
			buttonPos += Point<int16_t>(310, 0);

		buttons[Buttons::BT_CASHSHOP] = std::make_unique<MapleButton>(menu["button:CashShop"], buttonPos);
		buttons[Buttons::BT_MENU] = std::make_unique<MapleButton>(menu["button:Menu"], buttonPos);
		buttons[Buttons::BT_OPTIONS] = std::make_unique<MapleButton>(menu["button:Setting"], buttonPos);
		buttons[Buttons::BT_CHARACTER] = std::make_unique<MapleButton>(menu["button:Character"], buttonPos);
		buttons[Buttons::BT_COMMUNITY] = std::make_unique<MapleButton>(menu["button:Community"], buttonPos);
		buttons[Buttons::BT_EVENT] = std::make_unique<MapleButton>(menu["button:Event"], buttonPos);

		if (quickslot_active && VWIDTH > 800)
		{
			buttons[Buttons::BT_CASHSHOP]->set_active(false);
			buttons[Buttons::BT_MENU]->set_active(false);
			buttons[Buttons::BT_OPTIONS]->set_active(false);
			buttons[Buttons::BT_CHARACTER]->set_active(false);
			buttons[Buttons::BT_COMMUNITY]->set_active(false);
			buttons[Buttons::BT_EVENT]->set_active(false);
		}

		std::string fold = "button:Fold";
		std::string extend = "button:Extend";

		if (VWIDTH == 800)
		{
			fold += "800";
			extend += "800";
		}

		if (VWIDTH == 1366)
			quickslot_qs_adj = Point<int16_t>(213, 0);
		else
			quickslot_qs_adj = Point<int16_t>(211, 0);

		if (VWIDTH == 800)
		{
			Point<int16_t> quickslot_qs = Point<int16_t>(579, 0);

			buttons[Buttons::BT_FOLD_QS] = std::make_unique<MapleButton>(quickSlot[fold], quickslot_qs);
			buttons[Buttons::BT_EXTEND_QS] = std::make_unique<MapleButton>(quickSlot[extend], quickslot_qs + quickslot_qs_adj);
		}
		else if (VWIDTH == 1024)
		{
			Point<int16_t> quickslot_qs = Point<int16_t>(627 + pos_adj, 37);

			buttons[Buttons::BT_FOLD_QS] = std::make_unique<MapleButton>(quickSlot[fold], quickslot_qs);
			buttons[Buttons::BT_EXTEND_QS] = std::make_unique<MapleButton>(quickSlot[extend], quickslot_qs + quickslot_qs_adj);
		}
		else if (VWIDTH == 1280)
		{
			Point<int16_t> quickslot_qs = Point<int16_t>(621 + pos_adj, 37);

			buttons[Buttons::BT_FOLD_QS] = std::make_unique<MapleButton>(quickSlot[fold], quickslot_qs);
			buttons[Buttons::BT_EXTEND_QS] = std::make_unique<MapleButton>(quickSlot[extend], quickslot_qs + quickslot_qs_adj);
		}
		else if (VWIDTH == 1366)
		{
			Point<int16_t> quickslot_qs = Point<int16_t>(623 + pos_adj, 37);

			buttons[Buttons::BT_FOLD_QS] = std::make_unique<MapleButton>(quickSlot[fold], quickslot_qs);
			buttons[Buttons::BT_EXTEND_QS] = std::make_unique<MapleButton>(quickSlot[extend], quickslot_qs + quickslot_qs_adj);
		}
		else if (VWIDTH == 1920)
		{
			Point<int16_t> quickslot_qs = Point<int16_t>(900 + pos_adj, 37);

			buttons[Buttons::BT_FOLD_QS] = std::make_unique<MapleButton>(quickSlot[fold], quickslot_qs);
			buttons[Buttons::BT_EXTEND_QS] = std::make_unique<MapleButton>(quickSlot[extend], quickslot_qs + quickslot_qs_adj);
		}

		if (quickslot_active)
			buttons[Buttons::BT_EXTEND_QS]->set_active(false);
		else
			buttons[Buttons::BT_FOLD_QS]->set_active(false);

#pragma region Menu
		menubackground[0] = submenu["backgrnd"]["0"];
		menubackground[1] = submenu["backgrnd"]["1"];
		menubackground[2] = submenu["backgrnd"]["2"];

		buttons[Buttons::BT_MENU_ACHIEVEMENT] = std::make_unique<MapleButton>(submenu["menu"]["button:achievement"], menu_pos);
		buttons[Buttons::BT_MENU_AUCTION] = std::make_unique<MapleButton>(submenu["menu"]["button:auction"], menu_pos);
		buttons[Buttons::BT_MENU_BATTLE] = std::make_unique<MapleButton>(submenu["menu"]["button:battleStats"], menu_pos);
		buttons[Buttons::BT_MENU_CLAIM] = std::make_unique<MapleButton>(submenu["menu"]["button:Claim"], menu_pos);
		buttons[Buttons::BT_MENU_FISHING] = std::make_unique<MapleButton>(submenu["menu"]["button:Fishing"], menu_pos + Point<int16_t>(3, 1));
		buttons[Buttons::BT_MENU_HELP] = std::make_unique<MapleButton>(submenu["menu"]["button:Help"], menu_pos);
		buttons[Buttons::BT_MENU_MEDAL] = std::make_unique<MapleButton>(submenu["menu"]["button:medal"], menu_pos);
		buttons[Buttons::BT_MENU_MONSTER_COLLECTION] = std::make_unique<MapleButton>(submenu["menu"]["button:monsterCollection"], menu_pos);
		buttons[Buttons::BT_MENU_MONSTER_LIFE] = std::make_unique<MapleButton>(submenu["menu"]["button:monsterLife"], menu_pos);
		buttons[Buttons::BT_MENU_QUEST] = std::make_unique<MapleButton>(submenu["menu"]["button:quest"], menu_pos);
		buttons[Buttons::BT_MENU_UNION] = std::make_unique<MapleButton>(submenu["menu"]["button:union"], menu_pos);

		buttons[Buttons::BT_SETTING_CHANNEL] = std::make_unique<MapleButton>(submenu["setting"]["button:channel"], setting_pos);
		buttons[Buttons::BT_SETTING_QUIT] = std::make_unique<MapleButton>(submenu["setting"]["button:GameQuit"], setting_pos);
		buttons[Buttons::BT_SETTING_JOYPAD] = std::make_unique<MapleButton>(submenu["setting"]["button:JoyPad"], setting_pos);
		buttons[Buttons::BT_SETTING_KEYS] = std::make_unique<MapleButton>(submenu["setting"]["button:keySetting"], setting_pos);
		buttons[Buttons::BT_SETTING_OPTION] = std::make_unique<MapleButton>(submenu["setting"]["button:option"], setting_pos);

		buttons[Buttons::BT_COMMUNITY_PARTY] = std::make_unique<MapleButton>(submenu["community"]["button:bossParty"], community_pos);
		buttons[Buttons::BT_COMMUNITY_FRIENDS] = std::make_unique<MapleButton>(submenu["community"]["button:friends"], community_pos);
		buttons[Buttons::BT_COMMUNITY_GUILD] = std::make_unique<MapleButton>(submenu["community"]["button:guild"], community_pos);
		buttons[Buttons::BT_COMMUNITY_MAPLECHAT] = std::make_unique<MapleButton>(submenu["community"]["button:mapleChat"], community_pos);

		buttons[Buttons::BT_CHARACTER_INFO] = std::make_unique<MapleButton>(submenu["character"]["button:character"], character_pos);
		buttons[Buttons::BT_CHARACTER_EQUIP] = std::make_unique<MapleButton>(submenu["character"]["button:Equip"], character_pos);
		buttons[Buttons::BT_CHARACTER_ITEM] = std::make_unique<MapleButton>(submenu["character"]["button:Item"], character_pos);
		buttons[Buttons::BT_CHARACTER_SKILL] = std::make_unique<MapleButton>(submenu["character"]["button:Skill"], character_pos);
		buttons[Buttons::BT_CHARACTER_STAT] = std::make_unique<MapleButton>(submenu["character"]["button:Stat"], character_pos);

		buttons[Buttons::BT_EVENT_DAILY] = std::make_unique<MapleButton>(submenu["event"]["button:dailyGift"], event_pos);
		buttons[Buttons::BT_EVENT_SCHEDULE] = std::make_unique<MapleButton>(submenu["event"]["button:schedule"], event_pos);

		for (size_t i = Buttons::BT_MENU_QUEST; i <= Buttons::BT_EVENT_DAILY; i++)
			buttons[i]->set_active(false);

		menutitle[0] = submenu["title"]["character"];
		menutitle[1] = submenu["title"]["community"];
		menutitle[2] = submenu["title"]["event"];
		menutitle[3] = submenu["title"]["menu"];
		menutitle[4] = submenu["title"]["setting"];
#pragma endregion

		if (VWIDTH == 800)
		{
			position = Point<int16_t>(0, 480);
			position_x = 410;
			position_y = position.y();
			dimension = Point<int16_t>(VWIDTH - position_x, 140);
		}
		else if (VWIDTH == 1024)
		{
			position = Point<int16_t>(0, 648);
			position_x = 410;
			position_y = position.y() + 42;
			dimension = Point<int16_t>(VWIDTH - position_x, 75);
		}
		else if (VWIDTH == 1280)
		{
			position = Point<int16_t>(0, 600);
			position_x = 500;
			position_y = position.y() + 42;
			dimension = Point<int16_t>(VWIDTH - position_x, 75);
		}
		else if (VWIDTH == 1366)
		{
			position = Point<int16_t>(0, 648);
			position_x = 585;
			position_y = position.y() + 42;
			dimension = Point<int16_t>(VWIDTH - position_x, 75);
		}
		else if (VWIDTH == 1920)
		{
			position = Point<int16_t>(0, 960 + (VHEIGHT - 1080));
			position_x = 860;
			position_y = position.y() + 40;
			dimension = Point<int16_t>(VWIDTH - position_x, 80);
		}
	}

	void UIStatusBar::draw(float alpha) const
	{
		UIElement::draw_sprites(alpha);

		for (size_t i = 0; i <= Buttons::BT_EVENT; i++)
			buttons.at(i)->draw(position);

		hpmp_sprites[0].draw(position, alpha);

		expbar.draw(position + exp_pos);
		hpbar.draw(position + hpmp_pos);
		mpbar.draw(position + hpmp_pos);

		hpmp_sprites[1].draw(position, alpha);
		hpmp_sprites[2].draw(position, alpha);

		int16_t level = stats.get_stat(MapleStat::Id::LEVEL);
		int16_t hp = stats.get_stat(MapleStat::Id::HP);
		int16_t mp = stats.get_stat(MapleStat::Id::MP);
		int32_t maxhp = stats.get_total(EquipStat::Id::HP);
		int32_t maxmp = stats.get_total(EquipStat::Id::MP);
		int64_t exp = stats.get_exp();

		std::string expstring = std::to_string(100 * getexppercent());

		statset.draw(
			std::to_string(exp) + "[" + expstring.substr(0, expstring.find('.') + 3) + "%]",
			position + statset_pos
		);

		hpmpset.draw(
			"[" + std::to_string(hp) + "/" + std::to_string(maxhp) + "]",
			position + hpset_pos
		);

		hpmpset.draw(
			"[" + std::to_string(mp) + "/" + std::to_string(maxmp) + "]",
			position + mpset_pos
		);

		levelset.draw(
			std::to_string(level),
			position + levelset_pos
		);

		namelabel.draw(position + namelabel_pos);

		buttons.at(Buttons::BT_FOLD_QS)->draw(position + quickslot_adj);
		buttons.at(Buttons::BT_EXTEND_QS)->draw(position + quickslot_adj - quickslot_qs_adj);

		if (VWIDTH > 800 && VWIDTH < 1366)
		{
			quickslot[0].draw(position + quickslot_pos + Point<int16_t>(-1, 0) + quickslot_adj);
			quickslot[1].draw(position + quickslot_pos + Point<int16_t>(-1, 0) + quickslot_adj);
		}
		else
		{
			quickslot[0].draw(position + quickslot_pos + quickslot_adj);
			quickslot[1].draw(position + quickslot_pos + quickslot_adj);
		}

#pragma region Menu
		Point<int16_t> pos_adj = Point<int16_t>(0, 0);

		if (quickslot_active)
		{
			if (VWIDTH == 800)
				pos_adj += Point<int16_t>(0, -73);
			else
				pos_adj += Point<int16_t>(0, -31);
		}

		Point<int16_t> pos;
		uint8_t button_count, menutitle_index;

		if (character_active)
		{
			pos = character_pos;
			button_count = 5;
			menutitle_index = 0;
		}
		else if (community_active)
		{
			pos = community_pos;
			button_count = 4;
			menutitle_index = 1;
		}
		else if (event_active)
		{
			pos = event_pos;
			button_count = 2;
			menutitle_index = 2;
		}
		else if (menu_active)
		{
			pos = menu_pos;
			button_count = 11;
			menutitle_index = 3;
		}
		else if (setting_active)
		{
			pos = setting_pos;
			button_count = 5;
			menutitle_index = 4;
		}
		else
		{
			return;
		}

		Point<int16_t> mid_pos = Point<int16_t>(0, 29);

		uint16_t end_y = std::floor(28.2 * button_count);

		if (menu_active)
			end_y -= 1;

		uint16_t mid_y = end_y - mid_pos.y();

		menubackground[0].draw(position + pos + pos_adj);
		menubackground[1].draw(DrawArgument(position + pos + pos_adj) + DrawArgument(mid_pos, Point<int16_t>(0, mid_y)));
		menubackground[2].draw(position + pos + pos_adj + Point<int16_t>(0, end_y));

		menutitle[menutitle_index].draw(position + pos + pos_adj);

		for (size_t i = Buttons::BT_MENU_QUEST; i <= Buttons::BT_EVENT_DAILY; i++)
			buttons.at(i)->draw(position);
#pragma endregion
	}

	void UIStatusBar::update()
	{
		UIElement::update();

		for (Sprite sprite : hpmp_sprites)
			sprite.update();

		expbar.update(getexppercent());
		hpbar.update(gethppercent());
		mpbar.update(getmppercent());

		namelabel.change_text(stats.get_name());

		Point<int16_t> pos_adj = get_quickslot_pos();

		if (quickslot_active)
		{
			if (quickslot_adj.x() > quickslot_min)
			{
				int16_t new_x = quickslot_adj.x() - Constants::TIMESTEP;

				if (new_x < quickslot_min)
					quickslot_adj.set_x(quickslot_min);
				else
					quickslot_adj.shift_x(-Constants::TIMESTEP);
			}
		}
		else
		{
			if (quickslot_adj.x() < QUICKSLOT_MAX)
			{
				int16_t new_x = quickslot_adj.x() + Constants::TIMESTEP;

				if (new_x > QUICKSLOT_MAX)
					quickslot_adj.set_x(QUICKSLOT_MAX);
				else
					quickslot_adj.shift_x(Constants::TIMESTEP);
			}
		}

		for (size_t i = Buttons::BT_MENU_QUEST; i <= Buttons::BT_MENU_CLAIM; i++)
		{
			Point<int16_t> menu_adj = Point<int16_t>(0, 0);

			if (i == Buttons::BT_MENU_FISHING)
				menu_adj = Point<int16_t>(3, 1);

			buttons[i]->set_position(menu_pos + menu_adj + pos_adj);
		}

		for (size_t i = Buttons::BT_SETTING_CHANNEL; i <= Buttons::BT_SETTING_QUIT; i++)
			buttons[i]->set_position(setting_pos + pos_adj);

		for (size_t i = Buttons::BT_COMMUNITY_FRIENDS; i <= Buttons::BT_COMMUNITY_MAPLECHAT; i++)
			buttons[i]->set_position(community_pos + pos_adj);

		for (size_t i = Buttons::BT_CHARACTER_INFO; i <= Buttons::BT_CHARACTER_ITEM; i++)
			buttons[i]->set_position(character_pos + pos_adj);

		for (size_t i = Buttons::BT_EVENT_SCHEDULE; i <= Buttons::BT_EVENT_DAILY; i++)
			buttons[i]->set_position(event_pos + pos_adj);
	}

	Button::State UIStatusBar::button_pressed(uint16_t id)
	{
		switch (id)
		{
			case Buttons::BT_CASHSHOP:
			{
				EnterCashShopPacket().dispatch();
				break;
			}
			case Buttons::BT_MENU:
			{
				toggle_menu();
				break;
			}
			case Buttons::BT_OPTIONS:
			{
				toggle_setting();
				break;
			}
			case Buttons::BT_CHARACTER:
			{
				toggle_character();
				break;
			}
			case Buttons::BT_COMMUNITY:
			{
				toggle_community();
				break;
			}
			case Buttons::BT_EVENT:
			{
				toggle_event();
				break;
			}
			case Buttons::BT_FOLD_QS:
			{
				toggle_qs(false);
				break;
			}
			case Buttons::BT_EXTEND_QS:
			{
				toggle_qs(true);
				break;
			}
			case Buttons::BT_MENU_QUEST:
			{
				UI::get().emplace<UIQuestLog>(
					Stage::get().get_player().get_quests()
					);

				remove_menus();
				break;
			}
			case Buttons::BT_MENU_MEDAL:
			case Buttons::BT_MENU_UNION:
			case Buttons::BT_MENU_MONSTER_COLLECTION:
			case Buttons::BT_MENU_AUCTION:
			case Buttons::BT_MENU_MONSTER_LIFE:
			case Buttons::BT_MENU_BATTLE:
			case Buttons::BT_MENU_ACHIEVEMENT:
			case Buttons::BT_MENU_FISHING:
			case Buttons::BT_MENU_HELP:
			case Buttons::BT_MENU_CLAIM:
			{
				remove_menus();
				break;
			}
			case Buttons::BT_SETTING_CHANNEL:
			{
				UI::get().emplace<UIChannel>();

				remove_menus();
				break;
			}
			case Buttons::BT_SETTING_OPTION:
			{
				UI::get().emplace<UIOptionMenu>();

				remove_menus();
				break;
			}
			case Buttons::BT_SETTING_KEYS:
			{
				UI::get().emplace<UIKeyConfig>(
					Stage::get().get_player().get_inventory(),
					Stage::get().get_player().get_skills()
					);

				remove_menus();
				break;
			}
			case Buttons::BT_SETTING_JOYPAD:
			{
				UI::get().emplace<UIJoypad>();

				remove_menus();
				break;
			}
			case Buttons::BT_SETTING_QUIT:
			{
				UI::get().emplace<UIQuit>(stats);

				remove_menus();
				break;
			}
			case Buttons::BT_COMMUNITY_FRIENDS:
			case Buttons::BT_COMMUNITY_PARTY:
			{
				auto userlist = UI::get().get_element<UIUserList>();
				auto tab = (id == Buttons::BT_COMMUNITY_FRIENDS) ? UIUserList::Tab::FRIEND : UIUserList::Tab::PARTY;

				if (!userlist)
				{
					UI::get().emplace<UIUserList>(tab);
				}
				else
				{
					auto cur_tab = userlist->get_tab();
					auto is_active = userlist->is_active();

					if (cur_tab == tab)
					{
						if (is_active)
							userlist->deactivate();
						else
							userlist->makeactive();
					}
					else
					{
						if (!is_active)
							userlist->makeactive();

						userlist->change_tab(tab);
					}
				}

				remove_menus();
				break;
			}
			case Buttons::BT_COMMUNITY_GUILD:
			{
				remove_menus();
				break;
			}
			case Buttons::BT_COMMUNITY_MAPLECHAT:
			{
				UI::get().emplace<UIChat>();

				remove_menus();
				break;
			}
			case Buttons::BT_CHARACTER_INFO:
			{
				UI::get().emplace<UICharInfo>(
					Stage::get().get_player().get_oid()
					);

				remove_menus();
				break;
			}
			case Buttons::BT_CHARACTER_STAT:
			{
				UI::get().emplace<UIStatsInfo>(
					Stage::get().get_player().get_stats()
					);

				remove_menus();
				break;
			}
			case Buttons::BT_CHARACTER_SKILL:
			{
				UI::get().emplace<UISkillBook>(
					Stage::get().get_player().get_stats(),
					Stage::get().get_player().get_skills()
					);

				remove_menus();
				break;
			}
			case Buttons::BT_CHARACTER_EQUIP:
			{
				UI::get().emplace<UIEquipInventory>(
					Stage::get().get_player().get_inventory()
					);

				remove_menus();
				break;
			}
			case Buttons::BT_CHARACTER_ITEM:
			{
				UI::get().emplace<UIItemInventory>(
					Stage::get().get_player().get_inventory()
					);

				remove_menus();
				break;
			}
			case Buttons::BT_EVENT_SCHEDULE:
			{
				UI::get().emplace<UIEvent>();

				remove_menus();
				break;
			}
			case Buttons::BT_EVENT_DAILY:
			{
				remove_menus();
				break;
			}
		}

		return Button::State::NORMAL;
	}

	void UIStatusBar::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
			{
				if (!menu_active && !setting_active && !community_active && !character_active && !event_active)
					toggle_setting();
				else
					remove_menus();
			}
			else if (keycode == KeyAction::Id::RETURN)
			{
				for (size_t i = Buttons::BT_MENU_QUEST; i <= Buttons::BT_EVENT_DAILY; i++)
					if (buttons[i]->get_state() == Button::State::MOUSEOVER)
						button_pressed(i);
			}
			else if (keycode == KeyAction::Id::UP || keycode == KeyAction::Id::DOWN)
			{
				uint16_t min_id, max_id;

				if (menu_active)
				{
					min_id = Buttons::BT_MENU_QUEST;
					max_id = Buttons::BT_MENU_CLAIM;
				}
				else if (setting_active)
				{
					min_id = Buttons::BT_SETTING_CHANNEL;
					max_id = Buttons::BT_SETTING_QUIT;
				}
				else if (community_active)
				{
					min_id = Buttons::BT_COMMUNITY_FRIENDS;
					max_id = Buttons::BT_COMMUNITY_MAPLECHAT;
				}
				else if (character_active)
				{
					min_id = Buttons::BT_CHARACTER_INFO;
					max_id = Buttons::BT_CHARACTER_ITEM;
				}
				else if (event_active)
				{
					min_id = Buttons::BT_EVENT_SCHEDULE;
					max_id = Buttons::BT_EVENT_DAILY;
				}

				uint16_t id = min_id;

				for (size_t i = min_id; i <= max_id; i++)
				{
					if (buttons[i]->get_state() != Button::State::NORMAL)
					{
						id = i;

						buttons[i]->set_state(Button::State::NORMAL);
						break;
					}
				}

				if (keycode == KeyAction::Id::DOWN)
				{
					if (id < max_id)
						id++;
					else
						id = min_id;
				}
				else if (keycode == KeyAction::Id::UP)
				{
					if (id > min_id)
						id--;
					else
						id = max_id;
				}

				buttons[id]->set_state(Button::State::MOUSEOVER);
			}
		}
	}

	bool UIStatusBar::is_in_range(Point<int16_t> cursor_position) const
	{
		Point<int16_t> pos;
		Rectangle<int16_t> bounds;

		if (!character_active && !community_active && !event_active && !menu_active && !setting_active)
		{
			pos = Point<int16_t>(position_x, position_y);
			bounds = Rectangle<int16_t>(pos, pos + dimension);
		}
		else
		{
			uint8_t button_count;
			int16_t pos_y_adj;

			if (character_active)
			{
				pos = character_pos;
				button_count = 5;
				pos_y_adj = 248;
			}
			else if (community_active)
			{
				pos = community_pos;
				button_count = 4;
				pos_y_adj = 301;
			}
			else if (event_active)
			{
				pos = event_pos;
				button_count = 2;
				pos_y_adj = 417;
			}
			else if (menu_active)
			{
				pos = menu_pos;
				button_count = 11;
				pos_y_adj = -90;
			}
			else if (setting_active)
			{
				pos = setting_pos;
				button_count = 5;
				pos_y_adj = 248;
			}

			pos_y_adj += VHEIGHT - 600;

			Point<int16_t> pos_adj = get_quickslot_pos();
			pos = Point<int16_t>(pos.x(), std::abs(pos.y()) + pos_y_adj) + pos_adj;

			uint16_t end_y = std::floor(28.2 * button_count);

			bounds = Rectangle<int16_t>(pos, pos + Point<int16_t>(113, end_y + 35));
		}

		return bounds.contains(cursor_position);
	}

	UIElement::Type UIStatusBar::get_type() const
	{
		return TYPE;
	}

	void UIStatusBar::toggle_qs()
	{
		if (!menu_active && !setting_active && !community_active && !character_active && !event_active)
			toggle_qs(!quickslot_active);
	}

	void UIStatusBar::toggle_qs(bool quick_slot_active)
	{
		if (quickslot_active == quick_slot_active)
			return;

		quickslot_active = quick_slot_active;
		buttons[Buttons::BT_FOLD_QS]->set_active(quickslot_active);
		buttons[Buttons::BT_EXTEND_QS]->set_active(!quickslot_active);

		if (VWIDTH > 800)
		{
			buttons[Buttons::BT_CASHSHOP]->set_active(!quickslot_active);
			buttons[Buttons::BT_MENU]->set_active(!quickslot_active);
			buttons[Buttons::BT_OPTIONS]->set_active(!quickslot_active);
			buttons[Buttons::BT_CHARACTER]->set_active(!quickslot_active);
			buttons[Buttons::BT_COMMUNITY]->set_active(!quickslot_active);
			buttons[Buttons::BT_EVENT]->set_active(!quickslot_active);
		}
	}

	void UIStatusBar::toggle_menu()
	{
		remove_active_menu(MenuType::MENU);

		menu_active = !menu_active;

		buttons[Buttons::BT_MENU_ACHIEVEMENT]->set_active(menu_active);
		buttons[Buttons::BT_MENU_AUCTION]->set_active(menu_active);
		buttons[Buttons::BT_MENU_BATTLE]->set_active(menu_active);
		buttons[Buttons::BT_MENU_CLAIM]->set_active(menu_active);
		buttons[Buttons::BT_MENU_FISHING]->set_active(menu_active);
		buttons[Buttons::BT_MENU_HELP]->set_active(menu_active);
		buttons[Buttons::BT_MENU_MEDAL]->set_active(menu_active);
		buttons[Buttons::BT_MENU_MONSTER_COLLECTION]->set_active(menu_active);
		buttons[Buttons::BT_MENU_MONSTER_LIFE]->set_active(menu_active);
		buttons[Buttons::BT_MENU_QUEST]->set_active(menu_active);
		buttons[Buttons::BT_MENU_UNION]->set_active(menu_active);

		if (menu_active)
		{
			buttons[Buttons::BT_MENU_QUEST]->set_state(Button::State::MOUSEOVER);

			Sound(Sound::Name::DLGNOTICE).play();
		}
	}

	void UIStatusBar::toggle_setting()
	{
		remove_active_menu(MenuType::SETTING);

		setting_active = !setting_active;

		buttons[Buttons::BT_SETTING_CHANNEL]->set_active(setting_active);
		buttons[Buttons::BT_SETTING_QUIT]->set_active(setting_active);
		buttons[Buttons::BT_SETTING_JOYPAD]->set_active(setting_active);
		buttons[Buttons::BT_SETTING_KEYS]->set_active(setting_active);
		buttons[Buttons::BT_SETTING_OPTION]->set_active(setting_active);

		if (setting_active)
		{
			buttons[Buttons::BT_SETTING_CHANNEL]->set_state(Button::State::MOUSEOVER);

			Sound(Sound::Name::DLGNOTICE).play();
		}
	}

	void UIStatusBar::toggle_community()
	{
		remove_active_menu(MenuType::COMMUNITY);

		community_active = !community_active;

		buttons[Buttons::BT_COMMUNITY_PARTY]->set_active(community_active);
		buttons[Buttons::BT_COMMUNITY_FRIENDS]->set_active(community_active);
		buttons[Buttons::BT_COMMUNITY_GUILD]->set_active(community_active);
		buttons[Buttons::BT_COMMUNITY_MAPLECHAT]->set_active(community_active);

		if (community_active)
		{
			buttons[Buttons::BT_COMMUNITY_FRIENDS]->set_state(Button::State::MOUSEOVER);

			Sound(Sound::Name::DLGNOTICE).play();
		}
	}

	void UIStatusBar::toggle_character()
	{
		remove_active_menu(MenuType::CHARACTER);

		character_active = !character_active;

		buttons[Buttons::BT_CHARACTER_INFO]->set_active(character_active);
		buttons[Buttons::BT_CHARACTER_EQUIP]->set_active(character_active);
		buttons[Buttons::BT_CHARACTER_ITEM]->set_active(character_active);
		buttons[Buttons::BT_CHARACTER_SKILL]->set_active(character_active);
		buttons[Buttons::BT_CHARACTER_STAT]->set_active(character_active);

		if (character_active)
		{
			buttons[Buttons::BT_CHARACTER_INFO]->set_state(Button::State::MOUSEOVER);

			Sound(Sound::Name::DLGNOTICE).play();
		}
	}

	void UIStatusBar::toggle_event()
	{
		remove_active_menu(MenuType::EVENT);

		event_active = !event_active;

		buttons[Buttons::BT_EVENT_DAILY]->set_active(event_active);
		buttons[Buttons::BT_EVENT_SCHEDULE]->set_active(event_active);

		if (event_active)
		{
			buttons[Buttons::BT_EVENT_SCHEDULE]->set_state(Button::State::MOUSEOVER);

			Sound(Sound::Name::DLGNOTICE).play();
		}
	}

	void UIStatusBar::remove_menus()
	{
		if (menu_active)
			toggle_menu();
		else if (setting_active)
			toggle_setting();
		else if (community_active)
			toggle_community();
		else if (character_active)
			toggle_character();
		else if (event_active)
			toggle_event();
	}

	void UIStatusBar::remove_active_menu(MenuType type)
	{
		for (size_t i = Buttons::BT_MENU_QUEST; i <= Buttons::BT_EVENT_DAILY; i++)
			buttons[i]->set_state(Button::State::NORMAL);

		if (menu_active && type != MenuType::MENU)
			toggle_menu();
		else if (setting_active && type != MenuType::SETTING)
			toggle_setting();
		else if (community_active && type != MenuType::COMMUNITY)
			toggle_community();
		else if (character_active && type != MenuType::CHARACTER)
			toggle_character();
		else if (event_active && type != MenuType::EVENT)
			toggle_event();
	}

	Point<int16_t> UIStatusBar::get_quickslot_pos() const
	{
		if (quickslot_active)
		{
			if (VWIDTH == 800)
				return Point<int16_t>(0, -73);
			else
				return Point<int16_t>(0, -31);
		}

		return Point<int16_t>(0, 0);
	}

	bool UIStatusBar::is_menu_active()
	{
		return menu_active || setting_active || community_active || character_active || event_active;
	}

	float UIStatusBar::getexppercent() const
	{
		int16_t level = stats.get_stat(MapleStat::Id::LEVEL);

		if (level >= ExpTable::LEVELCAP)
			return 0.0f;

		int64_t exp = stats.get_exp();

		return static_cast<float>(
			static_cast<double>(exp) / ExpTable::values[level]
			);
	}

	float UIStatusBar::gethppercent() const
	{
		int16_t hp = stats.get_stat(MapleStat::Id::HP);
		int32_t maxhp = stats.get_total(EquipStat::Id::HP);

		return static_cast<float>(hp) / maxhp;
	}

	float UIStatusBar::getmppercent() const
	{
		int16_t mp = stats.get_stat(MapleStat::Id::MP);
		int32_t maxmp = stats.get_total(EquipStat::Id::MP);

		return static_cast<float>(mp) / maxmp;
	}
}

================
File: IO/UITypes/UIStatusBar.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../Components/Charset.h"
#include "../Components/Gauge.h"

#include "../../Character/CharStats.h"
#include "../../Graphics/SpecialText.h"

namespace ms
{
	class UIStatusBar : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::STATUSBAR;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		enum MenuType
		{
			MENU,
			SETTING,
			COMMUNITY,
			CHARACTER,
			EVENT
		};

		UIStatusBar(const CharStats& stats);

		void draw(float alpha) const override;
		void update() override;

		bool is_in_range(Point<int16_t> cursor_position) const override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		void toggle_qs();
		void toggle_menu();
		void remove_menus();
		bool is_menu_active();

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		static constexpr int16_t QUICKSLOT_MAX = 211;

		float getexppercent() const;
		float gethppercent() const;
		float getmppercent() const;

		void toggle_qs(bool quick_slot_active);
		void toggle_setting();
		void toggle_community();
		void toggle_character();
		void toggle_event();
		void remove_active_menu(MenuType type);

		Point<int16_t> get_quickslot_pos() const;

		enum Buttons : uint16_t
		{
			BT_CASHSHOP,
			BT_MENU,
			BT_OPTIONS,
			BT_CHARACTER,
			BT_COMMUNITY,
			BT_EVENT,
			BT_FOLD_QS,
			BT_EXTEND_QS,
			BT_MENU_QUEST,
			BT_MENU_MEDAL,
			BT_MENU_UNION,
			BT_MENU_MONSTER_COLLECTION,
			BT_MENU_AUCTION,
			BT_MENU_MONSTER_LIFE,
			BT_MENU_BATTLE,
			BT_MENU_ACHIEVEMENT,
			BT_MENU_FISHING,
			BT_MENU_HELP,
			BT_MENU_CLAIM,
			BT_SETTING_CHANNEL,
			BT_SETTING_OPTION,
			BT_SETTING_KEYS,
			BT_SETTING_JOYPAD,
			BT_SETTING_QUIT,
			BT_COMMUNITY_FRIENDS,
			BT_COMMUNITY_PARTY,
			BT_COMMUNITY_GUILD,
			BT_COMMUNITY_MAPLECHAT,
			BT_CHARACTER_INFO,
			BT_CHARACTER_STAT,
			BT_CHARACTER_SKILL,
			BT_CHARACTER_EQUIP,
			BT_CHARACTER_ITEM,
			BT_EVENT_SCHEDULE,
			BT_EVENT_DAILY
		};

		const CharStats& stats;

		Gauge expbar;
		Gauge hpbar;
		Gauge mpbar;
		Charset statset;
		Charset hpmpset;
		Charset levelset;
		Texture quickslot[2];
		Texture menutitle[5];
		Texture menubackground[3];
		OutlinedText namelabel;
		std::vector<Sprite> hpmp_sprites;

		Point<int16_t> exp_pos;
		Point<int16_t> hpmp_pos;
		Point<int16_t> hpset_pos;
		Point<int16_t> mpset_pos;
		Point<int16_t> statset_pos;
		Point<int16_t> levelset_pos;
		Point<int16_t> namelabel_pos;
		Point<int16_t> quickslot_pos;
		Point<int16_t> quickslot_adj;
		Point<int16_t> quickslot_qs_adj;
		Point<int16_t> menu_pos;
		Point<int16_t> setting_pos;
		Point<int16_t> community_pos;
		Point<int16_t> character_pos;
		Point<int16_t> event_pos;
		int16_t quickslot_min;
		int16_t position_x;
		int16_t position_y;

		bool quickslot_active;
		int16_t VWIDTH;
		int16_t VHEIGHT;

		bool menu_active;
		bool setting_active;
		bool community_active;
		bool character_active;
		bool event_active;
	};
}

================
File: IO/UITypes/UIStatusMessenger.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIStatusMessenger.h"

#include "../../Constants.h"

namespace ms
{
	StatusInfo::StatusInfo(const std::string& str, Color::Name color)
	{
		text = Text(Text::Font::A12M, Text::Alignment::RIGHT, color, str);
		shadow = Text(Text::Font::A12M, Text::Alignment::RIGHT, Color::Name::BLACK, str);

		opacity.set(1.0f);
	}

	void StatusInfo::draw(Point<int16_t> position, float alpha) const
	{
		float interopc = opacity.get(alpha);

		shadow.draw(DrawArgument(position + Point<int16_t>(1, 1), interopc));
		text.draw(DrawArgument(position, interopc));
	}

	bool StatusInfo::update()
	{
		constexpr float FADE_STEP = Constants::TIMESTEP * 1.0f / FADE_DURATION;
		opacity -= FADE_STEP;

		return opacity.last() < FADE_STEP;
	}

	UIStatusMessenger::UIStatusMessenger()
	{
		int16_t height = Constants::Constants::get().get_viewheight();
		int16_t width = Constants::Constants::get().get_viewwidth();

		update_screen(width, height);
	}

	void UIStatusMessenger::draw(float inter) const
	{
		Point<int16_t> infopos = Point<int16_t>(position.x(), position.y());

		for (const StatusInfo& info : statusinfos)
		{
			info.draw(infopos, inter);
			infopos.shift_y(-14);
		}
	}

	void UIStatusMessenger::update()
	{
		for (StatusInfo& info : statusinfos)
			info.update();
	}

	void UIStatusMessenger::update_screen(int16_t new_width, int16_t new_height)
	{
		int16_t y_adj = (new_width > 800) ? 37 : 0;

		position = Point<int16_t>(new_width - 6, new_height - 145 + y_adj);
	}

	UIElement::Type UIStatusMessenger::get_type() const
	{
		return TYPE;
	}

	void UIStatusMessenger::show_status(Color::Name color, const std::string& message)
	{
		statusinfos.push_front(StatusInfo(message, color));

		if (statusinfos.size() > MAX_MESSAGES)
			statusinfos.pop_back();
	}
}

================
File: IO/UITypes/UIStatusMessenger.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../../Graphics/Text.h"

#include <deque>

namespace ms
{
	class StatusInfo
	{
	public:
		StatusInfo(const std::string& str, Color::Name color);

		void draw(Point<int16_t> position, float alpha) const;
		bool update();

	private:
		Text text;
		Text shadow;
		Linear<float> opacity;

		// 8 seconds
		static constexpr int64_t FADE_DURATION = 8'000;
	};


	class UIStatusMessenger : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::STATUSMESSENGER;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = false;

		UIStatusMessenger();

		void draw(float alpha) const override;
		void update() override;
		void update_screen(int16_t new_width, int16_t new_height) override;

		UIElement::Type get_type() const override;

		void show_status(Color::Name color, const std::string& message);

	private:
		static constexpr size_t MAX_MESSAGES = 6;

		std::deque<StatusInfo> statusinfos;
	};
}

================
File: IO/UITypes/UITermsOfService.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UITermsOfService.h"

#include "UILoginWait.h"

#include "../UI.h"

#include "../Components/MapleButton.h"

#include "../../Net/Packets/LoginPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UITermsOfService::UITermsOfService(std::function<void()> oh) : okhandler(oh), offset(0), unit_rows(1)
	{
		nl::node Login = nl::nx::UI["Login.img"];
		nl::node TOS = Login["TOS"];

		sprites.emplace_back(TOS, Point<int16_t>(399, 250));

		buttons[Buttons::OK] = std::make_unique<MapleButton>(Login["BtOk"], Point<int16_t>(483, 425));
		buttons[Buttons::CANCEL] = std::make_unique<MapleButton>(Login["BtCancel"], Point<int16_t>(557, 425));

		EULA = nl::nx::String["TrialEULA.img"]["EULA"];
		max_rows = EULA.size();
		
		text = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::BLACK, "", 340, true, 2);

		int16_t slider_y = 77;

		slider = Slider(
			Slider::Type::LINE_PUNGA, Range<int16_t>(slider_y, slider_y + 305), 574, unit_rows, max_rows,
			[&](bool upwards)
			{
				int16_t shift = upwards ? -1 : 1;
				bool above = offset + shift >= 0;
				bool below = offset + shift <= max_rows - unit_rows;

				if (above && below)
				{
					offset += shift;
					update_accept(offset);
				}
			}
		);

		update_accept(offset);

		position = Point<int16_t>(0, 10);
		dimension = Texture(TOS).get_dimensions();
	}

	void UITermsOfService::draw(float inter) const
	{
		UIElement::draw(inter);

		int16_t range_min = 80;
		text.draw(position + Point<int16_t>(226, 84), Range<int16_t>(range_min, range_min + 316));
		slider.draw(position);
	}

	Cursor::State UITermsOfService::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		Point<int16_t> cursoroffset = cursorpos - position;

		if (slider.isenabled())
		{
			Cursor::State state = slider.send_cursor(cursoroffset, clicked);

			if (state != Cursor::State::IDLE)
				return state;
		}

		return UIElement::send_cursor(clicked, cursorpos);
	}

	UIElement::Type UITermsOfService::get_type() const
	{
		return TYPE;
	}

	Button::State UITermsOfService::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			case Buttons::OK:
				UI::get().emplace<UILoginWait>();

				TOSPacket().dispatch();
				break;
			case Buttons::CANCEL:
				UI::get().quit();
				break;
			default:
				break;
		}

		return Button::State::NORMAL;
	}

	void UITermsOfService::update_accept(uint16_t offset)
	{
		if (offset == max_rows - unit_rows)
			buttons[Buttons::OK]->set_state(Button::State::NORMAL);
		else
			buttons[Buttons::OK]->set_state(Button::State::DISABLED);

		std::string shownText = "";

		for (nl::node text : EULA)
		{
			std::string name = text.name();
			name = name.substr(4, 6);

			int32_t i = std::stoi(name);

			if (i >= offset && i <= offset + 5)
				shownText += text;
		}

		text.change_text(shownText);
	}
}

================
File: IO/UITypes/UITermsOfService.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../Components/Slider.h"

#include "../../Graphics/Text.h"

namespace ms
{
	class UITermsOfService : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::TOS;
		static constexpr bool FOCUSED = true;
		static constexpr bool TOGGLED = false;

		UITermsOfService(std::function<void()> okhandler);

		void draw(float inter) const override;

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void update_accept(uint16_t offset);

		enum Buttons : uint16_t
		{
			OK,
			CANCEL
		};

		Text text;
		Slider slider;
		std::function<void()> okhandler;
		uint16_t offset;
		int16_t unit_rows;
		int16_t max_rows;
		nl::node EULA;
	};
}

================
File: IO/UITypes/UIUserList.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIUserList.h"

#include "../../IO/Components/MapleButton.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIUserList::UIUserList(uint16_t t) : UIDragElement<PosUSERLIST>(Point<int16_t>(260, 20)), tab(t)
	{
		nl::node close = nl::nx::UI["Basic.img"]["BtClose3"];
		UserList = nl::nx::UI["UIWindow2.img"]["UserList"];
		nl::node Main = UserList["Main"];

		sprites.emplace_back(Main["backgrnd"]);

		buttons[Buttons::BT_CLOSE] = std::make_unique<MapleButton>(close, Point<int16_t>(244, 7));

		nl::node taben = Main["Tab"]["enabled"];
		nl::node tabdis = Main["Tab"]["disabled"];

		buttons[Buttons::BT_TAB_FRIEND] = std::make_unique<TwoSpriteButton>(tabdis["0"], taben["0"]);
		buttons[Buttons::BT_TAB_PARTY] = std::make_unique<TwoSpriteButton>(tabdis["1"], taben["1"]);
		buttons[Buttons::BT_TAB_BOSS] = std::make_unique<TwoSpriteButton>(tabdis["2"], taben["2"]);
		buttons[Buttons::BT_TAB_BLACKLIST] = std::make_unique<TwoSpriteButton>(tabdis["3"], taben["3"]);

		// Party Tab
		nl::node Party = Main["Party"];
		nl::node PartySearch = Party["PartySearch"];

		party_tab = Tab::PARTY_MINE;
		party_title = Party["title"];

		for (size_t i = 0; i <= 4; i++)
			party_mine_grid[i] = UserList["Sheet2"][i];

		party_mine_name = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::BLACK, "none", 0);

		nl::node party_taben = Party["Tab"]["enabled"];
		nl::node party_tabdis = Party["Tab"]["disabled"];

		buttons[Buttons::BT_PARTY_CREATE] = std::make_unique<MapleButton>(Party["BtPartyMake"]);
		buttons[Buttons::BT_PARTY_INVITE] = std::make_unique<MapleButton>(Party["BtPartyInvite"]);
		buttons[Buttons::BT_PARTY_LEAVE] = std::make_unique<MapleButton>(Party["BtPartyOut"]);
		buttons[Buttons::BT_PARTY_SETTINGS] = std::make_unique<MapleButton>(Party["BtPartySettings"]);
		buttons[Buttons::BT_PARTY_CREATE]->set_active(false);
		buttons[Buttons::BT_PARTY_INVITE]->set_active(false);
		buttons[Buttons::BT_PARTY_LEAVE]->set_active(false);
		buttons[Buttons::BT_PARTY_SETTINGS]->set_active(false);

		buttons[Buttons::BT_TAB_PARTY_MINE] = std::make_unique<TwoSpriteButton>(party_tabdis["0"], party_taben["0"]);
		buttons[Buttons::BT_TAB_PARTY_SEARCH] = std::make_unique<TwoSpriteButton>(party_tabdis["1"], party_taben["1"]);
		buttons[Buttons::BT_TAB_PARTY_MINE]->set_active(false);
		buttons[Buttons::BT_TAB_PARTY_SEARCH]->set_active(false);

		party_search_grid[0] = PartySearch["partyName"];
		party_search_grid[1] = PartySearch["request"];
		party_search_grid[2] = PartySearch["table"];

		buttons[Buttons::BT_PARTY_SEARCH_LEVEL] = std::make_unique<MapleButton>(PartySearch["BtPartyLevel"]);
		buttons[Buttons::BT_PARTY_SEARCH_LEVEL]->set_active(false);

		int16_t party_x = 243;
		int16_t party_y = 114;
		int16_t party_height = party_y + 168;
		int16_t party_unitrows = 6;
		int16_t party_rowmax = 6;
		party_slider = Slider(Slider::Type::DEFAULT_SILVER, Range<int16_t>(party_y, party_height), party_x, party_unitrows, party_rowmax, [](bool) {});

		// Buddy Tab
		nl::node Friend = Main["Friend"];

		friend_tab = Tab::FRIEND_ALL;
		friend_sprites.emplace_back(Friend["title"]);
		friend_sprites.emplace_back(Friend["CbCondition"]["text"]);
		friend_sprites.emplace_back(UserList["line"], DrawArgument(Point<int16_t>(132, 115), Point<int16_t>(230, 0)));

		buttons[Buttons::BT_FRIEND_GROUP_0] = std::make_unique<MapleButton>(UserList["BtSheetIClose"], Point<int16_t>(13, 118));
		buttons[Buttons::BT_FRIEND_GROUP_0]->set_active(false);

		for (size_t i = 0; i <= 3; i++)
			friend_grid[i] = UserList["Sheet1"][i];

		std::string text = "(" + std::to_string(friend_count) + std::string("/") + std::to_string(friend_total) + std::string(")");
		friends_online_text = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, text, 0);

		friends_cur_location = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::LIGHTGREY, "My Location - " + get_cur_location(), 0);
		friends_name = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::BLACK, "none", 0);
		friends_group_name = Text(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::WHITE, "Default Group (0/0)", 0);

		buttons[Buttons::BT_FRIEND_ADD] = std::make_unique<MapleButton>(Friend["BtAddFriend"]);
		buttons[Buttons::BT_FRIEND_ADD_GROUP] = std::make_unique<MapleButton>(Friend["BtAddGroup"]);
		buttons[Buttons::BT_FRIEND_EXPAND] = std::make_unique<MapleButton>(Friend["BtPlusFriend"]);
		buttons[Buttons::BT_FRIEND_ADD]->set_active(false);
		buttons[Buttons::BT_FRIEND_ADD_GROUP]->set_active(false);
		buttons[Buttons::BT_FRIEND_EXPAND]->set_active(false);

		buttons[Buttons::BT_TAB_FRIEND_ALL] = std::make_unique<MapleButton>(Friend["TapShowAll"]);
		buttons[Buttons::BT_TAB_FRIEND_ONLINE] = std::make_unique<MapleButton>(Friend["TapShowOnline"]);
		buttons[Buttons::BT_TAB_FRIEND_ALL]->set_active(false);
		buttons[Buttons::BT_TAB_FRIEND_ONLINE]->set_active(false);

		int16_t friends_x = 243;
		int16_t friends_y = 115;
		int16_t friends_height = friends_y + 148;
		int16_t friends_unitrows = 6;
		int16_t friends_rowmax = 6;
		friends_slider = Slider(Slider::Type::DEFAULT_SILVER, Range<int16_t>(friends_y, friends_height), friends_x, friends_unitrows, friends_rowmax, [](bool) {});

		// Boss tab
		nl::node Boss = Main["Boss"];

		boss_sprites.emplace_back(Boss["base"]);
		boss_sprites.emplace_back(Boss["base3"]);
		boss_sprites.emplace_back(Boss["base2"]);

		buttons[Buttons::BT_BOSS_0] = std::make_unique<TwoSpriteButton>(Boss["BossList"]["0"]["icon"]["disabled"]["0"], Boss["BossList"]["0"]["icon"]["normal"]["0"]);
		buttons[Buttons::BT_BOSS_1] = std::make_unique<TwoSpriteButton>(Boss["BossList"]["1"]["icon"]["disabled"]["0"], Boss["BossList"]["1"]["icon"]["normal"]["0"]);
		buttons[Buttons::BT_BOSS_2] = std::make_unique<TwoSpriteButton>(Boss["BossList"]["2"]["icon"]["disabled"]["0"], Boss["BossList"]["2"]["icon"]["normal"]["0"]);
		buttons[Buttons::BT_BOSS_3] = std::make_unique<TwoSpriteButton>(Boss["BossList"]["3"]["icon"]["disabled"]["0"], Boss["BossList"]["3"]["icon"]["normal"]["0"]);
		buttons[Buttons::BT_BOSS_4] = std::make_unique<TwoSpriteButton>(Boss["BossList"]["4"]["icon"]["disabled"]["0"], Boss["BossList"]["4"]["icon"]["normal"]["0"]);
		buttons[Buttons::BT_BOSS_L] = std::make_unique<MapleButton>(Boss["BtArrow"]["Left"]);
		buttons[Buttons::BT_BOSS_R] = std::make_unique<MapleButton>(Boss["BtArrow"]["Right"]);
		buttons[Buttons::BT_BOSS_DIFF_L] = std::make_unique<MapleButton>(Boss["BtArrow2"]["Left"]);
		buttons[Buttons::BT_BOSS_DIFF_R] = std::make_unique<MapleButton>(Boss["BtArrow2"]["Right"]);
		buttons[Buttons::BT_BOSS_GO] = std::make_unique<MapleButton>(Boss["BtEntry"]);
		buttons[Buttons::BT_BOSS_0]->set_active(false);
		buttons[Buttons::BT_BOSS_1]->set_active(false);
		buttons[Buttons::BT_BOSS_2]->set_active(false);
		buttons[Buttons::BT_BOSS_3]->set_active(false);
		buttons[Buttons::BT_BOSS_4]->set_active(false);
		buttons[Buttons::BT_BOSS_L]->set_active(false);
		buttons[Buttons::BT_BOSS_R]->set_active(false);
		buttons[Buttons::BT_BOSS_DIFF_L]->set_active(false);
		buttons[Buttons::BT_BOSS_DIFF_R]->set_active(false);
		buttons[Buttons::BT_BOSS_GO]->set_active(false);

		// Blacklist tab
		nl::node BlackList = Main["BlackList"];

		blacklist_title = BlackList["base"];

		for (size_t i = 0; i < 3; i++)
			blacklist_grid[i] = UserList["Sheet6"][i];

		blacklist_name = Text(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::BLACK, "none", 0);

		nl::node blacklist_taben = BlackList["Tab"]["enabled"];
		nl::node blacklist_tabdis = BlackList["Tab"]["disabled"];

		buttons[Buttons::BT_BLACKLIST_ADD] = std::make_unique<MapleButton>(BlackList["BtAdd"]);
		buttons[Buttons::BT_BLACKLIST_DELETE] = std::make_unique<MapleButton>(BlackList["BtDelete"]);
		buttons[Buttons::BT_TAB_BLACKLIST_INDIVIDUAL] = std::make_unique<MapleButton>(BlackList["TapShowIndividual"]);
		buttons[Buttons::BT_TAB_BLACKLIST_GUILD] = std::make_unique<MapleButton>(BlackList["TapShowGuild"]);
		buttons[Buttons::BT_BLACKLIST_ADD]->set_active(false);
		buttons[Buttons::BT_BLACKLIST_DELETE]->set_active(false);
		buttons[Buttons::BT_TAB_BLACKLIST_INDIVIDUAL]->set_active(false);
		buttons[Buttons::BT_TAB_BLACKLIST_GUILD]->set_active(false);

		change_tab(tab);

		dimension = Point<int16_t>(276, 390);
	}

	void UIUserList::draw(float alpha) const
	{
		UIElement::draw_sprites(alpha);

		background.draw(position);

		if (tab == Buttons::BT_TAB_PARTY)
		{
			party_title.draw(position);

			if (party_tab == Buttons::BT_TAB_PARTY_MINE)
			{
				party_mine_grid[0].draw(position + Point<int16_t>(10, 115));
				party_mine_grid[4].draw(position + Point<int16_t>(10, 133));
				party_mine_name.draw(position + Point<int16_t>(27, 130));
			}
			else if (party_tab == Buttons::BT_TAB_PARTY_SEARCH)
			{
				party_search_grid[0].draw(position);
				party_search_grid[1].draw(position);
				party_search_grid[2].draw(position);
				party_slider.draw(position);
			}
		}
		else if (tab == Buttons::BT_TAB_FRIEND)
		{
			for (Sprite sprite : friend_sprites)
				sprite.draw(position, alpha);

			friends_online_text.draw(position + Point<int16_t>(211, 62));
			friends_cur_location.draw(position + Point<int16_t>(9, 279));
			friend_grid[0].draw(position + Point<int16_t>(10, 116));
			friend_grid[2].draw(position + Point<int16_t>(10, 135));
			friends_name.draw(position + Point<int16_t>(24, 134));
			friends_group_name.draw(position + Point<int16_t>(29, 114));
			friends_slider.draw(position);
		}
		else if (tab == Buttons::BT_TAB_BOSS)
		{
			for (Sprite sprite : boss_sprites)
				sprite.draw(position, alpha);
		}
		else if (tab == Buttons::BT_TAB_BLACKLIST)
		{
			blacklist_title.draw(position + Point<int16_t>(24, 104));
			blacklist_grid[0].draw(position + Point<int16_t>(24, 134));
			blacklist_name.draw(position + Point<int16_t>(24, 134));
		}

		UIElement::draw_buttons(alpha);
	}

	void UIUserList::update()
	{
		UIElement::update();

		if (tab == Buttons::BT_TAB_FRIEND)
			for (Sprite sprite : friend_sprites)
				sprite.update();

		if (tab == Buttons::BT_TAB_BOSS)
			for (Sprite sprite : boss_sprites)
				sprite.update();
	}

	void UIUserList::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
			{
				deactivate();
			}
			else if (keycode == KeyAction::Id::TAB)
			{
				uint16_t new_tab = tab;

				if (new_tab < Buttons::BT_TAB_BLACKLIST)
					new_tab++;
				else
					new_tab = Buttons::BT_TAB_FRIEND;

				change_tab(new_tab);
			}
		}
	}

	UIElement::Type UIUserList::get_type() const
	{
		return TYPE;
	}

	Button::State UIUserList::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			case Buttons::BT_CLOSE:
				deactivate();
				break;
			case Buttons::BT_TAB_FRIEND:
			case Buttons::BT_TAB_PARTY:
			case Buttons::BT_TAB_BOSS:
			case Buttons::BT_TAB_BLACKLIST:
				change_tab(buttonid);
				return Button::State::PRESSED;
			case Buttons::BT_TAB_PARTY_MINE:
			case Buttons::BT_TAB_PARTY_SEARCH:
				change_party_tab(buttonid);
				return Button::State::PRESSED;
			case Buttons::BT_TAB_FRIEND_ALL:
			case Buttons::BT_TAB_FRIEND_ONLINE:
				change_friend_tab(buttonid);
				return Button::State::PRESSED;
			case Buttons::BT_TAB_BLACKLIST_INDIVIDUAL:
			case Buttons::BT_TAB_BLACKLIST_GUILD:
				change_blacklist_tab(buttonid);
				return Button::State::PRESSED;
			default:
				return Button::State::NORMAL;
		}

		return Button::State::NORMAL;
	}

	void UIUserList::change_tab(uint8_t tabid)
	{
		uint8_t oldtab = tab;
		tab = tabid;

		background = tabid == Buttons::BT_TAB_BOSS ? UserList["Main"]["Boss"]["backgrnd3"] : UserList["Main"]["backgrnd2"];

		if (oldtab != tab)
			buttons[Buttons::BT_TAB_FRIEND + oldtab]->set_state(Button::State::NORMAL);

		buttons[Buttons::BT_TAB_FRIEND + tab]->set_state(Button::State::PRESSED);

		if (tab == Buttons::BT_TAB_PARTY)
		{
			buttons[Buttons::BT_PARTY_CREATE]->set_active(true);
			buttons[Buttons::BT_PARTY_INVITE]->set_active(true);
			buttons[Buttons::BT_TAB_PARTY_MINE]->set_active(true);
			buttons[Buttons::BT_TAB_PARTY_SEARCH]->set_active(true);

			change_party_tab(Tab::PARTY_MINE);
		}
		else
		{
			buttons[Buttons::BT_PARTY_CREATE]->set_active(false);
			buttons[Buttons::BT_PARTY_INVITE]->set_active(false);
			buttons[Buttons::BT_TAB_PARTY_MINE]->set_active(false);
			buttons[Buttons::BT_TAB_PARTY_SEARCH]->set_active(false);
			buttons[Buttons::BT_PARTY_SEARCH_LEVEL]->set_active(false);
		}

		if (tab == Buttons::BT_TAB_FRIEND)
		{
			buttons[Buttons::BT_FRIEND_ADD]->set_active(true);
			buttons[Buttons::BT_FRIEND_ADD_GROUP]->set_active(true);
			buttons[Buttons::BT_FRIEND_EXPAND]->set_active(true);
			buttons[Buttons::BT_TAB_FRIEND_ALL]->set_active(true);
			buttons[Buttons::BT_TAB_FRIEND_ONLINE]->set_active(true);
			buttons[Buttons::BT_FRIEND_GROUP_0]->set_active(true);

			change_friend_tab(Tab::FRIEND_ALL);
		}
		else
		{
			buttons[Buttons::BT_FRIEND_ADD]->set_active(false);
			buttons[Buttons::BT_FRIEND_ADD_GROUP]->set_active(false);
			buttons[Buttons::BT_FRIEND_EXPAND]->set_active(false);
			buttons[Buttons::BT_TAB_FRIEND_ALL]->set_active(false);
			buttons[Buttons::BT_TAB_FRIEND_ONLINE]->set_active(false);
			buttons[Buttons::BT_FRIEND_GROUP_0]->set_active(false);
		}

		if (tab == Buttons::BT_TAB_BOSS)
		{
			buttons[Buttons::BT_BOSS_0]->set_active(true);
			buttons[Buttons::BT_BOSS_1]->set_active(true);
			buttons[Buttons::BT_BOSS_2]->set_active(true);
			buttons[Buttons::BT_BOSS_3]->set_active(true);
			buttons[Buttons::BT_BOSS_4]->set_active(true);
			buttons[Buttons::BT_BOSS_L]->set_active(true);
			buttons[Buttons::BT_BOSS_R]->set_active(true);
			buttons[Buttons::BT_BOSS_DIFF_L]->set_active(true);
			buttons[Buttons::BT_BOSS_DIFF_R]->set_active(true);
			buttons[Buttons::BT_BOSS_GO]->set_active(true);
			buttons[Buttons::BT_BOSS_L]->set_state(Button::State::DISABLED);
			buttons[Buttons::BT_BOSS_R]->set_state(Button::State::DISABLED);
			buttons[Buttons::BT_BOSS_GO]->set_state(Button::State::DISABLED);
			buttons[Buttons::BT_BOSS_DIFF_L]->set_state(Button::State::DISABLED);
			buttons[Buttons::BT_BOSS_DIFF_R]->set_state(Button::State::DISABLED);
		}
		else
		{
			buttons[Buttons::BT_BOSS_0]->set_active(false);
			buttons[Buttons::BT_BOSS_1]->set_active(false);
			buttons[Buttons::BT_BOSS_2]->set_active(false);
			buttons[Buttons::BT_BOSS_3]->set_active(false);
			buttons[Buttons::BT_BOSS_4]->set_active(false);
			buttons[Buttons::BT_BOSS_L]->set_active(false);
			buttons[Buttons::BT_BOSS_R]->set_active(false);
			buttons[Buttons::BT_BOSS_DIFF_L]->set_active(false);
			buttons[Buttons::BT_BOSS_DIFF_R]->set_active(false);
			buttons[Buttons::BT_BOSS_GO]->set_active(false);
		}

		if (tab == Buttons::BT_TAB_BLACKLIST)
		{
			buttons[Buttons::BT_BLACKLIST_ADD]->set_active(true);
			buttons[Buttons::BT_BLACKLIST_DELETE]->set_active(true);
			buttons[Buttons::BT_TAB_BLACKLIST_INDIVIDUAL]->set_active(true);
			buttons[Buttons::BT_TAB_BLACKLIST_GUILD]->set_active(true);
		}
		else
		{
			buttons[Buttons::BT_BLACKLIST_ADD]->set_active(false);
			buttons[Buttons::BT_BLACKLIST_DELETE]->set_active(false);
			buttons[Buttons::BT_TAB_BLACKLIST_INDIVIDUAL]->set_active(false);
			buttons[Buttons::BT_TAB_BLACKLIST_GUILD]->set_active(false);
		}
	}

	uint16_t UIUserList::get_tab()
	{
		return tab;
	}

	void UIUserList::change_party_tab(uint8_t tabid)
	{
		uint8_t oldtab = party_tab;
		party_tab = tabid;

		if (oldtab != party_tab)
			buttons[Buttons::BT_TAB_FRIEND + oldtab]->set_state(Button::State::NORMAL);

		buttons[Buttons::BT_TAB_FRIEND + party_tab]->set_state(Button::State::PRESSED);

		if (party_tab == Buttons::BT_TAB_PARTY_SEARCH)
			buttons[Buttons::BT_PARTY_SEARCH_LEVEL]->set_active(true);
		else
			buttons[Buttons::BT_PARTY_SEARCH_LEVEL]->set_active(false);
	}

	void UIUserList::change_friend_tab(uint8_t tabid)
	{
		uint8_t oldtab = friend_tab;
		friend_tab = tabid;

		if (oldtab != friend_tab)
			buttons[Buttons::BT_TAB_FRIEND + oldtab]->set_state(Button::State::NORMAL);

		buttons[Buttons::BT_TAB_FRIEND + friend_tab]->set_state(Button::State::PRESSED);
	}

	void UIUserList::change_blacklist_tab(uint8_t tabid)
	{
		uint8_t oldtab = blacklist_tab;
		blacklist_tab = tabid;

		if (oldtab != blacklist_tab)
			buttons[Buttons::BT_TAB_FRIEND + oldtab]->set_state(Button::State::NORMAL);

		buttons[Buttons::BT_TAB_FRIEND + blacklist_tab]->set_state(Button::State::PRESSED);
	}

	std::string UIUserList::get_cur_location()
	{
		return "Henesys Market";
	}
}

================
File: IO/UITypes/UIUserList.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../Components/Slider.h"
#include "../Components/Textfield.h"

namespace ms
{
	class UIUserList : public UIDragElement<PosUSERLIST>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::USERLIST;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIUserList(uint16_t tab);

		void draw(float inter) const override;
		void update() override;

		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		enum Tab
		{
			FRIEND,
			PARTY,
			BOSS,
			BLACKLIST,
			PARTY_MINE,
			PARTY_SEARCH,
			FRIEND_ALL,
			FRIEND_ONLINE
		};

		void change_tab(uint8_t tabid);
		uint16_t get_tab();

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void change_party_tab(uint8_t tabid);
		void change_friend_tab(uint8_t tabid);
		void change_blacklist_tab(uint8_t tabid);
		std::string get_cur_location();

		enum Buttons
		{
			BT_TAB_FRIEND,
			BT_TAB_PARTY,
			BT_TAB_BOSS,
			BT_TAB_BLACKLIST,
			BT_TAB_PARTY_MINE,
			BT_TAB_PARTY_SEARCH,
			BT_TAB_FRIEND_ALL,
			BT_TAB_FRIEND_ONLINE,
			BT_TAB_BLACKLIST_INDIVIDUAL,
			BT_TAB_BLACKLIST_GUILD,
			BT_CLOSE,
			BT_PARTY_CREATE,
			BT_PARTY_INVITE,
			BT_PARTY_LEAVE,
			BT_PARTY_SETTINGS,
			BT_PARTY_SEARCH_LEVEL,
			BT_PARTY_SEARCH_INVITE,
			BT_FRIEND_ADD,
			BT_FRIEND_ADD_GROUP,
			BT_FRIEND_EXPAND,
			BT_FRIEND_GROUP_0,
			BT_BOSS_0,
			BT_BOSS_1,
			BT_BOSS_2,
			BT_BOSS_3,
			BT_BOSS_4,
			BT_BOSS_L,
			BT_BOSS_R,
			BT_BOSS_DIFF_L,
			BT_BOSS_DIFF_R,
			BT_BOSS_GO,
			BT_BLACKLIST_ADD,
			BT_BLACKLIST_DELETE
		};

		uint16_t tab;
		nl::node UserList;
		Texture background;

		// Party tab
		uint16_t party_tab;
		Texture party_title;
		Texture party_mine_grid[5];
		Texture party_search_grid[3];
		Text party_mine_name;
		Slider party_slider;

		// Buddy tab
		uint16_t friend_tab;
		int friend_count = 0;
		int friend_total = 50;
		std::vector<Sprite> friend_sprites;
		Texture friend_grid[4];
		Text friends_online_text;
		Text friends_cur_location;
		Text friends_name;
		Text friends_group_name;
		Slider friends_slider;

		// Boss tab
		std::vector<Sprite> boss_sprites;

		// Blacklist tab
		uint16_t blacklist_tab;
		Texture blacklist_title;
		Texture blacklist_grid[3];
		Text blacklist_name;
	};
}

================
File: IO/UITypes/UIWorldMap.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIWorldMap.h"

#include "../UI.h"

#include "../../Gameplay/Stage.h"

#include "../../IO/Components/MapleButton.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIWorldMap::UIWorldMap() : UIDragElement<PosMAP>(), search_text_dim(Point<int16_t>(82, 14))
	{
		nl::node close = nl::nx::UI["Basic.img"]["BtClose3"];
		nl::node WorldMap = nl::nx::UI["UIWindow2.img"]["WorldMap"];
		nl::node WorldMapSearch = WorldMap["WorldMapSearch"];
		nl::node Border = WorldMap["Border"]["0"];
		nl::node backgrnd = WorldMapSearch["backgrnd"];
		nl::node MapHelper = nl::nx::Map["MapHelper.img"]["worldMap"];

		cur_pos = MapHelper["curPos"];

		for (size_t i = 0; i < MAPSPOT_TYPE_MAX; i++)
			npc_pos[i] = MapHelper["npcPos" + std::to_string(i)];

		sprites.emplace_back(Border);

		search_background = backgrnd;
		search_notice = WorldMapSearch["notice"];

		bg_dimensions = Texture(Border).get_dimensions();
		bg_search_dimensions = search_background.get_dimensions();

		int16_t bg_dimensions_x = bg_dimensions.x();
		int16_t bg_search_dimensions_x = bg_search_dimensions.x();

		background_dimensions = Point<int16_t>(bg_dimensions_x, 0);

		int16_t base_x = bg_dimensions_x / 2;
		int16_t base_y = bg_dimensions.y() / 2;
		base_position = Point<int16_t>(base_x, base_y + 15);

		Point<int16_t> close_dimensions = Point<int16_t>(bg_dimensions_x - 22, 4);

		buttons[Buttons::BT_CLOSE] = std::make_unique<MapleButton>(close, close_dimensions);
		buttons[Buttons::BT_SEARCH] = std::make_unique<MapleButton>(WorldMap["BtSearch"]);
		buttons[Buttons::BT_AUTOFLY] = std::make_unique<MapleButton>(WorldMap["BtAutoFly_1"]);
		buttons[Buttons::BT_NAVIREG] = std::make_unique<MapleButton>(WorldMap["BtNaviRegister"]);
		buttons[Buttons::BT_SEARCH_CLOSE] = std::make_unique<MapleButton>(close, close_dimensions + Point<int16_t>(bg_search_dimensions_x, 0));
		buttons[Buttons::BT_ALLSEARCH] = std::make_unique<MapleButton>(WorldMapSearch["BtAllsearch"], background_dimensions);

		int16_t search_limit = 8;

		search_text = Textfield(Text::Font::A11M, Text::Alignment::LEFT, Color::Name::BLACK, Rectangle<int16_t>(get_search_pos(), get_search_pos() + search_text_dim), search_limit);

		set_search(true);

		dragarea = Point<int16_t>(bg_dimensions_x, 20);
	}

	void UIWorldMap::draw(float alpha) const
	{
		UIElement::draw_sprites(alpha);

		if (search)
		{
			search_background.draw(position + background_dimensions);
			search_notice.draw(position + background_dimensions);
			search_text.draw(Point<int16_t>(1, -5));
		}

		base_img.draw(position + base_position);

		if (link_images.size() > 0)
		{
			for (auto& iter : buttons)
			{
				if (const auto button = iter.second.get())
				{
					if (iter.first >= Buttons::BT_LINK0 && button->get_state() == Button::State::MOUSEOVER)
					{
						if (link_images.find(iter.first) != link_images.end())
						{
							link_images.at(iter.first).draw(position + base_position);
							break;
						}
					}
				}
			}
		}

		if (show_path_img)
			path_img.draw(position + base_position);

		for (auto spot : map_spots)
			spot.second.marker.draw(spot.first + position + base_position);

		bool found = false;

		if (!found)
		{
			for (auto spot : map_spots)
			{
				for (auto map_id : spot.second.map_ids)
				{
					if (map_id == mapid)
					{
						found = true;
						npc_pos[spot.second.type].draw(spot.first + position + base_position, alpha);
						cur_pos.draw(spot.first + position + base_position, alpha);
						break;
					}
				}

				if (found)
					break;
			}
		}

		UIElement::draw_buttons(alpha);
	}

	void UIWorldMap::update()
	{
		int32_t mid = Stage::get().get_mapid();

		if (mid != mapid)
		{
			mapid = mid;

			int32_t prefix = mapid / 10000000;
			std::string parent_map = "WorldMap0" + std::to_string(prefix);
			user_map = parent_map;

			update_world(user_map);
		}

		search_text.update(get_search_pos(), search_text_dim);

		for (size_t i = 0; i < MAPSPOT_TYPE_MAX; i++)
			npc_pos[i].update(1);

		cur_pos.update();

		UIElement::update();
	}

	void UIWorldMap::toggle_active()
	{
		UIElement::toggle_active();

		if (!active)
		{
			set_search(true);
			update_world(user_map);
		}
	}

	void UIWorldMap::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed && escape)
		{
			if (search)
			{
				set_search(false);
			}
			else
			{
				if (parent_map == "")
				{
					toggle_active();

					update_world(user_map);
				}
				else
				{
					Sound(Sound::Name::SELECTMAP).play();

					update_world(parent_map);
				}
			}
		}
	}

	UIElement::Type UIWorldMap::get_type() const
	{
		return TYPE;
	}

	Button::State UIWorldMap::button_pressed(uint16_t buttonid)
	{
		if (buttonid >= Buttons::BT_LINK0)
		{
			update_world(link_maps[buttonid]);

			return Button::State::IDENTITY;
		}

		switch (buttonid)
		{
			case Buttons::BT_CLOSE:
				deactivate();
				return Button::State::NORMAL;
			case Buttons::BT_SEARCH:
				set_search(!search);
				return Button::State::NORMAL;
			case Buttons::BT_SEARCH_CLOSE:
				set_search(false);
				return Button::State::NORMAL;
			default:
				return Button::State::DISABLED;
		}
	}

	void UIWorldMap::remove_cursor()
	{
		UIDragElement::remove_cursor();

		UI::get().clear_tooltip(Tooltip::Parent::WORLDMAP);

		show_path_img = false;
	}

	Cursor::State UIWorldMap::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		if (Cursor::State new_state = search_text.send_cursor(cursorpos, clicked))
			return new_state;

		show_path_img = false;

		for (auto path : map_spots)
		{
			Point<int16_t> p = path.first + position + base_position - 10;
			Point<int16_t> d = p + path.second.marker.get_dimensions();
			Rectangle<int16_t> abs_bounds = Rectangle<int16_t>(p, d);

			if (!clicked && abs_bounds.contains(cursorpos))
			{
				path_img = path.second.path;
				show_path_img = path_img.is_valid();

				UI::get().show_map(Tooltip::Parent::WORLDMAP, path.second.title, path.second.description, path.second.map_ids[0], path.second.bolded, false);
				break;
			}
		}

		return UIDragElement::send_cursor(clicked, cursorpos);
	}

	void UIWorldMap::set_search(bool enable)
	{
		search = enable;

		buttons[Buttons::BT_SEARCH_CLOSE]->set_active(enable);
		buttons[Buttons::BT_ALLSEARCH]->set_active(enable);

		if (enable)
		{
			search_text.set_state(Textfield::State::NORMAL);
			dimension = bg_dimensions + Point<int16_t>(bg_search_dimensions.x(), 0);
		}
		else
		{
			search_text.set_state(Textfield::State::DISABLED);
			dimension = bg_dimensions;
		}
	}

	void UIWorldMap::update_world(std::string map)
	{
		nl::node WorldMap = nl::nx::Map["WorldMap"][map + ".img"];

		if (!WorldMap)
			WorldMap = nl::nx::Map["WorldMap"]["WorldMap.img"];

		base_img = WorldMap["BaseImg"][0];
		parent_map = WorldMap["info"]["parentMap"];

		link_images.clear();
		link_maps.clear();

		for (auto& iter : buttons)
			if (const auto button = iter.second.get())
				if (iter.first >= Buttons::BT_LINK0)
					button->set_active(false);

		size_t i = Buttons::BT_LINK0;

		for (nl::node link : WorldMap["MapLink"])
		{
			nl::node l = link["link"];
			Texture link_image = l["linkImg"];

			link_images[i] = link_image;
			link_maps[i] = l["linkMap"];

			buttons[i] = std::make_unique<AreaButton>(base_position - link_image.get_origin(), link_image.get_dimensions());
			buttons[i]->set_active(true);

			i++;
		}

		nl::node mapImage = nl::nx::Map["MapHelper.img"]["worldMap"]["mapImage"];

		map_spots.clear();

		for (nl::node list : WorldMap["MapList"])
		{
			nl::node desc = list["desc"];
			nl::node mapNo = list["mapNo"];
			nl::node path = list["path"];
			nl::node spot = list["spot"];
			nl::node title = list["title"];
			nl::node type = list["type"];
			nl::node marker = mapImage[type];
			
			bool bolded = !desc.get_string().empty();

			std::vector<int32_t> map_ids;

			for (nl::node map_no : mapNo)
				map_ids.push_back(map_no);

			if (!desc && !title)
			{
				NxHelper::Map::MapInfo map_info = NxHelper::Map::get_map_info_by_id(mapNo[0]);
				bolded = !map_info.description.empty();

				map_spots.emplace_back(std::make_pair<Point<int16_t>, MapSpot>(spot, { map_info.description, path, map_info.full_name, type, marker, bolded, map_ids }));
			}
			else
			{
				map_spots.emplace_back(std::make_pair<Point<int16_t>, MapSpot>(spot, { desc, path, title, type, marker, bolded, map_ids }));
			}
		}
	}

	Point<int16_t> UIWorldMap::get_search_pos()
	{
		return position + Point<int16_t>(bg_dimensions.x() + 13, 25);
	}
}

================
File: IO/UITypes/UIWorldMap.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIDragElement.h"

#include "../Components/AreaButton.h"
#include "../Components/Textfield.h"

namespace ms
{
	class UIWorldMap : public UIDragElement<PosMAP>
	{
	public:
		static constexpr Type TYPE = UIElement::Type::WORLDMAP;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = true;

		UIWorldMap();

		void draw(float inter) const override;
		void update() override;

		void toggle_active() override;

		void remove_cursor() override;
		Cursor::State send_cursor(bool clicked, Point<int16_t> cursor_pos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		static constexpr uint8_t MAPSPOT_TYPE_MAX = 4u;

		void set_search(bool enable);
		void update_world(std::string parent_map);

		Point<int16_t> get_search_pos();

		enum Buttons
		{
			BT_CLOSE,
			BT_SEARCH,
			BT_AUTOFLY,
			BT_NAVIREG,
			BT_ALLSEARCH,
			BT_SEARCH_CLOSE,
			BT_LINK0,
			BT_LINK1,
			BT_LINK2,
			BT_LINK3,
			BT_LINK4,
			BT_LINK5,
			BT_LINK6,
			BT_LINK7,
			BT_LINK8,
			BT_LINK9
		};

		struct MapSpot
		{
			std::string description;
			Texture path;
			std::string title;
			uint8_t type;
			Texture marker;
			bool bolded;
			std::vector<int32_t> map_ids;
		};

		bool search;
		bool show_path_img;

		int32_t mapid;

		std::string parent_map;
		std::string user_map;

		Texture search_background;
		Texture search_notice;
		Texture base_img;
		Texture path_img;

		Animation cur_pos;
		Animation npc_pos[MAPSPOT_TYPE_MAX];

		Textfield search_text;

		std::map<uint16_t, Texture> link_images;
		std::map<uint16_t, std::string> link_maps;

		std::vector<std::pair<Point<int16_t>, MapSpot>> map_spots;

		Point<int16_t> bg_dimensions;
		Point<int16_t> bg_search_dimensions;
		Point<int16_t> background_dimensions;
		Point<int16_t> base_position;
		Point<int16_t> search_text_dim;
	};
}

================
File: IO/UITypes/UIWorldSelect.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIWorldSelect.h"

#include "UILoginNotice.h"
#include "UILoginWait.h"
#include "UIRegion.h"

#include "../UI.h"

#include "../Components/MapleButton.h"
#include "../Components/TwoSpriteButton.h"

#include "../../Audio/Audio.h"
#include "../../Util/Randomizer.h"

#include "../../Net/Packets/LoginPackets.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIWorldSelect::UIWorldSelect() : UIElement(Point<int16_t>(0, 0), Point<int16_t>(800, 600)), worldcount(0), world_selected(false)
	{
		std::string version_text = Configuration::get().get_version();
		version = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::LEMONGRASS, "Ver. " + version_text);
		version_pos = nl::nx::UI["Login.img"]["Common"]["version"]["pos"];

		Point<int16_t> background_pos = Point<int16_t>(512, 384);
		channelsrc_pos = Point<int16_t>(314, 217);

		worldid = Setting<DefaultWorld>::get().load();
		channelid = Setting<DefaultChannel>::get().load();

		nl::node Login = nl::nx::UI["Login.img"];
		nl::node Common = Login["Common"];
		nl::node WorldSelect = Login["WorldSelect"];
		
		// Check for v87 compatibility - newer UI structure
		worldsrc = WorldSelect["BtWorld"]["release"];
		channelsrc = WorldSelect["BtChannel"];
		
		// If modern UI structure is missing, try v87 fallback
		if (!worldsrc || !channelsrc)
		{
			// v87 fallback: BtWorld might be directly accessible
			if (!worldsrc && WorldSelect["BtWorld"])
				worldsrc = WorldSelect["BtWorld"];
			
			// For channels, v87 might not have BtChannel at all
			// We'll handle this case in the channel setup below
		}

		uint8_t regionid = Setting<DefaultRegion>::get().load();
		set_region(regionid);

		// Try to load login background from Map data, fallback for v87
		nl::node WorldSelectMap = nl::nx::Map["Obj"]["login.img"]["WorldSelect"];
		if (WorldSelectMap && WorldSelectMap["default"]["0"])
		{
			sprites.emplace_back(WorldSelectMap["default"]["0"], background_pos);

			std::vector<std::string> backgrounds = { "MapleLive" };
			size_t backgrounds_size = backgrounds.size();

			if (backgrounds_size > 0)
			{
				if (backgrounds_size > 1)
				{
					Randomizer randomizer = Randomizer();
					size_t index = randomizer.next_int(backgrounds_size);

					if (WorldSelectMap[backgrounds[index]]["0"])
						sprites.emplace_back(WorldSelectMap[backgrounds[index]]["0"], background_pos);
				}
				else
				{
					if (WorldSelectMap[backgrounds[0]]["0"])
						sprites.emplace_back(WorldSelectMap[backgrounds[0]]["0"], background_pos);
				}
			}
		}
		else
		{
			// v87 fallback: try to find background in UI data
			nl::node uiBackground = WorldSelect["background"];
			if (!uiBackground)
				uiBackground = Login["background"];
			
			if (uiBackground)
				sprites.emplace_back(uiBackground, background_pos);
			// If no background found, continue without one (better than crashing)
		}

		// Only create region button if it exists (might not be in v87)
		if (WorldSelect["BtRegion"])
			buttons[Buttons::BtRegion] = std::make_unique<MapleButton>(WorldSelect["BtRegion"], Point<int16_t>(0, 1));
		
		buttons[Buttons::BtExit] = std::make_unique<MapleButton>(Common["BtExit"]);

		// Setup channel buttons only if modern channel UI exists
		if (channelsrc)
		{
			for (uint16_t i = 0; i < Buttons::BtGoWorld - Buttons::BtChannel0; i++)
			{
				std::string channel = std::to_string(i);

				nl::node channelBtn = channelsrc["button:" + channel];
				if (channelBtn && channelBtn["normal"]["0"])
				{
					nl::node focusedBtn = channelBtn["keyFocused"]["0"];
					if (!focusedBtn) 
						focusedBtn = channelBtn["normal"]["0"]; // fallback to normal if focused missing

					buttons[Buttons::BtChannel0 + i] = std::make_unique<TwoSpriteButton>(channelBtn["normal"]["0"], focusedBtn, channelsrc_pos);
					buttons[Buttons::BtChannel0 + i]->set_active(false);
				}

				nl::node gaugeNode = channelsrc["gauge"];
				if (gaugeNode)
				{
					channel_gauge[i] = Gauge(
						Gauge::Type::WORLDSELECT,
						gaugeNode,
						CHANNEL_LOAD,
						0.0f
					);
				}
			}

			channels_background = channelsrc["layer:bg"];

			nl::node goWorldBtn = channelsrc["button:GoWorld"];
			if (goWorldBtn)
			{
				buttons[Buttons::BtGoWorld] = std::make_unique<MapleButton>(goWorldBtn, channelsrc_pos);
				buttons[Buttons::BtGoWorld]->set_active(false);
			}
		}
		// If no modern channel UI, we'll handle channel selection differently
		// (auto-select channel 1 or create simple channel selection)

		chatballoon.change_text("Please select the World you would like to play in.");

		for (size_t i = 1; i <= FLAG_SIZE; i++)
			flag_sprites.emplace_back(Login["WorldNotice"][i]);

		worldNotice = WorldSelect["worldNotice"]["0"];
		rebootNotice = WorldSelect["worldNotice"]["reboot"];
		worldNoticeMessage = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::MINESHAFT);

		if (Configuration::get().get_auto_login())
		{
			uint8_t world = Configuration::get().get_auto_world();
			uint8_t channel = Configuration::get().get_auto_channel();

			Configuration::get().set_worldid(world);
			Configuration::get().set_channelid(channel);

			UI::get().emplace<UILoginWait>();

			auto loginwait = UI::get().get_element<UILoginWait>();

			if (loginwait && loginwait->is_active())
				CharlistRequestPacket(world, channel).dispatch();
		}
	}

	void UIWorldSelect::draw(float alpha) const
	{
		UIElement::draw_sprites(alpha);

		// Only draw worlds background if it exists
		if (worlds_background.is_valid())
			worlds_background.draw(position + worldsrc_pos);

		for (size_t i = 0; i < worlds.size(); i++)
		{
			World world = worlds[i];

			if (world.flag > 0 && world.flag <= FLAG_SIZE && i < flag_sprites.size())
				flag_sprites[world.flag - 1].draw(position + worldsrc_pos + Point<int16_t>(1, 25 + 33 * i), alpha);
		}

		if (world_selected)
		{
			// Only draw channel UI if it exists (not in v87)
			if (channels_background.is_valid())
				channels_background.draw(position + channelsrc_pos);
			
			// Only draw world texture if available
			if (worldid < world_textures.size() && world_textures[worldid].is_valid())
				world_textures[worldid].draw(position + channelsrc_pos);

			uint16_t worldEnum = world_map.find(worldid)->second;

			// Skip Reboot notice for v87 (no Reboot worlds)
			if (worldEnum == Worlds::REBOOT0 && rebootNotice.is_valid())
			{
				rebootNotice.draw(position);
			}
			else if (!worldNoticeMessage.get_text().empty())
			{
				worldNotice.draw(position + Point<int16_t>(-18, 3));
				worldNoticeMessage.draw(position + channelsrc_pos + Point<int16_t>(58, -50));
			}
		}

		UIElement::draw_buttons(alpha);

		if (world_selected)
		{
			World selectedWorld = worlds[worldid];
			uint8_t channel_total = selectedWorld.channel_count;

			for (size_t i = 0; i < Buttons::BtGoWorld - Buttons::BtChannel0 && i < channel_total; i++)
			{
				uint8_t columns = std::min(channel_total, COLUMNS);

				div_t div = std::div(i, columns);
				int32_t current_col = div.rem;
				int32_t current_row = div.quot;

				channel_gauge->draw(position + channelsrc_pos + Point<int16_t>(28 + 71 * current_col, 92 + 30 * current_row));
			}
		}

		version.draw(position + version_pos - Point<int16_t>(0, 5));
		chatballoon.draw(position + Point<int16_t>(747, 105));
	}

	Cursor::State UIWorldSelect::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		Rectangle<int16_t> channels_bounds = Rectangle<int16_t>(
			position + channelsrc_pos,
			position + channelsrc_pos + channels_background.get_dimensions()
			);

		Rectangle<int16_t> worlds_bounds = Rectangle<int16_t>(
			position + worldsrc_pos,
			position + worldsrc_pos + worlds_background.get_dimensions()
			);

		if (world_selected && !channels_bounds.contains(cursorpos) && !worlds_bounds.contains(cursorpos))
		{
			if (clicked)
			{
				world_selected = false;
				clear_selected_world();
			}
		}

		Cursor::State ret = clicked ? Cursor::State::CLICKING : Cursor::State::IDLE;

		for (auto& btit : buttons)
		{
			if (btit.second->is_active() && btit.second->bounds(position).contains(cursorpos))
			{
				if (btit.second->get_state() == Button::State::NORMAL)
				{
					Sound(Sound::Name::BUTTONOVER).play();

					btit.second->set_state(Button::State::MOUSEOVER);
					ret = Cursor::State::CANCLICK;
				}
				else if (btit.second->get_state() == Button::State::PRESSED)
				{
					if (clicked)
					{
						Sound(Sound::Name::BUTTONCLICK).play();

						btit.second->set_state(button_pressed(btit.first));

						ret = Cursor::State::IDLE;
					}
					else
					{
						ret = Cursor::State::CANCLICK;
					}
				}
				else if (btit.second->get_state() == Button::State::MOUSEOVER)
				{
					if (clicked)
					{
						Sound(Sound::Name::BUTTONCLICK).play();

						btit.second->set_state(button_pressed(btit.first));

						ret = Cursor::State::IDLE;
					}
					else
					{
						ret = Cursor::State::CANCLICK;
					}
				}
			}
			else if (btit.second->get_state() == Button::State::MOUSEOVER)
			{
				btit.second->set_state(Button::State::NORMAL);
			}
		}

		return ret;
	}

	void UIWorldSelect::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (world_selected)
			{
				World selectedWorld = worlds[worldid];

				uint8_t selected_channel = channelid;
				uint8_t channel_total = selectedWorld.channel_count;

				uint8_t columns = std::min(channel_total, COLUMNS);

				uint8_t rows = std::floor((channel_total - 1) / COLUMNS) + 1;

				div_t div = std::div(selected_channel, columns);
				int32_t current_col = div.rem;

				if (keycode == KeyAction::Id::UP)
				{
					auto next_channel = (selected_channel - COLUMNS < 0 ? (selected_channel - COLUMNS) + rows * COLUMNS : selected_channel - COLUMNS);

					if (next_channel == channelid)
						return;

					if (next_channel > channel_total)
						button_pressed(next_channel - COLUMNS + Buttons::BtChannel0);
					else
						button_pressed(next_channel + Buttons::BtChannel0);
				}
				else if (keycode == KeyAction::Id::DOWN)
				{
					auto next_channel = (selected_channel + COLUMNS >= channel_total ? current_col : selected_channel + COLUMNS);

					if (next_channel == channelid)
						return;

					if (next_channel > channel_total)
						button_pressed(next_channel + COLUMNS + Buttons::BtChannel0);
					else
						button_pressed(next_channel + Buttons::BtChannel0);
				}
				else if (keycode == KeyAction::Id::LEFT || keycode == KeyAction::Id::TAB)
				{
					if (selected_channel != 0)
						selected_channel--;
					else
						selected_channel = channel_total - 1;

					button_pressed(selected_channel + Buttons::BtChannel0);
				}
				else if (keycode == KeyAction::Id::RIGHT)
				{
					if (selected_channel != channel_total - 1)
						selected_channel++;
					else
						selected_channel = 0;

					button_pressed(selected_channel + Buttons::BtChannel0);
				}
				else if (escape)
				{
					world_selected = false;

					clear_selected_world();
				}
				else if (keycode == KeyAction::Id::RETURN)
				{
					button_pressed(Buttons::BtGoWorld);
				}
			}
			else
			{
				auto selected_world = worldid;
				auto world_count = worldcount - 1;

				if (keycode == KeyAction::Id::LEFT || keycode == KeyAction::Id::RIGHT || keycode == KeyAction::Id::UP || keycode == KeyAction::Id::DOWN || keycode == KeyAction::Id::TAB)
				{
					bool world_found = false;
					bool forward = keycode == KeyAction::Id::LEFT || keycode == KeyAction::Id::UP;

					while (!world_found)
					{
						selected_world = get_next_world(selected_world, forward);

						for (auto world : worlds)
						{
							if (world.id == selected_world)
							{
								world_found = true;
								break;
							}
						}
					}

					buttons[Buttons::BtWorld0 + worldid]->set_state(Button::State::NORMAL);

					worldid = static_cast<uint8_t>(selected_world);

					buttons[Buttons::BtWorld0 + worldid]->set_state(Button::State::PRESSED);
				}
				else if (escape)
				{
					auto quitconfirm = UI::get().get_element<UIQuitConfirm>();

					if (quitconfirm && quitconfirm->is_active())
						return UI::get().send_key(keycode, pressed);
					else
						button_pressed(Buttons::BtExit);
				}
				else if (keycode == KeyAction::Id::RETURN)
				{
					auto quitconfirm = UI::get().get_element<UIQuitConfirm>();

					if (quitconfirm && quitconfirm->is_active())
					{
						return UI::get().send_key(keycode, pressed);
					}
					else
					{
						bool found = false;

						for (size_t i = Buttons::BtWorld0; i < Buttons::BtChannel0; i++)
						{
							auto state = buttons[Buttons::BtWorld0 + i]->get_state();

							if (state == Button::State::PRESSED)
							{
								found = true;
								break;
							}
						}

						if (found)
							button_pressed(selected_world + Buttons::BtWorld0);
						else
							buttons[Buttons::BtWorld0 + selected_world]->set_state(Button::State::PRESSED);
					}
				}
			}
		}
	}

	UIElement::Type UIWorldSelect::get_type() const
	{
		return TYPE;
	}

	void UIWorldSelect::draw_world()
	{
		if (worldcount <= 0)
			return; // TODO: Send the user back to the login screen? Otherwise, I think the screen will be blank with no worlds, or throw a UILoginNotice up with failed to communite to server?

		for (auto world : worlds)
		{
			if (world.channel_count < 2)
				return; // I remove the world if there is only one channel because the graphic for the channel selection is defaulted to at least 2

			buttons[Buttons::BtWorld0 + world.id]->set_active(true);

			if (channelid >= world.channel_count)
				channelid = 0;
		}
	}

	void UIWorldSelect::add_world(World world)
	{
		worlds.emplace_back(std::move(world));
		worldcount++;
	}

	void UIWorldSelect::change_world(World selectedWorld)
	{
		buttons[Buttons::BtWorld0 + selectedWorld.id]->set_state(Button::State::PRESSED);

		for (size_t i = 0; i < selectedWorld.channel_count; ++i)
		{
			buttons[Buttons::BtChannel0 + i]->set_active(true);

			if (i == channelid)
				buttons[Buttons::BtChannel0 + i]->set_state(Button::State::PRESSED);

			channel_gauge[i].update(selectedWorld.channel_capacities[i]);
		}

		buttons[Buttons::BtGoWorld]->set_active(true);

		worldNoticeMessage.change_text(selectedWorld.event_message);
	}

	void UIWorldSelect::remove_selected()
	{
		deactivate();

		Sound(Sound::Name::SCROLLUP).play();

		world_selected = false;

		clear_selected_world();
	}

	void UIWorldSelect::set_region(uint8_t regionid)
	{
		// Set up v87-compatible world mapping (no Reboot worlds in v87)
		world_map[Buttons::BtWorld0] = Worlds::SCANIA;
		world_map[Buttons::BtWorld1] = Worlds::BERA;
		world_map[Buttons::BtWorld2] = Worlds::BROA;
		world_map[Buttons::BtWorld3] = Worlds::WINDIA;
		world_map[Buttons::BtWorld4] = Worlds::KHAINI;

		// Try modern UI structure first
		nl::node region = worldsrc["index"][regionid];
		if (region && region["layer:bg"])
		{
			// Modern UI with region support
			worlds_background = region["layer:bg"];
			worldsrc_pos = region["pos"];

			for (uint16_t i = Buttons::BtWorld0; i < Buttons::BtChannel0; i++)
			{
				std::string world = std::to_string(world_map[i]);
				if (channelsrc && channelsrc["release"])
					world_textures.emplace_back(channelsrc["release"]["layer:" + world]);

				nl::node worldbtn = worldsrc["button:" + world];
				if (worldbtn && worldbtn["normal"]["0"])
				{
					nl::node focusedBtn = worldbtn["keyFocused"]["0"];
					if (!focusedBtn) focusedBtn = worldbtn["normal"]["0"];

					buttons[Buttons::BtWorld0 + i] = std::make_unique<TwoSpriteButton>(worldbtn["normal"]["0"], focusedBtn, worldsrc_pos + Point<int16_t>(region["origin"][i + 1]));
					buttons[Buttons::BtWorld0 + i]->set_active(false);
				}
			}
		}
		else
		{
			// v87 fallback: simpler world structure
			if (worldsrc && worldsrc["layer:bg"])
				worlds_background = worldsrc["layer:bg"];
			
			worldsrc_pos = Point<int16_t>(50, 150); // Default position for v87

			// v87 likely has direct world buttons (world0, world1, etc.)
			for (uint16_t i = Buttons::BtWorld0; i < Buttons::BtChannel0; i++)
			{
				std::string worldIndex = std::to_string(i);
				nl::node worldbtn = worldsrc[worldIndex]; // Try indexed access
				
				if (!worldbtn) // Try named access
				{
					std::string worldName = std::to_string(world_map[i]);
					worldbtn = worldsrc[worldName];
				}
				
				if (worldbtn && worldbtn["normal"])
				{
					nl::node normalBtn = worldbtn["normal"][0] ? worldbtn["normal"][0] : worldbtn["normal"];
					nl::node focusedBtn = worldbtn["mouseOver"] ? worldbtn["mouseOver"][0] : normalBtn;
					if (!focusedBtn) focusedBtn = normalBtn;

					// Position worlds vertically for v87
					Point<int16_t> worldPos = worldsrc_pos + Point<int16_t>(0, i * 35);
					buttons[Buttons::BtWorld0 + i] = std::make_unique<TwoSpriteButton>(normalBtn, focusedBtn, worldPos);
					buttons[Buttons::BtWorld0 + i]->set_active(false);
				}
			}
		}
	}

	uint16_t UIWorldSelect::get_worldbyid(uint16_t worldid)
	{
		return world_map.find(worldid)->second;
	}

	Button::State UIWorldSelect::button_pressed(uint16_t id)
	{
		if (id == Buttons::BtGoWorld)
		{
			enter_world();

			return Button::State::NORMAL;
		}
		else if (id == Buttons::BtExit)
		{
			UI::get().emplace<UIQuitConfirm>();

			return Button::State::NORMAL;
		}
		else if (id == Buttons::BtRegion)
		{
			UI::get().emplace<UIRegion>();

			deactivate();

			return Button::State::NORMAL;
		}
		else if (id >= Buttons::BtWorld0 && id < Buttons::BtChannel0)
		{
			buttons[Buttons::BtWorld0 + worldid]->set_state(Button::State::NORMAL);

			worldid = id - Buttons::BtWorld0;

			ServerStatusRequestPacket(worldid).dispatch();

			// If no modern channel UI exists (v87), auto-enter world with channel 1
			if (!channelsrc || !buttons[Buttons::BtGoWorld])
			{
				channelid = 1; // Default to channel 1 for v87
				enter_world(); // Enter immediately without channel selection
				return Button::State::NORMAL;
			}

			world_selected = true;
			clear_selected_world();
			change_world(worlds[worldid]);

			return Button::State::PRESSED;
		}
		else if (id >= Buttons::BtChannel0 && id < Buttons::BtGoWorld)
		{
			uint8_t selectedch = static_cast<uint8_t>(id - Buttons::BtChannel0);

			if (selectedch != channelid)
			{
				buttons[Buttons::BtChannel0 + channelid]->set_state(Button::State::NORMAL);
				channelid = static_cast<uint8_t>(id - Buttons::BtChannel0);
				buttons[Buttons::BtChannel0 + channelid]->set_state(Button::State::PRESSED);
				Sound(Sound::Name::WORLDSELECT).play();
			}
			else
			{
				enter_world();
			}

			return Button::State::PRESSED;
		}
		else
		{
			return Button::State::NORMAL;
		}
	}

	void UIWorldSelect::enter_world()
	{
		Configuration::get().set_worldid(worldid);
		Configuration::get().set_channelid(channelid);

		UI::get().emplace<UILoginWait>();
		auto loginwait = UI::get().get_element<UILoginWait>();

		if (loginwait && loginwait->is_active())
			CharlistRequestPacket(worldid, channelid).dispatch();
	}

	void UIWorldSelect::clear_selected_world()
	{
		channelid = 0;

		for (size_t i = Buttons::BtChannel0; i < Buttons::BtGoWorld; i++)
			buttons[i]->set_state(Button::State::NORMAL);

		buttons[Buttons::BtChannel0]->set_state(Button::State::PRESSED);

		for (size_t i = 0; i < Buttons::BtGoWorld - Buttons::BtChannel0; i++)
		{
			buttons[Buttons::BtChannel0 + i]->set_active(false);

			channel_gauge[i].update(0);
		}

		buttons[Buttons::BtGoWorld]->set_active(false);

		worldNoticeMessage.change_text("");
	}

	uint16_t UIWorldSelect::get_next_world(uint16_t id, bool upward)
	{
		uint16_t next_world;

		if (world_map[Buttons::BtWorld0] == Worlds::SCANIA)
		{
			switch (id)
			{
				case Buttons::BtWorld0:
					next_world = (upward) ? Worlds::REBOOT0 : Worlds::BERA;
					break;
				case Buttons::BtWorld1:
					next_world = (upward) ? Worlds::SCANIA : Worlds::AURORA;
					break;
				case Buttons::BtWorld2:
					next_world = (upward) ? Worlds::BERA : Worlds::ELYSIUM;
					break;
				case Buttons::BtWorld3:
					next_world = (upward) ? Worlds::AURORA : Worlds::REBOOT0;
					break;
				case Buttons::BtWorld4:
					next_world = (upward) ? Worlds::ELYSIUM : Worlds::SCANIA;
					break;
				default:
					break;
			}
		}
		else
		{
			switch (id)
			{
				case Buttons::BtWorld0:
					next_world = (upward) ? Worlds::REBOOT0 : Worlds::REBOOT0;
					break;
				case Buttons::BtWorld4:
					next_world = (upward) ? Worlds::SCANIA : Worlds::SCANIA;
					break;
				default:
					break;
			}
		}

		auto world = world_map.begin();

		while (world != world_map.end())
		{
			if (world->second == next_world)
				return world->first;

			world++;
		}

		return Worlds::SCANIA;
	}
}

================
File: IO/UITypes/UIWorldSelect.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../Components/ChatBalloon.h"
#include "../Components/Gauge.h"

#include "../../Net/Login.h"

namespace ms
{
	class UIWorldSelect : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::WORLDSELECT;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = false;

		UIWorldSelect();

		void draw(float alpha) const override;

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		void draw_world();
		void add_world(World world);
		void change_world(World selectedWorld);
		void remove_selected();
		void set_region(uint8_t value);
		uint16_t get_worldbyid(uint16_t worldid);

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		static constexpr uint8_t COLUMNS = 5U;
		static constexpr uint8_t FLAG_SIZE = 3U;
		// This is from the server in ServerConstants
		static constexpr int32_t CHANNEL_LOAD = 100;

		void enter_world();
		void clear_selected_world();
		uint16_t get_next_world(uint16_t id, bool upward);

		enum Buttons : uint16_t
		{
			BtWorld0,
			BtWorld1,
			BtWorld2,
			BtWorld3,
			BtWorld4,
			BtChannel0,
			BtGoWorld = 35U,
			BtRegion,
			BtExit
		};

		/// If ever changing order, check the WZ file.
		enum Worlds : uint16_t
		{
			SCANIA,
			BERA,
			BROA,
			WINDIA,
			KHAINI,
			BELLOCAN,
			MARDIA,
			KRADIA,
			YELLONDE,
			DEMETHOS,
			GALICIA,
			ELNIDO,
			ZENITH,
			ARCANIA,
			CHAOS,
			NOVA,
			RENEGADES,
			AURORA,
			ELYSIUM,
			KOREAN_ENOSIS = 29,
			LUNA,
			ELYSIUM_LINK,
			LAB = 40,
			KOREAN_RED = 43,
			KOREAN_AURORA,
			REBOOT0,
			REBOOT1,
			PINKBEAN = 48,
			BURNING,
			KOREAN_ARCANE,
			KOREAN_NOVA,
			TESPIA = 100
		};

		Text version;
		Point<int16_t> version_pos;
		Texture worlds_background;
		Texture channels_background;
		Point<int16_t> worldsrc_pos;
		Point<int16_t> channelsrc_pos;
		ChatBalloonHorizontal chatballoon;

		uint8_t worldid;
		uint8_t channelid;
		uint8_t worldcount;

		std::vector<World> worlds;
		std::vector<Texture> world_textures;
		std::map<uint16_t, uint16_t> world_map;

		std::vector<Sprite> flag_sprites;
		Texture worldNotice;
		Texture rebootNotice;
		Text worldNoticeMessage;
		Gauge channel_gauge[Buttons::BtGoWorld - Buttons::BtChannel0];

		bool world_selected;

		nl::node worldsrc;
		nl::node channelsrc;
	};
}

================
File: IO/Window.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Window.h"

#include "UI.h"

#include "../Configuration.h"
#include "../Timer.h"

#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>
#include <Windows.h>

namespace ms
{
	Window::Window()
	{
		context = nullptr;
		glwnd = nullptr;
		opacity = 1.0f;
		opcstep = 0.0f;
		width = Constants::Constants::get().get_viewwidth();
		height = Constants::Constants::get().get_viewheight();
	}

	Window::~Window()
	{
		glfwTerminate();
	}

	void error_callback(int no, const char* description)
	{
		LOG(LOG_ERROR, "GLFW error [" << no << "]: " << description);
	}

	void key_callback(GLFWwindow*, int key, int, int action, int)
	{
		UI::get().send_key(key, action != GLFW_RELEASE);
	}

	std::chrono::time_point<std::chrono::steady_clock> start = ContinuousTimer::get().start();

	void mousekey_callback(GLFWwindow*, int button, int action, int)
	{
		switch (button)
		{
			case GLFW_MOUSE_BUTTON_LEFT:
			{
				switch (action)
				{
					case GLFW_PRESS:
					{
						UI::get().send_cursor(true);
						break;
					}
					case GLFW_RELEASE:
					{
						auto diff_ms = ContinuousTimer::get().stop(start) / 1000;

						start = ContinuousTimer::get().start();

						if (diff_ms > 10 && diff_ms < 200)
							UI::get().doubleclick();

						UI::get().send_cursor(false);
						break;
					}
				}

				break;
			}
			case GLFW_MOUSE_BUTTON_RIGHT:
			{
				switch (action)
				{
					case GLFW_PRESS:
						UI::get().rightclick();
						break;
				}

				break;
			}
		}
	}

	void cursor_callback(GLFWwindow*, double xpos, double ypos)
	{
		Point<int16_t> cursor_position = Point<int16_t>(
			static_cast<int16_t>(xpos),
			static_cast<int16_t>(ypos)
			);

		Point<int16_t> screen = Point<int16_t>(
			Constants::Constants::get().get_viewwidth(),
			Constants::Constants::get().get_viewheight()
			);

		if (cursor_position.x() > 0 && cursor_position.y() > 0)
			if (cursor_position.x() < screen.x() && cursor_position.y() < screen.y())
				UI::get().send_cursor(cursor_position);
	}

	void focus_callback(GLFWwindow*, int focused)
	{
		UI::get().send_focus(focused);
	}

	void scroll_callback(GLFWwindow*, double xoffset, double yoffset)
	{
		UI::get().send_scroll(yoffset);
	}

	void close_callback(GLFWwindow* window)
	{
		UI::get().send_close();

		glfwSetWindowShouldClose(window, GL_FALSE);
	}

	Error Window::init()
	{
		fullscreen = Setting<Fullscreen>::get().load();

		if (!glfwInit())
			return Error::Code::GLFW;

		glfwWindowHint(GLFW_VISIBLE, GL_FALSE);
		context = glfwCreateWindow(1, 1, "", nullptr, nullptr);
		glfwMakeContextCurrent(context);
		glfwSetErrorCallback(error_callback);
		glfwWindowHint(GLFW_VISIBLE, GL_TRUE);
		glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);

		if (Error error = GraphicsGL::get().init())
			return error;

		return initwindow();
	}

	Error Window::initwindow()
	{
		if (glwnd)
			glfwDestroyWindow(glwnd);

		glwnd = glfwCreateWindow(
			width,
			height,
			Configuration::get().get_title().c_str(),
			fullscreen ? glfwGetPrimaryMonitor() : nullptr,
			context
		);

		if (!glwnd)
			return Error::Code::WINDOW;

		glfwMakeContextCurrent(glwnd);

		bool vsync = Setting<VSync>::get().load();
		glfwSwapInterval(vsync ? 1 : 0);

		glViewport(0, 0, width, height);
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();

		glfwSetInputMode(glwnd, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);

		double xpos, ypos;

		glfwGetCursorPos(glwnd, &xpos, &ypos);
		cursor_callback(glwnd, xpos, ypos);

		glfwSetInputMode(glwnd, GLFW_STICKY_KEYS, GL_TRUE);
		glfwSetKeyCallback(glwnd, key_callback);
		glfwSetMouseButtonCallback(glwnd, mousekey_callback);
		glfwSetCursorPosCallback(glwnd, cursor_callback);
		glfwSetWindowFocusCallback(glwnd, focus_callback);
		glfwSetScrollCallback(glwnd, scroll_callback);
		glfwSetWindowCloseCallback(glwnd, close_callback);

		char buf[256];
		GetCurrentDirectoryA(256, buf);
		strcat_s(buf, sizeof(buf), "\\Icon.png");

		GLFWimage images[1];

		auto stbi = stbi_load(buf, &images[0].width, &images[0].height, 0, 4);

		if (stbi == NULL)
			return Error(Error::Code::MISSING_ICON, stbi_failure_reason());

		images[0].pixels = stbi;

		glfwSetWindowIcon(glwnd, 1, images);
		stbi_image_free(images[0].pixels);

		GraphicsGL::get().reinit();

		return Error::Code::NONE;
	}

	bool Window::not_closed() const
	{
		return glfwWindowShouldClose(glwnd) == 0;
	}

	void Window::update()
	{
		updateopc();
	}

	void Window::updateopc()
	{
		if (opcstep != 0.0f)
		{
			opacity += opcstep;

			if (opacity >= 1.0f)
			{
				opacity = 1.0f;
				opcstep = 0.0f;
			}
			else if (opacity <= 0.0f)
			{
				opacity = 0.0f;
				opcstep = -opcstep;

				fadeprocedure();
			}
		}
	}

	void Window::check_events()
	{
		int16_t max_width = Configuration::get().get_max_width();
		int16_t max_height = Configuration::get().get_max_height();
		int16_t new_width = Constants::Constants::get().get_viewwidth();
		int16_t new_height = Constants::Constants::get().get_viewheight();

		if (width != new_width || height != new_height)
		{
			width = new_width;
			height = new_height;

			if (new_width >= max_width || new_height >= max_height)
				fullscreen = true;

			initwindow();
		}

		glfwPollEvents();
	}

	void Window::begin() const
	{
		GraphicsGL::get().clearscene();
	}

	void Window::end() const
	{
		GraphicsGL::get().flush(opacity);
		glfwSwapBuffers(glwnd);

	}

	void Window::fadeout(float step, std::function<void()> fadeproc)
	{
		opcstep = -step;
		fadeprocedure = fadeproc;
	}

	void Window::setclipboard(const std::string& text) const
	{
		glfwSetClipboardString(glwnd, text.c_str());
	}

	std::string Window::getclipboard() const
	{
		const char* text = glfwGetClipboardString(glwnd);

		return text ? text : "";
	}

	void Window::toggle_fullscreen()
	{
		int16_t max_width = Configuration::get().get_max_width();
		int16_t max_height = Configuration::get().get_max_height();

		if (width < max_width && height < max_height)
		{
			fullscreen = !fullscreen;
			Setting<Fullscreen>::get().save(fullscreen);

			initwindow();
			glfwPollEvents();
		}
	}
}

================
File: IO/Window.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Error.h"

#include "../Template/Singleton.h"

#define GLEW_STATIC
#include <glew.h>
#include <glfw3.h>

#include <functional>

namespace ms
{
	class Window : public Singleton<Window>
	{
	public:
		Window();
		~Window();

		Error init();
		Error initwindow();

		bool not_closed() const;
		void update();
		void begin() const;
		void end() const;
		void fadeout(float step, std::function<void()> fadeprocedure);
		void check_events();

		void setclipboard(const std::string& text) const;
		std::string getclipboard() const;

		void toggle_fullscreen();

	private:
		void updateopc();

		GLFWwindow* glwnd;
		GLFWwindow* context;
		bool fullscreen;
		float opacity;
		float opcstep;
		std::function<void()> fadeprocedure;
		int16_t width;
		int16_t height;
	};
}

================
File: libs/WzLib.lib.recipe
================
<?xml version="1.0" encoding="utf-8"?>
<Project>
  <ProjectOutputs />
  <ContentFiles />
  <SatelliteDlls />
  <NonRecipeFileRefs />
</Project>

================
File: LICENSE
================
GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.

================
File: MapleStory.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Gameplay/Stage.h"
#include "IO/UI.h"
#include "IO/Window.h"
#include "Net/Session.h"
#include "Util/HardwareInfo.h"
#include "Util/ScreenResolution.h"

#include <iostream>
#include <fstream>

#ifdef USE_NX
#include "Util/NxFiles.h"
#else
#include "Util/WzFiles.h"
#endif

namespace ms
{
	Error init()
	{
		if (Error error = Session::get().init())
			return error;

#ifdef USE_NX
		if (Error error = NxFiles::init())
			return error;
#else
		if (Error error = WzFiles::init())
			return error;
#endif

		if (Error error = Window::get().init())
			return error;

		if (Error error = Sound::init())
			return error;

		if (Error error = Music::init())
			return error;

		Char::init();
		DamageNumber::init();
		MapPortals::init();
		Stage::get().init();
		UI::get().init();

		return Error::NONE;
	}

	void update()
	{
		Window::get().check_events();
		Window::get().update();
		Stage::get().update();
		UI::get().update();
		Session::get().read();
	}

	void draw(float alpha)
	{
		Window::get().begin();
		Stage::get().draw(alpha);
		UI::get().draw(alpha);
		Window::get().end();
	}

	bool running()
	{
		bool session_connected = Session::get().is_connected();
		bool ui_not_quitted = UI::get().not_quitted();
		bool window_not_closed = Window::get().not_closed();
		
		// Allow running during login screen even without session connection
		bool should_run = ui_not_quitted && window_not_closed;
		
		// Main loop state check
		
		return should_run;
	}

	void loop()
	{
		Timer::get().start();

		int64_t timestep = Constants::TIMESTEP * 1000;
		int64_t accumulator = timestep;

		int64_t period = 0;
		int32_t samples = 0;

		bool show_fps = Configuration::get().get_show_fps();

		while (running())
		{
			int64_t elapsed = Timer::get().stop();

			// Update game with constant timestep as many times as possible.
			for (accumulator += elapsed; accumulator >= timestep; accumulator -= timestep)
				update();

			// Draw the game. Interpolate to account for remaining time.
			float alpha = static_cast<float>(accumulator) / timestep;
			draw(alpha);

			if (show_fps)
			{
				if (samples < 100)
				{
					period += elapsed;
					samples++;
				}
				else if (period)
				{
					int64_t fps = (samples * 1000000) / period;

					LOG(LOG_INFO, "FPS: " << fps);

					period = 0;
					samples = 0;
				}
			}
		}

		Sound::close();
	}

	void start()
	{
		// Initialize and check for errors
		if (Error error = init())
		{
			const char* message = error.get_message();
			const char* args = error.get_args();
			bool can_retry = error.can_retry();

			if (args && args[0])
				LOG(LOG_ERROR, message << args);
			else
				LOG(LOG_ERROR, message);

			if (can_retry)
				LOG(LOG_INFO, "Enter 'retry' to try agC:\HeavenClient\NoLifeWzToNxain.");

			std::string command;
			std::cin >> command;

			if (can_retry && command == "retry")
				start();
		}
		else
		{
			loop();
		}
	}
}

#ifdef _DEBUG
int main()
#else
int APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, PSTR cmdline, int cmdshow)
#endif
{
	// Redirect stdout and stderr to debug_output.txt, clearing it on each run
	//static std::ofstream debug_file("debug_output.txt", std::ios::trunc);
	//static std::streambuf* orig_cout = std::cout.rdbuf();
	//static std::streambuf* orig_cerr = std::cerr.rdbuf();
	
	//std::cout.rdbuf(debug_file.rdbuf());
	//std::cerr.rdbuf(debug_file.rdbuf());
	
	ms::HardwareInfo();
	ms::ScreenResolution();
	ms::start();

	// Restore original streams before exit
	//std::cout.rdbuf(orig_cout);
	//std::cerr.rdbuf(orig_cerr);
	//debug_file.close();

	return 0;
}

================
File: MapleStory.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

// If defined use Asio for networking, otherwise use Winsock.
//#define USE_ASIO

// Use cryptography for communication with the server
#define USE_CRYPTO

// If defined use NX, otherwise use WZ.
#ifndef USE_NX
#define USE_NX
#endif

// Debug options
#define LOG_ERROR	1
#define LOG_WARN	2
#define LOG_INFO	3
#define LOG_DEBUG	4
#define LOG_NETWORK	5
#define LOG_UI		6
#define LOG_TRACE	7

// Log Level
#ifdef _DEBUG
	#define LOG_LEVEL LOG_DEBUG
#else
	#define LOG_LEVEL LOG_WARN
#endif

// Log Text
#define LOG_TEXT(level) (\
	level == LOG_ERROR		? "ERROR"	:\
	level == LOG_WARN		? "WARN"	:\
	level == LOG_INFO		? "INFO"	:\
	level == LOG_DEBUG		? "DEBUG"	:\
	level == LOG_NETWORK	? "NETWORK"	:\
	level == LOG_UI			? "UI"		:\
	level == LOG_TRACE		? "TRACE"	: "UNDEFINED")

// Log Commands
#ifdef _DEBUG
	#define LOG(level, message) level <= LOG_LEVEL ? std::cout << "[" << LOG_TEXT(level) << "]: " << message << std::endl : std::cout
#else
	#define LOG(level, message) void(0)
#endif

================
File: MapleStory.sln
================
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.438
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MapleStory", "MapleStory.vcxproj", "{5B3DB0E4-3267-4074-B7BE-ECD225862B7D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5B3DB0E4-3267-4074-B7BE-ECD225862B7D}.Debug|x64.ActiveCfg = Debug|x64
		{5B3DB0E4-3267-4074-B7BE-ECD225862B7D}.Debug|x64.Build.0 = Debug|x64
		{5B3DB0E4-3267-4074-B7BE-ECD225862B7D}.Debug|x86.ActiveCfg = Debug|Win32
		{5B3DB0E4-3267-4074-B7BE-ECD225862B7D}.Debug|x86.Build.0 = Debug|Win32
		{5B3DB0E4-3267-4074-B7BE-ECD225862B7D}.Release|x64.ActiveCfg = Release|x64
		{5B3DB0E4-3267-4074-B7BE-ECD225862B7D}.Release|x64.Build.0 = Release|x64
		{5B3DB0E4-3267-4074-B7BE-ECD225862B7D}.Release|x86.ActiveCfg = Release|Win32
		{5B3DB0E4-3267-4074-B7BE-ECD225862B7D}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {407A691B-FCA5-41A3-8753-03CF53192BD3}
	EndGlobalSection
EndGlobal

================
File: MapleStory.vcxproj
================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{5B3DB0E4-3267-4074-B7BE-ECD225862B7D}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>MapleStory</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>C:\Users\me\Downloads\PERISH\MapleStory\</OutDir>
    <IntDir>$(PlatformTarget)\obj-$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>C:\Users\me\Downloads\PERISH\MapleStory\</OutDir>
    <IntDir>$(PlatformTarget)\obj-$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>C:\Users\me\Downloads\PERISH\MapleStory\</OutDir>
    <IntDir>$(PlatformTarget)\obj-$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>C:\Users\me\Downloads\PERISH\MapleStory\</OutDir>
    <IntDir>$(PlatformTarget)\obj-$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;USE_NX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)includes\glew-2.1.0\include\GL;$(ProjectDir)includes\freetype\include;$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\include\GLFW;$(ProjectDir)includes\stb;$(ProjectDir)includes\bass24\c;$(ProjectDir)includes\NoLifeNx;$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>glew32s.lib;freetype.lib;glfw3.lib;bass.lib;OpenGL32.lib;Iphlpapi.lib;WzLib.lib;liblz4.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(ProjectDir)includes\glew-2.1.0\lib\Release\$(Platform);$(ProjectDir)includes\freetype\win$(PlatformArchitecture);$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\lib-vc2015;$(ProjectDir)includes\bass24\c\$(PlatformTarget);$(ProjectDir)includes\WzLib\bin\Win32Release;$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <PostBuildEvent>
      <Command>copy /y /d "$(ProjectDir)includes\freetype\win$(PlatformArchitecture)\freetype.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\bass24\$(PlatformTarget)\bass.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll\liblz4.so.1.8.2.dll" "$(OutDir)liblz4.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;USE_NX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)includes\glew-2.1.0\include\GL;$(ProjectDir)includes\freetype\include;$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\include\GLFW;$(ProjectDir)includes\stb;$(ProjectDir)includes\bass24\c;$(ProjectDir)includes\NoLifeNx;$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>glew32s.lib;freetype.lib;glfw3.lib;bass.lib;OpenGL32.lib;Iphlpapi.lib;liblz4.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(ProjectDir)includes\glew-2.1.0\lib\Release\$(Platform);$(ProjectDir)includes\freetype\win$(PlatformArchitecture);$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\lib-vc2015;$(ProjectDir)includes\bass24\c\$(PlatformTarget);$(ProjectDir)includes\WzLib\bin\Win32Release;$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <PostBuildEvent>
      <Command>copy /y /d "$(ProjectDir)includes\freetype\win$(PlatformArchitecture)\freetype.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\bass24\$(PlatformTarget)\bass.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll\liblz4.so.1.8.2.dll" "$(OutDir)liblz4.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;USE_NX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)includes\glew-2.1.0\include\GL;$(ProjectDir)includes\freetype\include;$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\include\GLFW;$(ProjectDir)includes\stb;$(ProjectDir)includes\bass24\c;$(ProjectDir)includes\NoLifeNx;$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>glew32s.lib;freetype.lib;glfw3.lib;bass.lib;OpenGL32.lib;Iphlpapi.lib;WzLib.lib;liblz4.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(ProjectDir)includes\glew-2.1.0\lib\Release\$(Platform);$(ProjectDir)includes\freetype\win$(PlatformArchitecture);$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\lib-vc2015;$(ProjectDir)includes\bass24\c\$(PlatformTarget);$(ProjectDir)includes\WzLib\bin\Win32Release;$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <PostBuildEvent>
      <Command>copy /y /d "$(ProjectDir)includes\freetype\win$(PlatformArchitecture)\freetype.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\bass24\$(PlatformTarget)\bass.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll\liblz4.so.1.8.2.dll" "$(OutDir)liblz4.dll"
echo Copying Debug output to MapleStory directory...
if not exist "C:\Users\me\Downloads\PERISH\MapleStory\" mkdir "C:\Users\me\Downloads\PERISH\MapleStory\"
copy /y "$(OutDir)MapleStory.exe" "C:\Users\me\Downloads\PERISH\MapleStory\"
copy /y "$(OutDir)*.dll" "C:\Users\me\Downloads\PERISH\MapleStory\"
copy /y "$(OutDir)MapleStory.pdb" "C:\Users\me\Downloads\PERISH\MapleStory\"
echo Copy completed.</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;USE_NX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)includes\glew-2.1.0\include\GL;$(ProjectDir)includes\freetype\include;$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\include\GLFW;$(ProjectDir)includes\stb;$(ProjectDir)includes\bass24\c;$(ProjectDir)includes\NoLifeNx;$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>glew32s.lib;freetype.lib;glfw3.lib;bass.lib;OpenGL32.lib;Iphlpapi.lib;liblz4.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(ProjectDir)includes\glew-2.1.0\lib\Release\$(Platform);$(ProjectDir)includes\freetype\win$(PlatformArchitecture);$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\lib-vc2015;$(ProjectDir)includes\bass24\c\$(PlatformTarget);$(ProjectDir)includes\WzLib\bin\Win32Release;$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <PostBuildEvent>
      <Command>copy /y /d "$(ProjectDir)includes\freetype\win$(PlatformArchitecture)\freetype.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\bass24\$(PlatformTarget)\bass.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll\liblz4.so.1.8.2.dll" "$(OutDir)liblz4.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Audio\Audio.cpp" />
    <ClCompile Include="Character\ActiveBuffs.cpp" />
    <ClCompile Include="Character\Buff.cpp" />
    <ClCompile Include="Character\Char.cpp" />
    <ClCompile Include="Character\CharEffect.cpp" />
    <ClCompile Include="Character\CharStats.cpp" />
    <ClCompile Include="Character\EquipStat.cpp" />
    <ClCompile Include="Character\ExpTable.cpp" />
    <ClCompile Include="Character\Inventory\Equip.cpp" />
    <ClCompile Include="Character\Inventory\EquipQuality.cpp" />
    <ClCompile Include="Character\Inventory\Inventory.cpp" />
    <ClCompile Include="Character\Inventory\InventoryType.cpp" />
    <ClCompile Include="Character\Inventory\Item.cpp" />
    <ClCompile Include="Character\Inventory\Pet.cpp" />
    <ClCompile Include="Character\Inventory\Weapon.cpp" />
    <ClCompile Include="Character\Job.cpp" />
    <ClCompile Include="Character\Look\Afterimage.cpp" />
    <ClCompile Include="Character\Look\Body.cpp" />
    <ClCompile Include="Character\Look\BodyDrawInfo.cpp" />
    <ClCompile Include="Character\Look\CharEquips.cpp" />
    <ClCompile Include="Character\Look\CharLook.cpp" />
    <ClCompile Include="Character\Look\Clothing.cpp" />
    <ClCompile Include="Character\Look\EquipSlot.cpp" />
    <ClCompile Include="Character\Look\Face.cpp" />
    <ClCompile Include="Character\Look\Hair.cpp" />
    <ClCompile Include="Character\Look\PetLook.cpp" />
    <ClCompile Include="Character\Look\Stance.cpp" />
    <ClCompile Include="Character\MapleStat.cpp" />
    <ClCompile Include="Character\MonsterBook.cpp" />
    <ClCompile Include="Character\OtherChar.cpp" />
    <ClCompile Include="Character\PassiveBuffs.cpp" />
    <ClCompile Include="Character\Player.cpp" />
    <ClCompile Include="Character\PlayerStates.cpp" />
    <ClCompile Include="Character\QuestLog.cpp" />
    <ClCompile Include="Character\SkillBook.cpp" />
    <ClCompile Include="Character\TeleportRock.cpp" />
    <ClCompile Include="Configuration.cpp" />
    <ClCompile Include="Data\BulletData.cpp" />
    <ClCompile Include="Data\EquipData.cpp" />
    <ClCompile Include="Data\ItemData.cpp" />
    <ClCompile Include="Data\JobData.cpp" />
    <ClCompile Include="Data\SkillData.cpp" />
    <ClCompile Include="Data\WeaponData.cpp" />
    <ClCompile Include="Gameplay\Camera.cpp" />
    <ClCompile Include="Gameplay\Combat\Bullet.cpp" />
    <ClCompile Include="Gameplay\Combat\Combat.cpp" />
    <ClCompile Include="Gameplay\Combat\DamageNumber.cpp" />
    <ClCompile Include="Gameplay\Combat\RegularAttack.cpp" />
    <ClCompile Include="Gameplay\Combat\Skill.cpp" />
    <ClCompile Include="Gameplay\Combat\SkillAction.cpp" />
    <ClCompile Include="Gameplay\Combat\SkillBullet.cpp" />
    <ClCompile Include="Gameplay\Combat\SkillHitEffect.cpp" />
    <ClCompile Include="Gameplay\Combat\SkillSound.cpp" />
    <ClCompile Include="Gameplay\Combat\SkillUseEffect.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Drop.cpp" />
    <ClCompile Include="Gameplay\MapleMap\ItemDrop.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapBackgrounds.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapChars.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapDrops.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapEffect.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapInfo.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapMobs.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapNpcs.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapObject.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapObjects.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapPortals.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapReactors.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapTilesObjs.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MesoDrop.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Mob.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Npc.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Obj.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Portal.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Reactor.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Tile.cpp" />
    <ClCompile Include="Gameplay\Physics\Foothold.cpp" />
    <ClCompile Include="Gameplay\Physics\FootholdTree.cpp" />
    <ClCompile Include="Gameplay\Physics\Physics.cpp" />
    <ClCompile Include="Gameplay\Spawn.cpp" />
    <ClCompile Include="Gameplay\Stage.cpp" />
    <ClCompile Include="Graphics\Animation.cpp" />
    <ClCompile Include="Graphics\Color.cpp" />
    <ClCompile Include="Graphics\EffectLayer.cpp" />
    <ClCompile Include="Graphics\Geometry.cpp" />
    <ClCompile Include="Graphics\GraphicsGL.cpp" />
    <ClCompile Include="Graphics\Sprite.cpp" />
    <ClCompile Include="Graphics\Text.cpp" />
    <ClCompile Include="Graphics\Texture.cpp" />
    <ClCompile Include="IO\Components\AreaButton.cpp" />
    <ClCompile Include="IO\Components\Button.cpp" />
    <ClCompile Include="IO\Components\Charset.cpp" />
    <ClCompile Include="IO\Components\ChatBalloon.cpp" />
    <ClCompile Include="IO\Components\EquipTooltip.cpp" />
    <ClCompile Include="IO\Components\Gauge.cpp" />
    <ClCompile Include="IO\Components\Icon.cpp" />
    <ClCompile Include="IO\Components\IconCover.cpp" />
    <ClCompile Include="IO\Components\ItemTooltip.cpp" />
    <ClCompile Include="IO\Components\MapleButton.cpp" />
    <ClCompile Include="IO\Components\MapleComboBox.cpp" />
    <ClCompile Include="IO\Components\MapleFrame.cpp" />
    <ClCompile Include="IO\Components\MapTooltip.cpp" />
    <ClCompile Include="IO\Components\NameTag.cpp" />
    <ClCompile Include="IO\Components\NpcText.cpp" />
    <ClCompile Include="IO\Components\ScrollingNotice.cpp" />
    <ClCompile Include="IO\Components\SkillTooltip.cpp" />
    <ClCompile Include="IO\Components\Slider.cpp" />
    <ClCompile Include="IO\Components\StatefulIcon.cpp" />
    <ClCompile Include="IO\Components\Textfield.cpp" />
    <ClCompile Include="IO\Components\TextTooltip.cpp" />
    <ClCompile Include="IO\Components\TwoSpriteButton.cpp" />
    <ClCompile Include="IO\Cursor.cpp" />
    <ClCompile Include="IO\Keyboard.cpp" />
    <ClCompile Include="IO\Messages.cpp" />
    <ClCompile Include="IO\UI.cpp" />
    <ClCompile Include="IO\UIElement.cpp" />
    <ClCompile Include="IO\UIStateCashShop.cpp" />
    <ClCompile Include="IO\UIStateGame.cpp" />
    <ClCompile Include="IO\UIStateLogin.cpp" />
    <ClCompile Include="IO\UITypes\UIBuffList.cpp" />
    <ClCompile Include="IO\UITypes\UICashShop.cpp" />
    <ClCompile Include="IO\UITypes\UIChannel.cpp" />
    <ClCompile Include="IO\UITypes\UICharInfo.cpp" />
    <ClCompile Include="IO\UITypes\UICharSelect.cpp" />
    <ClCompile Include="IO\UITypes\UIChat.cpp" />
    <ClCompile Include="IO\UITypes\UIChatBar.cpp" />
    <ClCompile Include="IO\UITypes\UICommonCreation.cpp" />
    <ClCompile Include="IO\UITypes\UIEquipInventory.cpp" />
    <ClCompile Include="IO\UITypes\UIEvent.cpp" />
    <ClCompile Include="IO\UITypes\UIGender.cpp" />
    <ClCompile Include="IO\UITypes\UIItemInventory.cpp" />
    <ClCompile Include="IO\UITypes\UIJoypad.cpp" />
    <ClCompile Include="IO\UITypes\UIKeyConfig.cpp" />
    <ClCompile Include="IO\UITypes\UILogin.cpp" />
    <ClCompile Include="IO\UITypes\UILoginNotice.cpp" />
    <ClCompile Include="IO\UITypes\UILoginWait.cpp" />
    <ClCompile Include="IO\UITypes\UILogo.cpp" />
    <ClCompile Include="IO\UITypes\UIMiniMap.cpp" />
    <ClCompile Include="IO\UITypes\UINotice.cpp" />
    <ClCompile Include="IO\UITypes\UINpcTalk.cpp" />
    <ClCompile Include="IO\UITypes\UIOptionMenu.cpp" />
    <ClCompile Include="IO\UITypes\UIQuestLog.cpp" />
    <ClCompile Include="IO\UITypes\UIQuit.cpp" />
    <ClCompile Include="IO\UITypes\UIRaceSelect.cpp" />
    <ClCompile Include="IO\UITypes\UIRegion.cpp" />
    <ClCompile Include="IO\UITypes\UIShop.cpp" />
    <ClCompile Include="IO\UITypes\UISkillBook.cpp" />
    <ClCompile Include="IO\UITypes\UISoftKey.cpp" />
    <ClCompile Include="IO\UITypes\UIStatsInfo.cpp" />
    <ClCompile Include="IO\UITypes\UIStatusBar.cpp" />
    <ClCompile Include="IO\UITypes\UIStatusMessenger.cpp" />
    <ClCompile Include="IO\UITypes\UITermsOfService.cpp" />
    <ClCompile Include="IO\UITypes\UIUserList.cpp" />
    <ClCompile Include="IO\UITypes\UIWorldMap.cpp" />
    <ClCompile Include="IO\UITypes\UIWorldSelect.cpp" />
    <ClCompile Include="IO\Window.cpp" />
    <ClCompile Include="MapleStory.cpp" />
    <ClCompile Include="Net\Cryptography.cpp" />
    <ClCompile Include="Net\Handlers\AttackHandlers.cpp" />
    <ClCompile Include="Net\Handlers\CashShopHandlers.cpp" />
    <ClCompile Include="Net\Handlers\CommonHandlers.cpp" />
    <ClCompile Include="Net\Handlers\Helpers\CashShopParser.cpp" />
    <ClCompile Include="Net\Handlers\Helpers\CharacterParser.cpp" />
    <ClCompile Include="Net\Handlers\Helpers\ItemParser.cpp" />
    <ClCompile Include="Net\Handlers\Helpers\LoginParser.cpp" />
    <ClCompile Include="Net\Handlers\Helpers\MovementParser.cpp" />
    <ClCompile Include="Net\Handlers\InventoryHandlers.cpp" />
    <ClCompile Include="Net\Handlers\LoginHandlers.cpp" />
    <ClCompile Include="Net\Handlers\MapObjectHandlers.cpp" />
    <ClCompile Include="Net\Handlers\MessagingHandlers.cpp" />
    <ClCompile Include="Net\Handlers\NpcInteractionHandlers.cpp" />
    <ClCompile Include="Net\Handlers\PlayerHandlers.cpp" />
    <ClCompile Include="Net\Handlers\PlayerInteractionHandlers.cpp" />
    <ClCompile Include="Net\Handlers\SetFieldHandlers.cpp" />
    <ClCompile Include="Net\Handlers\TestingHandlers.cpp" />
    <ClCompile Include="Net\InPacket.cpp" />
    <ClCompile Include="Net\OutPacket.cpp" />
    <ClCompile Include="Net\PacketSwitch.cpp" />
    <ClCompile Include="Net\Session.cpp" />
    <ClCompile Include="Net\SocketAsio.cpp" />
    <ClCompile Include="Net\SocketWinsock.cpp" />
    <ClCompile Include="Util\AssetRegistry.cpp" />
    <ClCompile Include="Util\AssetRegistryTest.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="Util\Misc.cpp" />
    <ClCompile Include="Util\NxFiles.cpp" />
    <ClCompile Include="Util\WzFiles.cpp" />
    <ClCompile Include="includes\NoLifeNx\nlnx\audio.cpp">
      <ObjectFileName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)nlnx_audio.obj</ObjectFileName>
      <ObjectFileName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)nlnx_audio.obj</ObjectFileName>
      <ObjectFileName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)nlnx_audio.obj</ObjectFileName>
      <ObjectFileName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)nlnx_audio.obj</ObjectFileName>
    </ClCompile>
    <ClCompile Include="includes\NoLifeNx\nlnx\bitmap.cpp" />
    <ClCompile Include="includes\NoLifeNx\nlnx\file.cpp" />
    <ClCompile Include="includes\NoLifeNx\nlnx\node.cpp" />
    <ClCompile Include="includes\NoLifeNx\nlnx\nx.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Audio\Audio.h" />
    <ClInclude Include="Character\ActiveBuffs.h" />
    <ClInclude Include="Character\Buff.h" />
    <ClInclude Include="Character\Char.h" />
    <ClInclude Include="Character\CharEffect.h" />
    <ClInclude Include="Character\CharStats.h" />
    <ClInclude Include="Character\EquipStat.h" />
    <ClInclude Include="Character\ExpTable.h" />
    <ClInclude Include="Character\Inventory\Equip.h" />
    <ClInclude Include="Character\Inventory\EquipQuality.h" />
    <ClInclude Include="Character\Inventory\Inventory.h" />
    <ClInclude Include="Character\Inventory\InventoryType.h" />
    <ClInclude Include="Character\Inventory\Item.h" />
    <ClInclude Include="Character\Inventory\Pet.h" />
    <ClInclude Include="Character\Inventory\Weapon.h" />
    <ClInclude Include="Character\Job.h" />
    <ClInclude Include="Character\Look\Afterimage.h" />
    <ClInclude Include="Character\Look\Body.h" />
    <ClInclude Include="Character\Look\BodyDrawInfo.h" />
    <ClInclude Include="Character\Look\CharEquips.h" />
    <ClInclude Include="Character\Look\CharLook.h" />
    <ClInclude Include="Character\Look\Clothing.h" />
    <ClInclude Include="Character\Look\EquipSlot.h" />
    <ClInclude Include="Character\Look\Face.h" />
    <ClInclude Include="Character\Look\Hair.h" />
    <ClInclude Include="Character\Look\PetLook.h" />
    <ClInclude Include="Character\Look\Stance.h" />
    <ClInclude Include="Character\MapleStat.h" />
    <ClInclude Include="Character\MonsterBook.h" />
    <ClInclude Include="Character\OtherChar.h" />
    <ClInclude Include="Character\PassiveBuffs.h" />
    <ClInclude Include="Character\Player.h" />
    <ClInclude Include="Character\PlayerStates.h" />
    <ClInclude Include="Character\Questlog.h" />
    <ClInclude Include="Character\SkillBook.h" />
    <ClInclude Include="Character\SkillId.h" />
    <ClInclude Include="Character\StatCaps.h" />
    <ClInclude Include="Character\TeleportRock.h" />
    <ClInclude Include="Configuration.h" />
    <ClInclude Include="Constants.h" />
    <ClInclude Include="Data\BulletData.h" />
    <ClInclude Include="Data\EquipData.h" />
    <ClInclude Include="Data\ItemData.h" />
    <ClInclude Include="Data\JobData.h" />
    <ClInclude Include="Data\SkillData.h" />
    <ClInclude Include="Data\WeaponData.h" />
    <ClInclude Include="Error.h" />
    <ClInclude Include="Gameplay\Camera.h" />
    <ClInclude Include="Gameplay\Combat\Attack.h" />
    <ClInclude Include="Gameplay\Combat\Bullet.h" />
    <ClInclude Include="Gameplay\Combat\Combat.h" />
    <ClInclude Include="Gameplay\Combat\DamageNumber.h" />
    <ClInclude Include="Gameplay\Combat\RegularAttack.h" />
    <ClInclude Include="Gameplay\Combat\Skill.h" />
    <ClInclude Include="Gameplay\Combat\SkillAction.h" />
    <ClInclude Include="Gameplay\Combat\SkillBullet.h" />
    <ClInclude Include="Gameplay\Combat\SkillHitEffect.h" />
    <ClInclude Include="Gameplay\Combat\SkillSound.h" />
    <ClInclude Include="Gameplay\Combat\SkillUseEffect.h" />
    <ClInclude Include="Gameplay\Combat\SpecialMove.h" />
    <ClInclude Include="Gameplay\MapleMap\Drop.h" />
    <ClInclude Include="Gameplay\MapleMap\ItemDrop.h" />
    <ClInclude Include="Gameplay\MapleMap\Layer.h" />
    <ClInclude Include="Gameplay\MapleMap\MapBackgrounds.h" />
    <ClInclude Include="Gameplay\MapleMap\MapChars.h" />
    <ClInclude Include="Gameplay\MapleMap\MapDrops.h" />
    <ClInclude Include="Gameplay\MapleMap\MapEffect.h" />
    <ClInclude Include="Gameplay\MapleMap\MapInfo.h" />
    <ClInclude Include="Gameplay\MapleMap\MapMobs.h" />
    <ClInclude Include="Gameplay\MapleMap\MapNpcs.h" />
    <ClInclude Include="Gameplay\MapleMap\MapObject.h" />
    <ClInclude Include="Gameplay\MapleMap\MapObjects.h" />
    <ClInclude Include="Gameplay\MapleMap\MapPortals.h" />
    <ClInclude Include="Gameplay\MapleMap\MapReactors.h" />
    <ClInclude Include="Gameplay\MapleMap\MapTilesObjs.h" />
    <ClInclude Include="Gameplay\MapleMap\MesoDrop.h" />
    <ClInclude Include="Gameplay\MapleMap\Mob.h" />
    <ClInclude Include="Gameplay\MapleMap\Npc.h" />
    <ClInclude Include="Gameplay\MapleMap\Obj.h" />
    <ClInclude Include="Gameplay\MapleMap\Portal.h" />
    <ClInclude Include="Gameplay\MapleMap\Reactor.h" />
    <ClInclude Include="Gameplay\MapleMap\Tile.h" />
    <ClInclude Include="Gameplay\Movement.h" />
    <ClInclude Include="Gameplay\Physics\Foothold.h" />
    <ClInclude Include="Gameplay\Physics\FootholdTree.h" />
    <ClInclude Include="Gameplay\Physics\Physics.h" />
    <ClInclude Include="Gameplay\Physics\PhysicsObject.h" />
    <ClInclude Include="Gameplay\Playable.h" />
    <ClInclude Include="Gameplay\Spawn.h" />
    <ClInclude Include="Gameplay\Stage.h" />
    <ClInclude Include="Graphics\Animation.h" />
    <ClInclude Include="Graphics\Color.h" />
    <ClInclude Include="Graphics\DrawArgument.h" />
    <ClInclude Include="Graphics\EffectLayer.h" />
    <ClInclude Include="Graphics\Geometry.h" />
    <ClInclude Include="Graphics\GraphicsGL.h" />
    <ClInclude Include="Graphics\SpecialText.h" />
    <ClInclude Include="Graphics\Sprite.h" />
    <ClInclude Include="Graphics\Text.h" />
    <ClInclude Include="Graphics\Texture.h" />
    <ClInclude Include="IO\Components\AreaButton.h" />
    <ClInclude Include="IO\Components\Button.h" />
    <ClInclude Include="IO\Components\Charset.h" />
    <ClInclude Include="IO\Components\ChatBalloon.h" />
    <ClInclude Include="IO\Components\EquipTooltip.h" />
    <ClInclude Include="IO\Components\Gauge.h" />
    <ClInclude Include="IO\Components\Icon.h" />
    <ClInclude Include="IO\Components\IconCover.h" />
    <ClInclude Include="IO\Components\ItemTooltip.h" />
    <ClInclude Include="IO\Components\MapleButton.h" />
    <ClInclude Include="IO\Components\MapleComboBox.h" />
    <ClInclude Include="IO\Components\MapleFrame.h" />
    <ClInclude Include="IO\Components\MapTooltip.h" />
    <ClInclude Include="IO\Components\NameTag.h" />
    <ClInclude Include="IO\Components\ScrollingNotice.h" />
    <ClInclude Include="IO\Components\SkillTooltip.h" />
    <ClInclude Include="IO\Components\Slider.h" />
    <ClInclude Include="IO\Components\StatefulIcon.h" />
    <ClInclude Include="IO\Components\Textfield.h" />
    <ClInclude Include="IO\Components\TextTooltip.h" />
    <ClInclude Include="IO\Components\Tooltip.h" />
    <ClInclude Include="IO\Components\TwoSpriteButton.h" />
    <ClInclude Include="IO\Cursor.h" />
    <ClInclude Include="IO\KeyAction.h" />
    <ClInclude Include="IO\Keyboard.h" />
    <ClInclude Include="IO\KeyConfig.h" />
    <ClInclude Include="IO\KeyType.h" />
    <ClInclude Include="IO\Messages.h" />
    <ClInclude Include="IO\UI.h" />
    <ClInclude Include="IO\UIDragElement.h" />
    <ClInclude Include="IO\UIElement.h" />
    <ClInclude Include="IO\UIState.h" />
    <ClInclude Include="IO\UIStateCashShop.h" />
    <ClInclude Include="IO\UIStateGame.h" />
    <ClInclude Include="IO\UIStateLogin.h" />
    <ClInclude Include="IO\UITypes\UIAranCreation.h" />
    <ClInclude Include="IO\UITypes\UIBuffList.h" />
    <ClInclude Include="IO\UITypes\UICashShop.h" />
    <ClInclude Include="IO\UITypes\UIChannel.h" />
    <ClInclude Include="IO\UITypes\UICharInfo.h" />
    <ClInclude Include="IO\UITypes\UICharSelect.h" />
    <ClInclude Include="IO\UITypes\UIChat.h" />
    <ClInclude Include="IO\UITypes\UIChatBar.h" />
    <ClInclude Include="IO\UITypes\UICommonCreation.h" />
    <ClInclude Include="IO\UITypes\UICygnusCreation.h" />
    <ClInclude Include="IO\UITypes\UIEquipInventory.h" />
    <ClInclude Include="IO\UITypes\UIEvent.h" />
    <ClInclude Include="IO\UITypes\UIExplorerCreation.h" />
    <ClInclude Include="IO\UITypes\UIGender.h" />
    <ClInclude Include="IO\UITypes\UIItemInventory.h" />
    <ClInclude Include="IO\UITypes\UIJoypad.h" />
    <ClInclude Include="IO\UITypes\UIKeyConfig.h" />
    <ClInclude Include="IO\UITypes\UILogin.h" />
    <ClInclude Include="IO\UITypes\UILoginNotice.h" />
    <ClInclude Include="IO\UITypes\UILoginWait.h" />
    <ClInclude Include="IO\UITypes\UILogo.h" />
    <ClInclude Include="IO\UITypes\UIMiniMap.h" />
    <ClInclude Include="IO\UITypes\UINotice.h" />
    <ClInclude Include="IO\UITypes\UINpcTalk.h" />
    <ClInclude Include="IO\UITypes\UIOptionMenu.h" />
    <ClInclude Include="IO\UITypes\UIQuestLog.h" />
    <ClInclude Include="IO\UITypes\UIQuit.h" />
    <ClInclude Include="IO\UITypes\UIRaceSelect.h" />
    <ClInclude Include="IO\UITypes\UIRegion.h" />
    <ClInclude Include="IO\UITypes\UIShop.h" />
    <ClInclude Include="IO\UITypes\UISkillBook.h" />
    <ClInclude Include="IO\UITypes\UISoftKey.h" />
    <ClInclude Include="IO\UITypes\UIStatsInfo.h" />
    <ClInclude Include="IO\UITypes\UIStatusBar.h" />
    <ClInclude Include="IO\UITypes\UIStatusMessenger.h" />
    <ClInclude Include="IO\UITypes\UITermsOfService.h" />
    <ClInclude Include="IO\UITypes\UIUserList.h" />
    <ClInclude Include="IO\UITypes\UIWorldMap.h" />
    <ClInclude Include="IO\UITypes\UIWorldSelect.h" />
    <ClInclude Include="IO\Window.h" />
    <ClInclude Include="MapleStory.h" />
    <ClInclude Include="Net\Cryptography.h" />
    <ClInclude Include="Net\Handlers\AttackHandlers.h" />
    <ClInclude Include="Net\Handlers\CashShopHandlers.h" />
    <ClInclude Include="Net\Handlers\CommonHandlers.h" />
    <ClInclude Include="Net\Handlers\Helpers\CashShopParser.h" />
    <ClInclude Include="Net\Handlers\Helpers\CharacterParser.h" />
    <ClInclude Include="Net\Handlers\Helpers\ItemParser.h" />
    <ClInclude Include="Net\Handlers\Helpers\LoginParser.h" />
    <ClInclude Include="Net\Handlers\Helpers\MovementParser.h" />
    <ClInclude Include="Net\Handlers\InventoryHandlers.h" />
    <ClInclude Include="Net\Handlers\LoginHandlers.h" />
    <ClInclude Include="Net\Handlers\MapObjectHandlers.h" />
    <ClInclude Include="Net\Handlers\MessagingHandlers.h" />
    <ClInclude Include="Net\Handlers\NpcInteractionHandlers.h" />
    <ClInclude Include="Net\Handlers\PlayerHandlers.h" />
    <ClInclude Include="Net\Handlers\PlayerInteractionHandlers.h" />
    <ClInclude Include="Net\Handlers\SetFieldHandlers.h" />
    <ClInclude Include="Net\Handlers\TestingHandlers.h" />
    <ClInclude Include="Net\InPacket.h" />
    <ClInclude Include="Net\Login.h" />
    <ClInclude Include="Net\NetConstants.h" />
    <ClInclude Include="Net\OutPacket.h" />
    <ClInclude Include="Net\PacketError.h" />
    <ClInclude Include="Net\PacketHandler.h" />
    <ClInclude Include="Net\PacketSwitch.h" />
    <ClInclude Include="Net\Packets\AttackAndSkillPackets.h" />
    <ClInclude Include="Net\Packets\CharCreationPackets.h" />
    <ClInclude Include="Net\Packets\CommonPackets.h" />
    <ClInclude Include="Net\Packets\GameplayPackets.h" />
    <ClInclude Include="Net\Packets\InventoryPackets.h" />
    <ClInclude Include="Net\Packets\LoginPackets.h" />
    <ClInclude Include="Net\Packets\MessagingPackets.h" />
    <ClInclude Include="Net\Packets\MovementPacket.h" />
    <ClInclude Include="Net\Packets\NpcInteractionPackets.h" />
    <ClInclude Include="Net\Packets\PlayerInteractionPackets.h" />
    <ClInclude Include="Net\Packets\PlayerPackets.h" />
    <ClInclude Include="Net\Packets\SelectCharPackets.h" />
    <ClInclude Include="Net\Session.h" />
    <ClInclude Include="Net\SocketAsio.h" />
    <ClInclude Include="Net\SocketWinsock.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="Template\BoolPair.h" />
    <ClInclude Include="Template\Cache.h" />
    <ClInclude Include="Template\Enumeration.h" />
    <ClInclude Include="Template\EnumMap.h" />
    <ClInclude Include="Template\Interpolated.h" />
    <ClInclude Include="Template\Optional.h" />
    <ClInclude Include="Template\Point.h" />
    <ClInclude Include="Template\Range.h" />
    <ClInclude Include="Template\Rectangle.h" />
    <ClInclude Include="Template\Singleton.h" />
    <ClInclude Include="Template\TimedQueue.h" />
    <ClInclude Include="Template\TypeMap.h" />
    <ClInclude Include="Timer.h" />
    <ClInclude Include="Util\AssetRegistry.h" />
    <ClInclude Include="Util\Assets.h" />
    <ClInclude Include="Util\HardwareInfo.h" />
    <ClInclude Include="Util\Lerp.h" />
    <ClInclude Include="Util\Misc.h" />
    <ClInclude Include="Util\NxFiles.h" />
    <ClInclude Include="Util\QuadTree.h" />
    <ClInclude Include="Util\Randomizer.h" />
    <ClInclude Include="Util\ScreenResolution.h" />
    <ClInclude Include="Util\TimedBool.h" />
    <ClInclude Include="Util\WzFiles.h" />
    <ClInclude Include="includes\NoLifeNx\nlnx\audio.hpp" />
    <ClInclude Include="includes\NoLifeNx\nlnx\bitmap.hpp" />
    <ClInclude Include="includes\NoLifeNx\nlnx\file.hpp" />
    <ClInclude Include="includes\NoLifeNx\nlnx\file_impl.hpp" />
    <ClInclude Include="includes\NoLifeNx\nlnx\node.hpp" />
    <ClInclude Include="includes\NoLifeNx\nlnx\node_impl.hpp" />
    <ClInclude Include="includes\NoLifeNx\nlnx\nx.hpp" />
    <ClInclude Include="includes\NoLifeNx\nlnx\nxfwd.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="MapleStory.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="Icon.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

================
File: MapleStory.vcxproj.backup
================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{5B3DB0E4-3267-4074-B7BE-ECD225862B7D}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>MapleStory</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>C:\Users\me\Downloads\PERISH\MapleStory\</OutDir>
    <IntDir>$(PlatformTarget)\obj-$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>C:\Users\me\Downloads\PERISH\MapleStory\</OutDir>
    <IntDir>$(PlatformTarget)\obj-$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>C:\Users\me\Downloads\PERISH\MapleStory\</OutDir>
    <IntDir>$(PlatformTarget)\obj-$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>C:\Users\me\Downloads\PERISH\MapleStory\</OutDir>
    <IntDir>$(PlatformTarget)\obj-$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;USE_NX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)includes\glew-2.1.0\include\GL;$(ProjectDir)includes\freetype\include;$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\include\GLFW;$(ProjectDir)includes\stb;$(ProjectDir)includes\bass24\c;$(ProjectDir)includes\NoLifeNx;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>glew32s.lib;freetype.lib;glfw3.lib;bass.lib;OpenGL32.lib;Iphlpapi.lib;NoLifeNx.lib;WzLib.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(ProjectDir)includes\glew-2.1.0\lib\Release\$(Platform);$(ProjectDir)includes\freetype\win$(PlatformArchitecture);$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\lib-vc2015;$(ProjectDir)includes\bass24\c\$(PlatformTarget);$(ProjectDir)includes\NoLifeNx\nlnx\$(PlatformTarget)\$(Configuration);$(ProjectDir)includes\WzLib\bin\Win32Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <PostBuildEvent>
      <Command>copy /y /d "$(ProjectDir)includes\freetype\win$(PlatformArchitecture)\freetype.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\bass24\$(PlatformTarget)\bass.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll\liblz4.so.1.8.2.dll" "$(OutDir)liblz4.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;USE_NX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)includes\glew-2.1.0\include\GL;$(ProjectDir)includes\freetype\include;$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\include\GLFW;$(ProjectDir)includes\stb;$(ProjectDir)includes\bass24\c;$(ProjectDir)includes\NoLifeNx;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>glew32s.lib;freetype.lib;glfw3.lib;bass.lib;OpenGL32.lib;Iphlpapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(ProjectDir)includes\glew-2.1.0\lib\Release\$(Platform);$(ProjectDir)includes\freetype\win$(PlatformArchitecture);$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\lib-vc2015;$(ProjectDir)includes\bass24\c\$(PlatformTarget);$(ProjectDir)includes\NoLifeNx\nlnx\$(PlatformTarget)\$(Configuration);$(ProjectDir)includes\WzLib\bin\Win32Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <PostBuildEvent>
      <Command>copy /y /d "$(ProjectDir)includes\freetype\win$(PlatformArchitecture)\freetype.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\bass24\$(PlatformTarget)\bass.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll\liblz4.so.1.8.2.dll" "$(OutDir)liblz4.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;USE_NX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)includes\glew-2.1.0\include\GL;$(ProjectDir)includes\freetype\include;$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\include\GLFW;$(ProjectDir)includes\stb;$(ProjectDir)includes\bass24\c;$(ProjectDir)includes\NoLifeNx;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>glew32s.lib;freetype.lib;glfw3.lib;bass.lib;OpenGL32.lib;Iphlpapi.lib;NoLifeNx.lib;WzLib.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(ProjectDir)includes\glew-2.1.0\lib\Release\$(Platform);$(ProjectDir)includes\freetype\win$(PlatformArchitecture);$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\lib-vc2015;$(ProjectDir)includes\bass24\c\$(PlatformTarget);$(ProjectDir)includes\NoLifeNx\nlnx\$(PlatformTarget)\$(Configuration);$(ProjectDir)includes\WzLib\bin\Win32Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <PostBuildEvent>
      <Command>copy /y /d "$(ProjectDir)includes\freetype\win$(PlatformArchitecture)\freetype.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\bass24\$(PlatformTarget)\bass.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll\liblz4.so.1.8.2.dll" "$(OutDir)liblz4.dll"
echo Copying Debug output to MapleStory directory...
if not exist "C:\Users\me\Downloads\PERISH\MapleStory\" mkdir "C:\Users\me\Downloads\PERISH\MapleStory\"
copy /y "$(OutDir)MapleStory.exe" "C:\Users\me\Downloads\PERISH\MapleStory\"
copy /y "$(OutDir)*.dll" "C:\Users\me\Downloads\PERISH\MapleStory\"
copy /y "$(OutDir)MapleStory.pdb" "C:\Users\me\Downloads\PERISH\MapleStory\"
echo Copy completed.</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;USE_NX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)includes\glew-2.1.0\include\GL;$(ProjectDir)includes\freetype\include;$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\include\GLFW;$(ProjectDir)includes\stb;$(ProjectDir)includes\bass24\c;$(ProjectDir)includes\NoLifeNx;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>glew32s.lib;freetype.lib;glfw3.lib;bass.lib;OpenGL32.lib;Iphlpapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(ProjectDir)includes\glew-2.1.0\lib\Release\$(Platform);$(ProjectDir)includes\freetype\win$(PlatformArchitecture);$(ProjectDir)includes\glfw-3.3.2.bin.WIN$(PlatformArchitecture)\lib-vc2015;$(ProjectDir)includes\bass24\c\$(PlatformTarget);$(ProjectDir)includes\NoLifeNx\nlnx\$(PlatformTarget)\$(Configuration);$(ProjectDir)includes\WzLib\bin\Win32Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <PostBuildEvent>
      <Command>copy /y /d "$(ProjectDir)includes\freetype\win$(PlatformArchitecture)\freetype.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\bass24\$(PlatformTarget)\bass.dll" "$(OutDir)"
copy /y /d "$(ProjectDir)includes\NoLifeNx\nlnx\includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll\liblz4.so.1.8.2.dll" "$(OutDir)liblz4.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Audio\Audio.cpp" />
    <ClCompile Include="Character\ActiveBuffs.cpp" />
    <ClCompile Include="Character\Buff.cpp" />
    <ClCompile Include="Character\Char.cpp" />
    <ClCompile Include="Character\CharEffect.cpp" />
    <ClCompile Include="Character\CharStats.cpp" />
    <ClCompile Include="Character\EquipStat.cpp" />
    <ClCompile Include="Character\ExpTable.cpp" />
    <ClCompile Include="Character\Inventory\Equip.cpp" />
    <ClCompile Include="Character\Inventory\EquipQuality.cpp" />
    <ClCompile Include="Character\Inventory\Inventory.cpp" />
    <ClCompile Include="Character\Inventory\InventoryType.cpp" />
    <ClCompile Include="Character\Inventory\Item.cpp" />
    <ClCompile Include="Character\Inventory\Pet.cpp" />
    <ClCompile Include="Character\Inventory\Weapon.cpp" />
    <ClCompile Include="Character\Job.cpp" />
    <ClCompile Include="Character\Look\Afterimage.cpp" />
    <ClCompile Include="Character\Look\Body.cpp" />
    <ClCompile Include="Character\Look\BodyDrawInfo.cpp" />
    <ClCompile Include="Character\Look\CharEquips.cpp" />
    <ClCompile Include="Character\Look\CharLook.cpp" />
    <ClCompile Include="Character\Look\Clothing.cpp" />
    <ClCompile Include="Character\Look\EquipSlot.cpp" />
    <ClCompile Include="Character\Look\Face.cpp" />
    <ClCompile Include="Character\Look\Hair.cpp" />
    <ClCompile Include="Character\Look\PetLook.cpp" />
    <ClCompile Include="Character\Look\Stance.cpp" />
    <ClCompile Include="Character\MapleStat.cpp" />
    <ClCompile Include="Character\MonsterBook.cpp" />
    <ClCompile Include="Character\OtherChar.cpp" />
    <ClCompile Include="Character\PassiveBuffs.cpp" />
    <ClCompile Include="Character\Player.cpp" />
    <ClCompile Include="Character\PlayerStates.cpp" />
    <ClCompile Include="Character\QuestLog.cpp" />
    <ClCompile Include="Character\SkillBook.cpp" />
    <ClCompile Include="Character\TeleportRock.cpp" />
    <ClCompile Include="Configuration.cpp" />
    <ClCompile Include="Data\BulletData.cpp" />
    <ClCompile Include="Data\EquipData.cpp" />
    <ClCompile Include="Data\ItemData.cpp" />
    <ClCompile Include="Data\JobData.cpp" />
    <ClCompile Include="Data\SkillData.cpp" />
    <ClCompile Include="Data\WeaponData.cpp" />
    <ClCompile Include="Gameplay\Camera.cpp" />
    <ClCompile Include="Gameplay\Combat\Bullet.cpp" />
    <ClCompile Include="Gameplay\Combat\Combat.cpp" />
    <ClCompile Include="Gameplay\Combat\DamageNumber.cpp" />
    <ClCompile Include="Gameplay\Combat\RegularAttack.cpp" />
    <ClCompile Include="Gameplay\Combat\Skill.cpp" />
    <ClCompile Include="Gameplay\Combat\SkillAction.cpp" />
    <ClCompile Include="Gameplay\Combat\SkillBullet.cpp" />
    <ClCompile Include="Gameplay\Combat\SkillHitEffect.cpp" />
    <ClCompile Include="Gameplay\Combat\SkillSound.cpp" />
    <ClCompile Include="Gameplay\Combat\SkillUseEffect.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Drop.cpp" />
    <ClCompile Include="Gameplay\MapleMap\ItemDrop.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapBackgrounds.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapChars.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapDrops.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapEffect.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapInfo.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapMobs.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapNpcs.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapObject.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapObjects.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapPortals.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapReactors.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MapTilesObjs.cpp" />
    <ClCompile Include="Gameplay\MapleMap\MesoDrop.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Mob.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Npc.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Obj.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Portal.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Reactor.cpp" />
    <ClCompile Include="Gameplay\MapleMap\Tile.cpp" />
    <ClCompile Include="Gameplay\Physics\Foothold.cpp" />
    <ClCompile Include="Gameplay\Physics\FootholdTree.cpp" />
    <ClCompile Include="Gameplay\Physics\Physics.cpp" />
    <ClCompile Include="Gameplay\Spawn.cpp" />
    <ClCompile Include="Gameplay\Stage.cpp" />
    <ClCompile Include="Graphics\Animation.cpp" />
    <ClCompile Include="Graphics\Color.cpp" />
    <ClCompile Include="Graphics\EffectLayer.cpp" />
    <ClCompile Include="Graphics\Geometry.cpp" />
    <ClCompile Include="Graphics\GraphicsGL.cpp" />
    <ClCompile Include="Graphics\Sprite.cpp" />
    <ClCompile Include="Graphics\Text.cpp" />
    <ClCompile Include="Graphics\Texture.cpp" />
    <ClCompile Include="IO\Components\AreaButton.cpp" />
    <ClCompile Include="IO\Components\Button.cpp" />
    <ClCompile Include="IO\Components\Charset.cpp" />
    <ClCompile Include="IO\Components\ChatBalloon.cpp" />
    <ClCompile Include="IO\Components\EquipTooltip.cpp" />
    <ClCompile Include="IO\Components\Gauge.cpp" />
    <ClCompile Include="IO\Components\Icon.cpp" />
    <ClCompile Include="IO\Components\IconCover.cpp" />
    <ClCompile Include="IO\Components\ItemTooltip.cpp" />
    <ClCompile Include="IO\Components\MapleButton.cpp" />
    <ClCompile Include="IO\Components\MapleComboBox.cpp" />
    <ClCompile Include="IO\Components\MapleFrame.cpp" />
    <ClCompile Include="IO\Components\MapTooltip.cpp" />
    <ClCompile Include="IO\Components\NameTag.cpp" />
    <ClCompile Include="IO\Components\NpcText.cpp" />
    <ClCompile Include="IO\Components\ScrollingNotice.cpp" />
    <ClCompile Include="IO\Components\SkillTooltip.cpp" />
    <ClCompile Include="IO\Components\Slider.cpp" />
    <ClCompile Include="IO\Components\StatefulIcon.cpp" />
    <ClCompile Include="IO\Components\Textfield.cpp" />
    <ClCompile Include="IO\Components\TextTooltip.cpp" />
    <ClCompile Include="IO\Components\TwoSpriteButton.cpp" />
    <ClCompile Include="IO\Cursor.cpp" />
    <ClCompile Include="IO\Keyboard.cpp" />
    <ClCompile Include="IO\Messages.cpp" />
    <ClCompile Include="IO\UI.cpp" />
    <ClCompile Include="IO\UIElement.cpp" />
    <ClCompile Include="IO\UIStateCashShop.cpp" />
    <ClCompile Include="IO\UIStateGame.cpp" />
    <ClCompile Include="IO\UIStateLogin.cpp" />
    <ClCompile Include="IO\UITypes\UIBuffList.cpp" />
    <ClCompile Include="IO\UITypes\UICashShop.cpp" />
    <ClCompile Include="IO\UITypes\UIChannel.cpp" />
    <ClCompile Include="IO\UITypes\UICharInfo.cpp" />
    <ClCompile Include="IO\UITypes\UICharSelect.cpp" />
    <ClCompile Include="IO\UITypes\UIChat.cpp" />
    <ClCompile Include="IO\UITypes\UIChatBar.cpp" />
    <ClCompile Include="IO\UITypes\UICommonCreation.cpp" />
    <ClCompile Include="IO\UITypes\UIEquipInventory.cpp" />
    <ClCompile Include="IO\UITypes\UIEvent.cpp" />
    <ClCompile Include="IO\UITypes\UIGender.cpp" />
    <ClCompile Include="IO\UITypes\UIItemInventory.cpp" />
    <ClCompile Include="IO\UITypes\UIJoypad.cpp" />
    <ClCompile Include="IO\UITypes\UIKeyConfig.cpp" />
    <ClCompile Include="IO\UITypes\UILogin.cpp" />
    <ClCompile Include="IO\UITypes\UILoginNotice.cpp" />
    <ClCompile Include="IO\UITypes\UILoginWait.cpp" />
    <ClCompile Include="IO\UITypes\UILogo.cpp" />
    <ClCompile Include="IO\UITypes\UIMiniMap.cpp" />
    <ClCompile Include="IO\UITypes\UINotice.cpp" />
    <ClCompile Include="IO\UITypes\UINpcTalk.cpp" />
    <ClCompile Include="IO\UITypes\UIOptionMenu.cpp" />
    <ClCompile Include="IO\UITypes\UIQuestLog.cpp" />
    <ClCompile Include="IO\UITypes\UIQuit.cpp" />
    <ClCompile Include="IO\UITypes\UIRaceSelect.cpp" />
    <ClCompile Include="IO\UITypes\UIRegion.cpp" />
    <ClCompile Include="IO\UITypes\UIShop.cpp" />
    <ClCompile Include="IO\UITypes\UISkillBook.cpp" />
    <ClCompile Include="IO\UITypes\UISoftKey.cpp" />
    <ClCompile Include="IO\UITypes\UIStatsInfo.cpp" />
    <ClCompile Include="IO\UITypes\UIStatusBar.cpp" />
    <ClCompile Include="IO\UITypes\UIStatusMessenger.cpp" />
    <ClCompile Include="IO\UITypes\UITermsOfService.cpp" />
    <ClCompile Include="IO\UITypes\UIUserList.cpp" />
    <ClCompile Include="IO\UITypes\UIWorldMap.cpp" />
    <ClCompile Include="IO\UITypes\UIWorldSelect.cpp" />
    <ClCompile Include="IO\Window.cpp" />
    <ClCompile Include="MapleStory.cpp" />
    <ClCompile Include="Net\Cryptography.cpp" />
    <ClCompile Include="Net\Handlers\AttackHandlers.cpp" />
    <ClCompile Include="Net\Handlers\CashShopHandlers.cpp" />
    <ClCompile Include="Net\Handlers\CommonHandlers.cpp" />
    <ClCompile Include="Net\Handlers\Helpers\CashShopParser.cpp" />
    <ClCompile Include="Net\Handlers\Helpers\CharacterParser.cpp" />
    <ClCompile Include="Net\Handlers\Helpers\ItemParser.cpp" />
    <ClCompile Include="Net\Handlers\Helpers\LoginParser.cpp" />
    <ClCompile Include="Net\Handlers\Helpers\MovementParser.cpp" />
    <ClCompile Include="Net\Handlers\InventoryHandlers.cpp" />
    <ClCompile Include="Net\Handlers\LoginHandlers.cpp" />
    <ClCompile Include="Net\Handlers\MapObjectHandlers.cpp" />
    <ClCompile Include="Net\Handlers\MessagingHandlers.cpp" />
    <ClCompile Include="Net\Handlers\NpcInteractionHandlers.cpp" />
    <ClCompile Include="Net\Handlers\PlayerHandlers.cpp" />
    <ClCompile Include="Net\Handlers\PlayerInteractionHandlers.cpp" />
    <ClCompile Include="Net\Handlers\SetFieldHandlers.cpp" />
    <ClCompile Include="Net\Handlers\TestingHandlers.cpp" />
    <ClCompile Include="Net\InPacket.cpp" />
    <ClCompile Include="Net\OutPacket.cpp" />
    <ClCompile Include="Net\PacketSwitch.cpp" />
    <ClCompile Include="Net\Session.cpp" />
    <ClCompile Include="Net\SocketAsio.cpp" />
    <ClCompile Include="Net\SocketWinsock.cpp" />
    <ClCompile Include="Util\AssetRegistry.cpp" />
    <ClCompile Include="Util\AssetRegistryTest.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="Util\Misc.cpp" />
    <ClCompile Include="Util\NxFiles.cpp" />
    <ClCompile Include="Util\WzFiles.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Audio\Audio.h" />
    <ClInclude Include="Character\ActiveBuffs.h" />
    <ClInclude Include="Character\Buff.h" />
    <ClInclude Include="Character\Char.h" />
    <ClInclude Include="Character\CharEffect.h" />
    <ClInclude Include="Character\CharStats.h" />
    <ClInclude Include="Character\EquipStat.h" />
    <ClInclude Include="Character\ExpTable.h" />
    <ClInclude Include="Character\Inventory\Equip.h" />
    <ClInclude Include="Character\Inventory\EquipQuality.h" />
    <ClInclude Include="Character\Inventory\Inventory.h" />
    <ClInclude Include="Character\Inventory\InventoryType.h" />
    <ClInclude Include="Character\Inventory\Item.h" />
    <ClInclude Include="Character\Inventory\Pet.h" />
    <ClInclude Include="Character\Inventory\Weapon.h" />
    <ClInclude Include="Character\Job.h" />
    <ClInclude Include="Character\Look\Afterimage.h" />
    <ClInclude Include="Character\Look\Body.h" />
    <ClInclude Include="Character\Look\BodyDrawInfo.h" />
    <ClInclude Include="Character\Look\CharEquips.h" />
    <ClInclude Include="Character\Look\CharLook.h" />
    <ClInclude Include="Character\Look\Clothing.h" />
    <ClInclude Include="Character\Look\EquipSlot.h" />
    <ClInclude Include="Character\Look\Face.h" />
    <ClInclude Include="Character\Look\Hair.h" />
    <ClInclude Include="Character\Look\PetLook.h" />
    <ClInclude Include="Character\Look\Stance.h" />
    <ClInclude Include="Character\MapleStat.h" />
    <ClInclude Include="Character\MonsterBook.h" />
    <ClInclude Include="Character\OtherChar.h" />
    <ClInclude Include="Character\PassiveBuffs.h" />
    <ClInclude Include="Character\Player.h" />
    <ClInclude Include="Character\PlayerStates.h" />
    <ClInclude Include="Character\Questlog.h" />
    <ClInclude Include="Character\SkillBook.h" />
    <ClInclude Include="Character\SkillId.h" />
    <ClInclude Include="Character\StatCaps.h" />
    <ClInclude Include="Character\TeleportRock.h" />
    <ClInclude Include="Configuration.h" />
    <ClInclude Include="Constants.h" />
    <ClInclude Include="Data\BulletData.h" />
    <ClInclude Include="Data\EquipData.h" />
    <ClInclude Include="Data\ItemData.h" />
    <ClInclude Include="Data\JobData.h" />
    <ClInclude Include="Data\SkillData.h" />
    <ClInclude Include="Data\WeaponData.h" />
    <ClInclude Include="Error.h" />
    <ClInclude Include="Gameplay\Camera.h" />
    <ClInclude Include="Gameplay\Combat\Attack.h" />
    <ClInclude Include="Gameplay\Combat\Bullet.h" />
    <ClInclude Include="Gameplay\Combat\Combat.h" />
    <ClInclude Include="Gameplay\Combat\DamageNumber.h" />
    <ClInclude Include="Gameplay\Combat\RegularAttack.h" />
    <ClInclude Include="Gameplay\Combat\Skill.h" />
    <ClInclude Include="Gameplay\Combat\SkillAction.h" />
    <ClInclude Include="Gameplay\Combat\SkillBullet.h" />
    <ClInclude Include="Gameplay\Combat\SkillHitEffect.h" />
    <ClInclude Include="Gameplay\Combat\SkillSound.h" />
    <ClInclude Include="Gameplay\Combat\SkillUseEffect.h" />
    <ClInclude Include="Gameplay\Combat\SpecialMove.h" />
    <ClInclude Include="Gameplay\MapleMap\Drop.h" />
    <ClInclude Include="Gameplay\MapleMap\ItemDrop.h" />
    <ClInclude Include="Gameplay\MapleMap\Layer.h" />
    <ClInclude Include="Gameplay\MapleMap\MapBackgrounds.h" />
    <ClInclude Include="Gameplay\MapleMap\MapChars.h" />
    <ClInclude Include="Gameplay\MapleMap\MapDrops.h" />
    <ClInclude Include="Gameplay\MapleMap\MapEffect.h" />
    <ClInclude Include="Gameplay\MapleMap\MapInfo.h" />
    <ClInclude Include="Gameplay\MapleMap\MapMobs.h" />
    <ClInclude Include="Gameplay\MapleMap\MapNpcs.h" />
    <ClInclude Include="Gameplay\MapleMap\MapObject.h" />
    <ClInclude Include="Gameplay\MapleMap\MapObjects.h" />
    <ClInclude Include="Gameplay\MapleMap\MapPortals.h" />
    <ClInclude Include="Gameplay\MapleMap\MapReactors.h" />
    <ClInclude Include="Gameplay\MapleMap\MapTilesObjs.h" />
    <ClInclude Include="Gameplay\MapleMap\MesoDrop.h" />
    <ClInclude Include="Gameplay\MapleMap\Mob.h" />
    <ClInclude Include="Gameplay\MapleMap\Npc.h" />
    <ClInclude Include="Gameplay\MapleMap\Obj.h" />
    <ClInclude Include="Gameplay\MapleMap\Portal.h" />
    <ClInclude Include="Gameplay\MapleMap\Reactor.h" />
    <ClInclude Include="Gameplay\MapleMap\Tile.h" />
    <ClInclude Include="Gameplay\Movement.h" />
    <ClInclude Include="Gameplay\Physics\Foothold.h" />
    <ClInclude Include="Gameplay\Physics\FootholdTree.h" />
    <ClInclude Include="Gameplay\Physics\Physics.h" />
    <ClInclude Include="Gameplay\Physics\PhysicsObject.h" />
    <ClInclude Include="Gameplay\Playable.h" />
    <ClInclude Include="Gameplay\Spawn.h" />
    <ClInclude Include="Gameplay\Stage.h" />
    <ClInclude Include="Graphics\Animation.h" />
    <ClInclude Include="Graphics\Color.h" />
    <ClInclude Include="Graphics\DrawArgument.h" />
    <ClInclude Include="Graphics\EffectLayer.h" />
    <ClInclude Include="Graphics\Geometry.h" />
    <ClInclude Include="Graphics\GraphicsGL.h" />
    <ClInclude Include="Graphics\SpecialText.h" />
    <ClInclude Include="Graphics\Sprite.h" />
    <ClInclude Include="Graphics\Text.h" />
    <ClInclude Include="Graphics\Texture.h" />
    <ClInclude Include="IO\Components\AreaButton.h" />
    <ClInclude Include="IO\Components\Button.h" />
    <ClInclude Include="IO\Components\Charset.h" />
    <ClInclude Include="IO\Components\ChatBalloon.h" />
    <ClInclude Include="IO\Components\EquipTooltip.h" />
    <ClInclude Include="IO\Components\Gauge.h" />
    <ClInclude Include="IO\Components\Icon.h" />
    <ClInclude Include="IO\Components\IconCover.h" />
    <ClInclude Include="IO\Components\ItemTooltip.h" />
    <ClInclude Include="IO\Components\MapleButton.h" />
    <ClInclude Include="IO\Components\MapleComboBox.h" />
    <ClInclude Include="IO\Components\MapleFrame.h" />
    <ClInclude Include="IO\Components\MapTooltip.h" />
    <ClInclude Include="IO\Components\NameTag.h" />
    <ClInclude Include="IO\Components\ScrollingNotice.h" />
    <ClInclude Include="IO\Components\SkillTooltip.h" />
    <ClInclude Include="IO\Components\Slider.h" />
    <ClInclude Include="IO\Components\StatefulIcon.h" />
    <ClInclude Include="IO\Components\Textfield.h" />
    <ClInclude Include="IO\Components\TextTooltip.h" />
    <ClInclude Include="IO\Components\Tooltip.h" />
    <ClInclude Include="IO\Components\TwoSpriteButton.h" />
    <ClInclude Include="IO\Cursor.h" />
    <ClInclude Include="IO\KeyAction.h" />
    <ClInclude Include="IO\Keyboard.h" />
    <ClInclude Include="IO\KeyConfig.h" />
    <ClInclude Include="IO\KeyType.h" />
    <ClInclude Include="IO\Messages.h" />
    <ClInclude Include="IO\UI.h" />
    <ClInclude Include="IO\UIDragElement.h" />
    <ClInclude Include="IO\UIElement.h" />
    <ClInclude Include="IO\UIState.h" />
    <ClInclude Include="IO\UIStateCashShop.h" />
    <ClInclude Include="IO\UIStateGame.h" />
    <ClInclude Include="IO\UIStateLogin.h" />
    <ClInclude Include="IO\UITypes\UIAranCreation.h" />
    <ClInclude Include="IO\UITypes\UIBuffList.h" />
    <ClInclude Include="IO\UITypes\UICashShop.h" />
    <ClInclude Include="IO\UITypes\UIChannel.h" />
    <ClInclude Include="IO\UITypes\UICharInfo.h" />
    <ClInclude Include="IO\UITypes\UICharSelect.h" />
    <ClInclude Include="IO\UITypes\UIChat.h" />
    <ClInclude Include="IO\UITypes\UIChatBar.h" />
    <ClInclude Include="IO\UITypes\UICommonCreation.h" />
    <ClInclude Include="IO\UITypes\UICygnusCreation.h" />
    <ClInclude Include="IO\UITypes\UIEquipInventory.h" />
    <ClInclude Include="IO\UITypes\UIEvent.h" />
    <ClInclude Include="IO\UITypes\UIExplorerCreation.h" />
    <ClInclude Include="IO\UITypes\UIGender.h" />
    <ClInclude Include="IO\UITypes\UIItemInventory.h" />
    <ClInclude Include="IO\UITypes\UIJoypad.h" />
    <ClInclude Include="IO\UITypes\UIKeyConfig.h" />
    <ClInclude Include="IO\UITypes\UILogin.h" />
    <ClInclude Include="IO\UITypes\UILoginNotice.h" />
    <ClInclude Include="IO\UITypes\UILoginWait.h" />
    <ClInclude Include="IO\UITypes\UILogo.h" />
    <ClInclude Include="IO\UITypes\UIMiniMap.h" />
    <ClInclude Include="IO\UITypes\UINotice.h" />
    <ClInclude Include="IO\UITypes\UINpcTalk.h" />
    <ClInclude Include="IO\UITypes\UIOptionMenu.h" />
    <ClInclude Include="IO\UITypes\UIQuestLog.h" />
    <ClInclude Include="IO\UITypes\UIQuit.h" />
    <ClInclude Include="IO\UITypes\UIRaceSelect.h" />
    <ClInclude Include="IO\UITypes\UIRegion.h" />
    <ClInclude Include="IO\UITypes\UIShop.h" />
    <ClInclude Include="IO\UITypes\UISkillBook.h" />
    <ClInclude Include="IO\UITypes\UISoftKey.h" />
    <ClInclude Include="IO\UITypes\UIStatsInfo.h" />
    <ClInclude Include="IO\UITypes\UIStatusBar.h" />
    <ClInclude Include="IO\UITypes\UIStatusMessenger.h" />
    <ClInclude Include="IO\UITypes\UITermsOfService.h" />
    <ClInclude Include="IO\UITypes\UIUserList.h" />
    <ClInclude Include="IO\UITypes\UIWorldMap.h" />
    <ClInclude Include="IO\UITypes\UIWorldSelect.h" />
    <ClInclude Include="IO\Window.h" />
    <ClInclude Include="MapleStory.h" />
    <ClInclude Include="Net\Cryptography.h" />
    <ClInclude Include="Net\Handlers\AttackHandlers.h" />
    <ClInclude Include="Net\Handlers\CashShopHandlers.h" />
    <ClInclude Include="Net\Handlers\CommonHandlers.h" />
    <ClInclude Include="Net\Handlers\Helpers\CashShopParser.h" />
    <ClInclude Include="Net\Handlers\Helpers\CharacterParser.h" />
    <ClInclude Include="Net\Handlers\Helpers\ItemParser.h" />
    <ClInclude Include="Net\Handlers\Helpers\LoginParser.h" />
    <ClInclude Include="Net\Handlers\Helpers\MovementParser.h" />
    <ClInclude Include="Net\Handlers\InventoryHandlers.h" />
    <ClInclude Include="Net\Handlers\LoginHandlers.h" />
    <ClInclude Include="Net\Handlers\MapObjectHandlers.h" />
    <ClInclude Include="Net\Handlers\MessagingHandlers.h" />
    <ClInclude Include="Net\Handlers\NpcInteractionHandlers.h" />
    <ClInclude Include="Net\Handlers\PlayerHandlers.h" />
    <ClInclude Include="Net\Handlers\PlayerInteractionHandlers.h" />
    <ClInclude Include="Net\Handlers\SetFieldHandlers.h" />
    <ClInclude Include="Net\Handlers\TestingHandlers.h" />
    <ClInclude Include="Net\InPacket.h" />
    <ClInclude Include="Net\Login.h" />
    <ClInclude Include="Net\NetConstants.h" />
    <ClInclude Include="Net\OutPacket.h" />
    <ClInclude Include="Net\PacketError.h" />
    <ClInclude Include="Net\PacketHandler.h" />
    <ClInclude Include="Net\PacketSwitch.h" />
    <ClInclude Include="Net\Packets\AttackAndSkillPackets.h" />
    <ClInclude Include="Net\Packets\CharCreationPackets.h" />
    <ClInclude Include="Net\Packets\CommonPackets.h" />
    <ClInclude Include="Net\Packets\GameplayPackets.h" />
    <ClInclude Include="Net\Packets\InventoryPackets.h" />
    <ClInclude Include="Net\Packets\LoginPackets.h" />
    <ClInclude Include="Net\Packets\MessagingPackets.h" />
    <ClInclude Include="Net\Packets\MovementPacket.h" />
    <ClInclude Include="Net\Packets\NpcInteractionPackets.h" />
    <ClInclude Include="Net\Packets\PlayerInteractionPackets.h" />
    <ClInclude Include="Net\Packets\PlayerPackets.h" />
    <ClInclude Include="Net\Packets\SelectCharPackets.h" />
    <ClInclude Include="Net\Session.h" />
    <ClInclude Include="Net\SocketAsio.h" />
    <ClInclude Include="Net\SocketWinsock.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="Template\BoolPair.h" />
    <ClInclude Include="Template\Cache.h" />
    <ClInclude Include="Template\Enumeration.h" />
    <ClInclude Include="Template\EnumMap.h" />
    <ClInclude Include="Template\Interpolated.h" />
    <ClInclude Include="Template\Optional.h" />
    <ClInclude Include="Template\Point.h" />
    <ClInclude Include="Template\Range.h" />
    <ClInclude Include="Template\Rectangle.h" />
    <ClInclude Include="Template\Singleton.h" />
    <ClInclude Include="Template\TimedQueue.h" />
    <ClInclude Include="Template\TypeMap.h" />
    <ClInclude Include="Timer.h" />
    <ClInclude Include="Util\AssetRegistry.h" />
    <ClInclude Include="Util\Assets.h" />
    <ClInclude Include="Util\HardwareInfo.h" />
    <ClInclude Include="Util\Lerp.h" />
    <ClInclude Include="Util\Misc.h" />
    <ClInclude Include="Util\NxFiles.h" />
    <ClInclude Include="Util\QuadTree.h" />
    <ClInclude Include="Util\Randomizer.h" />
    <ClInclude Include="Util\ScreenResolution.h" />
    <ClInclude Include="Util\TimedBool.h" />
    <ClInclude Include="Util\WzFiles.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="MapleStory.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="Icon.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

================
File: MapleStory.vcxproj.filters
================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Configuration.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MapleStory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Audio\Audio.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Inventory\Equip.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Inventory\EquipQuality.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Inventory\Inventory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Inventory\InventoryType.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Inventory\Item.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Inventory\Pet.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Inventory\Weapon.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Look\Afterimage.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Look\Body.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Look\CharEquips.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Look\CharLook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Look\Clothing.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Look\EquipSlot.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Look\Face.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Look\Hair.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Look\PetLook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Look\Stance.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\ActiveBuffs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Buff.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Char.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\CharEffect.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\CharStats.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\EquipStat.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\ExpTable.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Job.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\MapleStat.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\MonsterBook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\OtherChar.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\PassiveBuffs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Player.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\PlayerStates.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\QuestLog.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\SkillBook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\TeleportRock.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Data\BulletData.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Data\EquipData.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Data\ItemData.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Data\JobData.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Data\SkillData.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Data\WeaponData.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Combat\Bullet.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Combat\Combat.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Combat\DamageNumber.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Combat\RegularAttack.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Combat\Skill.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Combat\SkillAction.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Combat\SkillBullet.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Combat\SkillHitEffect.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Combat\SkillSound.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Combat\SkillUseEffect.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\Drop.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\ItemDrop.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\MapBackgrounds.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\MapChars.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\MapDrops.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\MapEffect.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\MapInfo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\MapMobs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\MapNpcs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\MapObject.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\MapObjects.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\MapPortals.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\MapReactors.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\MapTilesObjs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\MesoDrop.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\Mob.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\Npc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\Obj.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\Portal.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\Reactor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\MapleMap\Tile.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Physics\Foothold.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Physics\FootholdTree.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Physics\Physics.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Camera.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Spawn.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gameplay\Stage.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Animation.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Color.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\EffectLayer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Geometry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\GraphicsGL.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Sprite.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Text.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Texture.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\AreaButton.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\Button.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\Charset.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\ChatBalloon.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\EquipTooltip.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\Gauge.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\Icon.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\IconCover.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\ItemTooltip.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\MapleButton.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\MapleComboBox.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\MapleFrame.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\MapTooltip.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\NameTag.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\NpcText.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\ScrollingNotice.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\SkillTooltip.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\Slider.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\StatefulIcon.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\Textfield.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\TextTooltip.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Components\TwoSpriteButton.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIBuffList.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UICashShop.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIChannel.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UICharInfo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UICharSelect.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIChat.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIChatBar.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIEquipInventory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIEvent.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIGender.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIItemInventory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIJoypad.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIKeyConfig.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UILogin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UILoginNotice.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UILoginWait.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UILogo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIMiniMap.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UINotice.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UINpcTalk.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIOptionMenu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIQuestLog.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIQuit.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIRaceSelect.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIRegion.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIShop.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UISkillBook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UISoftKey.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIStatsInfo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIStatusBar.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIStatusMessenger.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UITermsOfService.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIUserList.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIWorldMap.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UIWorldSelect.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Cursor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Keyboard.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Messages.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UIElement.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UIStateCashShop.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UIStateGame.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UIStateLogin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\Window.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\Helpers\CashShopParser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\Helpers\CharacterParser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\Helpers\ItemParser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\Helpers\LoginParser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\Helpers\MovementParser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\AttackHandlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\CashShopHandlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\CommonHandlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\InventoryHandlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\LoginHandlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\MapObjectHandlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\MessagingHandlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\NpcInteractionHandlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\PlayerHandlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\PlayerInteractionHandlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\SetFieldHandlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Handlers\TestingHandlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Cryptography.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\InPacket.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\OutPacket.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\PacketSwitch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\Session.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\SocketAsio.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Net\SocketWinsock.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util\Misc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Character\Look\BodyDrawInfo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util\WzFiles.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util\NxFiles.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IO\UITypes\UICommonCreation.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Configuration.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Constants.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Error.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Timer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MapleStory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Audio\Audio.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Inventory\Equip.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Inventory\EquipQuality.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Inventory\Inventory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Inventory\InventoryType.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Inventory\Item.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Inventory\Pet.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Inventory\Weapon.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Look\Afterimage.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Look\Body.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Look\BodyDrawInfo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Look\CharEquips.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Look\CharLook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Look\Clothing.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Look\EquipSlot.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Look\Face.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Look\Hair.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Look\PetLook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Look\Stance.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\ActiveBuffs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Buff.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Char.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\CharEffect.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\CharStats.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\EquipStat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\ExpTable.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Job.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\MapleStat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\MonsterBook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\OtherChar.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\PassiveBuffs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Player.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\PlayerStates.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\Questlog.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\SkillBook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\SkillId.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\StatCaps.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Character\TeleportRock.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Data\BulletData.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Data\EquipData.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Data\ItemData.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Data\JobData.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Data\SkillData.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Data\WeaponData.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Combat\Attack.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Combat\Bullet.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Combat\Combat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Combat\DamageNumber.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Combat\RegularAttack.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Combat\Skill.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Combat\SkillAction.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Combat\SkillBullet.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Combat\SkillHitEffect.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Combat\SkillSound.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Combat\SkillUseEffect.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Combat\SpecialMove.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\Drop.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\ItemDrop.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\Layer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\MapBackgrounds.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\MapChars.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\MapDrops.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\MapEffect.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\MapInfo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\MapMobs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\MapNpcs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\MapObject.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\MapObjects.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\MapPortals.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\MapReactors.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\MapTilesObjs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\MesoDrop.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\Mob.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\Npc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\Obj.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\Portal.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\Reactor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\MapleMap\Tile.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Physics\Foothold.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Physics\FootholdTree.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Physics\Physics.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Physics\PhysicsObject.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Camera.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Movement.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Playable.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Spawn.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gameplay\Stage.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Animation.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Color.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\DrawArgument.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\EffectLayer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Geometry.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\GraphicsGL.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\SpecialText.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Sprite.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Text.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Texture.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\AreaButton.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\Button.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\Charset.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\ChatBalloon.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\EquipTooltip.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\Gauge.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\Icon.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\IconCover.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\ItemTooltip.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\MapleButton.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\MapleComboBox.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\MapleFrame.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\MapTooltip.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\NameTag.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\ScrollingNotice.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\SkillTooltip.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\Slider.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\StatefulIcon.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\Textfield.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\TextTooltip.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\Tooltip.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Components\TwoSpriteButton.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIAranCreation.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIBuffList.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UICashShop.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIChannel.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UICharInfo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UICharSelect.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIChat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIChatBar.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UICygnusCreation.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIEquipInventory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIEvent.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIExplorerCreation.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIGender.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIItemInventory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIJoypad.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIKeyConfig.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UILogin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UILoginNotice.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UILoginWait.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UILogo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIMiniMap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UINotice.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UINpcTalk.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIOptionMenu.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIQuestLog.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIQuit.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIRaceSelect.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIRegion.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIShop.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UISkillBook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UISoftKey.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIStatsInfo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIStatusBar.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIStatusMessenger.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UITermsOfService.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIUserList.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIWorldMap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UIWorldSelect.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Cursor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\KeyAction.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Keyboard.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\KeyConfig.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\KeyType.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Messages.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UI.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UIDragElement.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UIElement.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UIState.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UIStateCashShop.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UIStateGame.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UIStateLogin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\Window.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\Helpers\CashShopParser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\Helpers\CharacterParser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\Helpers\ItemParser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\Helpers\LoginParser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\Helpers\MovementParser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\AttackHandlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\CashShopHandlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\CommonHandlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\InventoryHandlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\LoginHandlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\MapObjectHandlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\MessagingHandlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\NpcInteractionHandlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\PlayerHandlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\PlayerInteractionHandlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\SetFieldHandlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Handlers\TestingHandlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Packets\AttackAndSkillPackets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Packets\CharCreationPackets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Packets\CommonPackets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Packets\GameplayPackets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Packets\InventoryPackets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Packets\LoginPackets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Packets\MessagingPackets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Packets\MovementPacket.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Packets\NpcInteractionPackets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Packets\PlayerInteractionPackets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Packets\PlayerPackets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Packets\SelectCharPackets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Cryptography.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\InPacket.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Login.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\NetConstants.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\OutPacket.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\PacketError.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\PacketHandler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\PacketSwitch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\Session.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\SocketAsio.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Net\SocketWinsock.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Template\BoolPair.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Template\Cache.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Template\Enumeration.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Template\EnumMap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Template\Interpolated.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Template\Optional.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Template\Point.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Template\Range.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Template\Rectangle.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Template\Singleton.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Template\TimedQueue.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Template\TypeMap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\HardwareInfo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\Lerp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\Misc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\QuadTree.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\Randomizer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\ScreenResolution.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\TimedBool.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\WzFiles.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\NxFiles.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IO\UITypes\UICommonCreation.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="MapleStory.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Icon.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>

================
File: Net/Cryptography.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Cryptography.h"

namespace ms
{
	Cryptography::Cryptography(const int8_t* handshake)
	{
#ifdef USE_CRYPTO
		for (size_t i = 0; i < HEADER_LENGTH; i++)
			sendiv[i] = handshake[i + 7];

		for (size_t i = 0; i < HEADER_LENGTH; i++)
			recviv[i] = handshake[i + 11];
#endif
	}

	Cryptography::Cryptography() {}
	Cryptography::~Cryptography() {}

	void Cryptography::encrypt(int8_t* bytes, size_t length)
	{
#ifdef USE_CRYPTO
		mapleencrypt(bytes, length);
		aesofb(bytes, length, sendiv);
#endif
	}

	void Cryptography::decrypt(int8_t* bytes, size_t length)
	{
#ifdef USE_CRYPTO
		aesofb(bytes, length, recviv);
		mapledecrypt(bytes, length);
#endif
	}

	void Cryptography::create_header(int8_t* buffer, size_t length) const
	{
#ifdef USE_CRYPTO
		static const uint8_t MAPLEVERSION = 83;

		size_t a = ((sendiv[3] << 8) | sendiv[2]) ^ MAPLEVERSION;
		size_t b = a ^ length;

		buffer[0] = static_cast<int8_t>(a % 0x100);
		buffer[1] = static_cast<int8_t>(a / 0x100);
		buffer[2] = static_cast<int8_t>(b % 0x100);
		buffer[3] = static_cast<int8_t>(b / 0x100);
#else
		int32_t length = static_cast<int32_t>(slength);

		for (int32_t i = 0; i < HEADERLEN; i++)
		{
			buffer[i] = static_cast<int8_t>(length);
			length = length >> 8;
		}
#endif
	}

	size_t Cryptography::check_length(const int8_t* bytes) const
	{
#ifdef USE_CRYPTO
		uint32_t headermask = 0;

		for (size_t i = 0; i < 4; i++)
			headermask |= static_cast<uint8_t>(bytes[i]) << (8 * i);

		return static_cast<int16_t>((headermask >> 16) ^ (headermask & 0xFFFF));
#else
		size_t length = 0;

		for (int32_t i = 0; i < HEADERLEN; i++)
			length += static_cast<uint8_t>(bytes[i]) << (8 * i);

		return length;
#endif
	}

	void Cryptography::mapleencrypt(int8_t* bytes, size_t length) const
	{
		for (size_t j = 0; j < 3; j++)
		{
			int8_t remember = 0;
			int8_t datalen = static_cast<int8_t>(length & 0xFF);

			for (size_t i = 0; i < length; i++)
			{
				int8_t cur = (rollleft(bytes[i], 3) + datalen) ^ remember;
				remember = cur;
				cur = rollright(cur, static_cast<int32_t>(datalen) & 0xFF);
				bytes[i] = static_cast<int8_t>((~cur) & 0xFF) + 0x48;
				datalen--;
			}

			remember = 0;
			datalen = static_cast<int8_t>(length & 0xFF);

			for (size_t i = length; i--;)
			{
				int8_t cur = (rollleft(bytes[i], 4) + datalen) ^ remember;
				remember = cur;
				bytes[i] = rollright(cur ^ 0x13, 3);
				datalen--;
			}
		}
	}

	void Cryptography::mapledecrypt(int8_t* bytes, size_t length) const
	{
		for (size_t i = 0; i < 3; i++)
		{
			uint8_t remember = 0;
			uint8_t datalen = static_cast<uint8_t>(length & 0xFF);

			for (size_t j = length; j--;)
			{
				uint8_t cur = rollleft(bytes[j], 3) ^ 0x13;
				bytes[j] = rollright((cur ^ remember) - datalen, 4);
				remember = cur;
				datalen--;
			}

			remember = 0;
			datalen = static_cast<uint8_t>(length & 0xFF);

			for (size_t j = 0; j < length; j++)
			{
				uint8_t cur = (~(bytes[j] - 0x48)) & 0xFF;
				cur = rollleft(cur, static_cast<int32_t>(datalen) & 0xFF);
				bytes[j] = rollright((cur ^ remember) - datalen, 3);
				remember = cur;
				datalen--;
			}
		}
	}

	void Cryptography::updateiv(uint8_t* iv) const
	{
		static const uint8_t maplebytes[256] =
		{
			0xEC, 0x3F, 0x77, 0xA4, 0x45, 0xD0, 0x71, 0xBF, 0xB7, 0x98, 0x20, 0xFC, 0x4B, 0xE9, 0xB3, 0xE1,
			0x5C, 0x22, 0xF7, 0x0C, 0x44, 0x1B, 0x81, 0xBD, 0x63, 0x8D, 0xD4, 0xC3, 0xF2, 0x10, 0x19, 0xE0,
			0xFB, 0xA1, 0x6E, 0x66, 0xEA, 0xAE, 0xD6, 0xCE, 0x06, 0x18, 0x4E, 0xEB, 0x78, 0x95, 0xDB, 0xBA,
			0xB6, 0x42, 0x7A, 0x2A, 0x83, 0x0B, 0x54, 0x67, 0x6D, 0xE8, 0x65, 0xE7, 0x2F, 0x07, 0xF3, 0xAA,
			0x27, 0x7B, 0x85, 0xB0, 0x26, 0xFD, 0x8B, 0xA9, 0xFA, 0xBE, 0xA8, 0xD7, 0xCB, 0xCC, 0x92, 0xDA,
			0xF9, 0x93, 0x60, 0x2D, 0xDD, 0xD2, 0xA2, 0x9B, 0x39, 0x5F, 0x82, 0x21, 0x4C, 0x69, 0xF8, 0x31,
			0x87, 0xEE, 0x8E, 0xAD, 0x8C, 0x6A, 0xBC, 0xB5, 0x6B, 0x59, 0x13, 0xF1, 0x04, 0x00, 0xF6, 0x5A,
			0x35, 0x79, 0x48, 0x8F, 0x15, 0xCD, 0x97, 0x57, 0x12, 0x3E, 0x37, 0xFF, 0x9D, 0x4F, 0x51, 0xF5,
			0xA3, 0x70, 0xBB, 0x14, 0x75, 0xC2, 0xB8, 0x72, 0xC0, 0xED, 0x7D, 0x68, 0xC9, 0x2E, 0x0D, 0x62,
			0x46, 0x17, 0x11, 0x4D, 0x6C, 0xC4, 0x7E, 0x53, 0xC1, 0x25, 0xC7, 0x9A, 0x1C, 0x88, 0x58, 0x2C,
			0x89, 0xDC, 0x02, 0x64, 0x40, 0x01, 0x5D, 0x38, 0xA5, 0xE2, 0xAF, 0x55, 0xD5, 0xEF, 0x1A, 0x7C,
			0xA7, 0x5B, 0xA6, 0x6F, 0x86, 0x9F, 0x73, 0xE6, 0x0A, 0xDE, 0x2B, 0x99, 0x4A, 0x47, 0x9C, 0xDF,
			0x09, 0x76, 0x9E, 0x30, 0x0E, 0xE4, 0xB2, 0x94, 0xA0, 0x3B, 0x34, 0x1D, 0x28, 0x0F, 0x36, 0xE3,
			0x23, 0xB4, 0x03, 0xD8, 0x90, 0xC8, 0x3C, 0xFE, 0x5E, 0x32, 0x24, 0x50, 0x1F, 0x3A, 0x43, 0x8A,
			0x96, 0x41, 0x74, 0xAC, 0x52, 0x33, 0xF0, 0xD9, 0x29, 0x80, 0xB1, 0x16, 0xD3, 0xAB, 0x91, 0xB9,
			0x84, 0x7F, 0x61, 0x1E, 0xCF, 0xC5, 0xD1, 0x56, 0x3D, 0xCA, 0xF4, 0x05, 0xC6, 0xE5, 0x08, 0x49
		};

		uint8_t mbytes[4] =
		{
			0xF2, 0x53, 0x50, 0xC6
		};

		for (size_t i = 0; i < 4; i++)
		{
			uint8_t ivbyte = iv[i];
			mbytes[0] += maplebytes[mbytes[1] & 0xFF] - ivbyte;
			mbytes[1] -= mbytes[2] ^ maplebytes[ivbyte & 0xFF] & 0xFF;
			mbytes[2] ^= maplebytes[mbytes[3] & 0xFF] + ivbyte;
			mbytes[3] += (maplebytes[ivbyte & 0xFF] & 0xFF) - (mbytes[0] & 0xFF);

			size_t mask = 0;
			mask |= (mbytes[0]) & 0xFF;
			mask |= (mbytes[1] << 8) & 0xFF00;
			mask |= (mbytes[2] << 16) & 0xFF0000;
			mask |= (mbytes[3] << 24) & 0xFF000000;
			mask = (mask >> 0x1D) | (mask << 3);

			for (size_t j = 0; j < 4; j++)
			{
				size_t value = mask >> (8 * j);
				mbytes[j] = static_cast<uint8_t>(value & 0xFF);
			}
		}

		for (size_t i = 0; i < 4; i++)
			iv[i] = mbytes[i];
	}

	int8_t Cryptography::rollleft(int8_t data, size_t count) const
	{
		int32_t mask = (data & 0xFF) << (count % 8);

		return static_cast<int8_t>((mask & 0xFF) | (mask >> 8));
	}

	int8_t Cryptography::rollright(int8_t data, size_t count) const
	{
		int32_t mask = ((data & 0xFF) << 8) >> (count % 8);

		return static_cast<int8_t>((mask & 0xFF) | (mask >> 8));
	}

	void Cryptography::aesofb(int8_t* bytes, size_t length, uint8_t* iv) const
	{
		size_t blocklength = 0x5B0;
		size_t offset = 0;

		while (offset < length)
		{
			uint8_t miv[16];

			for (size_t i = 0; i < 16; i++)
				miv[i] = iv[i % 4];

			size_t remaining = length - offset;

			if (remaining > blocklength)
				remaining = blocklength;

			for (size_t x = 0; x < remaining; x++)
			{
				size_t relpos = x % 16;

				if (relpos == 0)
					aesencrypt(miv);

				bytes[x + offset] ^= miv[relpos];
			}

			offset += blocklength;
			blocklength = 0x5B4;
		}

		updateiv(iv);
	}

	void Cryptography::aesencrypt(uint8_t* bytes) const
	{
		uint8_t round = 0;
		addroundkey(bytes, round);

		for (round = 1; round < 14; round++)
		{
			subbytes(bytes);
			shiftrows(bytes);
			mixcolumns(bytes);
			addroundkey(bytes, round);
		}

		subbytes(bytes);
		shiftrows(bytes);
		addroundkey(bytes, round);
	}

	void Cryptography::addroundkey(uint8_t* bytes, uint8_t round) const
	{
		// This key is already expanded
		// Only works for versions lower than version 118
		static const uint8_t maplekey[256] =
		{
			0x13, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xB4, 0x00, 0x00, 0x00,
			0x1B, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00,
			0x71, 0x63, 0x63, 0x00, 0x79, 0x63, 0x63, 0x00, 0x7F, 0x63, 0x63, 0x00, 0xCB, 0x63, 0x63, 0x00,
			0x04, 0xFB, 0xFB, 0x63, 0x0B, 0xFB, 0xFB, 0x63, 0x38, 0xFB, 0xFB, 0x63, 0x6A, 0xFB, 0xFB, 0x63,
			0x7C, 0x6C, 0x98, 0x02, 0x05, 0x0F, 0xFB, 0x02, 0x7A, 0x6C, 0x98, 0x02, 0xB1, 0x0F, 0xFB, 0x02,
			0xCC, 0x8D, 0xF4, 0x14, 0xC7, 0x76, 0x0F, 0x77, 0xFF, 0x8D, 0xF4, 0x14, 0x95, 0x76, 0x0F, 0x77,
			0x40, 0x1A, 0x6D, 0x28, 0x45, 0x15, 0x96, 0x2A, 0x3F, 0x79, 0x0E, 0x28, 0x8E, 0x76, 0xF5, 0x2A,
			0xD5, 0xB5, 0x12, 0xF1, 0x12, 0xC3, 0x1D, 0x86, 0xED, 0x4E, 0xE9, 0x92, 0x78, 0x38, 0xE6, 0xE5,
			0x4F, 0x94, 0xB4, 0x94, 0x0A, 0x81, 0x22, 0xBE, 0x35, 0xF8, 0x2C, 0x96, 0xBB, 0x8E, 0xD9, 0xBC,
			0x3F, 0xAC, 0x27, 0x94, 0x2D, 0x6F, 0x3A, 0x12, 0xC0, 0x21, 0xD3, 0x80, 0xB8, 0x19, 0x35, 0x65,
			0x8B, 0x02, 0xF9, 0xF8, 0x81, 0x83, 0xDB, 0x46, 0xB4, 0x7B, 0xF7, 0xD0, 0x0F, 0xF5, 0x2E, 0x6C,
			0x49, 0x4A, 0x16, 0xC4, 0x64, 0x25, 0x2C, 0xD6, 0xA4, 0x04, 0xFF, 0x56, 0x1C, 0x1D, 0xCA, 0x33,
			0x0F, 0x76, 0x3A, 0x64, 0x8E, 0xF5, 0xE1, 0x22, 0x3A, 0x8E, 0x16, 0xF2, 0x35, 0x7B, 0x38, 0x9E,
			0xDF, 0x6B, 0x11, 0xCF, 0xBB, 0x4E, 0x3D, 0x19, 0x1F, 0x4A, 0xC2, 0x4F, 0x03, 0x57, 0x08, 0x7C,
			0x14, 0x46, 0x2A, 0x1F, 0x9A, 0xB3, 0xCB, 0x3D, 0xA0, 0x3D, 0xDD, 0xCF, 0x95, 0x46, 0xE5, 0x51,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		};

		uint8_t offset = round * 16;

		for (uint8_t i = 0; i < 16; i++)
			bytes[i] ^= maplekey[i + offset];
	}

	void Cryptography::subbytes(uint8_t* bytes) const
	{
		// Rijndael substitution box
		static const uint8_t subbox[256] =
		{
			0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
			0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
			0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
			0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
			0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
			0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
			0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
			0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
			0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
			0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
			0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
			0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
			0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
			0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
			0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
			0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
		};

		for (uint8_t i = 0; i < 16; i++)
			bytes[i] = subbox[bytes[i]];
	}

	void Cryptography::shiftrows(uint8_t* bytes) const
	{
		uint8_t remember = bytes[1];
		bytes[1] = bytes[5];
		bytes[5] = bytes[9];
		bytes[9] = bytes[13];
		bytes[13] = remember;

		remember = bytes[10];
		bytes[10] = bytes[2];
		bytes[2] = remember;

		remember = bytes[3];
		bytes[3] = bytes[15];
		bytes[15] = bytes[11];
		bytes[11] = bytes[7];
		bytes[7] = remember;

		remember = bytes[14];
		bytes[14] = bytes[6];
		bytes[6] = remember;
	}

	uint8_t Cryptography::gmul(uint8_t x) const
	{
		return (x << 1) ^ (0x1B & (uint8_t)((int8_t)x >> 7));
	}

	void Cryptography::mixcolumns(uint8_t* bytes) const
	{
		for (uint8_t i = 0; i < 16; i += 4)
		{
			uint8_t cpy0 = bytes[i];
			uint8_t cpy1 = bytes[i + 1];
			uint8_t cpy2 = bytes[i + 2];
			uint8_t cpy3 = bytes[i + 3];

			uint8_t mul0 = gmul(bytes[i]);
			uint8_t mul1 = gmul(bytes[i + 1]);
			uint8_t mul2 = gmul(bytes[i + 2]);
			uint8_t mul3 = gmul(bytes[i + 3]);

			bytes[i] = mul0 ^ cpy3 ^ cpy2 ^ mul1 ^ cpy1;
			bytes[i + 1] = mul1 ^ cpy0 ^ cpy3 ^ mul2 ^ cpy2;
			bytes[i + 2] = mul2 ^ cpy1 ^ cpy0 ^ mul3 ^ cpy3;
			bytes[i + 3] = mul3 ^ cpy2 ^ cpy1 ^ mul0 ^ cpy0;
		}
	}
}

================
File: Net/Cryptography.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "NetConstants.h"

#include "../MapleStory.h"

namespace ms
{
	// Used to encrypt and decrypt packets for communication with the server
	class Cryptography
	{
	public:
		// Obtain the initialization vector from the handshake
		Cryptography(const int8_t* handshake);
		Cryptography();
		~Cryptography();

		// Encrypt a byte array with the given length and iv
		void encrypt(int8_t* bytes, size_t length);
		// Decrypt a byte array with the given length and iv
		void decrypt(int8_t* bytes, size_t length);
		// Generate a header for the specified length and key
		void create_header(int8_t* buffer, size_t length) const;
		// Use the 4-byte header of a received packet to determine its length
		size_t check_length(const int8_t* header) const;

	private:
		// Add the maple custom encryption
		void mapleencrypt(int8_t* bytes, size_t length) const;
		// Remove the maple custom encryption
		void mapledecrypt(int8_t* bytes, size_t length) const;
		// Update a key
		void updateiv(uint8_t* iv) const;
		// Perform a roll-left operation
		int8_t rollleft(int8_t byte, size_t count) const;
		// Perform a roll-right operation
		int8_t rollright(int8_t byte, size_t count) const;

		// Apply AES OFB to a byte array
		void aesofb(int8_t* bytes, size_t length, uint8_t* iv) const;
		// Encrypt a byte array with AES
		void aesencrypt(uint8_t* bytes) const;
		// AES add round key step
		void addroundkey(uint8_t* bytes, uint8_t round) const;
		// AES sub bytes step
		void subbytes(uint8_t* bytes) const;
		// AES shift rows step
		void shiftrows(uint8_t* bytes) const;
		// AES mix columns step
		void mixcolumns(uint8_t* bytes) const;
		// Perform a Galois multiplication
		uint8_t gmul(uint8_t byte) const;

#ifdef USE_CRYPTO
		uint8_t sendiv[HEADER_LENGTH];
		uint8_t recviv[HEADER_LENGTH];
#endif
	};
}

================
File: Net/Handlers/AttackHandlers.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "AttackHandlers.h"

#include "../../Character/SkillId.h"
#include "../../Gameplay/Stage.h"

namespace ms
{
	AttackHandler::AttackHandler(Attack::Type t)
	{
		type = t;
	}

	void AttackHandler::handle(InPacket& recv) const
	{
		int32_t cid = recv.read_int();
		uint8_t count = recv.read_byte();

		recv.skip(1);

		AttackResult attack;
		attack.type = type;
		attack.attacker = cid;

		attack.level = recv.read_byte();
		attack.skill = (attack.level > 0) ? recv.read_int() : 0;

		attack.display = recv.read_byte();
		attack.toleft = recv.read_bool();
		attack.stance = recv.read_byte();
		attack.speed = recv.read_byte();

		recv.skip(1);

		attack.bullet = recv.read_int();

		attack.mobcount = (count >> 4) & 0xF;
		attack.hitcount = count & 0xF;

		for (uint8_t i = 0; i < attack.mobcount; i++)
		{
			int32_t oid = recv.read_int();

			recv.skip(1);

			uint8_t length = (attack.skill == SkillId::Id::MESO_EXPLOSION) ? recv.read_byte() : attack.hitcount;

			for (uint8_t j = 0; j < length; j++)
			{
				int32_t damage = recv.read_int();
				bool critical = false; // TODO: ?
				auto singledamage = std::make_pair(damage, critical);
				attack.damagelines[oid].push_back(singledamage);
			}
		}

		Stage::get().get_combat().push_attack(attack);
	}
}

================
File: Net/Handlers/AttackHandlers.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../PacketHandler.h"

#include "../../Gameplay/Combat/Attack.h"

namespace ms
{
	class AttackHandler : public PacketHandler
	{
	public:
		void handle(InPacket& recv) const override;

	protected:
		AttackHandler(Attack::Type type);

	private:
		Attack::Type type;
	};

	class CloseAttackHandler : public AttackHandler
	{
	public:
		CloseAttackHandler() : AttackHandler(Attack::Type::CLOSE) {}
	};

	class RangedAttackHandler : public AttackHandler
	{
	public:
		RangedAttackHandler() : AttackHandler(Attack::Type::RANGED) {}
	};

	class MagicAttackHandler : public AttackHandler
	{
	public:
		MagicAttackHandler() : AttackHandler(Attack::Type::MAGIC) {}
	};
}

================
File: Net/Handlers/CashShopHandlers.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "CashShopHandlers.h"

#include "Helpers/CashShopParser.h"

#include "../../Gameplay/Stage.h"
#include "../../IO/UI.h"
#include "../../IO/Window.h"

namespace ms
{
	void SetCashShopHandler::handle(InPacket& recv) const
	{
		CashShopParser::parseCharacterInfo(recv);

		recv.skip_byte();	// Not MTS
		recv.skip_string();	// account_name
		recv.skip_int();

		int16_t specialcashitem_size = recv.read_short();

		for (size_t i = 0; i < specialcashitem_size; i++)
		{
			recv.skip_int();	// sn
			recv.skip_int();	// mod
			recv.skip_byte();	// info
		}

		recv.skip(121);

		for (size_t cat = 1; cat <= 8; cat++)
		{
			for (size_t gender = 0; gender < 2; gender++)
			{
				for (size_t in = 0; in < 5; in++)
				{
					recv.skip_int(); // category
					recv.skip_int(); // gender
					recv.skip_int(); // commoditysn
				}
			}
		}

		recv.skip_int();
		recv.skip_short();
		recv.skip_byte();
		recv.skip_int();

		transition();

		UI::get().change_state(UI::State::CASHSHOP);
	}

	void SetCashShopHandler::transition() const
	{
		Constants::Constants::get().set_viewwidth(1024);
		Constants::Constants::get().set_viewheight(768);

		float fadestep = 0.025f;

		Window::get().fadeout(
			fadestep,
			[]()
			{
				GraphicsGL::get().clear();

				Stage::get().load(-1, 0);

				UI::get().enable();
				Timer::get().start();
				GraphicsGL::get().unlock();
			}
		);

		GraphicsGL::get().lock();
		Stage::get().clear();
		Timer::get().start();
	}
}

================
File: Net/Handlers/CashShopHandlers.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../PacketHandler.h"

namespace ms
{
	// Handler for entering the Cash Shop
	class SetCashShopHandler : public PacketHandler
	{
	public:
		void handle(InPacket& recv) const override;

	private:
		void transition() const;
	};
}

================
File: Net/Handlers/CommonHandlers.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "CommonHandlers.h"

#include "../Packets/CommonPackets.h"

namespace ms
{
	void PingHandler::handle(InPacket&) const
	{
		PongPacket().dispatch();
	}
}

================
File: Net/Handlers/CommonHandlers.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../PacketHandler.h"

namespace ms
{
	class PingHandler : public PacketHandler
	{
		void handle(InPacket&) const override;
	};
}

================
File: Net/Handlers/Helpers/CashShopParser.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "CashShopParser.h"

#include "CharacterParser.h"

#include "../../../Gameplay/Stage.h"

namespace ms
{
	namespace CashShopParser
	{
		StatsEntry parseCharacterInfo(InPacket& recv)
		{
			recv.read_long();
			recv.read_byte();

			StatsEntry statsentry = parseCharStats(recv);

			Player& player = Stage::get().get_player();

			player.get_stats().set_mapid(statsentry.mapid);
			player.get_stats().set_portal(statsentry.portal);

			recv.read_byte(); // 'buddycap'

			if (recv.read_bool())
				recv.read_string(); // 'linkedname'

			CharacterParser::parse_inventory(recv, player.get_inventory());
			CharacterParser::parse_skillbook(recv, player.get_skills());
			CharacterParser::parse_cooldowns(recv, player);
			CharacterParser::parse_questlog(recv, player.get_quests());
			CharacterParser::parse_minigame(recv);
			CharacterParser::parse_ring1(recv);
			CharacterParser::parse_ring2(recv);
			CharacterParser::parse_ring3(recv);
			CharacterParser::parse_teleportrock(recv, player.get_teleportrock());
			CharacterParser::parse_monsterbook(recv, player.get_monsterbook());
			CharacterParser::parse_nyinfo(recv);
			CharacterParser::parse_areainfo(recv);

			player.recalc_stats(true);

			recv.read_short();

			return statsentry;
		}

		StatsEntry parseCharStats(InPacket& recv)
		{
			recv.read_int(); // character id

			// TODO: This is similar to LoginParser.cpp, try and merge these.
			StatsEntry statsentry;

			statsentry.name = recv.read_padded_string(13);
			statsentry.female = recv.read_bool();

			recv.read_byte();	// skin
			recv.read_int();	// face
			recv.read_int();	// hair

			for (size_t i = 0; i < 3; i++)
				statsentry.petids.push_back(recv.read_long());

			statsentry.stats[MapleStat::Id::LEVEL] = recv.read_short();

			auto job = recv.read_short();

			statsentry.stats[MapleStat::Id::JOB] = job;
			statsentry.stats[MapleStat::Id::STR] = recv.read_short();
			statsentry.stats[MapleStat::Id::DEX] = recv.read_short();
			statsentry.stats[MapleStat::Id::INT] = recv.read_short();
			statsentry.stats[MapleStat::Id::LUK] = recv.read_short();
			statsentry.stats[MapleStat::Id::HP] = recv.read_short();
			statsentry.stats[MapleStat::Id::MAXHP] = recv.read_short();
			statsentry.stats[MapleStat::Id::MP] = recv.read_short();
			statsentry.stats[MapleStat::Id::MAXMP] = recv.read_short();
			statsentry.stats[MapleStat::Id::AP] = recv.read_short();

			if (hasSPTable(job))
				parseRemainingSkillInfo(recv);
			else
				recv.read_short(); // remaining sp

			statsentry.exp = recv.read_int();
			statsentry.stats[MapleStat::Id::FAME] = recv.read_short();

			recv.skip(4); // gachaexp

			statsentry.mapid = recv.read_int();
			statsentry.portal = recv.read_byte();

			recv.skip(4); // timestamp

			return statsentry;
		}

		bool hasSPTable(int16_t job)
		{
			switch (job)
			{
				case Jobs::EVAN:
				case Jobs::EVAN1:
				case Jobs::EVAN2:
				case Jobs::EVAN3:
				case Jobs::EVAN4:
				case Jobs::EVAN5:
				case Jobs::EVAN6:
				case Jobs::EVAN7:
				case Jobs::EVAN8:
				case Jobs::EVAN9:
				case Jobs::EVAN10:
					return true;
				default:
					return false;
			}
		}

		void parseRemainingSkillInfo(InPacket& recv)
		{
			int count = recv.read_byte();

			for (int i = 0; i < count; i++)
			{
				recv.read_byte(); // Remaining SP index for job 
				recv.read_byte(); // The actual SP for that class
			}
		}
	}
}

================
File: Net/Handlers/Helpers/CashShopParser.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../InPacket.h"
#include "../../Login.h"

namespace ms
{
	namespace CashShopParser
	{
		enum Jobs : uint16_t
		{
			EVAN = 2001,
			EVAN1 = 2200,
			EVAN2 = 2210,
			EVAN3 = 2211,
			EVAN4 = 2212,
			EVAN5 = 2213,
			EVAN6 = 2214,
			EVAN7 = 2215,
			EVAN8 = 2216,
			EVAN9 = 2217,
			EVAN10 = 2218
		};

		StatsEntry parseCharacterInfo(InPacket& recv);
		StatsEntry parseCharStats(InPacket& recv);
		bool hasSPTable(int16_t job);
		void parseRemainingSkillInfo(InPacket& recv);
	}
}

================
File: Net/Handlers/Helpers/CharacterParser.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "CharacterParser.h"

#include "ItemParser.h"

namespace ms
{
	void CharacterParser::parse_inventory(InPacket& recv, Inventory& invent)
	{
		invent.set_meso(recv.read_int());
		invent.set_slotmax(InventoryType::EQUIP, recv.read_byte());
		invent.set_slotmax(InventoryType::USE, recv.read_byte());
		invent.set_slotmax(InventoryType::SETUP, recv.read_byte());
		invent.set_slotmax(InventoryType::ETC, recv.read_byte());
		invent.set_slotmax(InventoryType::CASH, recv.read_byte());

		recv.skip(8);

		for (size_t i = 0; i < 3; i++)
		{
			InventoryType::Id inv = (i == 0) ? InventoryType::EQUIPPED : InventoryType::EQUIP;
			int16_t pos = recv.read_short();

			while (pos != 0)
			{
				int16_t slot = (i == 1) ? -pos : pos;
				ItemParser::parse_item(recv, inv, slot, invent);
				pos = recv.read_short();
			}
		}

		recv.skip(2);

		InventoryType::Id toparse[4] =
		{
			InventoryType::USE, InventoryType::SETUP, InventoryType::ETC, InventoryType::CASH
		};

		for (size_t i = 0; i < 4; i++)
		{
			InventoryType::Id inv = toparse[i];
			int8_t pos = recv.read_byte();

			while (pos != 0)
			{
				ItemParser::parse_item(recv, inv, pos, invent);
				pos = recv.read_byte();
			}
		}
	}

	void CharacterParser::parse_skillbook(InPacket& recv, SkillBook& skills)
	{
		int16_t size = recv.read_short();

		for (int16_t i = 0; i < size; i++)
		{
			int32_t skill_id = recv.read_int();
			int32_t level = recv.read_int();
			int64_t expiration = recv.read_long();
			bool fourthtjob = ((skill_id % 100000) / 10000 == 2);
			int32_t masterlevel = fourthtjob ? recv.read_int() : 0;
			skills.set_skill(skill_id, level, masterlevel, expiration);
		}
	}

	void CharacterParser::parse_cooldowns(InPacket& recv, Player& player)
	{
		int16_t size = recv.read_short();

		for (int16_t i = 0; i < size; i++)
		{
			int32_t skill_id = recv.read_int();
			int32_t cooltime = recv.read_short();
			player.add_cooldown(skill_id, cooltime);
		}
	}

	void CharacterParser::parse_questlog(InPacket& recv, QuestLog& quests)
	{
		int16_t size = recv.read_short();

		for (int16_t i = 0; i < size; i++)
		{
			int16_t qid = recv.read_short();
			std::string qdata = recv.read_string();

			if (quests.is_started(qid))
			{
				int16_t qidl = quests.get_last_started();
				quests.add_in_progress(qidl, qid, qdata);
				//i--; // This was causing issues
			}
			else
			{
				quests.add_started(qid, qdata);
			}
		}

		std::map<int16_t, int64_t> completed;
		size = recv.read_short();

		for (int16_t i = 0; i < size; i++)
		{
			int16_t qid = recv.read_short();
			int64_t time = recv.read_long();
			quests.add_completed(qid, time);
		}
	}

	void CharacterParser::parse_ring1(InPacket& recv)
	{
		int16_t rsize = recv.read_short();

		for (int16_t i = 0; i < rsize; i++)
		{
			recv.read_int();
			recv.read_padded_string(13);
			recv.read_int();
			recv.read_int();
			recv.read_int();
			recv.read_int();
		}
	}

	void CharacterParser::parse_ring2(InPacket& recv)
	{
		int16_t rsize = recv.read_short();

		for (int16_t i = 0; i < rsize; i++)
		{
			recv.read_int();
			recv.read_padded_string(13);
			recv.read_int();
			recv.read_int();
			recv.read_int();
			recv.read_int();
			recv.read_int();
		}
	}

	void CharacterParser::parse_ring3(InPacket& recv)
	{
		int16_t rsize = recv.read_short();

		for (int16_t i = 0; i < rsize; i++)
		{
			recv.read_int();
			recv.read_int();
			recv.read_int();
			recv.read_short();
			recv.read_int();
			recv.read_int();
			recv.read_padded_string(13);
			recv.read_padded_string(13);
		}
	}

	void CharacterParser::parse_minigame(InPacket& recv)
	{
		recv.skip(2);
	}

	void CharacterParser::parse_monsterbook(InPacket& recv, MonsterBook& monsterbook)
	{
		monsterbook.set_cover(recv.read_int());

		recv.skip(1);

		int16_t size = recv.read_short();

		for (int16_t i = 0; i < size; i++)
		{
			int16_t cid = recv.read_short();
			int8_t mblv = recv.read_byte();

			monsterbook.add_card(cid, mblv);
		}
	}

	void CharacterParser::parse_teleportrock(InPacket& recv, TeleportRock& teleportrock)
	{
		for (size_t i = 0; i < 5; i++)
			teleportrock.addlocation(recv.read_int());

		for (size_t i = 0; i < 10; i++)
			teleportrock.addviplocation(recv.read_int());
	}

	void CharacterParser::parse_nyinfo(InPacket& recv)
	{
		int16_t nysize = recv.read_short();

		for (int16_t i = 0; i < nysize; i++)
		{
			recv.read_int();	// NewYear Id
			recv.read_int();	// NewYear SenderId
			recv.read_string();	// NewYear SenderName
			recv.read_bool();	// NewYear enderCardDiscarded
			recv.read_long();	// NewYear DateSent
			recv.read_int();	// NewYear ReceiverId
			recv.read_string();	// NewYear ReceiverName
			recv.read_bool();	// NewYear eceiverCardDiscarded
			recv.read_bool();	// NewYear eceiverCardReceived
			recv.read_long();	// NewYear DateReceived
			recv.read_string();	// NewYear Message
		}
	}

	void CharacterParser::parse_areainfo(InPacket& recv)
	{
		std::map<int16_t, std::string> areainfo;
		int16_t arsize = recv.read_short();

		for (int16_t i = 0; i < arsize; i++)
		{
			int16_t area = recv.read_short();
			areainfo[area] = recv.read_string();
		}
	}
}

================
File: Net/Handlers/Helpers/CharacterParser.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../InPacket.h"

#include "../../../Character/Player.h"

namespace ms
{
	namespace CharacterParser
	{
		void parse_inventory(InPacket& recv, Inventory& inventory);
		void parse_skillbook(InPacket& recv, SkillBook& skills);
		void parse_cooldowns(InPacket& recv, Player& player);
		void parse_questlog(InPacket& recv, QuestLog& quests);
		void parse_ring1(InPacket& recv);
		void parse_ring2(InPacket& recv);
		void parse_ring3(InPacket& recv);
		void parse_minigame(InPacket& recv);
		void parse_monsterbook(InPacket& recv, MonsterBook& monsterbook);
		void parse_teleportrock(InPacket& recv, TeleportRock& teleportrock);
		void parse_nyinfo(InPacket& recv);
		void parse_areainfo(InPacket& recv);
	}
}

================
File: Net/Handlers/Helpers/ItemParser.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "ItemParser.h"

namespace ms
{
	namespace ItemParser
	{
		// Parse a normal item from a packet
		void add_item(InPacket& recv, InventoryType::Id invtype, int16_t slot, int32_t id, Inventory& inventory)
		{
			// Read all item stats
			bool cash = recv.read_bool();

			if (cash)
				recv.skip(8); // unique id

			int64_t expire = recv.read_long();
			int16_t count = recv.read_short();
			std::string owner = recv.read_string();
			int16_t flag = recv.read_short();

			// If the item is a rechargeable projectile, some additional bytes are sent.
			if ((id / 10000 == 233) || (id / 10000 == 207))
				recv.skip(8);

			inventory.add_item(invtype, slot, id, cash, expire, count, owner, flag);
		}

		// Parse a pet from a packet
		void add_pet(InPacket& recv, InventoryType::Id invtype, int16_t slot, int32_t id, Inventory& inventory)
		{
			// Read all pet stats
			bool cash = recv.read_bool();

			if (cash)
				recv.skip(8); // unique id

			int64_t expire = recv.read_long();
			std::string petname = recv.read_padded_string(13);
			int8_t petlevel = recv.read_byte();
			int16_t closeness = recv.read_short();
			int8_t fullness = recv.read_byte();

			// Some unused bytes
			recv.skip(18);

			inventory.add_pet(invtype, slot, id, cash, expire, petname, petlevel, closeness, fullness);
		}

		// Parse an equip from a packet
		void add_equip(InPacket& recv, InventoryType::Id invtype, int16_t slot, int32_t id, Inventory& inventory)
		{
			// Read equip information
			bool cash = recv.read_bool();

			if (cash)
				recv.skip(8); // unique id

			int64_t expire = recv.read_long();
			uint8_t slots = recv.read_byte();
			uint8_t level = recv.read_byte();

			// Read equip stats
			EnumMap<EquipStat::Id, uint16_t> stats;

			for (auto iter : stats)
				iter.second = recv.read_short();

			// Some more information
			std::string owner = recv.read_string();
			int16_t flag = recv.read_short();
			uint8_t itemlevel = 0;
			uint16_t itemexp = 0;
			int32_t vicious = 0;

			if (cash)
			{
				// Some unused bytes
				recv.skip(10);
			}
			else
			{
				recv.read_byte();
				itemlevel = recv.read_byte();
				recv.read_short();
				itemexp = recv.read_short();
				vicious = recv.read_int();
				recv.read_long();
			}

			recv.skip(12);

			if (slot < 0)
			{
				invtype = InventoryType::Id::EQUIPPED;
				slot = -slot;
			}

			inventory.add_equip(invtype, slot, id, cash, expire, slots, level, stats, owner, flag, itemlevel, itemexp, vicious);
		}

		void parse_item(InPacket& recv, InventoryType::Id invtype, int16_t slot, Inventory& inventory)
		{
			// Read type and item id
			recv.read_byte(); // 'type' byte
			int32_t iid = recv.read_int();

			if (invtype == InventoryType::Id::EQUIP || invtype == InventoryType::Id::EQUIPPED)
			{
				// Parse an equip
				add_equip(recv, invtype, slot, iid, inventory);
			}
			else if (iid >= 5000000 && iid <= 5000102)
			{
				// Parse a pet
				add_pet(recv, invtype, slot, iid, inventory);
			}
			else
			{
				// Parse a normal item
				add_item(recv, invtype, slot, iid, inventory);
			}
		}
	}
}

================
File: Net/Handlers/Helpers/ItemParser.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../InPacket.h"

#include "../../../Character/Inventory/Inventory.h"

namespace ms
{
	namespace ItemParser
	{
		void parse_item(InPacket& recv, InventoryType::Id invtype, int16_t slot, Inventory& inventory);
	}
}

================
File: Net/Handlers/Helpers/LoginParser.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "LoginParser.h"

#include "../../Session.h"

namespace ms
{
	Account LoginParser::parse_account(InPacket& recv)
	{
		Account account;

		recv.skip_short();

		account.accid = recv.read_int();
		account.female = recv.read_byte();
		account.admin = recv.read_bool();

		recv.skip_byte(); // Admin
		recv.skip_byte(); // Country Code

		account.name = recv.read_string();

		recv.skip_byte();

		account.muted = recv.read_bool();

		recv.skip_long(); // muted until
		recv.skip_long(); // creation date

		recv.skip_int(); // Remove "Select the world you want to play in"

		account.pin = recv.read_bool(); // 0 - Enabled, 1 - Disabled
		account.pic = recv.read_byte(); // 0 - Register, 1 - Ask, 2 - Disabled

		return account;
	}

	World LoginParser::parse_world(InPacket& recv)
	{
		int8_t wid = recv.read_byte();

		if (wid == -1)
			return { {}, {}, {}, 0, 0, wid };

		std::string name = recv.read_string();
		uint8_t flag = recv.read_byte();
		std::string event_message = recv.read_string();

		recv.skip(5);

		std::vector<int32_t> channelload;
		uint8_t channelload_size = recv.read_byte();

		for (uint8_t i = 0; i < channelload_size; ++i)
		{
			recv.skip_string(); // channel name

			channelload.push_back(recv.read_int());

			recv.skip_byte(); // world id
			recv.skip_byte(); // channel id
			recv.skip_bool(); // adult channel
		}

		recv.skip_short();

		return { name, event_message, channelload, channelload_size, flag, wid };
	}

	CharEntry LoginParser::parse_charentry(InPacket& recv)
	{
		int32_t cid = recv.read_int();
		StatsEntry stats = parse_stats(recv);
		LookEntry look = parse_look(recv);

		recv.read_bool(); // 'rankinfo' bool

		if (recv.read_bool())
		{
			int32_t currank = recv.read_int();
			int32_t rankmv = recv.read_int();
			int32_t curjobrank = recv.read_int();
			int32_t jobrankmv = recv.read_int();
			int8_t rankmc = (rankmv > 0) ? '+' : (rankmv < 0) ? '-' : '=';
			int8_t jobrankmc = (jobrankmv > 0) ? '+' : (jobrankmv < 0) ? '-' : '=';

			stats.rank = std::make_pair(currank, rankmc);
			stats.jobrank = std::make_pair(curjobrank, jobrankmc);
		}

		return { stats, look, cid };
	}

	StatsEntry LoginParser::parse_stats(InPacket& recv)
	{
		// TODO: This is similar to CashShopParser.cpp, try and merge these.
		StatsEntry statsentry;

		statsentry.name = recv.read_padded_string(13);
		statsentry.female = recv.read_bool();

		recv.read_byte();	// skin
		recv.read_int();	// face
		recv.read_int();	// hair

		for (size_t i = 0; i < 3; i++)
			statsentry.petids.push_back(recv.read_long());

		statsentry.stats[MapleStat::Id::LEVEL] = recv.read_short();
		statsentry.stats[MapleStat::Id::JOB] = recv.read_short();
		statsentry.stats[MapleStat::Id::STR] = recv.read_short();
		statsentry.stats[MapleStat::Id::DEX] = recv.read_short();
		statsentry.stats[MapleStat::Id::INT] = recv.read_short();
		statsentry.stats[MapleStat::Id::LUK] = recv.read_short();
		statsentry.stats[MapleStat::Id::HP] = recv.read_short();
		statsentry.stats[MapleStat::Id::MAXHP] = recv.read_short();
		statsentry.stats[MapleStat::Id::MP] = recv.read_short();
		statsentry.stats[MapleStat::Id::MAXMP] = recv.read_short();
		statsentry.stats[MapleStat::Id::AP] = recv.read_short();
		statsentry.stats[MapleStat::Id::SP] = recv.read_short();
		statsentry.exp = recv.read_int();
		statsentry.stats[MapleStat::Id::FAME] = recv.read_short();

		recv.skip(4); // gachaexp

		statsentry.mapid = recv.read_int();
		statsentry.portal = recv.read_byte();

		recv.skip(4); // timestamp

		return statsentry;
	}

	LookEntry LoginParser::parse_look(InPacket& recv)
	{
		LookEntry look;

		look.female = recv.read_bool();
		look.skin = recv.read_byte();
		look.faceid = recv.read_int();

		recv.read_bool(); // megaphone

		look.hairid = recv.read_int();

		uint8_t eqslot = recv.read_byte();

		while (eqslot != 0xFF)
		{
			look.equips[eqslot] = recv.read_int();
			eqslot = recv.read_byte();
		}

		uint8_t mskeqslot = recv.read_byte();

		while (mskeqslot != 0xFF)
		{
			look.maskedequips[mskeqslot] = recv.read_int();
			mskeqslot = recv.read_byte();
		}

		look.maskedequips[-111] = recv.read_int();

		for (uint8_t i = 0; i < 3; i++)
			look.petids.push_back(recv.read_int());

		return look;
	}

	void LoginParser::parse_login(InPacket& recv)
	{
		recv.skip_byte();

		// Read the IPv4 address in a string
		std::string addrstr;

		for (size_t i = 0; i < 4; i++)
		{
			uint8_t num = static_cast<uint8_t>(recv.read_byte());
			addrstr.append(std::to_string(num));

			if (i < 3)
				addrstr.push_back('.');
		}

		// Read the port address in a string
		std::string portstr = std::to_string(recv.read_short());

		// Attempt to reconnect to the server
		Session::get().reconnect(addrstr.c_str(), portstr.c_str());
	}
}

================
File: Net/Handlers/Helpers/LoginParser.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../InPacket.h"
#include "../../Login.h"

namespace ms
{
	namespace LoginParser
	{
		Account parse_account(InPacket& recv);
		World parse_world(InPacket& recv);
		CharEntry parse_charentry(InPacket& recv);
		StatsEntry parse_stats(InPacket& recv);
		LookEntry parse_look(InPacket& recv);
		void parse_login(InPacket& recv);
	}
}

================
File: Net/Handlers/Helpers/MovementParser.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MovementParser.h"

namespace ms
{
	std::vector<Movement> MovementParser::parse_movements(InPacket& recv)
	{
		std::vector<Movement> movements;
		uint8_t length = recv.read_byte();

		for (uint8_t i = 0; i < length; ++i)
		{
			Movement fragment;
			fragment.command = recv.read_byte();

			switch (fragment.command)
			{
			case 0:
			case 5:
			case 17:
				fragment.type = Movement::ABSOLUTE;
				fragment.xpos = recv.read_short();
				fragment.ypos = recv.read_short();
				fragment.lastx = recv.read_short();
				fragment.lasty = recv.read_short();
				fragment.fh = recv.read_short();
				fragment.newstate = recv.read_byte();
				fragment.duration = recv.read_short();
				break;
			case 1:
			case 2:
			case 6:
			case 12:
			case 13:
			case 16:
				fragment.type = Movement::RELATIVE;
				fragment.xpos = recv.read_short();
				fragment.ypos = recv.read_short();
				fragment.newstate = recv.read_byte();
				fragment.duration = recv.read_short();
				break;
			case 11:
				fragment.type = Movement::CHAIR;
				fragment.xpos = recv.read_short();
				fragment.ypos = recv.read_short();
				recv.skip(2);
				fragment.newstate = recv.read_byte();
				fragment.duration = recv.read_short();
				break;
			case 15:
				fragment.type = Movement::JUMPDOWN;
				fragment.xpos = recv.read_short();
				fragment.ypos = recv.read_short();
				fragment.lastx = recv.read_short();
				fragment.lasty = recv.read_short();
				recv.skip(2);
				fragment.fh = recv.read_short();
				fragment.newstate = recv.read_byte();
				fragment.duration = recv.read_short();
				break;
			case 3:
			case 4:
			case 7:
			case 8:
			case 9:
			case 14:
				fragment.type = Movement::NONE;
				break;
			case 10:
				fragment.type = Movement::NONE;
				// Change equip
				break;
			}

			movements.push_back(fragment);
		}

		return movements;
	}
}

================
File: Net/Handlers/Helpers/MovementParser.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../../InPacket.h"

#include "../../../Gameplay/Movement.h"

#include <vector>

namespace ms
{
	namespace MovementParser
	{
		std::vector<Movement> parse_movements(InPacket& recv);
	}
}

================
File: Net/Handlers/InventoryHandlers.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "InventoryHandlers.h"

#include "Helpers/ItemParser.h"

#include "../../Gameplay/Stage.h"
#include "../../IO/UI.h"

#include "../../IO/UITypes/UIEquipInventory.h"
#include "../../IO/UITypes/UIItemInventory.h"
#include "../../IO/UITypes/UIKeyConfig.h"
#include "../../IO/UITypes/UIShop.h"

namespace ms
{
	void GatherResultHandler::handle(InPacket&) const
	{
		if (auto iteminventory = UI::get().get_element<UIItemInventory>())
			iteminventory->set_sort(true);
	}

	void SortResultHandler::handle(InPacket&) const
	{
		if (auto iteminventory = UI::get().get_element<UIItemInventory>())
		{
			iteminventory->set_sort(false);
			iteminventory->clear_new();
		}
	}

	void ModifyInventoryHandler::handle(InPacket& recv) const
	{
		recv.read_bool(); // 'updatetick'

		Inventory& inventory = Stage::get()
			.get_player()
			.get_inventory();

		struct Mod
		{
			int8_t mode;
			InventoryType::Id type;
			int16_t pos;
			int16_t arg;
		};

		std::vector<Mod> mods;

		int8_t size = recv.read_byte();

		for (int8_t i = 0; i < size; i++)
		{
			Mod mod;
			mod.mode = recv.read_byte();
			mod.type = InventoryType::by_value(recv.read_byte());
			mod.pos = recv.read_short();

			mod.arg = 0;

			switch (mod.mode)
			{
			case Inventory::Modification::ADD:
				ItemParser::parse_item(recv, mod.type, mod.pos, inventory);

				if (auto keyconfig = UI::get().get_element<UIKeyConfig>())
				{
					int16_t count_now = inventory.get_item_count(mod.type, mod.pos);
					keyconfig->update_item_count(mod.type, mod.pos, count_now);
				}

				break;
			case Inventory::Modification::CHANGECOUNT:
			{
				mod.arg = recv.read_short();

				int16_t count_before = inventory.get_item_count(mod.type, mod.pos);
				int16_t count_now = mod.arg;

				inventory.modify(mod.type, mod.pos, mod.mode, mod.arg, Inventory::Movement::MOVE_NONE);

				if (auto keyconfig = UI::get().get_element<UIKeyConfig>())
					keyconfig->update_item_count(mod.type, mod.pos, count_now - count_before);

				if (count_before < count_now)
					mod.mode = Inventory::Modification::ADDCOUNT;
			}
			break;
			case Inventory::Modification::SWAP:
				mod.arg = recv.read_short();
				break;
			case Inventory::Modification::REMOVE:
				if (auto keyconfig = UI::get().get_element<UIKeyConfig>())
				{
					int16_t count_before = inventory.get_item_count(mod.type, mod.pos);
					keyconfig->update_item_count(mod.type, mod.pos, -1 * count_before);
				}

				inventory.modify(mod.type, mod.pos, mod.mode, mod.arg, Inventory::Movement::MOVE_INTERNAL);
				break;
			}

			mods.push_back(mod);
		}

		Inventory::Movement move = (recv.length() > 0) ?
			Inventory::movementbyvalue(recv.read_byte()) :
			Inventory::Movement::MOVE_INTERNAL;

		for (const Mod& mod : mods)
		{
			if (mod.mode == 2)
				inventory.modify(mod.type, mod.pos, mod.mode, mod.arg, move);

			if (auto shop = UI::get().get_element<UIShop>())
				shop->modify(mod.type);

			auto eqinvent = UI::get().get_element<UIEquipInventory>();
			auto itinvent = UI::get().get_element<UIItemInventory>();

			switch (move)
			{
			case Inventory::Movement::MOVE_INTERNAL:
				switch (mod.type)
				{
				case InventoryType::Id::EQUIPPED:
					if (eqinvent)
						eqinvent->modify(mod.pos, mod.mode, mod.arg);

					Stage::get().get_player().change_equip(-mod.pos);
					Stage::get().get_player().change_equip(-mod.arg);
					break;
				case InventoryType::Id::EQUIP:
				case InventoryType::Id::USE:
				case InventoryType::Id::SETUP:
				case InventoryType::Id::ETC:
				case InventoryType::Id::CASH:
					if (itinvent)
						itinvent->modify(mod.type, mod.pos, mod.mode, mod.arg);

					break;
				}

				break;
			case Inventory::Movement::MOVE_EQUIP:
			case Inventory::Movement::MOVE_UNEQUIP:
				if (mod.pos < 0)
				{
					if (eqinvent)
						eqinvent->modify(-mod.pos, 3, 0);

					if (itinvent)
						itinvent->modify(InventoryType::Id::EQUIP, mod.arg, mod.mode, 0);

					Stage::get().get_player().change_equip(-mod.pos);
				}
				else if (mod.arg < 0)
				{
					if (eqinvent)
						eqinvent->modify(-mod.arg, 0, 0);

					if (itinvent)
						itinvent->modify(InventoryType::Id::EQUIP, mod.pos, Inventory::Modification::REMOVE, 0);

					Stage::get().get_player().change_equip(-mod.arg);
				}

				break;
			}
		}

		Stage::get().get_player().recalc_stats(true);
		UI::get().enable();
	}
}

================
File: Net/Handlers/InventoryHandlers.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../PacketHandler.h"

namespace ms
{
	// Handler for a packet which signifies that inventory items were gathered
	class GatherResultHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Handler for a packet which signifies that inventory items were sorted
	class SortResultHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Handler for a packet which modifies the player's inventory
	class ModifyInventoryHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};
}

================
File: Net/Handlers/LoginHandlers.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "LoginHandlers.h"

#include "Helpers/LoginParser.h"

#include "../Packets/LoginPackets.h"

#include "../../IO/UI.h"

#include "../../IO/UITypes/UICharSelect.h"
#include "../../IO/UITypes/UIGender.h"
#include "../../IO/UITypes/UILoginNotice.h"
#include "../../IO/UITypes/UILoginWait.h"
#include "../../IO/UITypes/UIRaceSelect.h"
#include "../../IO/UITypes/UITermsOfService.h"
#include "../../IO/UITypes/UIWorldSelect.h"

namespace ms
{
	void LoginResultHandler::handle(InPacket& recv) const
	{
		auto loginwait = UI::get().get_element<UILoginWait>();

		if (loginwait && loginwait->is_active())
		{
			// Remove previous UIs
			UI::get().remove(UIElement::Type::LOGINNOTICE);
			UI::get().remove(UIElement::Type::LOGINWAIT);
			UI::get().remove(UIElement::Type::TOS);
			UI::get().remove(UIElement::Type::GENDER);

			std::function<void()> okhandler = loginwait->get_handler();

			// The packet should contain a 'reason' integer which can signify various things
			if (int32_t reason = recv.read_int())
			{
				// Login unsuccessful
				// The LoginNotice displayed will contain the specific information
				switch (reason)
				{
					case 2:
					{
						UI::get().emplace<UILoginNotice>(UILoginNotice::Message::BLOCKED_ID, okhandler);
						break;
					}
					case 5:
					{
						UI::get().emplace<UILoginNotice>(UILoginNotice::Message::NOT_REGISTERED, okhandler);
						break;
					}
					case 7:
					{
						UI::get().emplace<UILoginNotice>(UILoginNotice::Message::ALREADY_LOGGED_IN, okhandler);
						break;
					}
					case 13:
					{
						UI::get().emplace<UILoginNotice>(UILoginNotice::Message::UNABLE_TO_LOGIN_WITH_IP, okhandler);
						break;
					}
					case 23:
					{
						UI::get().emplace<UITermsOfService>(okhandler);
						break;
					}
					default:
					{
						// Other reasons
						if (reason > 0)
						{
							auto reasonbyte = static_cast<int8_t>(reason - 1);

							UI::get().emplace<UILoginNotice>(reasonbyte, okhandler);
						}

						break;
					}
				}
			}
			else
			{
				// Login successful
				// The packet contains information on the account, so we initialize the account with it.
				Account account = LoginParser::parse_account(recv);

				Configuration::get().set_admin(account.admin);

				if (account.female == 10)
				{
					UI::get().emplace<UIGender>(okhandler);
				}
				else
				{
					// Save the "Login ID" if the box for it on the login screen is checked
					if (Setting<SaveLogin>::get().load())
						Setting<DefaultAccount>::get().save(account.name);

					// Request the list of worlds and channels online
					ServerRequestPacket().dispatch();
				}
			}
		}
	}

	void ServerStatusHandler::handle(InPacket& recv) const
	{
		// Possible values for status:
		// 0 - Normal
		// 1 - Highly populated
		// 2 - Full
		recv.read_short(); // status

		// TODO: I believe it shows a warning message if it's 1 and blocks enter into the world if it's 2. Need to find those messages.
	}

	void SelectCharacterHandler::handle(InPacket& recv) const
	{
		std::function<void()> okhandler = []() {};

		// The packet should contain a 'reason' integer which can signify various things
		if (int16_t reason = recv.read_short())
		{
			// Select character unsuccessful
			// The LoginNotice displayed will contain the specific information
			switch (reason)
			{
				case 2:
				{
					UI::get().emplace<UILoginNotice>(UILoginNotice::Message::BLOCKED_ID, okhandler);
					break;
				}
				case 5:
				{
					UI::get().emplace<UILoginNotice>(UILoginNotice::Message::NOT_REGISTERED, okhandler);
					break;
				}
				case 7:
				{
					UI::get().emplace<UILoginNotice>(UILoginNotice::Message::ALREADY_LOGGED_IN, okhandler);
					break;
				}
				case 13:
				{
					UI::get().emplace<UILoginNotice>(UILoginNotice::Message::UNABLE_TO_LOGIN_WITH_IP, okhandler);
					break;
				}
				case 23:
				{
					UI::get().emplace<UITermsOfService>(okhandler);
					break;
				}
				default:
				{
					// Other reasons
					if (reason > 0)
					{
						auto reasonbyte = static_cast<int8_t>(reason - 1);

						UI::get().emplace<UILoginNotice>(reasonbyte, okhandler);
					}

					break;
				}
			}
		}
	}

	void ServerlistHandler::handle(InPacket& recv) const
	{
		auto worldselect = UI::get().get_element<UIWorldSelect>();

		if (!worldselect)
			worldselect = UI::get().emplace<UIWorldSelect>();

		// Parse all worlds
		while (recv.available())
		{
			World world = LoginParser::parse_world(recv);

			if (world.id != -1)
			{
				worldselect->add_world(world);
			}
			else
			{
				// Remove previous UIs
				UI::get().remove(UIElement::Type::LOGIN);

				// Add the world selection screen to the UI
				worldselect->draw_world();

				// End of packet
				return;
			}
		}
	}

	void CharlistHandler::handle(InPacket& recv) const
	{
		auto loginwait = UI::get().get_element<UILoginWait>();

		if (loginwait && loginwait->is_active())
		{
			uint8_t channel_id = recv.read_byte();

			// Parse all characters
			std::vector<CharEntry> characters;
			int8_t charcount = recv.read_byte();

			for (uint8_t i = 0; i < charcount; ++i)
				characters.emplace_back(LoginParser::parse_charentry(recv));

			int8_t pic = recv.read_byte();
			int32_t slots = recv.read_int();

			// Remove previous UIs
			UI::get().remove(UIElement::Type::LOGINNOTICE);
			UI::get().remove(UIElement::Type::LOGINWAIT);

			// Remove the world selection screen
			if (auto worldselect = UI::get().get_element<UIWorldSelect>())
				worldselect->remove_selected();

			// Add the character selection screen
			UI::get().emplace<UICharSelect>(characters, charcount, slots, pic);
		}
	}

	void ServerIPHandler::handle(InPacket& recv) const
	{
		recv.skip_byte();

		LoginParser::parse_login(recv);

		int32_t cid = recv.read_int();
		PlayerLoginPacket(cid).dispatch();
	}

	void CharnameResponseHandler::handle(InPacket& recv) const
	{
		// Read the name and if it is already in use
		std::string name = recv.read_string();
		bool used = recv.read_bool();

		// Notify the character creation screen
		if (auto raceselect = UI::get().get_element<UIRaceSelect>())
			raceselect->send_naming_result(used);
	}

	void AddNewCharEntryHandler::handle(InPacket& recv) const
	{
		recv.skip(1);

		// Parse info on the new character
		CharEntry character = LoginParser::parse_charentry(recv);

		// Read the updated character selection
		if (auto charselect = UI::get().get_element<UICharSelect>())
			charselect->add_character(std::move(character));
	}

	void DeleteCharResponseHandler::handle(InPacket& recv) const
	{
		// Read the character id and if deletion was successful (PIC was correct)
		int32_t cid = recv.read_int();
		uint8_t state = recv.read_byte();

		// Extract information from the state byte
		if (state)
		{
			UILoginNotice::Message message;

			switch (state)
			{
				case 10:
					message = UILoginNotice::Message::BIRTHDAY_INCORRECT;
					break;
				case 20:
					message = UILoginNotice::Message::INCORRECT_PIC;
					break;
				default:
					message = UILoginNotice::Message::UNKNOWN_ERROR;
			}

			UI::get().emplace<UILoginNotice>(message);
		}
		else
		{
			if (auto charselect = UI::get().get_element<UICharSelect>())
				charselect->remove_character(cid);
		}
	}
}

================
File: Net/Handlers/LoginHandlers.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../PacketHandler.h"

namespace ms
{
	// Handler for a packet that contains the response to an attempt at logging in
	class LoginResultHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Handler for a packet that contains the status of the requested world
	class ServerStatusHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Handler for a packet that contains the status of the requested world
	class SelectCharacterHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Handles the packet that contains information on worlds and channels
	class ServerlistHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Handler for a packet that contains information on all chars on this world
	class CharlistHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Handles the packet which contains the IP of a channel server to connect to
	class ServerIPHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Handler for a packet which responds to the request for a character name
	class CharnameResponseHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Handler for the packet that notifies that a char was successfully created
	class AddNewCharEntryHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Handler for a packet that responds to the request to the delete a character
	class DeleteCharResponseHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};
}

================
File: Net/Handlers/MapObjectHandlers.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapObjectHandlers.h"

#include "Helpers/LoginParser.h"
#include "Helpers/MovementParser.h"

#include "../../Gameplay/Stage.h"

namespace ms
{
	void SpawnCharHandler::handle(InPacket& recv) const
	{
		int32_t cid = recv.read_int();

		// We don't need to spawn the player twice
		if (Stage::get().is_player(cid))
			return;

		uint16_t level = recv.read_short();
		std::string name = recv.read_string();

		recv.read_string();	// guildname
		recv.read_short();	// guildlogobg
		recv.read_byte();	// guildlogobgcolor
		recv.read_short();	// guildlogo
		recv.read_byte();	// guildlogocolor

		recv.skip(8);

		bool morphed = recv.read_int() == 2;
		int32_t buffmask1 = recv.read_int();
		int16_t buffvalue = 0;

		if (buffmask1 != 0)
			buffvalue = morphed ? recv.read_short() : recv.read_byte();

		recv.read_int(); // buffmask 2

		recv.skip(43);

		recv.read_int(); // 'mount'

		recv.skip(61);

		int16_t job = recv.read_short();
		LookEntry look = LoginParser::parse_look(recv);

		recv.read_int(); // count of 5110000 
		recv.read_int(); // 'itemeffect'
		recv.read_int(); // 'chair'

		Point<int16_t> position = recv.read_point();
		int8_t stance = recv.read_byte();

		recv.skip(3);

		for (size_t i = 0; i < 3; i++)
		{
			int8_t available = recv.read_byte();

			if (available == 1)
			{
				recv.read_byte();	// 'byte2'
				recv.read_int();	// petid
				recv.read_string();	// name
				recv.read_int();	// unique id
				recv.read_int();
				recv.read_point();	// pos
				recv.read_byte();	// stance
				recv.read_int();	// fhid
			}
			else
			{
				break;
			}
		}

		recv.read_int(); // mountlevel
		recv.read_int(); // mountexp
		recv.read_int(); // mounttiredness

		// TODO: Shop stuff
		recv.read_byte();
		// TODO: Shop stuff end

		bool chalkboard = recv.read_bool();
		std::string chalktext = chalkboard ? recv.read_string() : "";

		recv.skip(3);
		recv.read_byte(); // team

		Stage::get().get_chars().spawn(
			{ cid, look, level, job, name, stance, position }
		);
	}

	void RemoveCharHandler::handle(InPacket& recv) const
	{
		int32_t cid = recv.read_int();

		Stage::get().get_chars().remove(cid);
	}

	void SpawnPetHandler::handle(InPacket& recv) const
	{
		int32_t cid = recv.read_int();
		Optional<Char> character = Stage::get().get_character(cid);

		if (!character)
			return;

		uint8_t petindex = recv.read_byte();
		int8_t mode = recv.read_byte();

		if (mode == 1)
		{
			recv.skip(1);

			int32_t itemid = recv.read_int();
			std::string name = recv.read_string();
			int32_t uniqueid = recv.read_int();

			recv.skip(4);

			Point<int16_t> pos = recv.read_point();
			uint8_t stance = recv.read_byte();
			int32_t fhid = recv.read_int();

			character->add_pet(petindex, itemid, name, uniqueid, pos, stance, fhid);
		}
		else if (mode == 0)
		{
			bool hunger = recv.read_bool();

			character->remove_pet(petindex, hunger);
		}
	}

	void CharMovedHandler::handle(InPacket& recv) const
	{
		int32_t cid = recv.read_int();
		recv.skip(4);
		std::vector<Movement> movements = MovementParser::parse_movements(recv);

		Stage::get().get_chars().send_movement(cid, movements);
	}

	void UpdateCharLookHandler::handle(InPacket& recv) const
	{
		int32_t cid = recv.read_int();
		recv.read_byte();
		LookEntry look = LoginParser::parse_look(recv);

		Stage::get().get_chars().update_look(cid, look);
	}

	void ShowForeignEffectHandler::handle(InPacket& recv) const
	{
		int32_t cid = recv.read_int();
		int8_t effect = recv.read_byte();

		if (effect == 10) // recovery
		{
			recv.read_byte(); // 'amount'
		}
		else if (effect == 13) // card effect
		{
			Stage::get().show_character_effect(cid, CharEffect::MONSTER_CARD);
		}
		else if (recv.available()) // skill
		{
			int32_t skillid = recv.read_int();
			recv.read_byte(); // 'direction'
			// 9 more bytes after this

			Stage::get().get_combat().show_buff(cid, skillid, effect);
		}
		else
		{
			// TODO: Blank
		}
	}

	void SpawnMobHandler::handle(InPacket& recv) const
	{
		int32_t oid = recv.read_int();
		recv.read_byte(); // 5 if controller == null
		int32_t id = recv.read_int();

		recv.skip(22);

		Point<int16_t> position = recv.read_point();
		int8_t stance = recv.read_byte();

		recv.skip(2);

		uint16_t fh = recv.read_short();
		int8_t effect = recv.read_byte();

		if (effect > 0)
		{
			recv.read_byte();
			recv.read_short();

			if (effect == 15)
				recv.read_byte();
		}

		int8_t team = recv.read_byte();

		recv.skip(4);

		Stage::get().get_mobs().spawn(
			{ oid, id, 0, stance, fh, effect == -2, team, position }
		);
	}

	void KillMobHandler::handle(InPacket& recv) const
	{
		int32_t oid = recv.read_int();
		int8_t animation = recv.read_byte();

		Stage::get().get_mobs().remove(oid, animation);
	}

	void SpawnMobControllerHandler::handle(InPacket& recv) const
	{
		int8_t mode = recv.read_byte();
		int32_t oid = recv.read_int();

		if (mode == 0)
		{
			Stage::get().get_mobs().set_control(oid, false);
		}
		else
		{
			if (recv.available())
			{
				recv.skip(1);

				int32_t id = recv.read_int();

				recv.skip(22);

				Point<int16_t> position = recv.read_point();
				int8_t stance = recv.read_byte();

				recv.skip(2);

				uint16_t fh = recv.read_short();
				int8_t effect = recv.read_byte();

				if (effect > 0)
				{
					recv.read_byte();
					recv.read_short();

					if (effect == 15)
						recv.read_byte();
				}

				int8_t team = recv.read_byte();

				recv.skip(4);

				Stage::get().get_mobs().spawn(
					{ oid, id, mode, stance, fh, effect == -2, team, position }
				);
			}
			else
			{
				// TODO: Remove monster invisibility, not used (maybe in an event script?), Check this!
			}
		}
	}

	void MobMovedHandler::handle(InPacket& recv) const
	{
		int32_t oid = recv.read_int();

		recv.read_byte();
		recv.read_byte(); // useskill
		recv.read_byte(); // skill
		recv.read_byte(); // skill 1
		recv.read_byte(); // skill 2
		recv.read_byte(); // skill 3
		recv.read_byte(); // skill 4

		Point<int16_t> position = recv.read_point();
		std::vector<Movement> movements = MovementParser::parse_movements(recv);

		Stage::get().get_mobs().send_movement(oid, position, std::move(movements));
	}

	void ShowMobHpHandler::handle(InPacket& recv) const
	{
		int32_t oid = recv.read_int();
		int8_t hppercent = recv.read_byte();
		uint16_t playerlevel = Stage::get().get_player().get_stats().get_stat(MapleStat::Id::LEVEL);

		Stage::get().get_mobs().send_mobhp(oid, hppercent, playerlevel);
	}

	void SpawnNpcHandler::handle(InPacket& recv) const
	{
		int32_t oid = recv.read_int();
		int32_t id = recv.read_int();
		Point<int16_t> position = recv.read_point();
		bool flip = recv.read_bool();
		uint16_t fh = recv.read_short();

		recv.read_short(); // 'rx'
		recv.read_short(); // 'ry'

		Stage::get().get_npcs().spawn(
			{ oid, id, position, flip, fh }
		);
	}

	void SpawnNpcControllerHandler::handle(InPacket& recv) const
	{
		int8_t mode = recv.read_byte();
		int32_t oid = recv.read_int();

		if (mode == 0)
		{
			Stage::get().get_npcs().remove(oid);
		}
		else
		{
			int32_t id = recv.read_int();
			Point<int16_t> position = recv.read_point();
			bool flip = recv.read_bool();
			uint16_t fh = recv.read_short();

			recv.read_short();	// 'rx'
			recv.read_short();	// 'ry'
			recv.read_bool();	// 'minimap'

			Stage::get().get_npcs().spawn(
				{ oid, id, position, flip, fh }
			);
		}
	}

	void DropLootHandler::handle(InPacket& recv) const
	{
		int8_t mode = recv.read_byte();
		int32_t oid = recv.read_int();
		bool meso = recv.read_bool();
		int32_t itemid = recv.read_int();
		int32_t owner = recv.read_int();
		int8_t pickuptype = recv.read_byte();
		Point<int16_t> dropto = recv.read_point();

		recv.skip(4);

		Point<int16_t> dropfrom;

		if (mode != 2)
		{
			dropfrom = recv.read_point();

			recv.skip(2);

			Sound(Sound::Name::DROP).play();
		}
		else
		{
			dropfrom = dropto;
		}

		if (!meso)
			recv.skip(8);

		bool playerdrop = !recv.read_bool();

		Stage::get().get_drops().spawn(
			{ oid, itemid, meso, owner, dropfrom, dropto, pickuptype, mode, playerdrop }
		);
	}

	void RemoveLootHandler::handle(InPacket& recv) const
	{
		int8_t mode = recv.read_byte();
		int32_t oid = recv.read_int();

		Optional<PhysicsObject> looter;

		if (mode > 1)
		{
			int32_t cid = recv.read_int();

			if (recv.length() > 0)
				recv.read_byte(); // pet
			else if (auto character = Stage::get().get_character(cid))
				looter = character->get_phobj();

			Sound(Sound::Name::PICKUP).play();
		}

		Stage::get().get_drops().remove(oid, mode, looter.get());
	}

	void HitReactorHandler::handle(InPacket& recv) const
	{
		int32_t oid = recv.read_int();
		int8_t state = recv.read_byte();
		Point<int16_t> point = recv.read_point();
		int8_t stance = recv.read_byte(); // TODO: When is this different than state?
		recv.skip(2); // TODO: Unused
		recv.skip(1); // "frame" delay but this is in the WZ file?

		Stage::get().get_reactors().trigger(oid, state);
	}

	void SpawnReactorHandler::handle(InPacket& recv) const
	{
		int32_t oid = recv.read_int();
		int32_t rid = recv.read_int();
		int8_t state = recv.read_byte();
		Point<int16_t> point = recv.read_point();

		// TODO: Unused, Check this!
		// uint16_t fhid = recv.read_short();
		// recv.read_byte()

		Stage::get().get_reactors().spawn(
			{ oid, rid, state, point }
		);
	}

	void RemoveReactorHandler::handle(InPacket& recv) const
	{
		int32_t oid = recv.read_int();
		int8_t state = recv.read_byte();
		Point<int16_t> point = recv.read_point();

		Stage::get().get_reactors().remove(oid, state, point);
	}
}

================
File: Net/Handlers/MapObjectHandlers.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../PacketHandler.h"

namespace ms
{
	// Spawn a character on the stage
	// Opcode: SPAWN_CHAR(160)
	class SpawnCharHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Remove a character from the stage
	// Opcode: REMOVE_CHAR(161)
	class RemoveCharHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Spawn a pet on the stage
	// Opcode: SPAWN_PET(168)
	class SpawnPetHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Move a character
	// Opcode: CHAR_MOVED(185)
	class CharMovedHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Update the look of a character
	// Opcode: UPDATE_CHARLOOK(197)
	class UpdateCharLookHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Display an effect on a character
	// Opcode: SHOW_FOREIGN_EFFECT(198)
	class ShowForeignEffectHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Spawn a mob on the stage
	// Opcode: SPAWN_MOB(236)
	class SpawnMobHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Remove a map from the stage, either by killing it or making it invisible.
	// Opcode: KILL_MOB(237)
	class KillMobHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Spawn a mob on the stage and take control of it
	// Opcode: SPAWN_MOB_C(238)
	class SpawnMobControllerHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Update mob state and position with the client
	// Opcode: MOB_MOVED(239)
	class MobMovedHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Updates a mob's hp with the client
	// Opcode: SHOW_MOB_HP(250)
	class ShowMobHpHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Spawn an NPC on the current stage
	// Opcode: SPAWN_NPC(257)
	class SpawnNpcHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Spawn an NPC on the current stage and take control of it
	// Opcode: SPAWN_NPC_C(259)
	class SpawnNpcControllerHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Drop an item on the stage
	// Opcode: DROP_LOOT(268)
	class DropLootHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Remove an item from the stage
	// Opcode: REMOVE_LOOT(269)
	class RemoveLootHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Change state of reactor
	// Opcode: HIT_REACTOR(277)
	class HitReactorHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Parse a ReactorSpawn and send it to the Stage spawn queue
	// Opcode: SPAWN_REACTOR(279)
	class SpawnReactorHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Remove a reactor from the stage
	// Opcode: REMOVE_REACTOR(280)
	class RemoveReactorHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};
}

================
File: Net/Handlers/MessagingHandlers.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MessagingHandlers.h"

#include "../../Data/ItemData.h"
#include "../../Gameplay/Stage.h"
#include "../../IO/UI.h"

#include "../../IO/UITypes/UIChatBar.h"
#include "../../IO/UITypes/UIStatusMessenger.h"

namespace ms
{
	// Modes:
	// 0 - Item(0) or Meso(1) 
	// 3 - Exp gain
	// 4 - Fame
	// 5 - Mesos
	// 6 - Guild points
	void ShowStatusInfoHandler::handle(InPacket& recv) const
	{
		int8_t mode = recv.read_byte();

		if (mode == 0)
		{
			int8_t mode2 = recv.read_byte();

			if (mode2 == -1)
			{
				show_status(Color::Name::WHITE, "You can't get anymore items.");
			}
			else if (mode2 == 0)
			{
				int32_t itemid = recv.read_int();
				int32_t qty = recv.read_int();

				const ItemData& idata = ItemData::get(itemid);

				if (!idata.is_valid())
					return;

				std::string name = idata.get_name();

				if (name.length() > 21)
				{
					name.substr(0, 21);
					name += "..";
				}

				InventoryType::Id type = InventoryType::by_item_id(itemid);

				std::string tab = "";

				switch (type)
				{
					case InventoryType::Id::EQUIP:
						tab = "Eqp";
						break;
					case InventoryType::Id::USE:
						tab = "Use";
						break;
					case InventoryType::Id::SETUP:
						tab = "Setup";
						break;
					case InventoryType::Id::ETC:
						tab = "Etc";
						break;
					case InventoryType::Id::CASH:
						tab = "Cash";
						break;
					default:
						tab = "UNKNOWN";
						break;
				}

				// TODO: show_status(Color::Name::WHITE, "You have lost items in the " + tab + " tab (" + name + " " + std::to_string(qty) + ")");

				if (qty < 0)
					show_status(Color::Name::WHITE, "You have lost an item in the " + tab + " tab (" + name + ")");
				else if (qty == 1)
					show_status(Color::Name::WHITE, "You have gained an item in the " + tab + " tab (" + name + ")");
				else
					show_status(Color::Name::WHITE, "You have gained items in the " + tab + " tab (" + name + " " + std::to_string(qty) + ")");
			}
			else if (mode2 == 1)
			{
				recv.skip(1);

				int32_t gain = recv.read_int();
				std::string sign = (gain < 0) ? "-" : "+";

				show_status(Color::Name::WHITE, "You have gained mesos (" + sign + std::to_string(gain) + ")");
			}
			else
			{
				show_status(Color::Name::RED, "Mode: 0, Mode 2: " + std::to_string(mode2) + " is not handled.");
			}
		}
		else if (mode == 3)
		{
			bool white = recv.read_bool();
			int32_t gain = recv.read_int();
			bool inchat = recv.read_bool();
			int32_t bonus1 = recv.read_int();

			recv.read_short();
			recv.read_int();	// bonus 2
			recv.read_bool();	// 'event or party'
			recv.read_int();	// bonus 3
			recv.read_int();	// bonus 4
			recv.read_int();	// bonus 5

			std::string message = "You have gained experience (+" + std::to_string(gain) + ")";

			if (inchat)
			{
				show_status(Color::Name::RED, "Mode: 3, inchat is not handled.");
			}
			else
			{
				show_status(white ? Color::Name::WHITE : Color::Name::YELLOW, message);

				if (bonus1 > 0)
					show_status(Color::Name::YELLOW, "+ Bonus EXP (+" + std::to_string(bonus1) + ")");
			}
		}
		else if (mode == 4)
		{
			int32_t gain = recv.read_int();
			std::string sign = (gain < 0) ? "-" : "+";

			// TODO: Lose fame?
			show_status(Color::Name::WHITE, "You have gained fame. (" + sign + std::to_string(gain) + ")");
		}
		else
		{
			show_status(Color::Name::RED, "Mode: " + std::to_string(mode) + " is not handled.");
		}
	}

	void ShowStatusInfoHandler::show_status(Color::Name color, const std::string& message) const
	{
		if (auto messenger = UI::get().get_element<UIStatusMessenger>())
			messenger->show_status(color, message);
	}

	void ServerMessageHandler::handle(InPacket& recv) const
	{
		int8_t type = recv.read_byte();
		bool servermessage = recv.inspect_bool();

		if (servermessage)
			recv.skip_byte();

		std::string error = "[MessagingHandlers::ServerMessageHandler]: ";
		const std::string& message = recv.read_string();

		if (type == 3)
		{
			int8_t channel = recv.read_byte();
			bool megaEar = recv.read_bool();

#ifdef _DEBUG
			const std::string& megatype = megaEar ? "megaEar" : "unknown megatype";
			error += "Unhandled [" + megatype + "] on channel [" + std::to_string(channel) + "].";

			UI::get().get_element<UIChatBar>()->show_message(error.c_str(), UIChatBar::MessageType::RED);
#endif
		}
		else if (type == 4)
		{
			UI::get().set_scrollnotice(message);
		}
		else if (type == 5)
		{
			// TODO: Is this actually white?
			UI::get().get_element<UIChatBar>()->show_message(message.c_str(), UIChatBar::MessageType::WHITE);
		}
		else if (type == 6)
		{
			recv.skip_int();

#ifdef _DEBUG
			error += "Unhandled type [" + std::to_string(type) + "].";

			UI::get().get_element<UIChatBar>()->show_message(error.c_str(), UIChatBar::MessageType::RED);
#endif
		}
		else if (type == 7)
		{
			int32_t npc = recv.read_int();

#ifdef _DEBUG
			error += "Unhandled message for NPC [" + std::to_string(npc) + "].";

			UI::get().get_element<UIChatBar>()->show_message(error.c_str(), UIChatBar::MessageType::RED);
#endif
		}
		else
		{
#ifdef _DEBUG
			error += "Unhandled type [" + std::to_string(type) + "].";

			UI::get().get_element<UIChatBar>()->show_message(error.c_str(), UIChatBar::MessageType::RED);
#endif
		}
	}

	void WeekEventMessageHandler::handle(InPacket& recv) const
	{
		recv.read_byte(); // TODO: Always 0xFF, Check this!

		std::string message = recv.read_string();

		static const std::string MAPLETIP = "[MapleTip]";

		if (message.substr(0, MAPLETIP.length()).compare("[MapleTip]"))
			message = "[Notice] " + message;

		UI::get().get_element<UIChatBar>()->show_message(message.c_str(), UIChatBar::MessageType::YELLOW);
	}

	void ChatReceivedHandler::handle(InPacket& recv) const
	{
		int32_t charid = recv.read_int();

		recv.read_bool(); // 'gm'

		std::string message = recv.read_string();
		int8_t type = recv.read_byte();

		if (auto character = Stage::get().get_character(charid))
		{
			message = character->get_name() + " : " + message;
			character->speak(message);
		}

		auto linetype = static_cast<UIChatBar::MessageType>(type);

		if (auto chatbar = UI::get().get_element<UIChatBar>())
			chatbar->show_message(message.c_str(), linetype);
	}

	void ScrollResultHandler::handle(InPacket& recv) const
	{
		int32_t cid = recv.read_int();
		bool success = recv.read_bool();
		bool destroyed = recv.read_bool();

		recv.read_short(); // Legendary spirit if 1

		CharEffect::Id effect;
		Messages::Type message;

		if (success)
		{
			effect = CharEffect::Id::SCROLL_SUCCESS;
			message = Messages::Type::SCROLL_SUCCESS;
		}
		else
		{
			effect = CharEffect::Id::SCROLL_FAILURE;

			if (destroyed)
				message = Messages::Type::SCROLL_DESTROYED;
			else
				message = Messages::Type::SCROLL_FAILURE;
		}

		Stage::get().show_character_effect(cid, effect);

		if (Stage::get().is_player(cid))
		{
			if (auto chatbar = UI::get().get_element<UIChatBar>())
				chatbar->show_message(Messages::messages[message], UIChatBar::MessageType::RED);

			UI::get().enable();
		}
	}

	void ShowItemGainInChatHandler::handle(InPacket& recv) const
	{
		int8_t mode1 = recv.read_byte();

		if (mode1 == 3)
		{
			int8_t mode2 = recv.read_byte();

			if (mode2 == 1) // This is actually 'item gain in chat'
			{
				int32_t itemid = recv.read_int();
				int32_t qty = recv.read_int();

				const ItemData& idata = ItemData::get(itemid);

				if (!idata.is_valid())
					return;

				std::string name = idata.get_name();
				std::string sign = (qty < 0) ? "-" : "+";
				std::string message = "Gained an item: " + name + " (" + sign + std::to_string(qty) + ")";

				if (auto chatbar = UI::get().get_element<UIChatBar>())
					chatbar->show_message(message.c_str(), UIChatBar::MessageType::BLUE);
			}
		}
		else if (mode1 == 13) // card effect
		{
			Stage::get().get_player().show_effect_id(CharEffect::Id::MONSTER_CARD);
		}
		else if (mode1 == 18) // intro effect
		{
			recv.read_string(); // path
		}
		else if (mode1 == 23) // info
		{
			recv.read_string();	// path
			recv.read_int();	// some int
		}
		else // Buff effect
		{
			int32_t skillid = recv.read_int();

			// More bytes, but we don't need them.
			Stage::get().get_combat().show_player_buff(skillid);
		}
	}
}

================
File: Net/Handlers/MessagingHandlers.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../PacketHandler.h"

#include "../../Graphics/Text.h"

namespace ms
{
	// Show a status message
	// Opcode: SHOW_STATUS_INFO(39)
	class ShowStatusInfoHandler : public PacketHandler
	{
	public:
		void handle(InPacket& recv) const override;
	private:
		void show_status(Color::Name color, const std::string& message) const;
	};

	// Show a server message
	// Opcode: SERVER_MESSAGE(68)
	class ServerMessageHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Show another type of server message
	// Opcode: WEEK_EVENT_MESSAGE(77)
	class WeekEventMessageHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Show a chat message
	// CHAT_RECEIVED(162)
	class ChatReceivedHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Shows the effect of a scroll
	// Opcode: SCROLL_RESULT(167)
	class ScrollResultHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Can contain numerous different effects and messages
	// Opcode: SHOW_ITEM_GAIN_INCHAT(206)
	class ShowItemGainInChatHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};
}

================
File: Net/Handlers/NpcInteractionHandlers.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "NpcInteractionHandlers.h"

#include "../../IO/UI.h"

#include "../../IO/UITypes/UINpcTalk.h"
#include "../../IO/UITypes/UIShop.h"

namespace ms
{
	void NpcDialogueHandler::handle(InPacket& recv) const
	{
		recv.skip(1);

		int32_t npcid = recv.read_int();
		int8_t msgtype = recv.read_byte(); // 0 - textonly, 1 - yes/no, 4 - selection, 12 - accept/decline
		int8_t speaker = recv.read_byte();
		std::string text = recv.read_string();

		int16_t style = 0;

		if (msgtype == 0 && recv.length() > 0)
			style = recv.read_short();

		UI::get().emplace<UINpcTalk>();
		UI::get().enable();

		if (auto npctalk = UI::get().get_element<UINpcTalk>())
			npctalk->change_text(npcid, msgtype, style, speaker, text);
	}

	void OpenNpcShopHandler::handle(InPacket& recv) const
	{
		int32_t npcid = recv.read_int();
		auto oshop = UI::get().get_element<UIShop>();

		if (!oshop)
			return;

		UIShop& shop = *oshop;

		shop.reset(npcid);

		int16_t size = recv.read_short();

		for (int16_t i = 0; i < size; i++)
		{
			int32_t itemid = recv.read_int();
			int32_t price = recv.read_int();
			int32_t pitch = recv.read_int();
			int32_t time = recv.read_int();

			recv.skip(4);

			bool norecharge = recv.read_short() == 1;

			if (norecharge)
			{
				int16_t buyable = recv.read_short();

				shop.add_item(itemid, price, pitch, time, buyable);
			}
			else
			{
				recv.skip(4);

				int16_t rechargeprice = recv.read_short();
				int16_t slotmax = recv.read_short();

				shop.add_rechargable(itemid, price, pitch, time, rechargeprice, slotmax);
			}
		}
	}
}

================
File: Net/Handlers/NpcInteractionHandlers.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../PacketHandler.h"

namespace ms
{
	// Handler for a packet which contains NPC dialog
	class NpcDialogueHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Opens an NPC shop defined by the packet's contents
	class OpenNpcShopHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};
}

================
File: Net/Handlers/PlayerHandlers.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "PlayerHandlers.h"

#include "Helpers/LoginParser.h"

#include "../../Gameplay/Stage.h"
#include "../../IO/UI.h"

#include "../../IO/UITypes/UIBuffList.h"
#include "../../IO/UITypes/UICashShop.h"
#include "../../IO/UITypes/UISkillBook.h"
#include "../../IO/UITypes/UIStatsInfo.h"

namespace ms
{
	void ChangeChannelHandler::handle(InPacket& recv) const
	{
		LoginParser::parse_login(recv);

		auto cashshop = UI::get().get_element<UICashShop>();

		if (cashshop)
			cashshop->exit_cashshop();
	}

	void ChangeStatsHandler::handle(InPacket& recv) const
	{
		recv.read_bool(); // 'itemreaction'
		int32_t updatemask = recv.read_int();

		bool recalculate = false;

		for (auto iter : MapleStat::codes)
			if (updatemask & iter.second)
				recalculate |= handle_stat(iter.first, recv);

		if (recalculate)
			Stage::get().get_player().recalc_stats(false);

		UI::get().enable();
	}

	bool ChangeStatsHandler::handle_stat(MapleStat::Id stat, InPacket& recv) const
	{
		Player& player = Stage::get().get_player();

		bool recalculate = false;

		switch (stat)
		{
		case MapleStat::Id::SKIN:
			player.change_look(stat, recv.read_short());
			break;
		case MapleStat::Id::FACE:
		case MapleStat::Id::HAIR:
			player.change_look(stat, recv.read_int());
			break;
		case MapleStat::Id::LEVEL:
			player.change_level(recv.read_byte());
			break;
		case MapleStat::Id::JOB:
			player.change_job(recv.read_short());
			break;
		case MapleStat::Id::EXP:
			player.get_stats().set_exp(recv.read_int());
			break;
		case MapleStat::Id::MESO:
			player.get_inventory().set_meso(recv.read_int());
			break;
		default:
			player.get_stats().set_stat(stat, recv.read_short());
			recalculate = true;
			break;
		}

		bool update_statsinfo = need_statsinfo_update(stat);

		if (update_statsinfo && !recalculate)
			if (auto statsinfo = UI::get().get_element<UIStatsInfo>())
				statsinfo->update_stat(stat);

		bool update_skillbook = need_skillbook_update(stat);

		if (update_skillbook)
		{
			int16_t value = player.get_stats().get_stat(stat);

			if (auto skillbook = UI::get().get_element<UISkillBook>())
				skillbook->update_stat(stat, value);
		}

		return recalculate;
	}

	bool ChangeStatsHandler::need_statsinfo_update(MapleStat::Id stat) const
	{
		switch (stat)
		{
		case MapleStat::Id::JOB:
		case MapleStat::Id::STR:
		case MapleStat::Id::DEX:
		case MapleStat::Id::INT:
		case MapleStat::Id::LUK:
		case MapleStat::Id::HP:
		case MapleStat::Id::MAXHP:
		case MapleStat::Id::MP:
		case MapleStat::Id::MAXMP:
		case MapleStat::Id::AP:
			return true;
		default:
			return false;
		}
	}

	bool ChangeStatsHandler::need_skillbook_update(MapleStat::Id stat) const
	{
		switch (stat)
		{
		case MapleStat::Id::JOB:
		case MapleStat::Id::SP:
			return true;
		default:
			return false;
		}
	}

	void BuffHandler::handle(InPacket& recv) const
	{
		uint64_t firstmask = recv.read_long();
		uint64_t secondmask = recv.read_long();

		switch (secondmask)
		{
		case Buffstat::BATTLESHIP:
			handle_buff(recv, Buffstat::BATTLESHIP);
			return;
		}

		for (auto& iter : Buffstat::first_codes)
			if (firstmask & iter.second)
				handle_buff(recv, iter.first);

		for (auto& iter : Buffstat::second_codes)
			if (secondmask & iter.second)
				handle_buff(recv, iter.first);

		Stage::get().get_player().recalc_stats(false);
	}

	void ApplyBuffHandler::handle_buff(InPacket& recv, Buffstat::Id bs) const
	{
		int16_t value = recv.read_short();
		int32_t skillid = recv.read_int();
		int32_t duration = recv.read_int();

		Stage::get().get_player().give_buff({ bs, value, skillid, duration });

		if (auto bufflist = UI::get().get_element<UIBuffList>())
			bufflist->add_buff(skillid, duration);
	}

	void CancelBuffHandler::handle_buff(InPacket&, Buffstat::Id bs) const
	{
		Stage::get().get_player().cancel_buff(bs);
	}

	void RecalculateStatsHandler::handle(InPacket&) const
	{
		Stage::get().get_player().recalc_stats(false);
	}

	void UpdateSkillHandler::handle(InPacket& recv) const
	{
		recv.skip(3);

		int32_t skillid = recv.read_int();
		int32_t level = recv.read_int();
		int32_t masterlevel = recv.read_int();
		int64_t expire = recv.read_long();

		Stage::get().get_player().change_skill(skillid, level, masterlevel, expire);

		if (auto skillbook = UI::get().get_element<UISkillBook>())
			skillbook->update_skills(skillid);

		UI::get().enable();
	}

	void SkillMacrosHandler::handle(InPacket& recv) const
	{
		uint8_t size = recv.read_byte();

		for (uint8_t i = 0; i < size; i++)
		{
			recv.read_string();	// name
			recv.read_byte();	// 'shout' byte
			recv.read_int();	// skill 1
			recv.read_int();	// skill 2
			recv.read_int();	// skill 3
		}
	}

	void AddCooldownHandler::handle(InPacket& recv) const
	{
		int32_t skill_id = recv.read_int();
		int16_t cooltime = recv.read_short();

		Stage::get().get_player().add_cooldown(skill_id, cooltime);
	}

	void KeymapHandler::handle(InPacket& recv) const
	{
		recv.skip(1);

		for (uint8_t i = 0; i < 90; i++)
		{
			uint8_t type = recv.read_byte();
			int32_t action = recv.read_int();

			UI::get().add_keymapping(i, type, action);
		}
	}
}

================
File: Net/Handlers/PlayerHandlers.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../PacketHandler.h"

#include "../../Character/Buff.h"
#include "../../Character/MapleStat.h"

namespace ms
{
	// Handles the changing of channels for players
	// Opcode: CHANGE_CHANNEL(16)
	class ChangeChannelHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Notifies the client of changes in character stats
	// Opcode: CHANGE_STATS(31)
	class ChangeStatsHandler : public PacketHandler
	{
	public:
		void handle(InPacket& recv) const override;

	private:
		bool handle_stat(MapleStat::Id stat, InPacket& recv) const;
		bool need_statsinfo_update(MapleStat::Id stat) const;
		bool need_skillbook_update(MapleStat::Id stat) const;
	};

	// Base class for packets which need to parse buff stats
	class BuffHandler : public PacketHandler
	{
	public:
		void handle(InPacket& recv) const override;

	protected:
		virtual void handle_buff(InPacket& recv, Buffstat::Id stat) const = 0;
	};

	// Notifies the client that a buff was applied to the player
	// Opcode: GIVE_BUFF(32)
	class ApplyBuffHandler : public BuffHandler
	{
	protected:
		void handle_buff(InPacket& recv, Buffstat::Id stat) const override;
	};

	// Notifies the client that a buff was canceled
	// Opcode: CANCEL_BUFF(33)
	class CancelBuffHandler : public BuffHandler
	{
	protected:
		void handle_buff(InPacket& recv, Buffstat::Id stat) const override;
	};

	// Force a stat recalculation
	// Opcode: RECALCULATE_STATS(35)
	class RecalculateStatsHandler : public PacketHandler
	{
		void handle(InPacket&) const override;
	};

	// Updates the player's skills with the client
	// Opcode: UPDATE_SKILL(36)
	class UpdateSkillHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Parses skill macros
	// Opcode: SKILL_MACROS(124)
	class SkillMacrosHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Notifies the client that a skill is on cool-down
	// Opcode: ADD_COOLDOWN(234)
	class AddCooldownHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// Parses key mappings and sends them to the keyboard
	// Opcode: KEYMAP(335)
	class KeymapHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};
}

================
File: Net/Handlers/PlayerInteractionHandlers.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "PlayerInteractionHandlers.h"

#include "../../IO/UI.h"

#include "../../IO/UITypes/UICharInfo.h"

namespace ms
{
	void CharInfoHandler::handle(InPacket& recv) const
	{
		int32_t character_id = recv.read_int();
		uint16_t character_level = recv.read_short();
		int16_t character_job_id = recv.read_short();
		int16_t character_fame = recv.read_short();
		recv.skip_byte(); // character_marriage_ring

		std::string guild_name = recv.read_string();
		std::string alliance_name = recv.read_string();

		recv.skip_byte();

		int8_t pet_unique_id = recv.read_byte();

		while (pet_unique_id != 0)
		{
			recv.skip_int();	// pet_id
			recv.skip_string();	// pet_name
			recv.skip_byte();	// pet_level
			recv.skip_short();	// pet_closeness
			recv.skip_byte();	// pet_fullness

			recv.skip_short();

			recv.skip_int(); // pet_inventory_id

			pet_unique_id = recv.read_byte();
		}

		int8_t mount = recv.read_byte();

		if (mount != 0)
		{
			recv.skip_int(); // mount_level
			recv.skip_int(); // mount_exp
			recv.skip_int(); // mount_tiredness
		}

		int8_t wishlist_size = recv.read_byte();

		for (int8_t sn = 0; sn < wishlist_size; sn++)
			recv.skip_int(); // wishlist_item

		recv.skip_int(); // monster_book_level
		recv.skip_int(); // monster_book_card_normal
		recv.skip_int(); // monster_book_card_special
		recv.skip_int(); // monster_book_cards_total
		recv.skip_int(); // monster_book_cover

		recv.skip_int(); // medal

		int16_t medal_quests_size = recv.read_short();

		for (int16_t s = 0; s < medal_quests_size; s++)
			recv.skip_short(); // medal_quest

		// Update the character information window
		if (auto charinfo = UI::get().get_element<UICharInfo>())
			charinfo->update_stats(character_id, character_job_id, character_level, character_fame, guild_name, alliance_name);
	}
}

================
File: Net/Handlers/PlayerInteractionHandlers.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../PacketHandler.h"

namespace ms
{
	// Handler for a packet which contains character info
	class CharInfoHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};
}

================
File: Net/Handlers/SetFieldHandlers.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "SetFieldHandlers.h"

#include "Helpers/CharacterParser.h"
#include "Helpers/LoginParser.h"

#include "../Packets/GameplayPackets.h"

#include "../../Configuration.h"

#include "../../Gameplay/Stage.h"
#include "../../IO/UI.h"
#include "../../IO/Window.h"

#include "../../IO/UITypes/UICharSelect.h"

namespace ms
{
	void SetFieldHandler::transition(int32_t mapid, uint8_t portalid) const
	{
		float fadestep = 0.025f;

		Window::get().fadeout(
			fadestep,
			[mapid, portalid]()
			{
				GraphicsGL::get().clear();

				Stage::get().load(mapid, portalid);

				UI::get().enable();
				Timer::get().start();
				GraphicsGL::get().unlock();

				Stage::get().transfer_player();
			});

		GraphicsGL::get().lock();
		Stage::get().clear();
		Timer::get().start();
	}

	void SetFieldHandler::handle(InPacket& recv) const
	{
		Constants::Constants::get().set_viewwidth(Setting<Width>::get().load());
		Constants::Constants::get().set_viewheight(Setting<Height>::get().load());

		int32_t channel = recv.read_int();
		int8_t mode1 = recv.read_byte();
		int8_t mode2 = recv.read_byte();

		if (mode1 == 0 && mode2 == 0)
			change_map(recv, channel);
		else
			set_field(recv);
	}

	void SetFieldHandler::change_map(InPacket& recv, int32_t) const
	{
		recv.skip(3);

		int32_t mapid = recv.read_int();
		int8_t portalid = recv.read_byte();

		transition(mapid, portalid);
	}

	void SetFieldHandler::set_field(InPacket& recv) const
	{
		recv.skip(23);

		int32_t cid = recv.read_int();
		auto charselect = UI::get().get_element<UICharSelect>();

		if (!charselect)
			return;

		const CharEntry& playerentry = charselect->get_character(cid);

		if (playerentry.id != cid)
			return;

		Stage::get().loadplayer(playerentry);

		LoginParser::parse_stats(recv);

		Player& player = Stage::get().get_player();

		recv.read_byte(); // 'buddycap'

		if (recv.read_bool())
			recv.read_string(); // 'linkedname'

		CharacterParser::parse_inventory(recv, player.get_inventory());
		CharacterParser::parse_skillbook(recv, player.get_skills());
		CharacterParser::parse_cooldowns(recv, player);
		CharacterParser::parse_questlog(recv, player.get_quests());
		CharacterParser::parse_minigame(recv);
		CharacterParser::parse_ring1(recv);
		CharacterParser::parse_ring2(recv);
		CharacterParser::parse_ring3(recv);
		CharacterParser::parse_teleportrock(recv, player.get_teleportrock());
		CharacterParser::parse_monsterbook(recv, player.get_monsterbook());
		CharacterParser::parse_nyinfo(recv);
		CharacterParser::parse_areainfo(recv);

		player.recalc_stats(true);

		PlayerUpdatePacket().dispatch();

		uint8_t portalid = player.get_stats().get_portal();
		int32_t mapid = player.get_stats().get_mapid();

		transition(mapid, portalid);

		Sound(Sound::Name::GAMESTART).play();

		UI::get().change_state(UI::State::GAME);
	}
}

================
File: Net/Handlers/SetFieldHandlers.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../PacketHandler.h"

namespace ms
{
	// Handler for a packet which contains all character information on first login or warps the player to a different map
	class SetFieldHandler : public PacketHandler
	{
	public:
		void handle(InPacket& recv) const override;

	private:
		void transition(int32_t mapid, uint8_t portalid) const;
		void change_map(InPacket& recv, int32_t map_id) const;
		void set_field(InPacket& recv) const;
	};
}

================
File: Net/Handlers/TestingHandlers.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "TestingHandlers.h"

#include "../../Gameplay/Stage.h"
#include "../../IO/UI.h"

#include "../../IO/UITypes/UILoginNotice.h"

namespace ms
{
	void CheckSpwResultHandler::handle(InPacket& recv) const
	{
		int reason = recv.read_byte();

		if (reason == 0)
			UI::get().emplace<UILoginNotice>(UILoginNotice::Message::INCORRECT_PIC);
		else
			LOG(LOG_NETWORK, "[CheckSpwResultHandler]: Unknown reason: [" << reason << "]");

		UI::get().enable();
	}

	void FieldEffectHandler::handle(InPacket& recv) const
	{
		int rand = recv.read_byte();

		// Effect
		if (rand == 3)
		{
			std::string path = recv.read_string();

			Stage::get().add_effect(path);

			return;
		}

		LOG(LOG_NETWORK, "[FieldEffectHandler]: Unknown value: [" << rand << "]");
	}
}

================
File: Net/Handlers/TestingHandlers.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../PacketHandler.h"

namespace ms
{
	// TODO: Comment
	class CheckSpwResultHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};

	// TODO: Comment
	class FieldEffectHandler : public PacketHandler
	{
		void handle(InPacket& recv) const override;
	};
}

================
File: Net/InPacket.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "InPacket.h"

namespace ms
{
	InPacket::InPacket(const int8_t* recv, size_t length)
	{
		bytes = recv;
		top = length;
		pos = 0;
	}

	bool InPacket::available() const
	{
		return length() > 0;
	}

	size_t InPacket::length() const
	{
		return top - pos;
	}

	void InPacket::skip(size_t count)
	{
		if (count > length())
			throw PacketError("Stack underflow at " + std::to_string(pos));

		pos += count;
	}

	bool InPacket::read_bool()
	{
		return read_byte() == 1;
	}

	int8_t InPacket::read_byte()
	{
		return read<int8_t>();
	}

	int16_t InPacket::read_short()
	{
		return read<int16_t>();
	}

	int32_t InPacket::read_int()
	{
		return read<int32_t>();
	}

	int64_t InPacket::read_long()
	{
		return read<int64_t>();
	}

	Point<int16_t> InPacket::read_point()
	{
		int16_t x = read<int16_t>();
		int16_t y = read<int16_t>();

		return Point<int16_t>(x, y);
	}

	std::string InPacket::read_string()
	{
		uint16_t length = read<uint16_t>();

		return read_padded_string(length);
	}

	std::string InPacket::read_padded_string(uint16_t count)
	{
		std::string ret;

		for (int16_t i = 0; i < count; i++)
		{
			char letter = read_byte();

			if (letter != '\0')
				ret.push_back(letter);
		}

		return ret;
	}

	void InPacket::skip_bool()
	{
		skip_byte();
	}

	void InPacket::skip_byte()
	{
		skip(sizeof(int8_t));
	}

	void InPacket::skip_short()
	{
		skip(sizeof(int16_t));
	}

	void InPacket::skip_int()
	{
		skip(sizeof(int32_t));
	}

	void InPacket::skip_long()
	{
		skip(sizeof(int64_t));
	}

	void InPacket::skip_point()
	{
		skip(sizeof(int16_t));
		skip(sizeof(int16_t));
	}

	void InPacket::skip_string()
	{
		uint16_t length = read<uint16_t>();

		skip_padded_string(length);
	}

	void InPacket::skip_padded_string(uint16_t length)
	{
		skip(length);
	}

	bool InPacket::inspect_bool()
	{
		return inspect_byte() == 1;
	}

	int8_t InPacket::inspect_byte()
	{
		return inspect<int8_t>();
	}

	int16_t InPacket::inspect_short()
	{
		return inspect<int16_t>();
	}

	int32_t InPacket::inspect_int()
	{
		return inspect<int32_t>();
	}

	int64_t InPacket::inspect_long()
	{
		return inspect<int64_t>();
	}
}

================
File: Net/InPacket.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "PacketError.h"

#include "../Template/Point.h"

#include <cstdint>

namespace ms
{
	// A packet received from the server
	// Contains reading functions
	class InPacket
	{
	public:
		// Construct a packet from an array of bytes
		InPacket(const int8_t* bytes, size_t length);

		// Check if there are more bytes available
		bool available() const;
		// Return the remaining length in bytes
		size_t length() const;
		// Skip a number of bytes (by increasing the offset)
		void skip(size_t count);

		// Read a byte and check if it is equal to one
		bool read_bool();
		// Read a byte
		int8_t read_byte();
		// Read a short
		int16_t read_short();
		// Read a int
		int32_t read_int();
		// Read a long
		int64_t read_long();

		// Read a point
		Point<int16_t> read_point();

		// Read a string
		std::string read_string();
		// Read a fixed-length string
		std::string read_padded_string(uint16_t length);

		// Skip a byte
		void skip_bool();
		// Skip a byte
		void skip_byte();
		// Skip a short
		void skip_short();
		// Skip a int
		void skip_int();
		// Skip a long
		void skip_long();

		// Skip a point
		void skip_point();

		// Skip a string
		void skip_string();
		// Skip a fixed-length string
		void skip_padded_string(uint16_t length);

		// Inspect a byte and check if it is 1. Does not advance the buffer position.
		bool inspect_bool();
		// Inspect a byte. Does not advance the buffer position.
		int8_t inspect_byte();
		// Inspect a short. Does not advance the buffer position.
		int16_t inspect_short();
		// Inspect an int. Does not advance the buffer position.
		int32_t inspect_int();
		// Inspect a long. Does not advance the buffer position.
		int64_t inspect_long();

	private:
		template <typename T>
		// Read a number and advance the buffer position
		T read()
		{
			size_t count = sizeof(T) / sizeof(int8_t);
			T all = 0;

			for (size_t i = 0; i < count; i++)
			{
				T val = static_cast<uint8_t>(bytes[pos]);
				all += val << (8 * i);

				skip(1);
			}

			return static_cast<T>(all);
		}

		template <typename T>
		// Read without advancing the buffer position
		T inspect()
		{
			size_t before = pos;
			T value = read<T>();
			pos = before;

			return value;
		}

		const int8_t* bytes;
		size_t top;
		size_t pos;
	};
}

================
File: Net/Login.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Character/MapleStat.h"

#include <map>
#include <vector>

namespace ms
{
	struct Account
	{
		int32_t accid;
		int8_t female;
		bool admin;
		std::string name;
		bool muted;
		bool pin;
		int8_t pic;
	};

	struct World
	{
		std::string name;
		std::string event_message;
		std::vector<int32_t> channel_capacities;
		uint8_t channel_count;
		uint8_t flag;
		int8_t id;
	};

	struct StatsEntry
	{
		std::string name;
		bool female;
		std::vector<int64_t> petids;
		EnumMap<MapleStat::Id, uint16_t> stats;
		int64_t exp;
		int32_t mapid;
		uint8_t portal;
		std::pair<int32_t, int8_t> rank;
		std::pair<int32_t, int8_t> jobrank;
	};

	struct LookEntry
	{
		bool female;
		uint8_t skin;
		int32_t faceid;
		int32_t hairid;
		std::map<int8_t, int32_t> equips;
		std::map<int8_t, int32_t> maskedequips;
		std::vector<int32_t> petids;
	};

	struct CharEntry
	{
		StatsEntry stats;
		LookEntry look;
		int32_t id;
	};
}

================
File: Net/NetConstants.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cstdint>

namespace ms
{
	const size_t HEADER_LENGTH = 4;
	const size_t OPCODE_LENGTH = 2;
	const size_t MIN_PACKET_LENGTH = HEADER_LENGTH + OPCODE_LENGTH;
	const size_t MAX_PACKET_LENGTH = 131072;
}

================
File: Net/OutPacket.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "OutPacket.h"

#include "Session.h"

#include "../Configuration.h"

#include "../Util/Randomizer.h"

#include <chrono>

namespace ms
{
	OutPacket::OutPacket(int16_t opc) : opcode(opc)
	{
		write_short(opcode);
	}

	void OutPacket::dispatch()
	{
		Session::get().write(bytes.data(), bytes.size());

		if (Configuration::get().get_show_packets())
		{
			if (opcode == Opcode::PONG)
				LOG(LOG_NETWORK, "Sent Packet: PONG");
			else
				LOG(LOG_NETWORK, "Sent Packet: " << std::to_string(opcode));
		}
	}

	void OutPacket::skip(size_t count)
	{
		for (size_t i = 0; i < count; i++)
			bytes.push_back(0);
	}

	void OutPacket::write_byte(int8_t ch)
	{
		bytes.push_back(ch);
	}

	void OutPacket::write_short(int16_t sh)
	{
		for (size_t i = 0; i < sizeof(short); i++)
		{
			write_byte(static_cast<int8_t>(sh));
			sh >>= 8;
		}
	}

	void OutPacket::write_int(int32_t in)
	{
		for (size_t i = 0; i < sizeof(int); i++)
		{
			write_byte(static_cast<int8_t>(in));
			in >>= 8;
		}
	}

	void OutPacket::write_long(int64_t lg)
	{
		for (size_t i = 0; i < sizeof(long); i++)
		{
			write_byte(static_cast<int8_t>(lg));
			lg >>= 8;
		}
	}

	void OutPacket::write_time()
	{
		auto duration = std::chrono::steady_clock::now().time_since_epoch();
		auto since_epoch = std::chrono::duration_cast<std::chrono::milliseconds>(duration);
		int32_t timestamp = static_cast<int32_t>(since_epoch.count());

		write_int(timestamp);
	}

	void OutPacket::write_point(Point<int16_t> position)
	{
		write_short(position.x());
		write_short(position.y());
	}

	void OutPacket::write_string(const std::string& str)
	{
		int16_t length = static_cast<int16_t>(str.length());

		write_short(length);

		for (int16_t i = 0; i < length; i++)
			write_byte(str[i]);
	}

	void OutPacket::write_random()
	{
		auto randomizer = Randomizer();
		int32_t rand = randomizer.next_int(INT_MAX);

		write_int(rand);
	}

	void OutPacket::write_hardware_info()
	{
		std::string macs = Configuration::get().get_macs().c_str();
		std::string hwid = Configuration::get().get_hwid().c_str();

		write_string(macs);
		write_string(hwid);
	}

	int32_t OutPacket::hex_to_dec(std::string hexVal)
	{
		int32_t len = strlen(hexVal.c_str());
		int32_t base = 1;
		int32_t dec_val = 0;

		for (int32_t i = len - 1; i >= 0; i--)
		{
			if (hexVal[i] >= '0' && hexVal[i] <= '9')
			{
				dec_val += (hexVal[i] - 48) * base;
				base = base * 16;
			}
			else if (hexVal[i] >= 'A' && hexVal[i] <= 'F')
			{
				dec_val += (hexVal[i] - 55) * base;
				base = base * 16;
			}
		}

		return dec_val;
	}
}

================
File: Net/OutPacket.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Template/Point.h"

#include <vector>

namespace ms
{
	// A packet to be sent to the server
	// Used as a base class to create specific packets
	class OutPacket
	{
	public:
		// Construct a packet by writing its opcode
		OutPacket(int16_t opcode);

		void dispatch();

		// Opcodes for OutPackets associated with version 83 of the game
		enum Opcode : uint16_t
		{
			/// Login
			LOGIN = 1,
			LOGIN_EMAIL = 3,
			CHARLIST_REQUEST = 5,
			SERVERSTATUS_REQUEST = 6,
			ACCEPT_TOS = 7,
			SET_GENDER = 8,
			SERVERLIST_REQUEST = 11,
			SELECT_CHAR = 19,
			PLAYER_LOGIN = 20,
			NAME_CHAR = 21,
			CREATE_CHAR = 22,
			DELETE_CHAR = 23,
			PONG = 24,
			REGISTER_PIC = 29,
			SELECT_CHAR_PIC = 30,

			/// Gameplay 1
			CHANGEMAP = 38,
			ENTER_CASHSHOP = 40,
			MOVE_PLAYER = 41,
			CLOSE_ATTACK = 44,
			RANGED_ATTACK = 45,
			MAGIC_ATTACK = 46,
			TAKE_DAMAGE = 48,

			/// Messaging
			GENERAL_CHAT = 49,
			MULTI_CHAT = 119,
			SPOUSE_CHAT = 121,

			/// NPC Interaction
			TALK_TO_NPC = 58,
			NPC_TALK_MORE = 60,
			NPC_SHOP_ACTION = 61,

			/// Player Interaction
			CHAR_INFO_REQUEST = 97,

			/// Inventory
			GATHER_ITEMS = 69,
			SORT_ITEMS = 70,
			MOVE_ITEM = 71,
			USE_ITEM = 72,
			SCROLL_EQUIP = 86,

			/// Player
			SPEND_AP = 87,
			SPEND_SP = 90,
			CHANGE_KEYMAP = 135,

			/// Skill
			USE_SKILL = 91,

			/// Gameplay 2
			PARTY_OPERATION = 124,
			ADMIN_COMMAND = 128,
			MOVE_MONSTER = 188,
			PICKUP_ITEM = 202,
			DAMAGE_REACTOR = 205,
			PLAYER_MAP_TRANSFER = 207,
			PLAYER_UPDATE = 223
		};

	protected:
		// Skip a number of bytes (filled with zeros)
		void skip(size_t count);
		// Write a byte
		void write_byte(int8_t ch);
		// Write a short
		void write_short(int16_t sh);
		// Write an int
		void write_int(int32_t in);
		// Write a long
		void write_long(int64_t lg);

		// Write a point
		// One short for x and one for y
		void write_point(Point<int16_t> point);
		// Write a timestamp as an integer
		void write_time();
		// Write a string
		// Writes the length as a short and then each individual character as a byte
		void write_string(const std::string& str);
		// Write a random int
		void write_random();

		// Write the MACS and then write the HWID of the computer
		void write_hardware_info();
		// Function to convert hexadecimal to decimal
		int32_t hex_to_dec(std::string hexVal);

	private:
		std::vector<int8_t> bytes;
		int16_t opcode;
	};
}

================
File: Net/PacketError.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <string>
#include <stdexcept>

namespace ms
{
	// Error which is thrown by packet handling functions.
	class PacketError : public std::runtime_error
	{
	public:
		PacketError(const std::string& msg): std::runtime_error(PREFIX + msg) {}

	private:
		static constexpr const char* PREFIX = "Packet Error: ";
	};
}

================
File: Net/PacketHandler.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "InPacket.h"

namespace ms
{
	// Interface for classes that handle InPackets.
	class PacketHandler
	{
	public:
		virtual ~PacketHandler() {}

		virtual void handle(InPacket& recv) const = 0;
	};
}

================
File: Net/Packets/AttackAndSkillPackets.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../OutPacket.h"

namespace ms
{
	// Notifies the server of an attack
	// The opcode is determined by the attack type
	// Attack::CLOSE = CLOSE_ATTACK(44)
	// Attack::RANGED = RANGED_ATTACK(45)
	// Attack::MAGIC = MAGIC_ATTACK(46)
	class AttackPacket : public OutPacket
	{
	public:
		AttackPacket(const AttackResult& attack) : OutPacket(opcodefor(attack.type))
		{
			skip(1);

			write_byte((attack.mobcount << 4) | attack.hitcount);
			write_int(attack.skill);

			if (attack.charge > 0)
				write_int(attack.charge);

			skip(8);

			write_byte(attack.display);
			write_byte(attack.toleft);
			write_byte(attack.stance);

			skip(1);

			write_byte(attack.speed);

			if (attack.type == Attack::Type::RANGED)
			{
				skip(1);
				write_byte(attack.toleft);
				skip(7);
				// TODO: skip(4); If hurricane, piercing arrow or rapidfire.
			}
			else
			{
				skip(4);
			}

			for (auto& damagetomob : attack.damagelines)
			{
				write_int(damagetomob.first);

				skip(14);

				for (auto& singledamage : damagetomob.second)
				{
					write_int(singledamage.first);
					// TODO: Add critical here
				}

				if (attack.skill != 5221004)
					skip(4);
			}
		}

	private:
		static OutPacket::Opcode opcodefor(Attack::Type type)
		{
			switch (type)
			{
			case Attack::Type::CLOSE:
				return OutPacket::Opcode::CLOSE_ATTACK;
			case Attack::Type::RANGED:
				return OutPacket::Opcode::RANGED_ATTACK;
			default:
				return OutPacket::Opcode::MAGIC_ATTACK;
			}
		}
	};

	// Tells the server that the player took damage
	// Opcode: TAKE_DAMAGE(48)
	class TakeDamagePacket : public OutPacket
	{
	public:
		enum From : int8_t
		{
			TOUCH = -1
		};

		TakeDamagePacket(int8_t from, uint8_t element, int32_t damage, int32_t mobid, int32_t oid, uint8_t direction) : OutPacket(OutPacket::Opcode::TAKE_DAMAGE)
		{
			write_time();
			write_byte(from);
			write_byte(element);
			write_int(damage);
			write_int(mobid);
			write_int(oid);
			write_byte(direction);
		}

		// From mob attack result
		TakeDamagePacket(const MobAttackResult& result, From from) : TakeDamagePacket(from, 0, result.damage, result.mobid, result.oid, result.direction) {}
	};

	// Packet which notifies the server of a skill usage
	// Opcode: USE_SKILL(91)
	class UseSkillPacket : public OutPacket
	{
	public:
		UseSkillPacket(int32_t skillid, int32_t level) : OutPacket(OutPacket::Opcode::USE_SKILL)
		{
			write_time();
			write_int(skillid);
			write_byte(static_cast<uint8_t>(level));

			// If monster magnet : some more bytes

			if (skillid % 10000000 == 1004)
				skip(2); // TODO: No idea what this could be

			// TODO: A point (4 bytes) could be added at the end
		}
	};
}

================
File: Net/Packets/CharCreationPackets.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../OutPacket.h"

namespace ms
{
	// Reserve a name for the character to be created.
	// Opcode: NAME_CHAR(21)
	class NameCharPacket : public OutPacket
	{
	public:
		NameCharPacket(const std::string& name) : OutPacket(OutPacket::Opcode::NAME_CHAR)
		{
			write_string(name);
		}
	};

	// Requests creation of a character with the specified stats.
	// Opcode: CREATE_CHAR(22)
	class CreateCharPacket : public OutPacket
	{
	public:
		CreateCharPacket(const std::string& name, int32_t job, int32_t face, int32_t hair, int32_t skin, int32_t top, int32_t bottom, int32_t shoes, int32_t weapon, bool female) : OutPacket(OutPacket::Opcode::CREATE_CHAR)
		{
			write_string(name);
			write_int(job);
			write_int(face);
			write_int(hair);
			write_int(skin);
			write_int(top);
			write_int(bottom);
			write_int(shoes);
			write_int(weapon);
			write_byte(female);
		}
	};
}

================
File: Net/Packets/CommonPackets.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../OutPacket.h"

namespace ms
{
	// Packet which notifies the server that the connection is still alive.
	// Opcode: PONG(24)
	class PongPacket : public OutPacket
	{
	public:
		PongPacket() : OutPacket(PONG) {}
	};
}

================
File: Net/Packets/GameplayPackets.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "MovementPacket.h"

namespace ms
{
	// Opcode: CHANGE_MAP(38)
	class ChangeMapPacket : public OutPacket
	{
	public:
		// Request the server to warp the player to a different map
		ChangeMapPacket(bool died, int32_t targetid, const std::string& targetp, bool usewheel) : OutPacket(OutPacket::Opcode::CHANGEMAP)
		{
			write_byte(died);
			write_int(targetid);
			write_string(targetp);
			skip(1);
			write_short(usewheel ? 1 : 0);
		}

		// Request the server to exit the cash shop
		ChangeMapPacket() : OutPacket(OutPacket::Opcode::CHANGEMAP) {}
	};

	// Opcode: ENTER_CASHSHOP(40)
	class EnterCashShopPacket : public OutPacket
	{
	public:
		// Requests the server to warp the player into the cash shop
		EnterCashShopPacket() : OutPacket(OutPacket::Opcode::ENTER_CASHSHOP) {}
	};

	// Opcode: MOVE_PLAYER(41)
	class MovePlayerPacket : public MovementPacket
	{
	public:
		// Updates the player's position with the server
		MovePlayerPacket(const Movement& movement) : MovementPacket(OutPacket::Opcode::MOVE_PLAYER)
		{
			skip(9);
			write_byte(1);
			writemovement(movement);
		}
	};

	// Opcode: PARTY_OPERATION(124)
	class PartyOperationPacket : public OutPacket
	{
	public:
		enum Operation : int8_t
		{
			CREATE = 1,
			LEAVE = 2,
			JOIN = 3,
			INVITE = 4,
			EXPEL = 5,
			PASS_LEADER = 6
		};

	protected:
		PartyOperationPacket(Operation op) : OutPacket(OutPacket::Opcode::PARTY_OPERATION)
		{
			write_byte(op);
		}
	};

	// Creates a new party
	class CreatePartyPacket : public PartyOperationPacket
	{
	public:
		CreatePartyPacket() : PartyOperationPacket(PartyOperationPacket::Operation::CREATE) {}
	};

	// Leaves a party
	class LeavePartyPacket : public PartyOperationPacket
	{
	public:
		LeavePartyPacket() : PartyOperationPacket(PartyOperationPacket::Operation::LEAVE) {}
	};

	// Joins a party
	class JoinPartyPacket : public PartyOperationPacket
	{
	public:
		JoinPartyPacket(int32_t party_id) : PartyOperationPacket(PartyOperationPacket::Operation::JOIN)
		{
			write_int(party_id);
		}
	};

	// Invites a player to a party
	class InviteToPartyPacket : public PartyOperationPacket
	{
	public:
		InviteToPartyPacket(const std::string& name) : PartyOperationPacket(PartyOperationPacket::Operation::INVITE)
		{
			write_string(name);
		}
	};

	// Expels someone from a party
	class ExpelFromPartyPacket : public PartyOperationPacket
	{
	public:
		ExpelFromPartyPacket(int32_t cid) : PartyOperationPacket(PartyOperationPacket::Operation::EXPEL)
		{
			write_int(cid);
		}
	};

	// Passes party leadership to another character
	class ChangePartyLeaderPacket : public PartyOperationPacket
	{
	public:
		ChangePartyLeaderPacket(int32_t cid) : PartyOperationPacket(PartyOperationPacket::Operation::PASS_LEADER)
		{
			write_int(cid);
		}
	};

	// Opcode: ADMIN_COMMAND(128)
	class AdminCommandPacket : public OutPacket
	{
	public:
		enum Mode : int8_t
		{
			ENTER_MAP = 0x11
		};

	protected:
		AdminCommandPacket(Mode mode) : OutPacket(OutPacket::Opcode::ADMIN_COMMAND)
		{
			write_byte(mode);
		}
	};

	// Admin has entered the map
	class AdminEnterMapPacket : public AdminCommandPacket
	{
	public:
		enum Operation : int8_t
		{
			SHOW_USERS,
			ALERT_ADMINS = 12
		};

		AdminEnterMapPacket(Operation op) : AdminCommandPacket(AdminCommandPacket::Mode::ENTER_MAP)
		{
			write_byte(op);
		}
	};

	// Opcode: MOVE_MONSTER(188)
	class MoveMobPacket : public MovementPacket
	{
	public:
		// Updates a mob's position with the server
		MoveMobPacket(int32_t oid, int16_t type, int8_t skillb, int8_t skill0, int8_t skill1, int8_t skill2, int8_t skill3, int8_t skill4, Point<int16_t> startpos, const Movement& movement) : MovementPacket(OutPacket::Opcode::MOVE_MONSTER)
		{
			write_int(oid);
			write_short(type);
			write_byte(skillb);
			write_byte(skill0);
			write_byte(skill1);
			write_byte(skill2);
			write_byte(skill3);
			write_byte(skill4);

			skip(13);

			write_point(startpos);

			write_byte(1);
			writemovement(movement);
		}
	};

	// Opcode: PICKUP_ITEM(202)
	class PickupItemPacket : public OutPacket
	{
	public:
		// Requests picking up an item
		PickupItemPacket(int32_t oid, Point<int16_t> position) : OutPacket(OutPacket::Opcode::PICKUP_ITEM)
		{
			write_int(0);
			write_byte(0);
			write_point(position);
			write_int(oid);
		}
	};

	// Opcode: DAMAGE_REACTOR(205)
	class DamageReactorPacket : public OutPacket
	{
	public:
		// Requests damaging a reactor
		DamageReactorPacket(int32_t oid, Point<int16_t> position, int16_t stance, int skillid) : OutPacket(OutPacket::Opcode::DAMAGE_REACTOR)
		{
			write_int(oid);
			write_point(position);
			write_short(stance);
			skip(4);
			write_int(skillid);
		};
	};

	// Opcode: PLAYER_MAP_TRANSFER(207)
	class PlayerMapTransferPacket : public OutPacket
	{
	public:
		// Requests the server to set map transition complete
		PlayerMapTransferPacket() : OutPacket(OutPacket::Opcode::PLAYER_MAP_TRANSFER) {}
	};

	// Opcode: PLAYER_UPDATE(223)
	class PlayerUpdatePacket : public OutPacket
	{
	public:
		// Finished updating player stats
		PlayerUpdatePacket() : OutPacket(OutPacket::Opcode::PLAYER_UPDATE) {}
	};
}

================
File: Net/Packets/InventoryPackets.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../OutPacket.h"

#include "../../Character/Inventory/Inventory.h"

namespace ms
{
	// Packet which requests that the inventory is sorted
	// Opcode: GATHER_ITEMS(69)
	class GatherItemsPacket : public OutPacket
	{
	public:
		GatherItemsPacket(InventoryType::Id type) : OutPacket(OutPacket::Opcode::GATHER_ITEMS)
		{
			write_time();
			write_byte(type);
		}
	};

	// Packet which requests that the inventory is sorted
	// Opcode: SORT_ITEMS(70)
	class SortItemsPacket : public OutPacket
	{
	public:
		SortItemsPacket(InventoryType::Id type) : OutPacket(OutPacket::Opcode::SORT_ITEMS)
		{
			write_time();
			write_byte(type);
		}
	};

	// Packet which requests that an item is moved
	// Opcode: MOVE_ITEM(71)
	class MoveItemPacket : public OutPacket
	{
	public:
		MoveItemPacket(InventoryType::Id type, int16_t slot, int16_t action, int16_t qty) : OutPacket(OutPacket::Opcode::MOVE_ITEM)
		{
			write_time();
			write_byte(type);
			write_short(slot);
			write_short(action);
			write_short(qty);
		}
	};

	// Packet which requests that an item is equipped
	// Opcode: MOVE_ITEM(71)
	class EquipItemPacket : public MoveItemPacket
	{
	public:
		EquipItemPacket(int16_t src, EquipSlot::Id dest) : MoveItemPacket(InventoryType::Id::EQUIP, src, -dest, 1) {}
	};

	// Packet which requests that an item is unequipped
	// Opcode: MOVE_ITEM(71)
	class UnequipItemPacket : public MoveItemPacket
	{
	public:
		UnequipItemPacket(int16_t src, int16_t dest) : MoveItemPacket(InventoryType::Id::EQUIPPED, -src, dest, 1) {}
	};

	// A packet which requests that an 'USE' item is used
	// Opcode: USE_ITEM(72)
	class UseItemPacket : public OutPacket
	{
	public:
		UseItemPacket(int16_t slot, int32_t itemid) : OutPacket(OutPacket::Opcode::USE_ITEM)
		{
			Sound(itemid).play();

			write_time();
			write_short(slot);
			write_int(itemid);
		}
	};

	// Requests using a scroll on an equip 
	// Opcode: SCROLL_EQUIP(86)
	class ScrollEquipPacket : public OutPacket
	{
	public:
		enum Flag : uint8_t
		{
			NONE = 0x00,
			UNKNOWN = 0x01,
			WHITESCROLL = 0x02
		};

		ScrollEquipPacket(int16_t source, EquipSlot::Id target, uint8_t flags) : OutPacket(OutPacket::Opcode::SCROLL_EQUIP)
		{
			write_time();
			write_short(source);
			write_short(-target);
			write_short(flags);
		}

		ScrollEquipPacket(int16_t source, EquipSlot::Id target) : ScrollEquipPacket(source, target, 0) {}
	};
}

================
File: Net/Packets/LoginPackets.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../OutPacket.h"

#include "../../Configuration.h"

namespace ms
{
	// Opcode: LOGIN(1)
	class LoginPacket : public OutPacket
	{
	public:
		// Request to be logged-in to an account
		LoginPacket(const std::string& acc, const std::string& pass) : OutPacket(OutPacket::Opcode::LOGIN)
		{
			std::string volumeSerialNumber = Configuration::get().get_vol_serial_num();

			std::string part1 = volumeSerialNumber.substr(0, 2);
			std::string part2 = volumeSerialNumber.substr(2, 2);
			std::string part3 = volumeSerialNumber.substr(4, 2);
			std::string part4 = volumeSerialNumber.substr(6, 2);

			const int32_t h = hex_to_dec(part4);
			const int32_t w = hex_to_dec(part3);
			const int32_t i = hex_to_dec(part2);
			const int32_t d = hex_to_dec(part1);

			write_string(acc);
			write_string(pass);

			skip(6);

			write_byte(h);
			write_byte(w);
			write_byte(i);
			write_byte(d);
		}
	};

	// Opcode: LOGIN_EMAIL(3)
	class LoginEmailPacket : public OutPacket
	{
	public:
		// Request to be logged-in to an account
		LoginEmailPacket(const std::string& email, const std::string& pass) : OutPacket(OutPacket::Opcode::LOGIN_EMAIL)
		{
			std::string volumeSerialNumber = Configuration::get().get_vol_serial_num();

			std::string part1 = volumeSerialNumber.substr(0, 2);
			std::string part2 = volumeSerialNumber.substr(2, 2);
			std::string part3 = volumeSerialNumber.substr(4, 2);
			std::string part4 = volumeSerialNumber.substr(6, 2);

			const int32_t h = hex_to_dec(part4);
			const int32_t w = hex_to_dec(part3);
			const int32_t i = hex_to_dec(part2);
			const int32_t d = hex_to_dec(part1);

			write_string(email);
			write_string(pass);

			skip(6);

			write_byte(h);
			write_byte(w);
			write_byte(i);
			write_byte(d);
		}
	};

	// Opcode: CHARLIST_REQUEST(5)
	class CharlistRequestPacket : public OutPacket
	{
	public:
		// Requests the list of characters on a world
		CharlistRequestPacket(uint8_t world, uint8_t channel) : OutPacket(OutPacket::Opcode::CHARLIST_REQUEST)
		{
			write_byte(0);
			write_byte(world);
			write_byte(channel);
		}
	};

	// Opcode: SERVERSTATUS_REQUEST(6)
	class ServerStatusRequestPacket : public OutPacket
	{
	public:
		// Requests the status of the server
		ServerStatusRequestPacket(int16_t world) : OutPacket(OutPacket::Opcode::SERVERSTATUS_REQUEST)
		{
			write_short(world);
		}
	};

	// Opcode: ACCEPT_TOS(7)
	class TOSPacket : public OutPacket
	{
	public:
		// Accept the Terms of Service
		TOSPacket() : OutPacket(OutPacket::Opcode::ACCEPT_TOS)
		{
			write_byte(1);
		}
	};

	// Opcode: SET_GENDER(8)
	class GenderPacket : public OutPacket
	{
	public:
		// Send user selected Gender
		GenderPacket(const bool female) : OutPacket(OutPacket::Opcode::SET_GENDER)
		{
			write_byte(1);
			write_byte(female);
		}
	};

	// Opcode: SERVERLIST_REQUEST(11)
	class ServerRequestPacket : public OutPacket
	{
	public:
		// Requests the list of worlds and channels
		ServerRequestPacket() : OutPacket(OutPacket::Opcode::SERVERLIST_REQUEST) {}
	};

	// Opcode: PLAYER_LOGIN(20)
	class PlayerLoginPacket : public OutPacket
	{
	public:
		// Requests being logged-in to a channel server with the specified character
		PlayerLoginPacket(int32_t cid) : OutPacket(OutPacket::Opcode::PLAYER_LOGIN)
		{
			write_int(cid);
		}
	};
}

================
File: Net/Packets/MessagingPackets.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../OutPacket.h"

namespace ms
{
	// Packet which sends a message to general chat
	// Opcode: GENERAL_CHAT(49)
	class GeneralChatPacket : public OutPacket
	{
	public:
		GeneralChatPacket(const std::string& message, bool show) : OutPacket(OutPacket::Opcode::GENERAL_CHAT)
		{
			write_string(message);
			write_byte(show);
		}
	};

	// Packet which sends a message to different chats
	// Opcode: MULTI_CHAT(119)
	class MultiChatPacket : public OutPacket
	{
	public:
		enum Type : uint8_t
		{
			BUDDY,
			PARTY,
			GUILD,
			ALLIANCE
		};

		MultiChatPacket(Type type, const std::list<int32_t>& recipients, const std::string& message) : OutPacket(OutPacket::Opcode::MULTI_CHAT)
		{
			write_byte(type);
			write_byte(recipients.size());

			for (int32_t recipient : recipients)
				write_int(recipient);

			write_string(message);
		}
	};

	// Packet which sends a message to a spouse
	// Opcode: SPOUSE_CHAT(121)
	class SpouseChatPacket : public OutPacket
	{
	public:
		SpouseChatPacket(const std::string& message) : OutPacket(OutPacket::Opcode::SPOUSE_CHAT)
		{
			write_string(message);
		}
	};
}

================
File: Net/Packets/MovementPacket.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../OutPacket.h"

namespace ms
{
	// Base class for packets which update object movements with the server
	class MovementPacket : public OutPacket
	{
	public:
		MovementPacket(OutPacket::Opcode opc) : OutPacket(opc) {}

	protected:
		void writemovement(const Movement& movement)
		{
			write_byte(movement.command);
			write_short(movement.xpos);
			write_short(movement.ypos);
			write_short(movement.lastx);
			write_short(movement.lasty);
			write_short(movement.fh);
			write_byte(movement.newstate);
			write_short(movement.duration);
		}
	};
}

================
File: Net/Packets/NpcInteractionPackets.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../OutPacket.h"

namespace ms
{
	// Packet which requests a dialog with a server-sided NPC
	// Opcode: TALK_TO_NPC(58)
	class TalkToNPCPacket : public OutPacket
	{
	public:
		TalkToNPCPacket(int32_t oid) : OutPacket(OutPacket::Opcode::TALK_TO_NPC)
		{
			write_int(oid);
		}
	};

	// Packet which sends a response to an NPC dialog to the server
	// Opcode: NPC_TALK_MORE(60)
	class NpcTalkMorePacket : public OutPacket
	{
	public:
		NpcTalkMorePacket(int8_t lastmsg, int8_t response) : OutPacket(OutPacket::Opcode::NPC_TALK_MORE)
		{
			write_byte(lastmsg);
			write_byte(response);
		}

		NpcTalkMorePacket(const std::string& response) : NpcTalkMorePacket(2, 1)
		{
			write_string(response);
		}

		NpcTalkMorePacket(int32_t selection) : NpcTalkMorePacket(4, 1)
		{
			write_int(selection);
		}
	};

	// Packet which tells the server of an interaction with an NPC shop
	// Opcode: NPC_SHOP_ACTION(61)
	class NpcShopActionPacket : public OutPacket
	{
	public:
		// Requests that an item should be bought from or sold to a NPC shop
		NpcShopActionPacket(int16_t slot, int32_t itemid, int16_t qty, bool buy) : NpcShopActionPacket(buy ? Mode::BUY : Mode::SELL)
		{
			write_short(slot);
			write_int(itemid);
			write_short(qty);
		}

		// Requests that an item should be recharged at a NPC shop
		NpcShopActionPacket(int16_t slot) : NpcShopActionPacket(Mode::RECHARGE)
		{
			write_short(slot);
		}

		// Requests exiting from a NPC shop
		NpcShopActionPacket() : NpcShopActionPacket(Mode::LEAVE) {}

	protected:
		enum Mode : int8_t
		{
			BUY, SELL, RECHARGE, LEAVE
		};

		NpcShopActionPacket(Mode mode) : OutPacket(OutPacket::Opcode::NPC_SHOP_ACTION)
		{
			write_byte(mode);
		}
	};
}

================
File: Net/Packets/PlayerInteractionPackets.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../OutPacket.h"

namespace ms
{
	// Packet to request character info
	// Opcode: CHAR_INFO_REQUEST(97)
	class CharInfoRequestPacket : public OutPacket
	{
	public:
		CharInfoRequestPacket(int32_t character_id) : OutPacket(OutPacket::Opcode::CHAR_INFO_REQUEST)
		{
			write_random();
			write_int(character_id);
		}
	};
}

================
File: Net/Packets/PlayerPackets.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../OutPacket.h"

#include "../../Character/MapleStat.h"

#include "../../IO/UITypes/UIKeyConfig.h"

namespace ms
{
	// Requests a stat increase by spending AP
	// Opcode: SPEND_AP(87)
	class SpendApPacket : public OutPacket
	{
	public:
		SpendApPacket(MapleStat::Id stat) : OutPacket(OutPacket::Opcode::SPEND_AP)
		{
			write_time();
			write_int(MapleStat::codes[stat]);
		}
	};

	// Requests a skill level increase by spending SP
	// Opcode: SPEND_SP(90)
	class SpendSpPacket : public OutPacket
	{
	public:
		SpendSpPacket(int32_t skill_id) : OutPacket(OutPacket::Opcode::SPEND_SP)
		{
			write_time();
			write_int(skill_id);
		}
	};

	// Requests the server to change key mappings
	// Opcode: CHANGE_KEYMAP(135)
	class ChangeKeyMapPacket : public OutPacket
	{
	public:
		ChangeKeyMapPacket(std::vector<std::tuple<KeyConfig::Key, KeyType::Id, int32_t>> updated_actions) : OutPacket(OutPacket::Opcode::CHANGE_KEYMAP)
		{
			write_int(0); // mode
			write_int(updated_actions.size()); // Number of key changes

			for (size_t i = 0; i < updated_actions.size(); i++)
			{
				auto keymap = updated_actions[i];

				write_int(std::get<0>(keymap));		// key
				write_byte(std::get<1>(keymap));	// type
				write_int(std::get<2>(keymap));		// action
			}
		}
	};
}

================
File: Net/Packets/SelectCharPackets.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../OutPacket.h"

namespace ms
{
	// Tell the server which character was picked.
	// Opcode: SELECT_CHAR(19)
	class SelectCharPacket : public OutPacket
	{
	public:
		SelectCharPacket(int32_t cid) : OutPacket(OutPacket::Opcode::SELECT_CHAR)
		{
			write_int(cid);
			write_hardware_info();
		}
	};

	// Registers a pic and tells the server which character was picked.
	// Opcode: REGISTER_PIC(29)
	class RegisterPicPacket : public OutPacket
	{
	public:
		RegisterPicPacket(int32_t cid, const std::string& pic) : OutPacket(OutPacket::Opcode::REGISTER_PIC)
		{
			skip(1);

			write_int(cid);
			write_hardware_info();
			write_string(pic);
		}
	};

	// Requests using the specified character with the specified pic.
	// Opcode: SELECT_CHAR_PIC(30)
	class SelectCharPicPacket : public OutPacket
	{
	public:
		SelectCharPicPacket(const std::string& pic, int32_t cid) : OutPacket(OutPacket::Opcode::SELECT_CHAR_PIC)
		{
			write_string(pic);
			write_int(cid);
			write_hardware_info();
		}
	};

	// Requests deleting the specified character without a pic.
	// Opcode: DELETE_CHAR(23)
	class DeleteCharPacket : public OutPacket
	{
	public:
		DeleteCharPacket(int32_t cid) : OutPacket(OutPacket::Opcode::DELETE_CHAR)
		{
			write_string("");
			write_int(cid);
		}
	};

	// Requests deleting the specified character with the specified pic.
	// Opcode: DELETE_CHAR(23)
	class DeleteCharPicPacket : public OutPacket
	{
	public:
		DeleteCharPicPacket(const std::string& pic, int32_t cid) : OutPacket(OutPacket::Opcode::DELETE_CHAR)
		{
			write_string(pic);
			write_int(cid);
		}
	};
}

================
File: Net/PacketSwitch.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "PacketSwitch.h"

#include "Handlers/AttackHandlers.h"
#include "Handlers/CashShopHandlers.h"
#include "Handlers/CommonHandlers.h"
#include "Handlers/InventoryHandlers.h"
#include "Handlers/LoginHandlers.h"
#include "Handlers/MapObjectHandlers.h"
#include "Handlers/MessagingHandlers.h"
#include "Handlers/NpcInteractionHandlers.h"
#include "Handlers/PlayerHandlers.h"
#include "Handlers/PlayerInteractionHandlers.h"
#include "Handlers/SetFieldHandlers.h"
#include "Handlers/TestingHandlers.h"

#include "../Configuration.h"

namespace ms
{
	// Opcodes for InPackets
	enum Opcode : uint16_t
	{
		/// Login 1
		LOGIN_RESULT = 0,
		SERVERSTATUS = 3,
		SELECT_CHARACTER_BY_VAC = 9,
		SERVERLIST = 10,
		CHARLIST = 11,
		SERVER_IP = 12,
		CHARNAME_RESPONSE = 13,
		ADD_NEWCHAR_ENTRY = 14,
		DELCHAR_RESPONSE = 15,
		PING = 17,

		/// Login 2
		CHECK_SPW_RESULT = 28,

		/// Inventory 1
		MODIFY_INVENTORY = 29,

		/// Player 2
		CHANGE_CHANNEL = 16,
		CHANGE_STATS = 31,
		GIVE_BUFF = 32,
		CANCEL_BUFF = 33,
		RECALCULATE_STATS = 35,
		UPDATE_SKILL = 36,

		/// Messaging 1
		SHOW_STATUS_INFO = 39,

		/// Inventory 2
		GATHER_RESULT = 52,
		SORT_RESULT = 53,

		/// Player 3

		/// Messaging 2
		SERVER_MESSAGE = 68,
		WEEK_EVENT_MESSAGE = 77,

		SKILL_MACROS = 124,
		SET_FIELD = 125,
		FIELD_EFFECT = 138,

		/// MapObject
		SPAWN_CHAR = 160,
		REMOVE_CHAR = 161,

		/// Messaging
		CHAT_RECEIVED = 162,
		SCROLL_RESULT = 167,

		/// MapObject
		SPAWN_PET = 168,
		CHAR_MOVED = 185,

		/// Attack
		ATTACKED_CLOSE = 186,
		ATTACKED_RANGED = 187,
		ATTACKED_MAGIC = 188,

		UPDATE_CHARLOOK = 197,
		SHOW_FOREIGN_EFFECT = 198,
		SHOW_ITEM_GAIN_INCHAT = 206, // TODO: Rename this (Terribly named)

		/// Player
		ADD_COOLDOWN = 234,

		/// MapObject
		SPAWN_MOB = 236,
		KILL_MOB = 237,
		SPAWN_MOB_C = 238,
		MOB_MOVED = 239,
		SHOW_MOB_HP = 250,
		SPAWN_NPC = 257,
		SPAWN_NPC_C = 259,
		DROP_LOOT = 268,
		REMOVE_LOOT = 269,
		HIT_REACTOR = 277,
		SPAWN_REACTOR = 279,
		REMOVE_REACTOR = 280,

		/// NPC Interaction
		NPC_DIALOGUE = 304,
		OPEN_NPC_SHOP = 305,
		CONFIRM_SHOP_TRANSACTION = 306,
		KEYMAP = 335,

		/// Player Interaction
		CHAR_INFO = 61,

		/// Cash Shop
		SET_CASH_SHOP = 127
	};

	PacketSwitch::PacketSwitch()
	{
		// Common handlers
		emplace<PING, PingHandler>();

		// Login handlers
		emplace<LOGIN_RESULT, LoginResultHandler>();
		emplace<SERVERSTATUS, ServerStatusHandler>();
		emplace<SELECT_CHARACTER_BY_VAC, SelectCharacterHandler>();
		emplace<SERVERLIST, ServerlistHandler>();
		emplace<CHARLIST, CharlistHandler>();
		emplace<SERVER_IP, ServerIPHandler>();
		emplace<CHARNAME_RESPONSE, CharnameResponseHandler>();
		emplace<ADD_NEWCHAR_ENTRY, AddNewCharEntryHandler>();
		emplace<DELCHAR_RESPONSE, DeleteCharResponseHandler>();

		// SetField handlers
		emplace<SET_FIELD, SetFieldHandler>();

		// MapObject handlers
		emplace<SPAWN_CHAR, SpawnCharHandler>();
		emplace<CHAR_MOVED, CharMovedHandler>();
		emplace<UPDATE_CHARLOOK, UpdateCharLookHandler>();
		emplace<SHOW_FOREIGN_EFFECT, ShowForeignEffectHandler>();
		emplace<REMOVE_CHAR, RemoveCharHandler>();
		emplace<SPAWN_PET, SpawnPetHandler>();
		emplace<SPAWN_NPC, SpawnNpcHandler>();
		emplace<SPAWN_NPC_C, SpawnNpcControllerHandler>();
		emplace<SPAWN_MOB, SpawnMobHandler>();
		emplace<SPAWN_MOB_C, SpawnMobControllerHandler>();
		emplace<MOB_MOVED, MobMovedHandler>();
		emplace<SHOW_MOB_HP, ShowMobHpHandler>();
		emplace<KILL_MOB, KillMobHandler>();
		emplace<DROP_LOOT, DropLootHandler>();
		emplace<REMOVE_LOOT, RemoveLootHandler>();
		emplace<HIT_REACTOR, HitReactorHandler>();
		emplace<SPAWN_REACTOR, SpawnReactorHandler>();
		emplace<REMOVE_REACTOR, RemoveReactorHandler>();

		// Attack handlers
		emplace<ATTACKED_CLOSE, CloseAttackHandler>();
		emplace<ATTACKED_RANGED, RangedAttackHandler>();
		emplace<ATTACKED_MAGIC, MagicAttackHandler>();

		// Player handlers
		emplace<CHANGE_CHANNEL, ChangeChannelHandler>();
		emplace<KEYMAP, KeymapHandler>();
		emplace<SKILL_MACROS, SkillMacrosHandler>();
		emplace<CHANGE_STATS, ChangeStatsHandler>();
		emplace<GIVE_BUFF, ApplyBuffHandler>();
		emplace<CANCEL_BUFF, CancelBuffHandler>();
		emplace<RECALCULATE_STATS, RecalculateStatsHandler>();
		emplace<UPDATE_SKILL, UpdateSkillHandler>();
		emplace<ADD_COOLDOWN, AddCooldownHandler>();

		// Messaging handlers
		emplace<SHOW_STATUS_INFO, ShowStatusInfoHandler>();
		emplace<CHAT_RECEIVED, ChatReceivedHandler>();
		emplace<SCROLL_RESULT, ScrollResultHandler>();
		emplace<SERVER_MESSAGE, ServerMessageHandler>();
		emplace<WEEK_EVENT_MESSAGE, WeekEventMessageHandler>();
		emplace<SHOW_ITEM_GAIN_INCHAT, ShowItemGainInChatHandler>();

		// Inventory Handlers
		emplace<MODIFY_INVENTORY, ModifyInventoryHandler>();
		emplace<GATHER_RESULT, GatherResultHandler>();
		emplace<SORT_RESULT, SortResultHandler>();

		// NPC Interaction Handlers
		emplace<NPC_DIALOGUE, NpcDialogueHandler>();
		emplace<OPEN_NPC_SHOP, OpenNpcShopHandler>();

		// Player Interaction
		emplace<CHAR_INFO, CharInfoHandler>();

		// Cash Shop
		emplace<SET_CASH_SHOP, SetCashShopHandler>();

		// TODO: New handlers, they need coded and moved to a proper file.
		emplace<CHECK_SPW_RESULT, CheckSpwResultHandler>();
		emplace<FIELD_EFFECT, FieldEffectHandler>();
	}

	void PacketSwitch::forward(const int8_t* bytes, size_t length) const
	{
		// Wrap the bytes with a parser
		InPacket recv = { bytes, length };

		// Read the opcode to determine handler responsible
		uint16_t opcode = recv.read_short();

		bool opcode_error = false;

		if (opcode < NUM_HANDLERS)
		{
			if (auto& handler = handlers[opcode])
			{
				// Handler is good, packet is passed on

				try
				{
					handler->handle(recv);
				}
				catch (const PacketError& err)
				{
					// Notice about an error
					warn(err.what(), opcode);
					opcode_error = true;
				}
			}
			else
			{
				// Warn about an unhandled packet
				warn(MSG_UNHANDLED, opcode);
				opcode_error = true;
			}
		}
		else
		{
			// Warn about a packet with opcode out of bounds
			warn(MSG_OUTOFBOUNDS, opcode);
			opcode_error = true;
		}

#if LOG_LEVEL >= LOG_NETWORK
		if (!opcode_error)
			LOG(LOG_NETWORK, "Received Packet: " << OpcodeName(opcode));
#endif
	}

	void PacketSwitch::warn(const std::string& message, size_t opcode) const
	{
		std::string opcode_msg = OpcodeName(opcode);
		LOG(LOG_NETWORK, "[PacketSwitch::warn]: Opcode [" << opcode_msg << "] Error: " << message);
	}

	std::string PacketSwitch::OpcodeName(size_t opcode) const
	{
		std::string opcode_msg = std::to_string(opcode);

		switch (opcode)
		{
			case 0: opcode_msg = "LOGIN_STATUS"; break;
			case 1: opcode_msg = "GUEST_ID_LOGIN"; break;
			case 2: opcode_msg = "ACCOUNT_INFO"; break;
			case 3: opcode_msg = "SERVERSTATUS"; break;
			case 4: opcode_msg = "GENDER_DONE"; break;
			case 5: opcode_msg = "CONFIRM_EULA_RESULT"; break;
			case 6: opcode_msg = "CHECK_PINCODE"; break;
			case 7: opcode_msg = "UPDATE_PINCODE"; break;
			case 8: opcode_msg = "VIEW_ALL_CHAR"; break;
			case 9: opcode_msg = "SELECT_CHARACTER_BY_VAC"; break;
			case 10: opcode_msg = "SERVERLIST"; break;
			case 11: opcode_msg = "CHARLIST"; break;
			case 12: opcode_msg = "SERVER_IP"; break;
			case 13: opcode_msg = "CHAR_NAME_RESPONSE"; break;
			case 14: opcode_msg = "ADD_NEW_CHAR_ENTRY"; break;
			case 15: opcode_msg = "DELETE_CHAR_RESPONSE"; break;
			case 16: opcode_msg = "CHANGE_CHANNEL"; break;
			case 17: opcode_msg = "PING"; break;
			case 18: opcode_msg = "KOREAN_INTERNET_CAFE_SHIT"; break;
			case 20: opcode_msg = "CHANNEL_SELECTED"; break;
			case 21: opcode_msg = "HACKSHIELD_REQUEST"; break;
			case 22: opcode_msg = "RELOG_RESPONSE"; break;
			case 25: opcode_msg = "CHECK_CRC_RESULT"; break;
			case 26: opcode_msg = "LAST_CONNECTED_WORLD"; break;
			case 27: opcode_msg = "RECOMMENDED_WORLD_MESSAGE"; break;
			case 28: opcode_msg = "CHECK_SPW_RESULT"; break;
			case 29: opcode_msg = "INVENTORY_OPERATION"; break;
			case 30: opcode_msg = "INVENTORY_GROW"; break;
			case 31: opcode_msg = "STAT_CHANGED"; break;
			case 32: opcode_msg = "GIVE_BUFF"; break;
			case 33: opcode_msg = "CANCEL_BUFF"; break;
			case 34: opcode_msg = "FORCED_STAT_SET"; break;
			case 35: opcode_msg = "FORCED_STAT_RESET"; break;
			case 36: opcode_msg = "UPDATE_SKILLS"; break;
			case 37: opcode_msg = "SKILL_USE_RESULT"; break;
			case 38: opcode_msg = "FAME_RESPONSE"; break;
			case 39: opcode_msg = "SHOW_STATUS_INFO"; break;
			case 40: opcode_msg = "OPEN_FULL_CLIENT_DOWNLOAD_LINK"; break;
			case 41: opcode_msg = "MEMO_RESULT"; break;
			case 42: opcode_msg = "MAP_TRANSFER_RESULT"; break;
			case 43: opcode_msg = "WEDDING_PHOTO"; break;
			case 45: opcode_msg = "CLAIM_RESULT"; break;
			case 46: opcode_msg = "CLAIM_AVAILABLE_TIME"; break;
			case 47: opcode_msg = "CLAIM_STATUS_CHANGED"; break;
			case 48: opcode_msg = "SET_TAMING_MOB_INFO"; break;
			case 49: opcode_msg = "QUEST_CLEAR"; break;
			case 50: opcode_msg = "ENTRUSTED_SHOP_CHECK_RESULT"; break;
			case 51: opcode_msg = "SKILL_LEARN_ITEM_RESULT"; break;
			case 52: opcode_msg = "GATHER_ITEM_RESULT"; break;
			case 53: opcode_msg = "SORT_ITEM_RESULT"; break;
			case 55: opcode_msg = "SUE_CHARACTER_RESULT"; break;
			case 57: opcode_msg = "TRADE_MONEY_LIMIT"; break;
			case 58: opcode_msg = "SET_GENDER"; break;
			case 59: opcode_msg = "GUILD_BBS_PACKET"; break;
			case 61: opcode_msg = "CHAR_INFO"; break;
			case 62: opcode_msg = "PARTY_OPERATION"; break;
			case 63: opcode_msg = "BUDDYLIST"; break;
			case 65: opcode_msg = "GUILD_OPERATION"; break;
			case 66: opcode_msg = "ALLIANCE_OPERATION"; break;
			case 67: opcode_msg = "SPAWN_PORTAL"; break;
			case 68: opcode_msg = "SERVERMESSAGE"; break;
			case 69: opcode_msg = "INCUBATOR_RESULT"; break;
			case 70: opcode_msg = "SHOP_SCANNER_RESULT"; break;
			case 71: opcode_msg = "SHOP_LINK_RESULT"; break;
			case 72: opcode_msg = "MARRIAGE_REQUEST"; break;
			case 73: opcode_msg = "MARRIAGE_RESULT"; break;
			case 74: opcode_msg = "WEDDING_GIFT_RESULT"; break;
			case 75: opcode_msg = "NOTIFY_MARRIED_PARTNER_MAP_TRANSFER"; break;
			case 76: opcode_msg = "CASH_PET_FOOD_RESULT"; break;
			case 77: opcode_msg = "SET_WEEK_EVENT_MESSAGE"; break;
			case 78: opcode_msg = "SET_POTION_DISCOUNT_RATE"; break;
			case 79: opcode_msg = "BRIDLE_MOB_CATCH_FAIL"; break;
			case 80: opcode_msg = "IMITATED_NPC_RESULT"; break;
			case 81: opcode_msg = "IMITATED_NPC_DATA"; break;
			case 82: opcode_msg = "LIMITED_NPC_DISABLE_INFO"; break;
			case 83: opcode_msg = "MONSTER_BOOK_SET_CARD"; break;
			case 84: opcode_msg = "MONSTER_BOOK_SET_COVER"; break;
			case 85: opcode_msg = "HOUR_CHANGED"; break;
			case 86: opcode_msg = "MINIMAP_ON_OFF"; break;
			case 87: opcode_msg = "CONSULT_AUTHKEY_UPDATE"; break;
			case 88: opcode_msg = "CLASS_COMPETITION_AUTHKEY_UPDATE"; break;
			case 89: opcode_msg = "WEB_BOARD_AUTHKEY_UPDATE"; break;
			case 90: opcode_msg = "SESSION_VALUE"; break;
			case 91: opcode_msg = "PARTY_VALUE"; break;
			case 92: opcode_msg = "FIELD_SET_VARIABLE"; break;
			case 93: opcode_msg = "BONUS_EXP_CHANGED"; break;
			case 94: opcode_msg = "FAMILY_CHART_RESULT"; break;
			case 95: opcode_msg = "FAMILY_INFO_RESULT"; break;
			case 96: opcode_msg = "FAMILY_RESULT"; break;
			case 97: opcode_msg = "FAMILY_JOIN_REQUEST"; break;
			case 98: opcode_msg = "FAMILY_JOIN_REQUEST_RESULT"; break;
			case 99: opcode_msg = "FAMILY_JOIN_ACCEPTED"; break;
			case 100: opcode_msg = "FAMILY_PRIVILEGE_LIST"; break;
			case 101: opcode_msg = "FAMILY_FAMOUS_POINT_INC_RESULT"; break;
			case 102: opcode_msg = "FAMILY_NOTIFY_LOGIN_OR_LOGOUT"; break;
			case 103: opcode_msg = "FAMILY_SET_PRIVILEGE"; break;
			case 104: opcode_msg = "FAMILY_SUMMON_REQUEST"; break;
			case 105: opcode_msg = "NOTIFY_LEVELUP"; break;
			case 106: opcode_msg = "NOTIFY_MARRIAGE"; break;
			case 107: opcode_msg = "NOTIFY_JOB_CHANGE"; break;
			case 108: opcode_msg = "SET_BUY_EQUIP_EXT"; break;
			case 109: opcode_msg = "MAPLE_TV_USE_RES"; break;
			case 110: opcode_msg = "AVATAR_MEGAPHONE_RESULT"; break;
			case 111: opcode_msg = "SET_AVATAR_MEGAPHONE"; break;
			case 112: opcode_msg = "CLEAR_AVATAR_MEGAPHONE"; break;
			case 113: opcode_msg = "CANCEL_NAME_CHANGE_RESULT"; break;
			case 114: opcode_msg = "CANCEL_TRANSFER_WORLD_RESULT"; break;
			case 115: opcode_msg = "DESTROY_SHOP_RESULT"; break;
			case 116: opcode_msg = "FAKE_GM_NOTICE"; break;
			case 117: opcode_msg = "SUCCESS_IN_USE_GACHAPON_BOX"; break;
			case 118: opcode_msg = "NEW_YEAR_CARD_RES"; break;
			case 119: opcode_msg = "RANDOM_MORPH_RES"; break;
			case 120: opcode_msg = "CANCEL_NAME_CHANGE_BY_OTHER"; break;
			case 121: opcode_msg = "SET_EXTRA_PENDANT_SLOT"; break;
			case 122: opcode_msg = "SCRIPT_PROGRESS_MESSAGE"; break;
			case 123: opcode_msg = "DATA_CRC_CHECK_FAILED"; break;
			case 124: opcode_msg = "MACRO_SYS_DATA_INIT"; break;
			case 125: opcode_msg = "SET_FIELD"; break;
			case 126: opcode_msg = "SET_ITC"; break;
			case 127: opcode_msg = "SET_CASH_SHOP"; break;
			case 128: opcode_msg = "SET_BACK_EFFECT"; break;
			case 129: opcode_msg = "SET_MAP_OBJECT_VISIBLE"; break;
			case 130: opcode_msg = "CLEAR_BACK_EFFECT"; break;
			case 131: opcode_msg = "BLOCKED_MAP"; break;
			case 132: opcode_msg = "BLOCKED_SERVER"; break;
			case 133: opcode_msg = "FORCED_MAP_EQUIP"; break;
			case 134: opcode_msg = "MULTICHAT"; break;
			case 135: opcode_msg = "WHISPER"; break;
			case 136: opcode_msg = "SPOUSE_CHAT"; break;
			case 137: opcode_msg = "SUMMON_ITEM_INAVAILABLE"; break;
			case 138: opcode_msg = "FIELD_EFFECT"; break;
			case 139: opcode_msg = "FIELD_OBSTACLE_ONOFF"; break;
			case 140: opcode_msg = "FIELD_OBSTACLE_ONOFF_LIST"; break;
			case 141: opcode_msg = "FIELD_OBSTACLE_ALL_RESET"; break;
			case 142: opcode_msg = "BLOW_WEATHER"; break;
			case 143: opcode_msg = "PLAY_JUKEBOX"; break;
			case 144: opcode_msg = "ADMIN_RESULT"; break;
			case 145: opcode_msg = "OX_QUIZ"; break;
			case 146: opcode_msg = "GMEVENT_INSTRUCTIONS"; break;
			case 147: opcode_msg = "CLOCK"; break;
			case 148: opcode_msg = "CONTI_MOVE"; break;
			case 149: opcode_msg = "CONTI_STATE"; break;
			case 150: opcode_msg = "SET_QUEST_CLEAR"; break;
			case 151: opcode_msg = "SET_QUEST_TIME"; break;
			case 152: opcode_msg = "WARN_MESSAGE"; break;
			case 153: opcode_msg = "SET_OBJECT_STATE"; break;
			case 154: opcode_msg = "STOP_CLOCK"; break;
			case 155: opcode_msg = "ARIANT_ARENA_SHOW_RESULT"; break;
			case 157: opcode_msg = "PYRAMID_GAUGE"; break;
			case 158: opcode_msg = "PYRAMID_SCORE"; break;
			case 160: opcode_msg = "SPAWN_PLAYER"; break;
			case 161: opcode_msg = "REMOVE_PLAYER_FROM_MAP"; break;
			case 162: opcode_msg = "CHATTEXT"; break;
			case 163: opcode_msg = "CHATTEXT1"; break;
			case 164: opcode_msg = "CHALKBOARD"; break;
			case 165: opcode_msg = "UPDATE_CHAR_BOX"; break;
			case 166: opcode_msg = "SHOW_CONSUME_EFFECT"; break;
			case 167: opcode_msg = "SHOW_SCROLL_EFFECT"; break;
			case 168: opcode_msg = "SPAWN_PET"; break;
			case 170: opcode_msg = "MOVE_PET"; break;
			case 171: opcode_msg = "PET_CHAT"; break;
			case 172: opcode_msg = "PET_NAMECHANGE"; break;
			case 173: opcode_msg = "PET_EXCEPTION_LIST"; break;
			case 174: opcode_msg = "PET_COMMAND"; break;
			case 175: opcode_msg = "SPAWN_SPECIAL_MAPOBJECT"; break;
			case 176: opcode_msg = "REMOVE_SPECIAL_MAPOBJECT"; break;
			case 177: opcode_msg = "MOVE_SUMMON"; break;
			case 178: opcode_msg = "SUMMON_ATTACK"; break;
			case 179: opcode_msg = "DAMAGE_SUMMON"; break;
			case 180: opcode_msg = "SUMMON_SKILL"; break;
			case 181: opcode_msg = "SPAWN_DRAGON"; break;
			case 182: opcode_msg = "MOVE_DRAGON"; break;
			case 183: opcode_msg = "REMOVE_DRAGON"; break;
			case 185: opcode_msg = "MOVE_PLAYER"; break;
			case 186: opcode_msg = "CLOSE_RANGE_ATTACK"; break;
			case 187: opcode_msg = "RANGED_ATTACK"; break;
			case 188: opcode_msg = "MAGIC_ATTACK"; break;
			case 189: opcode_msg = "ENERGY_ATTACK"; break;
			case 190: opcode_msg = "SKILL_EFFECT"; break;
			case 191: opcode_msg = "CANCEL_SKILL_EFFECT"; break;
			case 192: opcode_msg = "DAMAGE_PLAYER"; break;
			case 193: opcode_msg = "FACIAL_EXPRESSION"; break;
			case 194: opcode_msg = "SHOW_ITEM_EFFECT"; break;
			case 196: opcode_msg = "SHOW_CHAIR"; break;
			case 197: opcode_msg = "UPDATE_CHAR_LOOK"; break;
			case 198: opcode_msg = "SHOW_FOREIGN_EFFECT"; break;
			case 199: opcode_msg = "GIVE_FOREIGN_BUFF"; break;
			case 200: opcode_msg = "CANCEL_FOREIGN_BUFF"; break;
			case 201: opcode_msg = "UPDATE_PARTYMEMBER_HP"; break;
			case 202: opcode_msg = "GUILD_NAME_CHANGED"; break;
			case 203: opcode_msg = "GUILD_MARK_CHANGED"; break;
			case 204: opcode_msg = "THROW_GRENADE"; break;
			case 205: opcode_msg = "CANCEL_CHAIR"; break;
			case 206: opcode_msg = "SHOW_ITEM_GAIN_INCHAT"; break;
			case 207: opcode_msg = "DOJO_WARP_UP"; break;
			case 208: opcode_msg = "LUCKSACK_PASS"; break;
			case 209: opcode_msg = "LUCKSACK_FAIL"; break;
			case 210: opcode_msg = "MESO_BAG_MESSAGE"; break;
			case 211: opcode_msg = "UPDATE_QUEST_INFO"; break;
			case 214: opcode_msg = "PLAYER_HINT"; break;
			case 219: opcode_msg = "KOREAN_EVENT"; break;
			case 220: opcode_msg = "OPEN_UI"; break;
			case 221: opcode_msg = "LOCK_UI"; break;
			case 222: opcode_msg = "DISABLE_UI"; break;
			case 223: opcode_msg = "SPAWN_GUIDE"; break;
			case 224: opcode_msg = "TALK_GUIDE"; break;
			case 225: opcode_msg = "SHOW_COMBO"; break;
			case 234: opcode_msg = "COOLDOWN"; break;
			case 236: opcode_msg = "SPAWN_MONSTER"; break;
			case 237: opcode_msg = "KILL_MONSTER"; break;
			case 238: opcode_msg = "SPAWN_MONSTER_CONTROL"; break;
			case 239: opcode_msg = "MOVE_MONSTER"; break;
			case 240: opcode_msg = "MOVE_MONSTER_RESPONSE"; break;
			case 242: opcode_msg = "APPLY_MONSTER_STATUS"; break;
			case 243: opcode_msg = "CANCEL_MONSTER_STATUS"; break;
			case 244: opcode_msg = "RESET_MONSTER_ANIMATION"; break;
			case 246: opcode_msg = "DAMAGE_MONSTER"; break;
			case 249: opcode_msg = "ARIANT_THING"; break;
			case 250: opcode_msg = "SHOW_MONSTER_HP"; break;
			case 251: opcode_msg = "CATCH_MONSTER"; break;
			case 252: opcode_msg = "CATCH_MONSTER_WITH_ITEM"; break;
			case 253: opcode_msg = "SHOW_MAGNET"; break;
			case 257: opcode_msg = "SPAWN_NPC"; break;
			case 258: opcode_msg = "REMOVE_NPC"; break;
			case 259: opcode_msg = "SPAWN_NPC_REQUEST_CONTROLLER"; break;
			case 260: opcode_msg = "NPC_ACTION"; break;
			case 265: opcode_msg = "SPAWN_HIRED_MERCHANT"; break;
			case 266: opcode_msg = "DESTROY_HIRED_MERCHANT"; break;
			case 267: opcode_msg = "UPDATE_HIRED_MERCHANT"; break;
			case 268: opcode_msg = "DROP_ITEM_FROM_MAPOBJECT"; break;
			case 269: opcode_msg = "REMOVE_ITEM_FROM_MAP"; break;
			case 270: opcode_msg = "CANNOT_SPAWN_KITE"; break;
			case 271: opcode_msg = "SPAWN_KITE"; break;
			case 272: opcode_msg = "REMOVE_KITE"; break;
			case 273: opcode_msg = "SPAWN_MIST"; break;
			case 274: opcode_msg = "REMOVE_MIST"; break;
			case 275: opcode_msg = "SPAWN_DOOR"; break;
			case 276: opcode_msg = "REMOVE_DOOR"; break;
			case 277: opcode_msg = "REACTOR_HIT"; break;
			case 279: opcode_msg = "REACTOR_SPAWN"; break;
			case 280: opcode_msg = "REACTOR_DESTROY"; break;
			case 281: opcode_msg = "SNOWBALL_STATE"; break;
			case 282: opcode_msg = "HIT_SNOWBALL"; break;
			case 283: opcode_msg = "SNOWBALL_MESSAGE"; break;
			case 284: opcode_msg = "LEFT_KNOCK_BACK"; break;
			case 285: opcode_msg = "COCONUT_HIT"; break;
			case 286: opcode_msg = "COCONUT_SCORE"; break;
			case 287: opcode_msg = "GUILD_BOSS_HEALER_MOVE"; break;
			case 288: opcode_msg = "GUILD_BOSS_PULLEY_STATE_CHANGE"; break;
			case 289: opcode_msg = "MONSTER_CARNIVAL_START"; break;
			case 290: opcode_msg = "MONSTER_CARNIVAL_OBTAINED_CP"; break;
			case 291: opcode_msg = "MONSTER_CARNIVAL_PARTY_CP"; break;
			case 292: opcode_msg = "MONSTER_CARNIVAL_SUMMON"; break;
			case 293: opcode_msg = "MONSTER_CARNIVAL_MESSAGE"; break;
			case 294: opcode_msg = "MONSTER_CARNIVAL_DIED"; break;
			case 295: opcode_msg = "MONSTER_CARNIVAL_LEAVE"; break;
			case 297: opcode_msg = "ARIANT_ARENA_USER_SCORE"; break;
			case 299: opcode_msg = "SHEEP_RANCH_INFO"; break;
			case 300: opcode_msg = "SHEEP_RANCH_CLOTHES"; break;
			case 301: opcode_msg = "ARIANT_SCORE"; break;
			case 302: opcode_msg = "HORNTAIL_CAVE"; break;
			case 303: opcode_msg = "ZAKUM_SHRINE"; break;
			case 304: opcode_msg = "NPC_TALK"; break;
			case 305: opcode_msg = "OPEN_NPC_SHOP"; break;
			case 306: opcode_msg = "CONFIRM_SHOP_TRANSACTION"; break;
			case 307: opcode_msg = "ADMIN_SHOP_MESSAGE"; break;
			case 308: opcode_msg = "ADMIN_SHOP"; break;
			case 309: opcode_msg = "STORAGE"; break;
			case 310: opcode_msg = "FREDRICK_MESSAGE"; break;
			case 311: opcode_msg = "FREDRICK"; break;
			case 312: opcode_msg = "RPS_GAME"; break;
			case 313: opcode_msg = "MESSENGER"; break;
			case 314: opcode_msg = "PLAYER_INTERACTION"; break;
			case 315: opcode_msg = "TOURNAMENT"; break;
			case 316: opcode_msg = "TOURNAMENT_MATCH_TABLE"; break;
			case 317: opcode_msg = "TOURNAMENT_SET_PRIZE"; break;
			case 318: opcode_msg = "TOURNAMENT_UEW"; break;
			case 319: opcode_msg = "TOURNAMENT_CHARACTERS"; break;
			case 320: opcode_msg = "WEDDING_PROGRESS"; break;
			case 321: opcode_msg = "WEDDING_CEREMONY_END"; break;
			case 322: opcode_msg = "PARCEL"; break;
			case 323: opcode_msg = "CHARGE_PARAM_RESULT"; break;
			case 324: opcode_msg = "QUERY_CASH_RESULT"; break;
			case 325: opcode_msg = "CASHSHOP_OPERATION"; break;
			case 327: opcode_msg = "CASHSHOP_GIFT_INFO_RESULT"; break;
			case 328: opcode_msg = "CASHSHOP_CHECK_NAME_CHANGE"; break;
			case 329: opcode_msg = "CASHSHOP_CHECK_NAME_CHANGE_POSSIBLE_RESULT"; break;
			case 330: opcode_msg = "CASHSHOP_REGISTER_NEW_CHARACTER_RESULT"; break;
			case 331: opcode_msg = "CASHSHOP_CHECK_TRANSFER_WORLD_POSSIBLE_RESULT"; break;
			case 332: opcode_msg = "CASHSHOP_GACHAPON_STAMP_RESULT"; break;
			case 333: opcode_msg = "CASHSHOP_CASH_ITEM_GACHAPON_RESULT"; break;
			case 334: opcode_msg = "CASHSHOP_CASH_GACHAPON_OPEN_RESULT"; break;
			case 335: opcode_msg = "KEYMAP"; break;
			case 336: opcode_msg = "AUTO_HP_POT"; break;
			case 337: opcode_msg = "AUTO_MP_POT"; break;
			case 341: opcode_msg = "SEND_TV"; break;
			case 342: opcode_msg = "REMOVE_TV"; break;
			case 343: opcode_msg = "ENABLE_TV"; break;
			case 347: opcode_msg = "MTS_OPERATION2"; break;
			case 348: opcode_msg = "MTS_OPERATION"; break;
			case 349: opcode_msg = "MAPLELIFE_RESULT"; break;
			case 350: opcode_msg = "MAPLELIFE_ERROR"; break;
			case 354: opcode_msg = "VICIOUS_HAMMER"; break;
			case 358: opcode_msg = "VEGA_SCROLL"; break;
			default: break;
		}

		return opcode_msg;
	}
}

================
File: Net/PacketSwitch.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "PacketHandler.h"

#include <memory>

namespace ms
{
	// Class which contains the array of handler classes to use
	class PacketSwitch
	{
	public:
		// Register all handlers
		PacketSwitch();

		// Forward a packet to the correct handler
		void forward(const int8_t* bytes, size_t length) const;

	private:
		// Print a warning
		void warn(const std::string& message, size_t opcode) const;

		// Get the string value of the Opcode
		std::string OpcodeName(size_t opcode) const;

		// Opcodes for which handlers can be registered
		enum Opcode : uint16_t;

		// Message when an unhandled packet is received
		static constexpr const char* MSG_UNHANDLED = "Unhandled packet detected";
		// Message when a packet with a larger opcode than the array size is received
		static constexpr const char* MSG_OUTOFBOUNDS = "Large opcode detected";
		// Message when a packet with a larger opcode than the array size is received
		static constexpr const char* MSG_REREGISTER = "Handler was registered twice";
		// Maximum number of handlers needed
		static constexpr const size_t NUM_HANDLERS = 500;

		std::unique_ptr<PacketHandler> handlers[NUM_HANDLERS];

		// Register a handler for the specified opcode
		template <size_t O, typename T, typename...Args>
		void emplace(Args&& ...args)
		{
			static_assert(O < NUM_HANDLERS, "PacketSwitch::emplace - Opcode out of array bounds");
			static_assert(std::is_base_of<PacketHandler, T>::value, "Error: Packet handlers must derive from PacketHandler");

			if (handlers[O])
				warn(MSG_REREGISTER, O);

			handlers[O] = std::make_unique<T>(
				std::forward<Args>(args)...
				);
		}
	};
}

================
File: Net/Session.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Session.h"

#include "../Configuration.h"

namespace ms
{
	Session::Session()
	{
		connected = false;
		length = 0;
		pos = 0;
	}

	Session::~Session()
	{
		if (connected)
			socket.close();
	}

	bool Session::init(const char* host, const char* port)
	{
		// Connect to the server
		connected = socket.open(host, port);

		if (connected)
		{
			// Read keys necessary for communicating with the server
			cryptography = { socket.get_buffer() };
		}

		return connected;
	}

	Error Session::init()
	{
		std::string HOST = Setting<ServerIP>::get().load();
		std::string PORT = Setting<ServerPort>::get().load();

		if (!init(HOST.c_str(), PORT.c_str()))
			return Error::CONNECTION;

		return Error::NONE;
	}

	void Session::reconnect(const char* address, const char* port)
	{
		// Close the current connection and open a new one
		bool success = socket.close();

		if (success)
			init(address, port);
		else
			connected = false;
	}

	void Session::process(const int8_t* bytes, size_t available)
	{
		if (pos == 0)
		{
			// Position is zero, meaning this is the start of a new packet. Start by determining length.
			length = cryptography.check_length(bytes);
			// Reading the length means we processed the header. Move forward by the header length.
			bytes = bytes + HEADER_LENGTH;
			available -= HEADER_LENGTH;
		}

		// Determine how much we can write. Write data into the buffer.
		size_t towrite = length - pos;

		if (towrite > available)
			towrite = available;

		memcpy(buffer + pos, bytes, towrite);
		pos += towrite;

		// Check if the current packet has been fully processed
		if (pos >= length)
		{
			cryptography.decrypt(buffer, length);

			try
			{
				packetswitch.forward(buffer, length);
			}
			catch (const PacketError& err)
			{
				LOG(LOG_NETWORK, err.what());
			}

			pos = 0;
			length = 0;

			// Check if there is more available
			size_t remaining = available - towrite;

			if (remaining >= MIN_PACKET_LENGTH)
			{
				// More packets are available, so we start over.
				process(bytes + towrite, remaining);
			}
		}
	}

	void Session::write(int8_t* packet_bytes, size_t packet_length)
	{
		if (!connected)
			return;

		int8_t header[HEADER_LENGTH];
		cryptography.create_header(header, packet_length);
		cryptography.encrypt(packet_bytes, packet_length);

		socket.dispatch(header, HEADER_LENGTH);
		socket.dispatch(packet_bytes, packet_length);
	}

	void Session::read()
	{
		// Check if a packet has arrived. Handle if data is sufficient: 4 bytes (header) + 2 bytes (opcode) = 6 bytes.
		size_t result = socket.receive(&connected);

		if (result >= MIN_PACKET_LENGTH || length > 0)
		{
			// Retrieve buffer from the socket and process it
			const int8_t* bytes = socket.get_buffer();
			process(bytes, result);
		}
	}

	void Session::reconnect()
	{
		std::string HOST = Setting<ServerIP>::get().load();
		std::string PORT = Setting<ServerPort>::get().load();

		reconnect(HOST.c_str(), PORT.c_str());
	}

	bool Session::is_connected() const
	{
		return connected;
	}
}

================
File: Net/Session.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Cryptography.h"
#include "PacketSwitch.h"

#include "../Error.h"
#include "../MapleStory.h"

#include "../Template/Singleton.h"

#ifdef USE_ASIO
#include "SocketAsio.h"
#else
#include "SocketWinsock.h"
#endif

namespace ms
{
	class Session : public Singleton<Session>
	{
	public:
		Session();
		~Session();

		// Connect using host and port from the configuration file
		Error init();
		// Send a packet to the server
		void write(int8_t* bytes, size_t length);
		// Check for incoming packets and handle them
		void read();
		// Closes the current connection and opens a new one with default connection settings
		void reconnect();
		// Closes the current connection and opens a new one
		void reconnect(const char* address, const char* port);
		// Check if the connection is alive
		bool is_connected() const;

	private:
		bool init(const char* host, const char* port);
		void process(const int8_t* bytes, size_t available);

		Cryptography cryptography;
		PacketSwitch packetswitch;

		int8_t buffer[MAX_PACKET_LENGTH];
		size_t length;
		size_t pos;
		bool connected;

#ifdef USE_ASIO
		SocketAsio socket;
#else
		SocketWinsock socket;
#endif
	};
}

================
File: Net/SocketAsio.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "SocketAsio.h"

#ifdef USE_ASIO
namespace ms
{
	SocketAsio::SocketAsio() : resolver(ioservice), socket(ioservice) {}

	SocketAsio::~SocketAsio()
	{
		if (socket.is_open())
		{
			error_code error;
			socket.close(error);
		}
	}

	bool SocketAsio::open(const char* address, const char* port)
	{
		tcp::resolver::query query(address, port);
		tcp::resolver::iterator endpointiter = resolver.resolve(query);
		error_code error;
		asio::connect(socket, endpointiter, error);

		if (!error)
		{
			size_t result = socket.read_some(asio::buffer(buffer), error);
			return !error && (result == HANDSHAKE_LEN);
		}

		return !error;
	}

	bool SocketAsio::close()
	{
		error_code error;
		socket.shutdown(tcp::socket::shutdown_both, error);
		socket.close(error);

		return !error;
	}

	size_t SocketAsio::receive(bool* recvok)
	{
		if (socket.available() > 0)
		{
			error_code error;
			size_t result = socket.read_some(asio::buffer(buffer), error);
			*recvok = !error;

			return result;
		}

		return 0;
	}

	const int8_t* SocketAsio::get_buffer() const
	{
		return buffer;
	}

	bool SocketAsio::dispatch(const int8_t* bytes, size_t length)
	{
		error_code error;
		size_t result = asio::write(socket, asio::buffer(bytes, length), error);

		return !error && (result == length);
	}
}
#endif

================
File: Net/SocketAsio.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../MapleStory.h"

#ifdef USE_ASIO
#include "NetConstants.h"

#define BOOST_DATE_TIME_NO_LIB
#define BOOST_REGEX_NO_LIB
#include "asio.hpp"

namespace ms
{
#ifndef USE_CRYPTO
	const size_t HANDSHAKE_LEN = 2;
#else
	const size_t HANDSHAKE_LEN = 16;
#endif

	using asio::io_service;
	using asio::ip::tcp;
	using asio::error_code;

	// Class that wraps an asio socket.
	class SocketAsio
	{
	public:
		SocketAsio();
		~SocketAsio();

		bool open(const char* address, const char* port);
		bool close();
		size_t receive(bool* connected);
		const int8_t* get_buffer() const;
		bool dispatch(const int8_t* bytes, size_t length);

	private:
		io_service ioservice;
		tcp::resolver resolver;
		tcp::socket socket;
		int8_t buffer[MAX_PACKET_LENGTH];
	};
}
#endif

================
File: Net/SocketWinsock.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "SocketWinsock.h"

#ifndef USE_ASIO
#include <ws2tcpip.h>

// TODO: Can this be moved?
#pragma comment (lib, "Ws2_32.lib")

namespace ms
{
	bool SocketWinsock::open(const char* iaddr, const char* port)
	{
		WSADATA wsa_info;
		sock = INVALID_SOCKET;

		struct addrinfo* addr_info = NULL;
		struct addrinfo* ptr = NULL;
		struct addrinfo hints;

		int result = WSAStartup(MAKEWORD(2, 2), &wsa_info);

		if (result != 0)
			return false;

		ZeroMemory(&hints, sizeof(hints));

		hints.ai_family = AF_UNSPEC;
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_protocol = IPPROTO_TCP;

		result = getaddrinfo(iaddr, port, &hints, &addr_info);

		if (result != 0)
		{
			WSACleanup();

			return false;
		}

		for (ptr = addr_info; ptr != NULL; ptr = ptr->ai_next)
		{
			sock = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);

			if (sock == INVALID_SOCKET)
			{
				WSACleanup();

				return false;
			}

			result = connect(sock, ptr->ai_addr, (int)ptr->ai_addrlen);

			if (result == SOCKET_ERROR)
			{
				closesocket(sock);

				sock = INVALID_SOCKET;

				continue;
			}

			break;
		}

		freeaddrinfo(addr_info);

		if (sock == INVALID_SOCKET)
		{
			WSACleanup();

			return false;
		}

		result = recv(sock, (char*)buffer, 32, 0);

		if (result == HANDSHAKE_LEN)
		{
			return true;
		}
		else
		{
			WSACleanup();

			return false;
		}
	}

	bool SocketWinsock::close()
	{
		int error = closesocket(sock);

		WSACleanup();

		return error != SOCKET_ERROR;
	}

	bool SocketWinsock::dispatch(const int8_t* bytes, size_t length) const
	{
		return send(sock, (char*)bytes, static_cast<int>(length), 0) != SOCKET_ERROR;
	}

	size_t SocketWinsock::receive(bool* success)
	{
		timeval timeout = { 0, 0 };
		fd_set sockset = { 0 };

		FD_SET(sock, &sockset);

		int result = select(0, &sockset, 0, 0, &timeout);

		if (result > 0)
			result = recv(sock, (char*)buffer, MAX_PACKET_LENGTH, 0);

		if (result == SOCKET_ERROR)
		{
			*success = false;

			return 0;
		}
		else
		{
			return result;
		}
	}

	const int8_t* SocketWinsock::get_buffer() const
	{
		return buffer;
	}
}
#endif

================
File: Net/SocketWinsock.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../MapleStory.h"

#ifndef USE_ASIO
#include "NetConstants.h"

namespace ms
{
#ifdef USE_CRYPTO
	const size_t HANDSHAKE_LEN = 16;
#else
	const size_t HANDSHAKE_LEN = 2;
#endif

	class SocketWinsock
	{
	public:
		bool open(const char* address, const char* port);
		bool close();

		bool dispatch(const int8_t* bytes, size_t length) const;
		size_t receive(bool* connected);
		const int8_t* get_buffer() const;

	private:
		uint64_t sock;
		int8_t buffer[MAX_PACKET_LENGTH];
	};
}
#endif

================
File: NoLifeNx_build/.git/config
================
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[remote "origin"]
	url = https://github.com/ryantpayton/NoLifeNx.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "update"]
	remote = origin
	merge = refs/heads/update

================
File: NoLifeNx_build/.git/description
================
Unnamed repository; edit this file 'description' to name the repository.

================
File: NoLifeNx_build/.git/HEAD
================
ref: refs/heads/update

================
File: NoLifeNx_build/.git/hooks/applypatch-msg.sample
================
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:

================
File: NoLifeNx_build/.git/hooks/commit-msg.sample
================
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}

================
File: NoLifeNx_build/.git/hooks/fsmonitor-watchman.sample
================
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}

================
File: NoLifeNx_build/.git/hooks/post-update.sample
================
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info

================
File: NoLifeNx_build/.git/hooks/pre-applypatch.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:

================
File: NoLifeNx_build/.git/hooks/pre-commit.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --

================
File: NoLifeNx_build/.git/hooks/pre-merge-commit.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:

================
File: NoLifeNx_build/.git/hooks/pre-push.sample
================
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0

================
File: NoLifeNx_build/.git/hooks/pre-rebase.sample
================
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END

================
File: NoLifeNx_build/.git/hooks/pre-receive.sample
================
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi

================
File: NoLifeNx_build/.git/hooks/prepare-commit-msg.sample
================
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi

================
File: NoLifeNx_build/.git/hooks/push-to-checkout.sample
================
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi

================
File: NoLifeNx_build/.git/hooks/sendemail-validate.sample
================
#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi

================
File: NoLifeNx_build/.git/hooks/update.sample
================
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0

================
File: NoLifeNx_build/.git/info/exclude
================
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~

================
File: NoLifeNx_build/.git/logs/HEAD
================
0000000000000000000000000000000000000000 dd5e4d2efab87b0a8d64fb768899bc7bf189d85a ilia s <iliashlomov@gmail.com> 1752388278 +0300	clone: from https://github.com/ryantpayton/NoLifeNx.git

================
File: NoLifeNx_build/.git/logs/refs/heads/update
================
0000000000000000000000000000000000000000 dd5e4d2efab87b0a8d64fb768899bc7bf189d85a ilia s <iliashlomov@gmail.com> 1752388278 +0300	clone: from https://github.com/ryantpayton/NoLifeNx.git

================
File: NoLifeNx_build/.git/logs/refs/remotes/origin/HEAD
================
0000000000000000000000000000000000000000 dd5e4d2efab87b0a8d64fb768899bc7bf189d85a ilia s <iliashlomov@gmail.com> 1752388278 +0300	clone: from https://github.com/ryantpayton/NoLifeNx.git

================
File: NoLifeNx_build/.git/packed-refs
================
# pack-refs with: peeled fully-peeled sorted 
eab99bbacddaade460a8947a95093cd5abe44c41 refs/remotes/origin/master
dd5e4d2efab87b0a8d64fb768899bc7bf189d85a refs/remotes/origin/update
89e12b37be46ee4f29f445a73864c290b6f84f14 refs/tags/1.0.0
^651130bc2b2daefb2d91bbf37606ff6661ba4ba6

================
File: NoLifeNx_build/.git/refs/heads/update
================
dd5e4d2efab87b0a8d64fb768899bc7bf189d85a

================
File: NoLifeNx_build/.git/refs/remotes/origin/HEAD
================
ref: refs/remotes/origin/update

================
File: NoLifeNx_build/.gitignore
================
/.vs
/x64
/x86

*.vcxproj.user

================
File: NoLifeNx_build/audio.cpp
================
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

#include "audio.hpp"

namespace nl {
    audio::audio(void const * d, uint32_t l) :
        m_data(d), m_length(l) {}
    bool audio::operator<(audio const & o) const {
        return m_data < o.m_data;
    }
    bool audio::operator==(audio const & o) const {
        return m_data == o.m_data;
    }
    audio::operator bool() const {
        return m_data ? true : false;
    }
    void const * audio::data() const {
        return m_data;
    }
    uint32_t audio::length() const {
        return m_length;
    }
    size_t audio::id() const {
        return reinterpret_cast<size_t>(m_data);
    }
}

================
File: NoLifeNx_build/audio.hpp
================
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

#pragma once
#include "nxfwd.hpp"
#include <cstdint>
#include <cstddef>

namespace nl {
    class audio {
    public:
        audio() = default;
        audio(audio const &) = default;
        audio & operator=(audio const &) = default;
        //Comparison operators, useful for containers
        bool operator==(audio const &) const;
        bool operator<(audio const &)const;
        //Returns whether the audio is valid or merely null
        explicit operator bool() const;
        //Does not do any sort of decompression
        //Do not free the pointer returned by this method
        //The pointer remains valid until the file this audio is part of is destroyed
        void const * data() const;
        uint32_t length() const;
        //Returns a unique id, useful for keeping track of what audio you loaded
        size_t id() const;
    private:
        audio(void const *, uint32_t);
        void const * m_data = nullptr;
        uint32_t m_length = 0;
        friend node;
    };
}

================
File: NoLifeNx_build/bitmap.cpp
================
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

#include "bitmap.hpp"
#include <lz4.h>
#include <vector>

namespace nl {
    bitmap::bitmap(void const * d, uint16_t w, uint16_t h) :
        m_data(d), m_width(w), m_height(h) {}
    bool bitmap::operator<(bitmap const & o) const {
        return m_data < o.m_data;
    }
    bool bitmap::operator==(bitmap const & o) const {
        return m_data == o.m_data;
    }
    bitmap::operator bool() const {
        return m_data ? true : false;
    }
    std::vector<char> bitmap_buf;
    void const * bitmap::data() const {
        if (!m_data)
            return nullptr;
        auto const l = length();
        if (l + 0x20 > bitmap_buf.size())
            bitmap_buf.resize(l + 0x20);
        ::LZ4_decompress_fast(4 + reinterpret_cast<char const *>(m_data),
            bitmap_buf.data(), static_cast<int>(l));
        return bitmap_buf.data();
    }
    uint16_t bitmap::width() const {
        return m_width;
    }
    uint16_t bitmap::height() const {
        return m_height;
    }
    uint32_t bitmap::length() const {
        return 4u * m_width * m_height;
    }
    size_t bitmap::id() const {
        return reinterpret_cast<size_t>(m_data);
    }
}

================
File: NoLifeNx_build/bitmap.hpp
================
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

#pragma once
#include "nxfwd.hpp"
#include <cstdint>
#include <cstddef>

namespace nl {
    class bitmap {
    public:
        bitmap() = default;
        bitmap(bitmap const &) = default;
        bitmap & operator=(bitmap const &) = default;
        //Comparison operators, useful for containers
        bool operator==(bitmap const &) const;
        bool operator<(bitmap const &) const;
        //Returns whether the bitmap is valid or merely null
        explicit operator bool() const;
        //This function decompresses the data on the fly
        //Do not free the pointer returned by this method
        //Every time this function is called
        //any previous pointers returned by this method become invalid
        void const * data() const;
        uint16_t width() const;
        uint16_t height() const;
        uint32_t length() const;
        //Returns a unique id, useful for keeping track of what bitmaps you loaded
        size_t id() const;
    private:
        bitmap(void const *, uint16_t, uint16_t);
        void const * m_data = nullptr;
        uint16_t m_width = 0;
        uint16_t m_height = 0;
        friend node;
    };
}

================
File: NoLifeNx_build/file_impl.hpp
================
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright � 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

#pragma once
#include "file.hpp"
#include "node_impl.hpp"
#include <vector>

namespace nl {
#pragma pack(push, 1)
    struct file::header {
        uint32_t const magic;
        uint32_t const node_count;
        uint64_t const node_offset;
        uint32_t const string_count;
        uint64_t const string_offset;
        uint32_t const bitmap_count;
        uint64_t const bitmap_offset;
        uint32_t const audio_count;
        uint64_t const audio_offset;
    };
#pragma pack(pop)
    struct _file_data {
        void const * base = nullptr;
        node::data const * node_table = nullptr;
        uint64_t const * string_table = nullptr;
        uint64_t const * bitmap_table = nullptr;
        uint64_t const * audio_table = nullptr;
        file::header const * header = nullptr;
        // v92 compatibility: synthetic bitmap table for files with bitmap_count=0
        std::vector<uint64_t> synthetic_bitmap_table;
        bool v92_mode = false;
#ifdef _WIN32
        void * file_handle = nullptr;
        void * map = nullptr;
#else
        int file_handle = 0;
        size_t size = 0;
#endif
    };
}

================
File: NoLifeNx_build/file.cpp
================
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

#include "file_impl.hpp"
#include "node_impl.hpp"
#include <iostream>
#ifdef _WIN32
#  ifdef _MSC_VER
#    include <codecvt>
#  else
#    include <clocale>
#    include <cstdlib>
#  endif
#  ifdef __MINGW32__
#    include <windows.h>
#  else
#    include <Windows.h>
#  endif // __MINGW32__
#else
#  include <sys/types.h>
#  include <sys/stat.h>
#  include <sys/fcntl.h>
#  include <sys/mman.h>
#  include <unistd.h>
#endif
#include <stdexcept>

namespace nl {
    file::file(std::string name) {
        open(name);
    }
    file::~file() {
        close();
    }
    void file::open(std::string name) {
        close();
        m_data = new data();
#ifdef _WIN32
#  ifdef _MSC_VER
        std::wstring_convert<std::codecvt_utf8<wchar_t>> convert;
        auto str = convert.from_bytes(name);
#  else
        std::setlocale(LC_ALL, "en_US.utf8");
        auto str = std::wstring(name.size(), 0);
        auto len = std::mbstowcs(const_cast<wchar_t *>(str.c_str()), name.c_str(), str.size());
        str.resize(len);
#  endif
#  if WINAPI_FAMILY == WINAPI_FAMILY_APP
        m_data->file_handle = ::CreateFile2(str.c_str(), GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, nullptr);
#  else
        m_data->file_handle = ::CreateFileW(str.c_str(), GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, nullptr);
#  endif
        if (m_data->file_handle == INVALID_HANDLE_VALUE)
            throw std::runtime_error("Failed to open file " + name);
#  if WINAPI_FAMILY == WINAPI_FAMILY_APP
        m_data->map = ::CreateFileMappingFromApp(m_data->file_handle, 0, PAGE_READONLY, 0, nullptr);
#  else
        m_data->map = ::CreateFileMappingW(m_data->file_handle, 0, PAGE_READONLY, 0, 0, nullptr);
#  endif
        if (!m_data->map)
            throw std::runtime_error("Failed to create file mapping of file " + name);
#  if WINAPI_FAMILY == WINAPI_FAMILY_APP
        m_data->base = ::MapViewOfFileFromApp(m_data->map, FILE_MAP_READ, 0, 0);
#  else
        m_data->base = ::MapViewOfFile(m_data->map, FILE_MAP_READ, 0, 0, 0);
#  endif
        if (!m_data->base)
            throw std::runtime_error("Failed to map view of file " + name);
#else
        m_data->file_handle = ::open(name.c_str(), O_RDONLY);
        if (m_data->file_handle == -1)
            throw std::runtime_error("Failed to open file " + name);
        struct stat finfo;
        if (::fstat(m_data->file_handle, &finfo) == -1)
            throw std::runtime_error("Failed to obtain file information of file " + name);
        m_data->size = finfo.st_size;
        m_data->base = ::mmap(nullptr, m_data->size, PROT_READ, MAP_SHARED, m_data->file_handle, 0);
        if (reinterpret_cast<intptr_t>(m_data->base) == -1)
            throw std::runtime_error("Failed to create memory mapping of file " + name);
#endif
        m_data->header = reinterpret_cast<header const *>(m_data->base);
        if (m_data->header->magic != 0x34474B50)
            throw std::runtime_error(name + " is not a PKG4 NX file");
        m_data->node_table = reinterpret_cast<node::data const *>(reinterpret_cast<char const *>(m_data->base) + m_data->header->node_offset);
        m_data->string_table = reinterpret_cast<uint64_t const *>(reinterpret_cast<char const *>(m_data->base) + m_data->header->string_offset);
        m_data->bitmap_table = reinterpret_cast<uint64_t const *>(reinterpret_cast<char const *>(m_data->base) + m_data->header->bitmap_offset);
        m_data->audio_table = reinterpret_cast<uint64_t const *>(reinterpret_cast<char const *>(m_data->base) + m_data->header->audio_offset);
        
        // v92 NX compatibility: handle files with bitmap_count=0 but containing bitmap nodes
        if (m_data->header->bitmap_count == 0) {
            build_synthetic_bitmap_table(name);
        }
    }
    void file::close() {
        if (!m_data) return;
#ifdef _WIN32
        ::UnmapViewOfFile(m_data->base);
        ::CloseHandle(m_data->map);
        ::CloseHandle(m_data->file_handle);
#else
        ::munmap(const_cast<void *>(m_data->base), m_data->size);
        ::close(m_data->file_handle);
#endif
        delete m_data;
        m_data = nullptr;
    }
    node file::root() const {
        return {m_data->node_table, m_data};
    }
    file::operator node() const {
        return root();
    }
    uint32_t file::string_count() const {
        return m_data->header->string_count;
    }
    uint32_t file::bitmap_count() const {
        // For v92 files, return the synthetic bitmap count if available
        if (m_data->v92_mode && !m_data->synthetic_bitmap_table.empty()) {
            return static_cast<uint32_t>(m_data->synthetic_bitmap_table.size());
        }
        return m_data->header->bitmap_count;
    }
    uint32_t file::audio_count() const {
        return m_data->header->audio_count;
    }
    uint32_t file::node_count() const {
        return m_data->header->node_count;
    }
    std::string file::get_string(uint32_t i) const {
        auto const s = reinterpret_cast<char const *>(m_data->base) + m_data->string_table[i];
        return {s + 2, *reinterpret_cast<uint16_t const *>(s)};
    }
    
    void file::build_synthetic_bitmap_table(const std::string& filename) {
        std::cout << "[NoLifeNx] Detected v92 NX file with bitmap_count=0: " << filename << std::endl;
        
        // First pass: count bitmap nodes and check if any exist
        uint32_t bitmap_node_count = 0;
        uint32_t max_bitmap_id = 0;
        
        for (uint32_t i = 0; i < m_data->header->node_count; ++i) {
            const auto& node = m_data->node_table[i];
            if (node.type == node::type::bitmap) {
                bitmap_node_count++;
                if (node.bitmap.index > max_bitmap_id) {
                    max_bitmap_id = node.bitmap.index;
                }
            }
        }
        
        if (bitmap_node_count == 0) {
            std::cout << "[NoLifeNx] No bitmap nodes found, file truly has no images" << std::endl;
            return;
        }
        
        std::cout << "[NoLifeNx] Found " << bitmap_node_count << " bitmap nodes, max ID: " << max_bitmap_id << std::endl;
        
        // Try to find bitmap data block after string data
#ifdef _WIN32
        LARGE_INTEGER file_size;
        if (!GetFileSizeEx(m_data->file_handle, &file_size)) {
            std::cout << "[NoLifeNx] Failed to get file size for v92 parsing" << std::endl;
            return;
        }
        size_t fileSize = static_cast<size_t>(file_size.QuadPart);
#else
        size_t fileSize = m_data->size;
#endif
        
        // Calculate start of bitmap data (after string data block)
        uint64_t string_data_end = m_data->header->string_offset + (m_data->header->string_count * 8);
        
        // Find the actual end of string data by parsing each string
        uint64_t actual_string_end = m_data->header->string_offset + (m_data->header->string_count * 8);
        for (uint32_t i = 0; i < m_data->header->string_count; ++i) {
            uint64_t str_offset = m_data->string_table[i];
            if (str_offset >= fileSize - 2) continue;
            
            auto str_ptr = reinterpret_cast<char const *>(m_data->base) + str_offset;
            uint16_t str_len = *reinterpret_cast<uint16_t const *>(str_ptr);
            uint64_t str_end = str_offset + 2 + str_len;
            if (str_end > actual_string_end) {
                actual_string_end = str_end;
            }
        }
        
        // Align to 8-byte boundary
        uint64_t bitmap_start = (actual_string_end + 7) & ~7ULL;
        
        std::cout << "[NoLifeNx] Attempting to parse bitmap data starting at offset: 0x" << std::hex << bitmap_start << std::dec << std::endl;
        
        if (bitmap_start >= fileSize) {
            std::cout << "[NoLifeNx] No space for bitmap data in file" << std::endl;
            return;
        }
        
        // Try to build bitmap offset table
        m_data->synthetic_bitmap_table.clear();
        m_data->synthetic_bitmap_table.resize(max_bitmap_id + 1, 0);
        
        uint64_t current_offset = bitmap_start;
        uint32_t images_parsed = 0;
        
        while (current_offset + 4 < fileSize && images_parsed <= max_bitmap_id) {
            // Read length of this image
            auto length_ptr = reinterpret_cast<uint32_t const *>(reinterpret_cast<char const *>(m_data->base) + current_offset);
            uint32_t image_length = *length_ptr;
            
            // Sanity check on length (should be reasonable for compressed image)
            if (image_length == 0 || image_length > 50 * 1024 * 1024) { // Max 50MB per image
                std::cout << "[NoLifeNx] Invalid image length " << image_length << " at offset 0x" << std::hex << current_offset << std::dec << std::endl;
                break;
            }
            
            if (current_offset + 4 + image_length > fileSize) {
                std::cout << "[NoLifeNx] Image data would exceed file bounds" << std::endl;
                break;
            }
            
            // Store offset for this image index
            if (images_parsed < m_data->synthetic_bitmap_table.size()) {
                m_data->synthetic_bitmap_table[images_parsed] = current_offset;
            }
            
            // Move to next image (align to 8-byte boundary)
            current_offset = ((current_offset + 4 + image_length + 7) & ~7ULL);
            images_parsed++;
        }
        
        if (images_parsed > 0) {
            std::cout << "[NoLifeNx] Successfully parsed " << images_parsed << " images, enabling v92 mode" << std::endl;
            m_data->v92_mode = true;
            // Point bitmap_table to our synthetic table
            m_data->bitmap_table = m_data->synthetic_bitmap_table.data();
        } else {
            std::cout << "[NoLifeNx] Failed to parse any bitmap data" << std::endl;
        }
    }
}

================
File: NoLifeNx_build/file.hpp
================
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

#pragma once
#include "nxfwd.hpp"
#include <cstdint>
#include <string>

namespace nl {
    struct _file_data;
    class file {
    public:
        typedef _file_data data;
        struct header;
        //Creates a null file object
        //Nothing can really be done until you call open()
        file() = default;
        //Used to construct an nx file from a filename
        //Multiple file objects can be created from the same filename
        //and the resulting nodes are interchangeable
        file(std::string name);
        //Destructor calls close()
        ~file();
        //Files cannot be copied
        file(file const &) = delete;
        //Files cannot be copied
        file & operator=(file const &) = delete;
        //Transfers ownership of the file handle to another file
        file(file &&);
        //Transfers ownership of the file handle to another file
        file & operator=(file &&);
        //Opens the file with the given name
        void open(std::string name);
        //Closes the given file
        //Any nodes derived from this file become invalid after closing it
        //Any attempts to use invalid nodes will result in undefined behavior
        void close();
        //Obtains the root node from which all other nodes may be accessed
        //If the file is not open, a null node is returned
        node root() const;
        //Effectivelly calls root()
        operator node() const;
        //Returns the number of strings in the file
        uint32_t string_count() const;
        //Returns the number of bitmaps in the file
        uint32_t bitmap_count() const;
        //Returns the number of audios in the file
        uint32_t audio_count() const;
        //Returns the number of nodes in the file
        uint32_t node_count() const;
        //Returns the string with a given id number
        std::string get_string(uint32_t) const;
    private:
        data * m_data = nullptr;
        //v92 compatibility: builds synthetic bitmap table for files with bitmap_count=0
        void build_synthetic_bitmap_table(const std::string& filename);
        friend node;
        friend bitmap;
        friend audio;
    };
}

================
File: NoLifeNx_build/node_impl.hpp
================
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

#pragma once
#include "node.hpp"

namespace nl {
    //Internal data structure
#pragma pack(push, 1)
    struct node::data {
        uint32_t const name;
        uint32_t const children;
        uint16_t const num;
        node::type const type;
        union {
            int64_t const ireal;
            double const dreal;
            uint32_t const string;
            int32_t const vector[2];
            struct {
                uint32_t index;
                uint16_t width;
                uint16_t height;
            } const bitmap;
            struct {
                uint32_t index;
                uint32_t length;
            } const audio;
        };
    };
#pragma pack(pop)
}

================
File: NoLifeNx_build/node.cpp
================
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

#include "node_impl.hpp"
#include "file_impl.hpp"
#include "bitmap.hpp"
#include "audio.hpp"
#include <cstring>
#include <stdexcept>
#include <vector>
#include <sstream>
#include <iostream>

namespace nl {
    node::node(node const & o) :
        m_data(o.m_data), m_file(o.m_file) {}
    node::node(data const * d, file::data const * f) :
        m_data(d), m_file(f) {}
    node node::begin() const {
        if (!m_data)
            return {nullptr, m_file};
        return {m_file->node_table + m_data->children, m_file};
    }
    node node::end() const {
        if (!m_data)
            return {nullptr, m_file};
        return {m_file->node_table + m_data->children + m_data->num, m_file};
    }
    node node::operator*() const {
        return *this;
    }
    node & node::operator++() {
        ++m_data;
        return *this;
    }
    node node::operator++(int) {
        return {m_data++, m_file};
    }
    bool node::operator==(node const & o) const {
        return m_data == o.m_data;
    }
    bool node::operator!=(node const & o) const {
        return m_data != o.m_data;
    }
    bool node::operator<(node const & o) const {
        return m_data < o.m_data;
    }
    std::string operator+(std::string s, node n) {
        return s + n.get_string();
    }
    std::string operator+(char const * s, node n) {
        return s + n.get_string();
    }
    std::string operator+(node n, std::string s) {
        return n.get_string() + s;
    }
    std::string operator+(node n, char const * s) {
        return n.get_string() + s;
    }
    node node::operator[](unsigned int n) const {
        return operator[](std::to_string(n));
    }
    node node::operator[](signed int n) const {
        return operator[](std::to_string(n));
    }
    node node::operator[](unsigned long n) const {
        return operator[](std::to_string(n));
    }
    node node::operator[](signed long n) const {
        return operator[](std::to_string(n));
    }
    node node::operator[](unsigned long long n) const {
        return operator[](std::to_string(n));
    }
    node node::operator[](signed long long n) const {
        return operator[](std::to_string(n));
    }
    node node::operator[](std::string const & o) const {
        return get_child(o.c_str(), static_cast<uint16_t>(o.length()));
    }
    node node::operator[](char const * o) const {
        return get_child(o, static_cast<uint16_t>(std::strlen(o)));
    }
    node node::operator[](node const & o) const {
        return operator[](o.get_string());
    }
    node::operator unsigned char() const {
        return static_cast<unsigned char>(get_integer());
    }
    node::operator signed char() const {
        return static_cast<signed char>(get_integer());
    }
    node::operator unsigned short() const {
        return static_cast<unsigned short>(get_integer());
    }
    node::operator signed short() const {
        return static_cast<signed short>(get_integer());
    }
    node::operator unsigned int() const {
        return static_cast<unsigned int>(get_integer());
    }
    node::operator signed int() const {
        return static_cast<signed int>(get_integer());
    }
    node::operator unsigned long() const {
        return static_cast<unsigned long>(get_integer());
    }
    node::operator signed long() const {
        return static_cast<signed long>(get_integer());
    }
    node::operator unsigned long long() const {
        return static_cast<unsigned long long>(get_integer());
    }
    node::operator signed long long() const {
        return static_cast<signed long long>(get_integer());
    }
    node::operator float() const {
        return static_cast<float>(get_real());
    }
    node::operator double() const {
        return static_cast<double>(get_real());
    }
    node::operator long double() const {
        return static_cast<long double>(get_real());
    }
    node::operator std::string() const {
        return get_string();
    }
    node::operator vector2i() const {
        return get_vector();
    }
    node::operator bitmap() const {
        return get_bitmap();
    }
    node::operator audio() const {
        return get_audio();
    }
    node::operator bool() const {
        return m_data ? true : false;
    }
    int64_t node::get_integer(int64_t def) const {
        if (!m_data)
            return def;
        switch (m_data->type) {
        case type::none:
        case type::vector:
        case type::bitmap:
        case type::audio:
            return def;
        case type::integer:
            return to_integer();
        case type::real:
            return static_cast<int64_t>(to_real());
        case type::string:
            return std::stoll(to_string());
        default:
            throw std::runtime_error("Unknown node type");
        }
    }
    double node::get_real(double def) const {
        if (!m_data)
            return def;
        switch (m_data->type) {
        case type::none:
        case type::vector:
        case type::bitmap:
        case type::audio:
            return def;
        case type::integer:
            return static_cast<double>(to_integer());
        case type::real:
            return to_real();
        case type::string:
            return std::stod(to_string());
        default:
            throw std::runtime_error("Unknown node type");
        }
    }
    std::string node::get_string(std::string def) const {
        if (!m_data)
            return def;
        switch (m_data->type) {
        case type::none:
        case type::vector:
        case type::bitmap:
        case type::audio:
            return def;
        case type::integer:
            return std::to_string(to_integer());
        case type::real:
            return std::to_string(to_real());
        case type::string:
            return to_string();
        default:
            throw std::runtime_error("Unknown node type");
        }
    }
    vector2i node::get_vector(vector2i def) const {
        if (m_data && m_data->type == type::vector)
            return to_vector();
        return def;
    }
    bitmap node::get_bitmap() const {
        if (!m_data || m_data->type != type::bitmap) {
            return {nullptr, 0, 0};
        }
        
        // For v92 hybrid bitmap nodes, the bitmap data is in the node itself, not children
        // Children are just metadata (like 'origin', 'z', etc.)
        if (m_data->num > 0) {
            std::cout << "[NoLifeNx DEBUG] Hybrid bitmap node detected with " << m_data->num << " children" << std::endl;
            // First try to get bitmap data from the node itself (v92 pattern)
            try {
                bitmap result = to_bitmap();
                if (result.id() != 0) {
                    std::cout << "[NoLifeNx DEBUG] Successfully got bitmap data from hybrid node itself" << std::endl;
                    return result;
                }
            } catch (...) {
                std::cout << "[NoLifeNx DEBUG] Failed to get bitmap from hybrid node itself, trying children" << std::endl;
            }
            
            // Fallback: try to find a child that contains the actual bitmap data
            auto it = begin();
            for (uint32_t i = 0; i < m_data->num; ++i, ++it) {
                node child = *it;
                std::cout << "[NoLifeNx DEBUG] Child " << i << " name: '" << child.name() << "', type: " << static_cast<int>(child.data_type()) << ", children: " << child.size() << std::endl;
                
                // If child is a bitmap type with no children (actual bitmap data)
                if (child.data_type() == type::bitmap && child.size() == 0) {
                    std::cout << "[NoLifeNx DEBUG] Using child '" << child.name() << "' for bitmap data" << std::endl;
                    return child.get_bitmap();
                }
                
                // Also try child named "0" as common convention
                if (child.name() == "0") {
                    std::cout << "[NoLifeNx DEBUG] Found child '0', type: " << static_cast<int>(child.data_type()) << ", trying to get bitmap" << std::endl;
                    if (child.data_type() == type::bitmap) {
                        return child.get_bitmap();
                    }
                }
            }
            std::cout << "[NoLifeNx DEBUG] No suitable bitmap child found in hybrid node" << std::endl;
        }
        
        // Handle v92 NX files with synthetic bitmap table
        if (m_file->header->bitmap_count == 0) {
            // Check if we're in v92 mode with synthetic table
            if (m_file->v92_mode && !m_file->synthetic_bitmap_table.empty()) {
                std::cout << "[NoLifeNx DEBUG] Using v92 synthetic bitmap table" << std::endl;
                return to_bitmap();
            } else {
                std::cout << "[NoLifeNx DEBUG] bitmap_count=0 and no synthetic table available" << std::endl;
                return {nullptr, 0, 0};
            }
        } else {
            // Normal case - bitmap_count > 0
            return to_bitmap();
        }
    }
    audio node::get_audio() const {
        if (m_data && m_data->type == type::audio && m_file->header->audio_count)
            return to_audio();
        return {nullptr, 0};
    }
    bool node::get_bool() const {
        return m_data && m_data->type == type::integer && to_integer() ? true : false;
    }
    bool node::get_bool(bool def) const {
        return m_data && m_data->type == type::integer ? to_integer() ? true : false : def;
    }
    int32_t node::x() const {
        return m_data && m_data->type == type::vector ? m_data->vector[0] : 0;
    }
    int32_t node::y() const {
        return m_data && m_data->type == type::vector ? m_data->vector[1] : 0;
    }
    std::string node::name() const {
        if (!m_data)
            return {};
        auto const s = reinterpret_cast<char const *>(m_file->base)
            + m_file->string_table[m_data->name];
        return {s + 2, *reinterpret_cast<uint16_t const *>(s)};
    }
    size_t node::size() const {
        return m_data ? m_data->num : 0u;
    }
    node::type node::data_type() const {
        return m_data ? m_data->type : type::none;
    }
    node node::get_child(char const * const o, uint16_t const l) const {
        if (!m_data)
            return {nullptr, m_file};
        auto p = m_file->node_table + m_data->children;
        auto n = m_data->num;
        auto const b = reinterpret_cast<const char *>(m_file->base);
        auto const t = m_file->string_table;
        for (;;) {
            if (!n)
                return {nullptr, m_file};
            auto const n2 = static_cast<decltype(n)>(n >> 1);
            auto const p2 = p + n2;
            auto const sl = b + t[p2->name];
            auto const l1 = *reinterpret_cast<uint16_t const *>(sl);
            auto const s = reinterpret_cast<uint8_t const *>(sl + 2);
            auto const os = reinterpret_cast<uint8_t const *>(o);
            bool z = false;
            auto const len = l1 < l ? l1 : l;
            for (auto i = 0U; i < len; ++i) {
                if (s[i] > os[i]) {
                    n = n2;
                    z = true;
                    break;
                } else if (s[i] < os[i]) {
                    p = p2 + 1;
                    n -= n2 + 1;
                    z = true;
                    break;
                }
            }
            if (z)
                continue;
            else if (l1 < l)
                p = p2 + 1, n -= n2 + 1;
            else if (l1 > l)
                n = n2;
            else
                return {p2, m_file};
        }
    }
    int64_t node::to_integer() const {
        return m_data->ireal;
    }
    double node::to_real() const {
        return m_data->dreal;
    }
    std::string node::to_string() const {
        auto const s = reinterpret_cast<char const *>(m_file->base)
            + m_file->string_table[m_data->string];
        return {s + 2, *reinterpret_cast<uint16_t const *>(s)};
    }
    vector2i node::to_vector() const {
        return {m_data->vector[0], m_data->vector[1]};
    }
    bitmap node::to_bitmap() const {
        return {reinterpret_cast<char const *>(m_file->base)
            + m_file->bitmap_table[m_data->bitmap.index],
            m_data->bitmap.width, m_data->bitmap.height};
    }
    audio node::to_audio() const {
        return {reinterpret_cast<char const *>(m_file->base)
            + m_file->audio_table[m_data->audio.index],
            m_data->audio.length};
    }
    node node::root() const {
        return {m_file->node_table, m_file};
    }
    node node::resolve(std::string path) const {
        std::istringstream stream(path);
        std::vector<std::string> parts;
        std::string segment;
        while (std::getline(stream, segment, '/'))
            parts.push_back(segment);
        auto n = *this;
        for (auto & part : parts) {
            n = n[part];
        }
        return n;
    }
}

================
File: NoLifeNx_build/node.hpp
================
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

#pragma once
#include "nxfwd.hpp"
#include <string>
#include <cstdint>
#include <cstddef>

namespace nl {
    struct _file_data;
    typedef std::pair<int32_t, int32_t> vector2i;
    class node {
    public:
        using difference_type = ptrdiff_t;
        using value_type = node;
        using pointer = node;
        using reference = node &;
        using iterator_category = std::random_access_iterator_tag;
        struct data;
        //Type of node data
        enum class type : uint16_t {
            none = 0,
            integer = 1,
            real = 2,
            string = 3,
            vector = 4,
            bitmap = 5,
            audio = 6,
        };
        //Constructors
        node() = default;
        node(node const &);//Only reason this isn't defaulted is because msvc has issues
        node & operator=(node const &) = default;
        //These methods are primarily so nodes can be used as iterators and iterated over
        node begin() const;
        node end() const;
        node operator*() const;
        node & operator++();
        node operator++(int);
        bool operator==(node const &) const;
        bool operator!=(node const &) const;
        bool operator<(node const &) const;
        //This checks whether or not the node points to an actual node
        //Even if the node ends up being a null node, you can still use it safely
        //It'll just fall back to returning default values and more null nodes
        //However, if the file this node was obtained from was deleted
        //then the node becomes invalid and this operator cannot tell you that
        explicit operator bool() const;
        //Methods to access the children of the node by name
        //Note that the versions taking integers convert the integer to a string
        //They do not access the children by their integer index
        //If you wish to do that, use somenode.begin() + integer_index
        node operator[](unsigned int) const;
        node operator[](signed int) const;
        node operator[](unsigned long) const;
        node operator[](signed long) const;
        node operator[](unsigned long long) const;
        node operator[](signed long long) const;
        node operator[](std::string const &) const;
        node operator[](char const *) const;
        //This method uses the string value of the node, not the node's name
        node operator[](node const &) const;
        //Operators to easily cast a node to get the data
        //Allows things like string s = somenode
        //Will automatically cast between data types as needed
        //For example if the node has an integer value but you want a string
        //then the operator will automatically convert the integer to a string
        operator unsigned char() const;
        operator signed char() const;
        operator unsigned short() const;
        operator signed short() const;
        operator unsigned int() const;
        operator signed int() const;
        operator unsigned long() const;
        operator signed long() const;
        operator unsigned long long() const;
        operator signed long long() const;
        operator float() const;
        operator double() const;
        operator long double() const;
        operator std::string() const;
        operator vector2i() const;
        operator bitmap() const;
        operator audio() const;
        //Explicitly called versions of all the operators
        //When it takes a parameter, that is used as the default value
        //if a suitable data value cannot be found in the node
        int64_t get_integer(int64_t = 0) const;
        double get_real(double = 0) const;
        std::string get_string(std::string = "") const;
        vector2i get_vector(vector2i = {0, 0}) const;
        bitmap get_bitmap() const;
        audio get_audio() const;
        bool get_bool() const;
        bool get_bool(bool) const;
        //Returns the x and y coordinates of the vector data value
        int32_t x() const;
        int32_t y() const;
        //The name of the node
        std::string name() const;
        //The number of children in the node
        size_t size() const;
        //Gets the type of data contained within the node
        type data_type() const;
        //Returns the root node of the file this node was derived from
        node root() const;
        //Takes a '/' separated string, and resolves the given path
        node resolve(std::string) const;
    private:
        node(data const *, _file_data const *);
        node get_child(char const *, uint16_t) const;
        int64_t to_integer() const;
        double to_real() const;
        std::string to_string() const;
        vector2i to_vector() const;
        bitmap to_bitmap() const;
        audio to_audio() const;
        //Internal variables
        data const * m_data = nullptr;
        _file_data const * m_file = nullptr;
        friend file;
    };
    //More convenience string concatenation operators
    std::string operator+(std::string, node);
    std::string operator+(char const *, node);
    std::string operator+(node, std::string);
    std::string operator+(node, char const *);
}

================
File: NoLifeNx_build/NoLifeNx.sln
================
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.438
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NoLifeNx", "NoLifeNx.vcxproj", "{7C2F0F4B-B5DC-4F8F-9227-8D660582D494}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7C2F0F4B-B5DC-4F8F-9227-8D660582D494}.Debug|x64.ActiveCfg = Debug|x64
		{7C2F0F4B-B5DC-4F8F-9227-8D660582D494}.Debug|x64.Build.0 = Debug|x64
		{7C2F0F4B-B5DC-4F8F-9227-8D660582D494}.Debug|x86.ActiveCfg = Debug|Win32
		{7C2F0F4B-B5DC-4F8F-9227-8D660582D494}.Debug|x86.Build.0 = Debug|Win32
		{7C2F0F4B-B5DC-4F8F-9227-8D660582D494}.Release|x64.ActiveCfg = Release|x64
		{7C2F0F4B-B5DC-4F8F-9227-8D660582D494}.Release|x64.Build.0 = Release|x64
		{7C2F0F4B-B5DC-4F8F-9227-8D660582D494}.Release|x86.ActiveCfg = Release|Win32
		{7C2F0F4B-B5DC-4F8F-9227-8D660582D494}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C0F350AD-D818-42B8-8BF1-F08E530F4157}
	EndGlobalSection
EndGlobal

================
File: NoLifeNx_build/NoLifeNx.vcxproj
================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{7C2F0F4B-B5DC-4F8F-9227-8D660582D494}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>NoLifeNx</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)$(PlatformTarget)\$(Configuration)\</OutDir>
    <IntDir>$(PlatformTarget)\obj-$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)$(PlatformTarget)\$(Configuration)\</OutDir>
    <IntDir>$(PlatformTarget)\obj-$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)$(PlatformTarget)\$(Configuration)\</OutDir>
    <IntDir>$(PlatformTarget)\obj-$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)$(PlatformTarget)\$(Configuration)\</OutDir>
    <IntDir>$(PlatformTarget)\obj-$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)includes\lz4_v1_8_2_win$(PlatformArchitecture)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <AdditionalLibraryDirectories>$(ProjectDir)includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>liblz4.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)includes\lz4_v1_8_2_win$(PlatformArchitecture)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <AdditionalLibraryDirectories>$(ProjectDir)includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>liblz4.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)includes\lz4_v1_8_2_win$(PlatformArchitecture)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <AdditionalLibraryDirectories>$(ProjectDir)includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>liblz4.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)includes\lz4_v1_8_2_win$(PlatformArchitecture)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <AdditionalLibraryDirectories>$(ProjectDir)includes\lz4_v1_8_2_win$(PlatformArchitecture)\dll;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>liblz4.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Lib>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="audio.hpp" />
    <ClInclude Include="bitmap.hpp" />
    <ClInclude Include="file.hpp" />
    <ClInclude Include="file_impl.hpp" />
    <ClInclude Include="node.hpp" />
    <ClInclude Include="node_impl.hpp" />
    <ClInclude Include="nx.hpp" />
    <ClInclude Include="nxfwd.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="audio.cpp" />
    <ClCompile Include="bitmap.cpp" />
    <ClCompile Include="file.cpp" />
    <ClCompile Include="node.cpp" />
    <ClCompile Include="nx.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

================
File: NoLifeNx_build/NoLifeNx.vcxproj.filters
================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="audio.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="bitmap.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="file.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="node.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="nx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="audio.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="bitmap.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="file.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="file_impl.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="node.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="node_impl.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nx.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nxfwd.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>

================
File: NoLifeNx_build/nx.cpp
================
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "nx.hpp"
#include "file.hpp"
#include "node.hpp"

#include <fstream>
#include <vector>
#include <memory>
#include <stdexcept>

namespace nl
{
	namespace nx
	{
		std::vector<std::unique_ptr<file>> files;

		bool exists(std::string name)
		{
			return std::ifstream(name).is_open();
		}

		node add_file(std::string name)
		{
			if (!exists(name))
				return {};

			files.emplace_back(new file(name));

			return *files.back();
		}

		node Base, Character, Effect, Etc, Item, Map, Map001, Map002, Map2, Mob, Mob001, Mob002, Mob2, Morph, Npc, Quest, Reactor, Skill, Skill001, Skill002, Skill003, Sound, Sound001, Sound002, Sound2, String, TamingMob, UI;

		void load_all()
		{
			if (exists("Base.nx"))
			{
				Base = add_file("Base.nx");
				Character = add_file("Character.nx");
				Effect = add_file("Effect.nx");
				Etc = add_file("Etc.nx");
				Item = add_file("Item.nx");
				Map = add_file("Map.nx");
				Map001 = add_file("Map001.nx");
				Map002 = add_file("Map002.nx");
				Map2 = add_file("Map2.nx");
				Mob = add_file("Mob.nx");
				Mob001 = add_file("Mob001.nx");
				Mob002 = add_file("Mob002.nx");
				Mob2 = add_file("Mob2.nx");
				Morph = add_file("Morph.nx");
				Npc = add_file("Npc.nx");
				Quest = add_file("Quest.nx");
				Reactor = add_file("Reactor.nx");
				Skill = add_file("Skill.nx");
				Skill001 = add_file("Skill001.nx");
				Skill002 = add_file("Skill002.nx");
				Skill003 = add_file("Skill003.nx");
				Sound = add_file("Sound.nx");
				Sound001 = add_file("Sound001.nx");
				Sound002 = add_file("Sound002.nx");
				Sound2 = add_file("Sound2.nx");
				String = add_file("String.nx");
				TamingMob = add_file("TamingMob.nx");
				UI = add_file("UI.nx");
			}
			else if (exists("Data.nx"))
			{
				Base = add_file("Data.nx");
				Character = Base["Character"];
				Effect = Base["Effect"];
				Etc = Base["Etc"];
				Item = Base["Item"];
				Map = Base["Map"];
				Map001 = Base["Map001"];
				Map002 = Base["Map002"];
				Map2 = Base["Map2"];
				Mob = Base["Mob"];
				Mob001 = Base["Mob001"];
				Mob002 = Base["Mob002"];
				Mob2 = Base["Mob2"];
				Morph = Base["Morph"];
				Npc = Base["Npc"];
				Quest = Base["Quest"];
				Reactor = Base["Reactor"];
				Skill = Base["Skill"];
				Skill001 = Base["Skill001"];
				Skill002 = Base["Skill002"];
				Skill003 = Base["Skill003"];
				Sound = Base["Sound"];
				Sound001 = Base["Sound001"];
				Sound002 = Base["Sound002"];
				Sound2 = Base["Sound2"];
				String = Base["String"];
				TamingMob = Base["TamingMob"];
				UI = Base["UI"];
			}
			else
			{
				throw std::runtime_error("Failed to locate nx files.");
			}
		}
	}
}

================
File: NoLifeNx_build/nx.hpp
================
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "nxfwd.hpp"

namespace nl
{
	namespace nx
	{
		// Pre-defined nodes to access standard MapleStory style data
		// Make sure you called load_all first
		extern node Base, Character, Effect, Etc, Item, Map, Map001, Map002, Map2, Mob, Mob001, Mob002, Mob2, Morph, Npc, Quest, Reactor, Skill, Skill001, Skill002, Skill003, Sound, Sound001, Sound002, Sound2, String, TamingMob, UI;

		// Loads the pre-defined nodes from a standard setup of nx files for MapleStory
		// Only call this function once
		void load_all();
	}
}

================
File: NoLifeNx_build/nxfwd.hpp
================
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

#pragma once

namespace nl {
    class node;
    class file;
    class bitmap;
    class audio;
}

================
File: NoLifeNx_build/README.md
================
# NoLifeNx
Forked from [NoLifeDev/NoLifeNx](https://github.com/NoLifeDev/NoLifeNx)

# Dependencies
- [LZ4](https://github.com/lz4/lz4/releases)

================
File: NoLifeWzToNx/convert_all_wz.bat
================
@echo off
REM convert_all_wz.bat  -- converts every .wz in .\files\ to .nx one folder up

pushd "%~dp0"                          && REM make sure we’re in NoLifeWzToNx
if not exist files\*.wz (
    echo No .wz files found in .\files\ 1>&2
    pause & exit /b 1
)

for %%F in (files\*.wz) do (
    echo Converting %%~nxF …
    NoLifeWzToNx.exe "%%F" "..\%%~nF.nx"
)

echo.
echo All done!  NX files are now in the parent folder.
popd
pause

================
File: nul
================
ERROR: Invalid argument/option - 'F:/'.
Type "TASKKILL /?" for usage.

================
File: README_BUILD.md
================
# HeavenClient Build Instructions

This guide will help you compile and run the HeavenClient on Windows.

## Prerequisites

- Windows 10/11
- Visual Studio 2019 Community (or newer)
- Windows SDK 8.1
- Platform Toolset v140 (Visual Studio 2015 Build Tools)

## Quick Start

1. **Install Dependencies** (run as Administrator):
   ```batch
   install_dependencies.bat
   ```

2. **Build the Client**:
   ```batch
   build.bat
   ```

3. **Run the Client**:
   ```batch
   run_client.bat
   ```

## Detailed Instructions

### 1. Install Visual Studio 2019

1. Download Visual Studio 2019 Community from: https://visualstudio.microsoft.com/downloads/
2. During installation, select:
   - Desktop development with C++
   - Windows 10 SDK
   - MSVC v142 - VS 2019 C++ x64/x86 build tools
   - MSVC v140 - VS 2015 C++ build tools (for v140 toolset)

### 2. Install Windows SDK 8.1

1. Download from: https://developer.microsoft.com/en-us/windows/downloads/sdk-archive
2. Install "Windows SDK for Windows 8.1"

### 3. Set up WZ to NX Conversion

The client requires NX files (converted from WZ files). You have WZ files at:
`C:\Users\me\Downloads\PERISH\MapleStory`

1. Download NoLifeWzToNx from: https://github.com/ryantpayton/NoLifeWzToNx/releases
2. Extract `NoLifeWzToNx.exe` to the `NoLifeWzToNx` folder
3. Run `setup_nx_conversion.bat` to convert WZ files to NX format

### 4. Build the Client

Run `build.bat` to compile the client. Options:
- `build.bat` - Build Release x64 (default)
- `build.bat debug` - Build Debug x64
- `build.bat release x86` - Build Release x86
- `build.bat debug x86` - Build Debug x86

### 5. Run the Client

Run `run_client.bat` to launch the client. This script will:
- Check for the executable
- Verify NX files are present
- Launch the client with proper settings

## File Structure

After building, your directory should look like:
```
HeavenClient/
├── x64/Release/MapleStory.exe    # Main executable
├── Base.nx                       # Game data files
├── Character.nx
├── Effect.nx
├── Etc.nx
├── Item.nx
├── Map.nx
├── Mob.nx
├── Morph.nx
├── Npc.nx
├── Quest.nx
├── Reactor.nx
├── Skill.nx
├── Sound.nx
├── String.nx
├── TamingMob.nx
├── UI.nx
└── includes/                     # All dependencies included
```

## Dependencies Included

All required dependencies are included in the `includes/` folder:
- **GLEW 2.1.0** - OpenGL extensions
- **GLFW 3.3.2** - Windowing and input
- **FreeType** - Font rendering
- **Bass 2.4** - Audio library
- **NoLifeNx** - NX file handling
- **STB** - Image loading

## Build Scripts

- `install_dependencies.bat` - Checks and installs required tools
- `build.bat` - Compiles the client
- `setup_nx_conversion.bat` - Converts WZ files to NX format
- `run_client.bat` - Launches the client with checks

## Troubleshooting

### Build Errors

**Missing Windows SDK 8.1:**
```
Download from: https://developer.microsoft.com/en-us/windows/downloads/sdk-archive
```

**Missing Platform Toolset v140:**
```
Install Visual Studio 2015 Build Tools or add v140 toolset to VS 2019
```

**Link errors:**
```
Make sure all dependencies are in the includes/ folder
```

### Runtime Errors

**Missing DLLs:**
```
The build script automatically copies required DLLs to the output folder
```

**Client crashes on startup:**
```
1. Check that all NX files are present
2. Verify debug.log for error details
3. Make sure Visual C++ Redistributables are installed
```

**Missing NX files:**
```
Run setup_nx_conversion.bat to convert WZ files
```

### Clean Build

If you encounter issues, try a clean build:
```batch
# Delete build artifacts
rmdir /s /q x64
rmdir /s /q x86  
rmdir /s /q .vs
del debug.log
del MapleStory.aps
del Settings

# Rebuild
build.bat
```

## Configuration

Edit `MapleStory.h` to configure build options:
- `USE_ASIO`: Use Asio for networking (requires additional setup)
- `USE_CRYPTO`: Use cryptography for server communication
- `USE_NX`: Use NX files instead of WZ files (recommended)
- `USE_DEBUG`: Enable debug features

Edit `Configuration.h` to change default settings (server address, resolution, etc.)

## Server Connection

The client is designed to work with version 83 servers. Make sure to:
1. Configure the server address in `Configuration.h`
2. Ensure the server is running and accessible
3. Check that client and server versions match

## Support

For issues specific to this build setup, check:
1. The console output from build scripts
2. Visual Studio build output
3. The `debug.log` file generated by the client
4. Original project README.md for general client information

================
File: README.md
================
# HeavenClient
HeavenClient is a custom, made-from-scratch game client.

# Supported versions
- The client is currently compatible with version 83 servers
- The client has only been tested with [HeavenMS]
- **[Switch]**
- **[Linux]**

# Configuration
The build can be configured by editing the **MapleStory.h** file. The following options are available:
- **USE_ASIO**: Use Asio for networking (additional dependency)
- **USE_CRYPTO**: Use cryptography when communicating for the server
- **USE_NX**: Use NX files instead of WZ files
- **USE_DEBUG**: This suppresses the generation of the Settings file

The default settings can be configured by editing the **Configuration.h** file. These are also generated after a game session in a file called **Settings**. These can be altered in the same way as **Configuration.h**, although, these do not persist if you delete the file, unlike **Configuration.h**.

# Building
1. Open **MapleStory.sln** in Visual Studio 2019 CE
2. Make sure to use **Windows SDK Version: 8.1** and **Platform Toolset: v140** (If you don't have these, download them.)
   * [Windows 8.1 SDK]
3. Press **Build** > **Build Solution** or **Ctrl + Shift + B**
4. After a successful build, you can now run the program by pressing **Debug** > **Start Debugging** or **F5**.
5. Make sure all NX files are present in the parent folder. To convert WZ files to NX you can use the [NoLifeWzToNx] project.
   - Extract the zip
   - Place your WZ files in the **files** folder
   - Run **start.bat**
   - See **Required Files** for a list of required NX files

# Required Files
*All WZ files from the official client are required to be converted*
*Check **NxFiles.h** for an updated list of required NX files*
*Check **Configuration.h** for the latest version of WZ files tested*

# Dependencies
- Nx library:
[NoLifeNx]

- Wz library:
TBA

- Graphics:
[GLFW3], [GLEW], [FreeType]

- Audio:
[Bass]

- Networking:
[Asio] (optional)

# In-Game Issues
If you experience any kind of in-game glitches, UI rendering issues, or anything else that seems out of the ordinary that other developers are not experiences; Follow these steps in order to hopefully resolve aforementioned issues.
1. Clean Solution
2. Close Visual Studio
3. Delete the following files/folders: **.vs**, **x64**, **debug.log**, **MapleStory.aps**, **Settings**
4. Open Solution
5. Rebuild Solution

# Binaries (08.19.2019)
The latest build ([e3e97c2][commit]) can be found here: [HeavenClient v228.3.zip][archive]

# Donations
If you feel obligated to donate, to further help and support all parties involved in the development of the HeavenClient project, you can donate using [this][donate] link.

Please remember this is ONLY for the HeavenClient development and will only be used in the support of helping further develop the client. *Also please remember to support Nexon as this is not meant to replace anything Nexon offers*

Another important note to remember is that HeavenClient is a free open-sourced client developed for personal use. Do NOT pay for any services requested by anyone in regards to this client. It will always remain open and free of charge. There is no intent to publish this code with any payment in mind. If that ever changes, donations and disclaimers for donations will be removed.

[HeavenMS]:          https://github.com/ryantpayton/MapleStory
[Switch]:            https://github.com/lain3d/HeavenClientNX
[Linux]:             https://github.com/ryantpayton/HeavenClient/tree/linux
[Windows 8.1 SDK]:   https://developer.microsoft.com/en-us/windows/downloads/sdk-archive
[NoLifeWzToNx]:      https://github.com/ryantpayton/NoLifeWzToNx
[NoLifeNx]:          https://github.com/ryantpayton/NoLifeNx
[GLFW3]:             http://www.glfw.org/download.html
[GLEW]:              http://glew.sourceforge.net/
[FreeType]:          http://www.freetype.org/
[Bass]:              http://www.un4seen.com/
[Asio]:              http://think-async.com/
[commit]:            https://github.com/ryantpayton/MapleStory-Client/commit/e3e97c23fc6a92b87356fc2484c7f8b12d71bf19
[archive]:           https://1drv.ms/u/s!Al6eadQnem68on8i7qG62UBsFXpV?e=sumYue
[donate]:            https://www.paypal.com/donate?business=MZDZLUH2UC5FE&no_recurring=0&currency_code=USD

================
File: resource.h
================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by MapleStory.rc
//
#define GLFW_ICON                       102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

================
File: run_client.bat
================
@echo off
echo HeavenClient Launcher
echo =====================

:: Check if client executable exists
set "CLIENT_PATH_X64=x64\Release\MapleStory.exe"
set "CLIENT_PATH_X86=x86\Release\MapleStory.exe"
set "CLIENT_PATH_X64_DEBUG=x64\Debug\MapleStory.exe"
set "CLIENT_PATH_X86_DEBUG=x86\Debug\MapleStory.exe"

echo Checking for client executable...
if exist "%CLIENT_PATH_X64%" (
    set "CLIENT_PATH=%CLIENT_PATH_X64%"
    echo Found x64 Release build
) else if exist "%CLIENT_PATH_X86%" (
    set "CLIENT_PATH=%CLIENT_PATH_X86%"
    echo Found x86 Release build
) else if exist "%CLIENT_PATH_X64_DEBUG%" (
    set "CLIENT_PATH=%CLIENT_PATH_X64_DEBUG%"
    echo Found x64 Debug build
) else if exist "%CLIENT_PATH_X86_DEBUG%" (
    set "CLIENT_PATH=%CLIENT_PATH_X86_DEBUG%"
    echo Found x86 Debug build
) else (
    echo ERROR: Client executable not found!
    echo Please build the client first using build.bat
    pause
    exit /b 1
)

:: Check for NX files
echo.
echo Checking for NX files...
set "MISSING_NX=0"
set "NX_FILES=Base Character Effect Etc Item Map Mob Morph Npc Quest Reactor Skill Sound String TamingMob UI"

for %%f in (%NX_FILES%) do (
    if not exist "%%f.nx" (
        echo WARNING: %%f.nx not found!
        set "MISSING_NX=1"
    )
)

if "%MISSING_NX%"=="1" (
    echo.
    echo Some NX files are missing!
    echo The client may not work properly without them.
    echo.
    echo Would you like to convert WZ files now? (y/n)
    set /p "CONVERT_WZ="
    if /i "%CONVERT_WZ%"=="y" (
        echo.
        call setup_nx_conversion.bat
    ) else (
        echo.
        echo WARNING: Running without all NX files may cause crashes!
        echo Press any key to continue anyway...
        pause >nul
    )
) else (
    echo All NX files found!
)

:: Check for required DLLs
echo.
echo Checking for required DLLs...
set "DLL_MISSING=0"

:: Check in the client directory
if exist "%CLIENT_PATH%" (
    for /f "tokens=*" %%i in ('dir /b "%CLIENT_PATH%\.."') do (
        if "%%i"=="freetype.dll" echo ✓ freetype.dll found
        if "%%i"=="bass.dll" echo ✓ bass.dll found
        if "%%i"=="liblz4.dll" echo ✓ liblz4.dll found
    )
)

:: Launch the client
echo.
echo Starting HeavenClient...
echo.
echo Client path: %CLIENT_PATH%
echo Working directory: %CD%
echo.

:: Change to client directory and run
cd /d "%~dp0"
start "" "%CLIENT_PATH%"

echo Client launched!
echo.
echo If the client fails to start, check:
echo 1. All NX files are present
echo 2. Visual C++ Redistributables are installed
echo 3. DirectX Runtime is installed
echo 4. All DLL files are in the client directory
echo.
echo Check the debug.log file for error details if the client crashes.
echo.
pause

================
File: setup_nx_conversion.bat
================
@echo off
echo NX File Conversion Setup
echo ========================

:: Check if WZ files exist
set "WZ_PATH=C:\Users\me\Downloads\PERISH\MapleStory"
if not exist "%WZ_PATH%" (
    echo ERROR: WZ files not found at %WZ_PATH%
    echo Please check the path and try again.
    pause
    exit /b 1
)

echo Found WZ files at: %WZ_PATH%
echo.

:: Create NoLifeWzToNx directory if it doesn't exist
if not exist "NoLifeWzToNx" mkdir "NoLifeWzToNx"
cd "NoLifeWzToNx"

:: Download NoLifeWzToNx if not present
if not exist "NoLifeWzToNx.exe" (
    echo Downloading NoLifeWzToNx...
    echo Please download NoLifeWzToNx from: https://github.com/ryantpayton/NoLifeWzToNx/releases
    echo Extract it to the NoLifeWzToNx folder and run this script again.
    pause
    cd ..
    exit /b 1
)

:: Create files directory if it doesn't exist
if not exist "files" mkdir "files"

:: Copy WZ files to NoLifeWzToNx files directory
echo Copying WZ files...
copy "%WZ_PATH%\Base.wz" "files\" >nul
copy "%WZ_PATH%\Character.wz" "files\" >nul
copy "%WZ_PATH%\Effect.wz" "files\" >nul
copy "%WZ_PATH%\Etc.wz" "files\" >nul
copy "%WZ_PATH%\Item.wz" "files\" >nul
copy "%WZ_PATH%\Map.wz" "files\" >nul
copy "%WZ_PATH%\Mob.wz" "files\" >nul
copy "%WZ_PATH%\Morph.wz" "files\" >nul
copy "%WZ_PATH%\Npc.wz" "files\" >nul
copy "%WZ_PATH%\Quest.wz" "files\" >nul
copy "%WZ_PATH%\Reactor.wz" "files\" >nul
copy "%WZ_PATH%\Skill.wz" "files\" >nul
copy "%WZ_PATH%\Sound.wz" "files\" >nul
copy "%WZ_PATH%\String.wz" "files\" >nul
copy "%WZ_PATH%\TamingMob.wz" "files\" >nul
copy "%WZ_PATH%\UI.wz" "files\" >nul

:: Run NoLifeWzToNx
echo.
echo Converting WZ files to NX format...
echo This may take several minutes...
NoLifeWzToNx.exe

:: Move NX files to parent directory
echo.
echo Moving NX files to client directory...
if exist "Base.nx" move "Base.nx" ".." >nul
if exist "Character.nx" move "Character.nx" ".." >nul
if exist "Effect.nx" move "Effect.nx" ".." >nul
if exist "Etc.nx" move "Etc.nx" ".." >nul
if exist "Item.nx" move "Item.nx" ".." >nul
if exist "Map.nx" move "Map.nx" ".." >nul
if exist "Mob.nx" move "Mob.nx" ".." >nul
if exist "Morph.nx" move "Morph.nx" ".." >nul
if exist "Npc.nx" move "Npc.nx" ".." >nul
if exist "Quest.nx" move "Quest.nx" ".." >nul
if exist "Reactor.nx" move "Reactor.nx" ".." >nul
if exist "Skill.nx" move "Skill.nx" ".." >nul
if exist "Sound.nx" move "Sound.nx" ".." >nul
if exist "String.nx" move "String.nx" ".." >nul
if exist "TamingMob.nx" move "TamingMob.nx" ".." >nul
if exist "UI.nx" move "UI.nx" ".." >nul

cd ..

:: Clean up WZ files from NoLifeWzToNx directory
echo Cleaning up...
if exist "NoLifeWzToNx\files\*.wz" del "NoLifeWzToNx\files\*.wz" >nul

echo.
echo NX conversion complete!
echo You can now run the HeavenClient.
echo.
pause

================
File: Template/BoolPair.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <stdexcept>

namespace ms
{
	template <typename T>
	class BoolPair
	{
	public:
		template <typename...Args>
		BoolPair(Args&& ...argsf, Args&& ...argss) : first(std::forward<Args>(argsf)...), second(std::forward<Args>(argss)...) {}
		BoolPair(T f, T s) : first(f), second(s) {}
		BoolPair() {}

		template <typename...Args>
		void set(bool b, Args&& ...args)
		{
			if (b)
				first = T(std::forward<Args>(args)...);
			else
				second = T(std::forward<Args>(args)...);
		}

		T& operator [](bool b)
		{
			return b ? first : second;
		}

		const T& operator [](bool b) const
		{
			return b ? first : second;
		}

	private:
		T first;
		T second;
	};
}

================
File: Template/Cache.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <unordered_map>
#include <cstdint>

namespace ms
{
	template <typename T>
	// Template for a cache of game objects 
	// which can be constructed from an identifier.
	// The 'get' factory method is static.
	class Cache
	{
	public:
		virtual ~Cache() {}

		// Return a ref to the game object with the specified id.
		// If the object is not in cache, it is created.
		static const T& get(std::int32_t id)
		{
			auto iter = cache.find(id);

			if (iter == cache.end())
				iter = cache.emplace(id, T{ id }).first;

			return iter->second;
		}

	private:
		static std::unordered_map<std::int32_t, T> cache;
	};

	template <typename T>
	std::unordered_map<std::int32_t, T> Cache<T>::cache;
}

================
File: Template/Enumeration.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <type_traits>
#include <array>

namespace ms
{
	template <typename E, E LENGTH = E::LENGTH>
	// Makes contiguous enums iterable.
	class Enumeration
	{
	public:
		using underlying_t = typename std::array<E, LENGTH>;

		template <std::size_t...VS>
		constexpr Enumeration(std::index_sequence<VS...>) : values{ { static_cast<E>(VS)... } } {}

		constexpr Enumeration() : Enumeration(std::make_index_sequence<LENGTH>{})
		{
			static_assert(std::is_enum<E>::value, "Template parameter E for Enumeration must be an enum.");
		}

		auto begin() const
		{
			return values.begin();
		}

		auto end() const
		{
			return values.end();
		}

		auto cbegin() const
		{
			return values.cbegin();
		}

		auto cend() const
		{
			return values.cend();
		}

	private:
		underlying_t values;
	};
}

================
File: Template/EnumMap.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <array>

namespace ms
{
	template <typename K, typename V, K LENGTH = K::LENGTH>
	// Wraps an array so that it is addressable by enumeration values
	class EnumMap
	{
	public:
		template <typename...Args>
		// Initialize with an initializer list
		EnumMap(Args&& ... args) : m_values{ { std::forward<Args>(args)... } }
		{
			static_assert(std::is_enum<K>::value, "Template parameter 'K' for EnumMap must be an enum.");

			for (size_t i = 0; i < LENGTH; i++)
				m_keys[i] = static_cast<K>(i);
		}

		void clear()
		{
			for (size_t i = 0; i < LENGTH; i++)
				m_values[i] = V();
		}

		void erase(K key)
		{
			if (key >= 0 && key < LENGTH)
				m_values[key] = V();
		}

		template <typename...Args>
		void emplace(K key, Args&& ...args)
		{
			m_values[key] = { std::forward<Args>(args)... };
		}

		V& operator [](K key)
		{
			return m_values[key];
		}

		const V& operator[](K key) const
		{
			return m_values[key];
		}

		template <typename T>
		class base_iterator : public std::iterator<std::forward_iterator_tag, V> {

		public:
			using index_type = typename std::underlying_type<K>::type;

			base_iterator(T* p, index_type i) : value(p), index(i) {}

			struct node
			{
				K first;
				T& second;

				node(K f, T& s) : first(f), second(s) {}

				node& operator =(const node&) = delete;

				void set(const T& t)
				{
					second = t;
				}
			};

			node operator *()
			{
				return node{ first(), second() };
			}

			explicit operator bool() const
			{
				return index >= 0 && index < LENGTH;
			}

			K first() const
			{
				return static_cast<K>(index);
			}

			T& second()
			{
				if (!this)
					throw std::out_of_range("iterator out of range");
				else
					return *(value + index);
			}

			base_iterator& operator ++()
			{
				index++;
				return *this;
			}

			bool operator != (const base_iterator& other) const
			{
				return index != other.index;
			}

			bool operator == (const base_iterator& other) const
			{
				return index == other.index;
			}

		private:
			T* value;
			index_type index;
		};

		using iterator = base_iterator<V>;
		using const_iterator = base_iterator<const V>;
		using node = typename iterator::node;
		using cnode = typename const_iterator::node;

		iterator find(K key)
		{
			return { m_values.data(), key };
		}

		const_iterator find(K key) const
		{
			return { m_values.data(), key };
		}

		iterator begin()
		{
			return { m_values.data(), 0 };
		}

		iterator end()
		{
			return { m_values.data(), LENGTH };
		}

		const_iterator begin() const
		{
			return { m_values.data(), 0 };
		}

		const_iterator end() const
		{
			return { m_values.data(), LENGTH };
		}

		const std::array<K, LENGTH>& keys() const
		{
			return m_keys;
		}

		std::array<V, LENGTH>& values()
		{
			return m_values;
		}

		const std::array<V, LENGTH>& values() const
		{
			return m_values;
		}

	private:
		std::array<K, LENGTH> m_keys;
		std::array<V, LENGTH> m_values;
	};
}

================
File: Template/Interpolated.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Util/Lerp.h"

namespace ms
{
	template <typename T>
	class Nominal
	{
	public:
		constexpr Nominal() : now(T()), before(T()), threshold(0.0f) {}

		T get() const
		{
			return now;
		}

		T get(float alpha) const
		{
			return alpha >= threshold ? now : before;
		}

		T last() const
		{
			return before;
		}

		void set(T value)
		{
			now = value;
			before = value;
		}

		void normalize()
		{
			before = now;
		}

		bool normalized() const
		{
			return before == now;
		}

		void next(T value, float thrs)
		{
			before = now;
			now = value;
			threshold = thrs;
		}

		bool operator == (T value) const
		{
			return now == value;
		}

		bool operator != (T value) const
		{
			return now != value;
		}

		T operator + (T value) const
		{
			return now + value;
		}

		T operator - (T value) const
		{
			return now - value;
		}

		T operator * (T value) const
		{
			return now * value;
		}

		T operator / (T value) const
		{
			return now / value;
		}

	private:
		T now;
		T before;
		float threshold;
	};

	template <typename T>
	class Linear
	{
	public:
		T get() const
		{
			return now;
		}

		T get(float alpha) const
		{
			return lerp<T>(before, now, alpha);
		}

		T last() const
		{
			return before;
		}

		void set(T value)
		{
			now = value;
			before = value;
		}

		void normalize()
		{
			before = now;
		}

		bool normalized() const
		{
			return before == now;
		}

		void operator = (T value)
		{
			before = now;
			now = value;
		}

		void operator += (T value)
		{
			before = now;
			now += value;
		}

		void operator -= (T value)
		{
			before = now;
			now -= value;
		}

		bool operator == (T value) const
		{
			return now == value;
		}

		bool operator != (T value) const
		{
			return now != value;
		}

		bool operator < (T value) const
		{
			return now < value;
		}

		bool operator <= (T value) const
		{
			return now <= value;
		}

		bool operator > (T value) const
		{
			return now > value;
		}

		bool operator >= (T value) const
		{
			return now >= value;
		}

		T operator + (T value) const
		{
			return now + value;
		}

		T operator - (T value) const
		{
			return now - value;
		}

		T operator * (T value) const
		{
			return now * value;
		}

		T operator / (T value) const
		{
			return now / value;
		}

		T operator + (Linear<T> value) const
		{
			return now + value.get();
		}

		T operator - (Linear<T> value) const
		{
			return now - value.get();
		}

		T operator * (Linear<T> value) const
		{
			return now * value.get();
		}

		T operator / (Linear<T> value) const
		{
			return now / value.get();
		}

	private:
		T now;
		T before;
	};
}

================
File: Template/Optional.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <functional>
#include <type_traits>

namespace ms
{
	template <typename T>
	class Optional
	{
	public:
		template <typename R, typename = std::enable_if_t<std::is_base_of<R, T>::value || std::is_base_of<T, R>::value>>
		constexpr Optional(R* r_val) : val(static_cast<T*>(r_val)) {}

		template <typename R, typename = std::enable_if_t<std::is_base_of<R, T>::value || std::is_base_of<T, R>::value>>constexpr Optional(Optional<R> r_opt) : Optional(r_opt.get()) {}
		constexpr Optional(T* p) : val(p) {}
		constexpr Optional(T& p) : val(&p) {}
		constexpr Optional() : val(nullptr) {}

		explicit operator bool() const
		{
			return val != nullptr;
		}

		T* get() const
		{
			return val;
		}

		T* operator ->() const
		{
			return val;
		}

		T& operator *() const
		{
			return *val;
		}

	private:
		T* val;
	};
}

================
File: Template/Point.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../MapleStory.h"

#ifdef USE_NX
#include <nlnx/node.hpp>
#else
#include "../Util/WzFiles.h"
#endif

namespace ms
{
	template <class T>
	class Point
	{
	public:
		// Construct a point from a vector property
		Point(nl::node src)
		{
			a = static_cast<T>(src.x());
			b = static_cast<T>(src.y());
		}

		// Construct a point from the specified coordinates
		constexpr Point(T first, T second) : a(first), b(second) {}

		// Construct a point with coordinates (0, 0)
		constexpr Point() : Point(0, 0) {}

		// Return the x-coordinate
		constexpr T x() const
		{
			return a;
		}

		// Return the y-coordinate
		constexpr T y() const
		{
			return b;
		}

		// Return the inner product
		constexpr T length() const
		{
			return static_cast<T>(
				std::sqrt(a * a + b * b)
				);
		}

		// Check whether the coordinates are equal
		constexpr bool straight() const
		{
			return a == b;
		}

		// Return a string representation of the point
		std::string to_string() const
		{
			return "(" + std::to_string(a) + "," + std::to_string(b) + ")";
		}

		// Return the distance to another point
		constexpr T distance(Point<T> v) const
		{
			return Point<T>(a - v.a, b - v.b).length();
		}

		// Set the x-coordinate
		void set_x(T v)
		{
			a = v;
		}

		// Set the y-coordinate
		void set_y(T v)
		{
			b = v;
		}

		// Shift the x-coordinate by the specified amount
		void shift_x(T v)
		{
			a += v;
		}

		// Shift the y-coordinate by the specified amount
		void shift_y(T v)
		{
			b += v;
		}

		// Shift the coordinates by the specified amounts
		void shift(T x, T y)
		{
			a += x;
			b += y;
		}

		// Shift the this point by the amounts defined by another point
		// Equivalent to += operator
		void shift(Point<T> v)
		{
			a += v.a;
			b += v.b;
		}

		// Take the absolute value of the point
		Point<T> abs()
		{
			return {
				static_cast<T>(std::abs(a)),
				static_cast<T>(std::abs(b))
			};
		}

		// Check whether point is equivalent to the specified point
		constexpr bool operator == (const Point<T>& v) const
		{
			return a == v.a && b == v.b;
		}

		// Check whether point is not equivalent to the specified point
		constexpr bool operator != (const Point<T>& v) const
		{
			return !(*this == v);
		}

		// Shift the this point by the amounts defined by another point
		void operator += (Point<T> v)
		{
			a += v.a;
			b += v.b;
		}

		// Shift the this point in reverse direction by the amounts defined by another point
		void operator -= (Point<T> v)
		{
			a -= v.a;
			b -= v.b;
		}

		// Return a point whose coordinates are the negation of this point's coordinates
		constexpr Point<T> operator - () const
		{
			return { -a, -b };
		}

		// Return a point whose coordinates have been added the specified amount
		constexpr Point<T> operator + (T v) const
		{
			return { a + v, b + v };
		}

		// Return a point whose coordinates have been subtracted the specified amount
		constexpr Point<T> operator - (T v) const
		{
			return { a - v, b - v };
		}

		// Return a point whose coordinates have been multiplied by the specified amount
		constexpr Point<T> operator * (T v) const
		{
			return { a * v, b * v };
		}

		// Return a point whose coordinates have been divided by the specified amount
		constexpr Point<T> operator / (T v) const
		{
			return { a / v, b / v };
		}

		// Return a point whose coordinates are the sum of this and another points coordinates
		constexpr Point<T> operator + (Point<T> v) const
		{
			return { a + v.a, b + v.b };
		}

		// Return a point whose coordinates are the difference of this and another points coordinates
		constexpr Point<T> operator - (Point<T> v) const
		{
			return { a - v.a, b - v.b };
		}

		// Return a point whose coordinates are the product of this and another points coordinates
		constexpr Point<T> operator * (Point<T> v) const
		{
			return { a / v.a, b / v.b };
		}

		// Return a point whose coordinates are the division of this and another points coordinates
		constexpr Point<T> operator / (Point<T> v) const
		{
			return {
				a / (v.a == 0 ? 1 : v.a),
				b / (v.b == 0 ? 1 : v.b)
			};
		}

	private:
		T a;
		T b;
	};
}

================
File: Template/Range.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

namespace ms
{
	template <class T>
	class Range
	{
	public:
		// Construct a range from the specified values
		constexpr Range(const T& first, const T& second) : a(first), b(second) {}

		// Construct a range of (0, 0)
		constexpr Range() : Range(0, 0) {}

		// Return the first value
		constexpr const T& first() const
		{
			return a;
		}

		// Return the second value
		constexpr const T& second() const
		{
			return b;
		}

		// Return the greater value
		constexpr const T& greater() const
		{
			return (a > b) ? a : b;
		}

		// Return the smaller value
		constexpr const T& smaller() const
		{
			return (a < b) ? a : b;
		}

		// Return the difference between the values
		constexpr T delta() const
		{
			return b - a;
		}

		// Return the absolute difference between the values
		constexpr T length() const
		{
			return greater() - smaller();
		}

		// Return the mean of both values
		constexpr T center() const
		{
			return (a + b) / 2;
		}

		// Check if both values are equal
		constexpr bool empty() const
		{
			return a == b;
		}

		// Check if the range contains a value
		constexpr bool contains(const T& v) const
		{
			return v >= a && v <= b;
		}

		// Check if the range contains another range
		constexpr bool contains(const Range<T>& v) const
		{
			return v.a >= a && v.b <= b;
		}

		// Check if the ranges overlap
		constexpr bool overlaps(const Range<T>& v) const
		{
			return contains(v.a) || contains(v.b) || v.contains(a) || v.contains(b);
		}

		// Check whether the range is equivalent to another range
		constexpr bool operator == (const Range<T>& v) const
		{
			return a == v.a && b == v.b;
		}

		// Check whether the range is not equivalent to another range
		constexpr bool operator != (const Range<T>& v) const
		{
			return !(*this == v);
		}

		// Shift this range by the amounts defined by another range
		constexpr Range<T> operator + (const Range<T>& v) const
		{
			return { a + v.a, b + v.b };
		}

		// Shift this range by the negative amounts defined by another range
		constexpr Range<T> operator - (const Range<T>& v) const
		{
			return { a - v.a, b - v.b };
		}

		// Return the negative of this range
		constexpr Range<T> operator - () const
		{
			return { -a, -b };
		}

		// Construct a symmetric range around mid
		static Range<T> symmetric(const T& mid, const T& tail)
		{
			return { mid - tail, mid + tail };
		}

	private:
		T a;
		T b;
	};
}

================
File: Template/Rectangle.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Point.h"
#include "Range.h"

namespace ms
{
	template <class T>
	class Rectangle
	{
	public:
		Rectangle(nl::node sourceLeftTop, nl::node sourceRightBottom) : left_top(sourceLeftTop), right_bottom(sourceRightBottom) {}
		Rectangle(nl::node source) : left_top(source["lt"]), right_bottom(source["rb"]) {}

		constexpr Rectangle(Point<T> leftTop, Point<T> rightBottom) : left_top(leftTop), right_bottom(rightBottom) {}
		constexpr Rectangle(T left, T right, T top, T bottom) : left_top(left, top), right_bottom(right, bottom) {}
		constexpr Rectangle() {}

		constexpr T width() const
		{
			return std::abs(left() - right());
		}

		constexpr T height() const
		{
			return std::abs(top() - bottom());
		}

		constexpr T left() const
		{
			return left_top.x();
		}

		constexpr T top() const
		{
			return left_top.y();
		}

		constexpr T right() const
		{
			return right_bottom.x();
		}

		constexpr T bottom() const
		{
			return right_bottom.y();
		}

		constexpr bool contains(const Point<T>& v) const
		{
			return
				!straight() &&
				v.x() >= left() && v.x() <= right() &&
				v.y() >= top() && v.y() <= bottom();
		}

		constexpr bool overlaps(const Rectangle<T>& ar) const
		{
			return
				get_horizontal().overlaps(Range<T>(ar.left(), ar.right())) &&
				get_vertical().overlaps(Range<T>(ar.top(), ar.bottom()));
		}

		constexpr bool straight() const
		{
			return left_top == right_bottom;
		}

		constexpr bool empty() const
		{
			return left_top.straight() && right_bottom.straight() && straight();
		}

		constexpr const Point<T>& get_left_top() const
		{
			return left_top;
		}

		constexpr const Point<T>& get_right_bottom() const
		{
			return right_bottom;
		}

		constexpr Range<T> get_horizontal() const
		{
			return { left(), right() };
		}

		constexpr Range<T> get_vertical() const
		{
			return { top(), bottom() };
		}

		void shift(const Point<T>& v)
		{
			left_top = left_top + v;
			right_bottom = right_bottom + v;
		}

	private:
		Point<T> left_top;
		Point<T> right_bottom;
	};
}

================
File: Template/Singleton.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

namespace ms
{
	template <class T>
	class Singleton
	{
	public:
		virtual ~Singleton() {}

		static T& get()
		{
			return instance;
		}

	private:
		T& operator = (const T&) = delete;

		static T instance;
	};

	template <class T>
	T Singleton<T>::instance;
}

================
File: Template/TimedQueue.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Constants.h"

#include <queue>
#include <functional>
#include <cstdint>

namespace ms
{
	template <typename T>
	class TimedQueue
	{
	public:
		TimedQueue(std::function<void(const T&)> in_action) : action(in_action)
		{
			time = 0;
		}

		void push(int64_t delay, const T& t)
		{
			queue.emplace(time + delay, t);
		}

		template <typename...Args>
		void emplace(int64_t delay, Args&& ...args)
		{
			queue.emplace(time + delay, std::move(args)...);
		}

		void update(int64_t timestep = Constants::TIMESTEP)
		{
			time += timestep;

			for (; !queue.empty(); queue.pop())
			{
				const Timed& top = queue.top();

				if (top.when > time)
					break;

				action(top.value);
			}
		}

	private:
		struct Timed
		{
			T value;
			int64_t when;

			Timed(int64_t w, const T& v) : when{ w }, value{ v } {}

			template <typename...Args>
			Timed(int64_t w, Args&& ...args) : when{ w }, value{ std::forward<Args>(args)... } {}
		};

		struct TimedComparator
		{
			bool operator ()(const Timed& a, const Timed& b) const
			{
				return a.when > b.when;
			}
		};

		std::priority_queue<Timed, std::vector<Timed>, TimedComparator> queue;
		std::function<void(const T&)> action;
		int64_t time;
	};
}

================
File: Template/TypeMap.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <typeindex>
#include <unordered_map>
#include <memory>

namespace ms
{
	template <typename T>
	// An unordered map which uses the type as key.
	class TypeMap
	{
	public:
		using t_ptr = typename std::unique_ptr<T>;
		using pair = typename std::pair<std::type_index, t_ptr>;
		using cpair = typename std::pair<const std::type_index, t_ptr>;
		using underlying_map = typename std::unordered_map<std::type_index, t_ptr>;

		template <typename D, typename...Args>
		D* emplace(Args&& ... args)
		{
			auto* ptr = container.emplace(typeid(D), std::make_unique<D>(args...)).first->second.get();
			return static_cast<D*>(ptr);
		}

		template <typename D>
		void erase()
		{
			container.erase(typeid(D));
		}

		void clear()
		{
			container.clear();
		}

		template <typename D>
		D* get()
		{
			return static_cast<D*>(container[typeid(D)].get());
		}

		template <typename D>
		const D* get() const
		{
			return static_cast<D*>(container[typeid(D)].get());
		}

		typename underlying_map::iterator begin()
		{
			return container.begin();
		}

		typename underlying_map::iterator end()
		{
			return container.end();
		}

		typename underlying_map::const_iterator begin() const
		{
			return container.begin();
		}

		typename underlying_map::const_iterator end() const
		{
			return container.end();
		}

	private:
		underlying_map container;
	};
}

================
File: Timer.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Template/Singleton.h"

#include <cstdint>
#include <chrono>

namespace ms
{
	// Small class for measuring elapsed time between game loops.
	class Timer : public Singleton<Timer>
	{
	public:
		Timer()
		{
			start();
		}

		~Timer() {}

		// Start the timer by setting the last measurement to now.
		void start()
		{
			point = clock::now();
		}

		// Return time elapsed since the last measurement.
		int64_t stop()
		{
			clock::time_point last = point;
			point = clock::now();

			auto duration = std::chrono::duration_cast<std::chrono::microseconds>(point - last);
			return duration.count();
		}

	private:
		using clock = std::chrono::high_resolution_clock;

		clock::time_point point;
	};

	// Small class for measuring elapsed time given a specific start time.
	class ContinuousTimer : public Singleton<ContinuousTimer>
	{
	public:
		using point = std::chrono::time_point<std::chrono::steady_clock>;

		ContinuousTimer()
		{
			start();
		}

		~ContinuousTimer() {}

		// Return now from the clock to be used to calculate elapsed time later.
		point start()
		{
			return clock::now();
		}

		// Return time elapsed since the last measurement provided.
		int64_t stop(point last)
		{
			auto now = clock::now();

			auto duration = std::chrono::duration_cast<std::chrono::microseconds>(now - last);
			return duration.count();
		}

	private:
		using clock = std::chrono::high_resolution_clock;
	};
}

================
File: Util/AssetRegistry.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.						//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "AssetRegistry.h"

#include <fstream>
#include <sstream>
#include <iostream>
#include <algorithm>

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
    // Static member definitions
    const std::string AssetRegistry::empty_string_ = "";
    const std::vector<std::string> AssetRegistry::empty_vector_ = {};

    AssetRegistry& AssetRegistry::get()
    {
        static AssetRegistry instance;
        return instance;
    }

    bool AssetRegistry::load(const std::string& map_filepath)
    {
        last_error_ = ErrorCode::NONE;
        last_error_message_.clear();

        // Initialize the name to ID mapping
        initializeNameMapping();

        // For now, use hardcoded mappings instead of YAML parsing
        // This provides immediate functionality while YAML support can be added later
        initializeHardcodedMappings();

        loaded_ = true;
        std::cout << "[AssetRegistry] Loaded asset mappings successfully" << std::endl;
        return true;
    }

    bool AssetRegistry::is_loaded() const
    {
        return loaded_;
    }

    const std::string& AssetRegistry::getPath(AssetID id) const
    {
        if (!loaded_)
        {
            setError(ErrorCode::NX_NOT_LOADED, "AssetRegistry not loaded");
            return empty_string_;
        }

        auto it = asset_map_.find(id);
        if (it == asset_map_.end())
        {
            setError(ErrorCode::ASSET_NOT_FOUND, "Asset ID not found in registry");
            return empty_string_;
        }

        const auto& info = it->second;
        
        // Try each path in priority order until we find a valid one
        for (const auto& path : info.prioritized_paths)
        {
#ifdef USE_NX
            if (isPathValid(path))
            {
                return path;
            }
#else
            // Without NX, return the first path
            return path;
#endif
        }

        // No valid paths found
        setError(ErrorCode::NO_VALID_PATHS, "No valid paths found for asset");
        return empty_string_;
    }

    const std::vector<std::string>& AssetRegistry::getAllPaths(AssetID id) const
    {
        auto it = asset_map_.find(id);
        if (it == asset_map_.end())
        {
            return empty_vector_;
        }
        return it->second.prioritized_paths;
    }

    bool AssetRegistry::hasValidPath(AssetID id) const
    {
        if (!loaded_)
            return false;

        auto it = asset_map_.find(id);
        if (it == asset_map_.end())
            return false;

#ifdef USE_NX
        for (const auto& path : it->second.prioritized_paths)
        {
            if (isPathValid(path))
                return true;
        }
        return false;
#else
        return !it->second.prioritized_paths.empty();
#endif
    }

    const std::string& AssetRegistry::getAssetType(AssetID id) const
    {
        auto it = asset_map_.find(id);
        if (it == asset_map_.end())
            return empty_string_;
        return it->second.asset_type;
    }

    const std::string& AssetRegistry::getAssetNotes(AssetID id) const
    {
        auto it = asset_map_.find(id);
        if (it == asset_map_.end())
            return empty_string_;
        return it->second.notes;
    }

    std::string AssetRegistry::resolveFullPath(AssetID id) const
    {
        const std::string& path = getPath(id);
        if (path.empty())
            return "";

        // Path format: "nx_file:path/to/asset"
        auto colon_pos = path.find(':');
        if (colon_pos == std::string::npos)
            return path;

        return path.substr(colon_pos + 1);
    }

#ifdef USE_NX

    bool AssetRegistry::isPathValid(const std::string& path) const
    {
        if (path.empty())
            return false;

        try
        {
            nl::node node = resolvePathToNode(path);
            return !node.name().empty();
        }
        catch (...)
        {
            return false;
        }
    }

    nl::node AssetRegistry::resolvePathToNode(const std::string& full_path) const
    {
        // Parse path format: "nx_file:path/to/asset"
        auto colon_pos = full_path.find(':');
        if (colon_pos == std::string::npos)
        {
            // No colon, assume it's just a path for UI.nx
            // No colon found, treating as UI path
            return nl::nx::UI.resolve(full_path);
        }

        std::string nx_file = full_path.substr(0, colon_pos);
        std::string asset_path = full_path.substr(colon_pos + 1);
        
        // Parsed nx file and asset path

        // Map nx file name to actual node (v83 consolidated - no Map001/Map002)
        if (nx_file == "UI") {
            // Resolving UI path
            nl::node result = nl::nx::UI.resolve(asset_path);
            // UI path resolved
            return result;
        }
        else if (nx_file == "Map")
            return nl::nx::Map.resolve(asset_path);
        else if (nx_file == "Character")
            return nl::nx::Character.resolve(asset_path);
        else if (nx_file == "Sound")
            return nl::nx::Sound.resolve(asset_path);
        else if (nx_file == "String")
            return nl::nx::String.resolve(asset_path);
        else if (nx_file == "Item")
            return nl::nx::Item.resolve(asset_path);
        else if (nx_file == "Effect")
            return nl::nx::Effect.resolve(asset_path);
        else if (nx_file == "Etc")
            return nl::nx::Etc.resolve(asset_path);

        // Unknown nx file
        return nl::node();
    }

    nl::node AssetRegistry::resolve(AssetID id) const
    {
        const std::string& path = getPath(id);
        if (path.empty()) {
            // Failed to get path for AssetID
            setError(ErrorCode::ASSET_NOT_FOUND, "No path configured for AssetID.");
            return nl::node();
        }

        // Resolving AssetID to path
        nl::node result = resolvePathToNode(path);

        if (result.name().empty()) {
            // Path resolution failed
            setError(ErrorCode::NO_VALID_PATHS, "Path resolution failed for: " + path);
            return result;
        }

        // --- NEW: Intelligent Hybrid Node Resolution Logic ---
        auto asset_map_it = asset_map_.find(id);
        if (asset_map_it == asset_map_.end()) {
            // This case should ideally not happen if getPath succeeded, but is a safe check.
            return result;
        }
        const auto& assetInfo = asset_map_it->second;

        // Only attempt to traverse if the node is a container AND the asset allows hybrid resolution
        if (result.data_type() == nl::node::type::none && result.size() > 0 && assetInfo.allow_hybrid_resolve) {
            // Hybrid container detected, searching for child bitmap
            
            // Prioritize child named "0" as this is a common pattern, then iterate.
            nl::node child_zero = result["0"];
            if (child_zero && child_zero.data_type() == nl::node::type::bitmap) {
                // Found valid child bitmap
                return child_zero;
            }

            // Fallback to iterating all children if "0" is not a valid bitmap.
            for (const auto& child : result) {
                if (child.data_type() == nl::node::type::bitmap) {
                    // Found valid child bitmap
                    return child;
                }
            }

            setError(ErrorCode::NO_VALID_PATHS, "Hybrid node '" + path + "' contains no valid child bitmaps.");
            // Hybrid node contains no valid child bitmaps
            return nl::node(); // Return invalid node if no suitable child is found.
        }
        
        // Asset successfully resolved
        return result;
    }
#endif

    AssetRegistry::ErrorCode AssetRegistry::getLastError() const
    {
        return last_error_;
    }

    const std::string& AssetRegistry::getLastErrorMessage() const
    {
        return last_error_message_;
    }

    void AssetRegistry::setError(ErrorCode code, const std::string& message) const
    {
        last_error_ = code;
        last_error_message_ = message;
    }

    void AssetRegistry::initializeNameMapping()
    {
        // Map string names to AssetID enum values for future YAML parsing
        name_to_id_["UI_Login_Background"] = AssetID::UI_Login_Background;
        name_to_id_["UI_Login_Title_Background"] = AssetID::UI_Login_Title_Background;
        name_to_id_["UI_Login_Version_Position"] = AssetID::UI_Login_Version_Position;
        name_to_id_["UI_Shop_Background"] = AssetID::UI_Shop_Background;
        name_to_id_["Map_Login_Background"] = AssetID::Map_Login_Background;
        name_to_id_["Sound_UI_Button_Click"] = AssetID::Sound_UI_Button_Click;
        // Add more mappings as needed
    }

    void AssetRegistry::initializeHardcodedMappings()
    {
        // Helper function to create AssetInfo with default hybrid resolve = false
        auto createAssetInfo = [](const std::vector<std::string>& paths, const std::string& type, 
                                 const std::string& notes, const std::vector<std::string>& consumers,
                                 const std::string& version, const std::vector<std::string>& fallback,
                                 bool hybrid = false) -> AssetInfo {
            AssetInfo info;
            info.prioritized_paths = paths;
            info.asset_type = type;
            info.notes = notes;
            info.consumers = consumers;
            info.version_compatibility = version;
            info.fallback_paths = fallback;
            info.allow_hybrid_resolve = hybrid;
            return info;
        };

        // Temporary hardcoded mappings based on extracted asset data
        // These replace the most commonly used hardcoded paths
        
        // UI Login Assets - UPDATED FOR V92 STRUCTURE WITH HYBRID HANDLING
        asset_map_[AssetID::UI_Login_Background] = createAssetInfo(
            {"UI:Login.img/Notice/backgrnd"}, "Texture",
            "Login screen background - v92 hybrid container with child bitmaps",
            {"IO/UITypes/UILogin.cpp"}, "v92", {}, true);

        asset_map_[AssetID::UI_Login_Title_Background] = createAssetInfo(
            {"UI:Login.img/Notice/backgrnd"}, "Texture",
            "Login title area background - using same background as main",
            {"IO/UITypes/UILogin.cpp"}, "v92", {}, true);

        asset_map_[AssetID::UI_Login_Version_Position] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Point",
            "Version text position - using frame as reference",
            {"IO/UITypes/UILogin.cpp"}, "v83", {});

        // Shop Assets
        asset_map_[AssetID::UI_Shop_Background] = createAssetInfo(
            {"UI:UIWindow2.img/Shop2/backgrnd"}, "Texture",
            "Shop interface background texture",
            {"IO/UITypes/UIShop.cpp"}, "all", {});

        // Sound Assets
        asset_map_[AssetID::Sound_UI_Button_Click] = createAssetInfo(
            {"Sound:UI.img/BtMouseClick"}, "Audio",
            "Standard UI button click sound effect",
            {"Audio/Audio.cpp"}, "all", {});

        // Character Select Background - CORRECTED for v83 consolidated structure
        asset_map_[AssetID::UI_CharSelect_Background] = createAssetInfo(
            {"UI:Login.img/Notice/Loading/backgrnd/0"}, "Node",
            "Character selection background - using available background",
            {"IO/UITypes/UICharSelect.cpp"}, "v83", {});

        // Login UI Elements - Essential for login screen functionality
        asset_map_[AssetID::UI_Login_Capslock_Warning] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Texture",
            "Caps lock warning indicator", {"IO/UITypes/UILogin.cpp"}, "v92", {});

        asset_map_[AssetID::UI_Login_Checkbox_Unchecked] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Texture", 
            "Save login unchecked checkbox", {"IO/UITypes/UILogin.cpp"}, "v92", {});

        asset_map_[AssetID::UI_Login_Checkbox_Checked] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Texture",
            "Save login checked checkbox", {"IO/UITypes/UILogin.cpp"}, "v92", {});

        asset_map_[AssetID::UI_Login_Button_Login] = createAssetInfo(
            {"UI:Login.img/BtLogin/normal/0"}, "Texture",
            "Login button", {"IO/UITypes/UILogin.cpp"}, "v92", {}, true);

        asset_map_[AssetID::UI_Login_Button_New] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Texture",
            "New account button", {"IO/UITypes/UILogin.cpp"}, "v92", {});

        asset_map_[AssetID::UI_Login_Button_Quit] = createAssetInfo(
            {"UI:Login.img/BtQuit/normal/0"}, "Texture", 
            "Quit button", {"IO/UITypes/UILogin.cpp"}, "v92", {}, true);

        asset_map_[AssetID::UI_Login_Button_Homepage] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Texture",
            "Homepage button", {"IO/UITypes/UILogin.cpp"}, "v92", {});

        asset_map_[AssetID::UI_Login_Button_PasswdLost] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Texture",
            "Lost password button", {"IO/UITypes/UILogin.cpp"}, "v92", {});

        asset_map_[AssetID::UI_Login_Button_EmailLost] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Texture",
            "Lost email button", {"IO/UITypes/UILogin.cpp"}, "v92", {});

        asset_map_[AssetID::UI_Login_Button_EmailSave] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Texture",
            "Save email button", {"IO/UITypes/UILogin.cpp"}, "v92", {});

        asset_map_[AssetID::UI_Login_Tab_Disabled] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Texture",
            "Disabled tab state", {"IO/UITypes/UILogin.cpp"}, "v92", {});

        asset_map_[AssetID::UI_Login_Tab_Enabled] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Texture",
            "Enabled tab state", {"IO/UITypes/UILogin.cpp"}, "v92", {});

        asset_map_[AssetID::UI_Login_Field_MapleID] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Texture",
            "MapleID input field", {"IO/UITypes/UILogin.cpp"}, "v92", {});

        asset_map_[AssetID::UI_Login_Field_NexonID] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Texture", 
            "NexonID input field", {"IO/UITypes/UILogin.cpp"}, "v92", {});

        asset_map_[AssetID::UI_Login_Field_Password] = createAssetInfo(
            {"UI:Login.img/Common/frame"}, "Texture",
            "Password input field", {"IO/UITypes/UILogin.cpp"}, "v92", {});

        std::cout << "[AssetRegistry] Initialized " << asset_map_.size() << " hardcoded asset mappings" << std::endl;
    }

    // Convenience functions
#ifdef USE_NX
    nl::node GetAsset(AssetID id)
    {
        return AssetRegistry::get().resolve(id);
    }
#endif

    std::string GetAssetPath(AssetID id)
    {
        return AssetRegistry::get().resolveFullPath(id);
    }
}

================
File: Util/AssetRegistry.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.						//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Assets.h"
#include <string>
#include <vector>
#include <unordered_map>
#include <memory>

#ifdef USE_NX
#include <nlnx/node.hpp>
#endif

// Hash specialization for AssetID enum to work with unordered_map
namespace std {
    template<>
    struct hash<ms::AssetID> {
        size_t operator()(const ms::AssetID& assetId) const {
            return hash<int>()(static_cast<int>(assetId));
        }
    };
}

namespace ms
{
    // Centralized asset management system that replaces hardcoded string paths
    // with type-safe logical identifiers and provides version compatibility
    class AssetRegistry
    {
    public:
        // Singleton access
        static AssetRegistry& get();
        
        // Initialize the registry by loading the master asset map
        bool load(const std::string& map_filepath = "assets_master.yml");
        
        // Check if the registry has been initialized
        bool is_loaded() const;
        
        // Retrieve the resolved path for a logical asset ID
        // Returns the first valid path from the prioritized list
        const std::string& getPath(AssetID id) const;
        
        // Get all possible paths for an asset (for debugging/analysis)
        const std::vector<std::string>& getAllPaths(AssetID id) const;
        
        // Check if an asset has any valid paths available
        bool hasValidPath(AssetID id) const;
        
        // Get asset metadata
        const std::string& getAssetType(AssetID id) const;
        const std::string& getAssetNotes(AssetID id) const;
        
        // Utility functions for path resolution
        std::string resolveFullPath(AssetID id) const;
        
#ifdef USE_NX
        // Resolve an asset ID to an actual nl::node
        nl::node resolve(AssetID id) const;
        
        // Check if a specific path is valid in the loaded nx data
        bool isPathValid(const std::string& path) const;
#endif
        
        // Error handling
        enum class ErrorCode
        {
            NONE,
            FILE_NOT_FOUND,
            PARSE_ERROR,
            ASSET_NOT_FOUND,
            NO_VALID_PATHS,
            NX_NOT_LOADED
        };
        
        ErrorCode getLastError() const;
        const std::string& getLastErrorMessage() const;
        
    private:
        AssetRegistry() = default;
        ~AssetRegistry() = default;
        AssetRegistry(const AssetRegistry&) = delete;
        AssetRegistry& operator=(const AssetRegistry&) = delete;
        
        // Internal data structure to hold asset information
        struct AssetInfo
        {
            std::vector<std::string> prioritized_paths;  // Multiple paths for fallback
            std::string asset_type;                      // Texture, Node, Audio, etc.
            std::string notes;                           // Description and compatibility info
            std::vector<std::string> consumers;          // Files that use this asset
            std::string version_compatibility;           // v83, post-v83, etc.
            std::vector<std::string> fallback_paths;     // Alternative asset locations
            bool allow_hybrid_resolve = false;           // Enable automatic hybrid container traversal
        };
        
        // Asset ID to info mapping
        std::unordered_map<AssetID, AssetInfo> asset_map_;
        
        // String to AssetID mapping for YAML parsing
        std::unordered_map<std::string, AssetID> name_to_id_;
        
        // Error handling
        mutable ErrorCode last_error_ = ErrorCode::NONE;
        mutable std::string last_error_message_;
        
        // Loading state
        bool loaded_ = false;
        
        // Helper methods
        bool parseYAMLFile(const std::string& filepath);
        void initializeNameMapping();
        void initializeHardcodedMappings();
        void setError(ErrorCode code, const std::string& message) const;
        
        // Path processing helpers
        std::string constructFullPath(const std::string& root_node, const std::string& path) const;
        std::pair<std::string, std::string> parseAssetPath(const std::string& full_path) const;
        
#ifdef USE_NX
        // NX-specific path resolution
        nl::node resolvePathToNode(const std::string& full_path) const;
#endif
        
        // Default empty strings for error cases
        static const std::string empty_string_;
        static const std::vector<std::string> empty_vector_;
    };
    
    // Convenience function for direct asset resolution
#ifdef USE_NX
    nl::node GetAsset(AssetID id);
#endif
    
    // Asset path helper for legacy code migration
    std::string GetAssetPath(AssetID id);
}

================
File: Util/AssetRegistryTest.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.						//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "AssetRegistry.h"
#include <iostream>
#include <cassert>

namespace ms
{
    // Simple test framework
    class AssetRegistryTest
    {
    public:
        static void runAllTests()
        {
            std::cout << "[AssetRegistryTest] Starting unit tests..." << std::endl;
            
            testSingletonAccess();
            testLoadRegistry();
            testAssetResolution();
            testErrorHandling();
            testFallbackLogic();
            
            std::cout << "[AssetRegistryTest] All tests passed!" << std::endl;
        }

    private:
        static void testSingletonAccess()
        {
            std::cout << "[Test] Singleton access..." << std::endl;
            
            AssetRegistry& registry1 = AssetRegistry::get();
            AssetRegistry& registry2 = AssetRegistry::get();
            
            // Should be the same instance
            assert(&registry1 == &registry2);
            
            std::cout << "[Test] Singleton access - PASSED" << std::endl;
        }

        static void testLoadRegistry()
        {
            std::cout << "[Test] Registry loading..." << std::endl;
            
            AssetRegistry& registry = AssetRegistry::get();
            
            // Should not be loaded initially
            assert(!registry.is_loaded());
            
            // Load the registry
            bool loaded = registry.load();
            assert(loaded);
            assert(registry.is_loaded());
            
            std::cout << "[Test] Registry loading - PASSED" << std::endl;
        }

        static void testAssetResolution()
        {
            std::cout << "[Test] Asset resolution..." << std::endl;
            
            AssetRegistry& registry = AssetRegistry::get();
            
            // Test known assets
            const std::string& login_bg_path = registry.getPath(AssetID::UI_Login_Background);
            assert(!login_bg_path.empty());
            
            const std::string& shop_bg_path = registry.getPath(AssetID::UI_Shop_Background);
            assert(!shop_bg_path.empty());
            
            // Test full path resolution
            std::string full_path = registry.resolveFullPath(AssetID::UI_Login_Background);
            assert(!full_path.empty());
            
            // Test metadata access
            const std::string& asset_type = registry.getAssetType(AssetID::UI_Login_Background);
            assert(asset_type == "Texture");
            
            std::cout << "[Test] Asset resolution - PASSED" << std::endl;
        }

        static void testErrorHandling()
        {
            std::cout << "[Test] Error handling..." << std::endl;
            
            AssetRegistry& registry = AssetRegistry::get();
            
            // Test with invalid asset ID (cast to valid range to avoid compiler issues)
            AssetID invalid_id = static_cast<AssetID>(999999);
            const std::string& invalid_path = registry.getPath(invalid_id);
            assert(invalid_path.empty());
            
            // Check error state
            assert(registry.getLastError() == AssetRegistry::ErrorCode::ASSET_NOT_FOUND);
            assert(!registry.getLastErrorMessage().empty());
            
            std::cout << "[Test] Error handling - PASSED" << std::endl;
        }

        static void testFallbackLogic()
        {
            std::cout << "[Test] Fallback logic..." << std::endl;
            
            AssetRegistry& registry = AssetRegistry::get();
            
            // Test assets with multiple paths
            const auto& all_paths = registry.getAllPaths(AssetID::UI_Login_Background);
            assert(all_paths.size() > 1);  // Should have fallback paths
            
            // Test path validation
            bool has_valid = registry.hasValidPath(AssetID::UI_Login_Background);
            // Note: This test depends on NX files being loaded, so we just check it doesn't crash
            (void)has_valid;  // Suppress unused variable warning
            
            std::cout << "[Test] Fallback logic - PASSED" << std::endl;
        }
    };

    // Test runner function that can be called from main or debug code
    void runAssetRegistryTests()
    {
        AssetRegistryTest::runAllTests();
    }
}

================
File: Util/Assets.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.						//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

namespace ms
{
    // Logical asset identifiers to replace hardcoded string paths
    // Each enum value maps to one or more physical asset paths with fallback support
    enum class AssetID
    {
        // === UI Assets ===
        
        // Login Screen
        UI_Login_Background,                // Login screen main background
        UI_Login_Title_Background,          // Login title area background
        UI_Login_Version_Position,          // Version text position
        UI_Login_Capslock_Warning,          // Caps lock indicator
        UI_Login_Checkbox_Unchecked,        // Save login unchecked state
        UI_Login_Checkbox_Checked,          // Save login checked state
        UI_Login_Button_Login,              // Login button
        UI_Login_Button_New,                // New account button
        UI_Login_Button_Quit,               // Quit button
        UI_Login_Button_Homepage,           // Homepage button
        UI_Login_Button_PasswdLost,         // Lost password button
        UI_Login_Button_EmailLost,          // Lost email button
        UI_Login_Button_EmailSave,          // Save email button
        UI_Login_Tab_Disabled,              // Disabled tab states
        UI_Login_Tab_Enabled,               // Enabled tab states
        UI_Login_Field_MapleID,             // MapleID input field background
        UI_Login_Field_NexonID,             // NexonID input field background
        UI_Login_Field_Password,            // Password input field background
        
        // World Selection
        UI_WorldSelect_Background,          // World selection background
        UI_WorldSelect_Button_Exit,         // Exit button
        UI_WorldSelect_World_Button,        // World selection buttons
        UI_WorldSelect_Channel_Button,      // Channel selection buttons
        
        // Character Selection
        UI_CharSelect_Background,           // Character selection background
        
        // Shop Interface
        UI_Shop_Background,                 // Shop main background
        UI_Shop_Button_Buy,                 // Buy button
        UI_Shop_Button_Sell,                // Sell button
        
        // Chat Interface
        UI_Chat_Background,                 // Chat window background
        UI_Chat_Input_Background,           // Chat input field
        UI_Chat_Button_ItemLink,            // Item link button (post-v87)
        UI_Chat_Button_Emoticon,            // Emoticon button (post-v87)
        
        // Minimap
        UI_MiniMap_Background,              // Minimap background
        UI_MiniMap_Icons,                   // Minimap icons
        
        // Inventory
        UI_Inventory_Background,            // Inventory window background
        UI_Inventory_Tabs,                  // Inventory tab buttons
        
        // Status Bar
        UI_StatusBar_Background,            // Status bar background
        UI_StatusBar_HP_Bar,                // HP bar graphics
        UI_StatusBar_MP_Bar,                // MP bar graphics
        
        // World Map
        UI_WorldMap_Background,             // World map background
        UI_WorldMap_Icons,                  // World map location icons
        
        // Notice/Dialog
        UI_Notice_Background,               // Notice dialog background
        UI_Notice_Button_OK,                // OK button
        UI_Notice_Button_Cancel,            // Cancel button
        
        // Logo
        UI_Logo_Wizet,                      // Wizet startup logo
        UI_Logo_Nexon,                      // Nexon logo
        
        // === Map Assets ===
        
        // Backgrounds
        Map_Login_Background,               // Login screen map background
        Map_CharSelect_Background,          // Character select background
        
        // Portals
        Map_Portal_Default_Animation,       // Default portal animation
        Map_Portal_Game_Animation,          // In-game portal animation
        
        // Map Helper
        Map_Helper_WorldMap_Image,          // World map images
        Map_Helper_Portal_Graphics,         // Portal graphics
        
        // Effects
        Map_Effect_Animation,               // Map-based effects
        
        // Objects
        Map_Object_CharCreation,            // Character creation objects
        
        // === Character Assets ===
        
        // Body
        Character_Body_Default,             // Default character body
        Character_Body_Skin_Names,          // Skin tone names
        
        // Equipment
        Character_Weapon_Graphics,          // Weapon graphics
        Character_Equipment_Graphics,       // Equipment graphics
        
        // Effects
        Character_Afterimage_Sword,         // Sword afterimage effects
        Character_Skill_Effects,            // Skill visual effects
        
        // === Sound Assets ===
        
        // UI Sounds
        Sound_UI_Button_Click,              // Button click sound
        Sound_UI_Button_Hover,              // Button hover sound
        Sound_UI_Window_Open,               // Window open sound
        Sound_UI_Window_Close,              // Window close sound
        
        // Game Sounds
        Sound_Game_Portal,                  // Portal usage sound
        Sound_Game_LevelUp,                 // Level up sound
        Sound_Game_ItemDrop,                // Item drop sound
        
        // Weapon Sounds
        Sound_Weapon_Sword_Attack,          // Sword attack sounds
        Sound_Weapon_Bow_Attack,            // Bow attack sounds
        Sound_Weapon_Magic_Cast,            // Magic casting sounds
        
        // === String Assets ===
        
        // Equipment Names
        String_Equipment_Weapon_Names,      // Weapon names
        String_Equipment_Armor_Names,       // Armor names
        String_Equipment_Accessory_Names,   // Accessory names
        
        // Monster Names
        String_Monster_Names,               // Monster display names
        String_Monster_Descriptions,        // Monster descriptions
        
        // Skill Names
        String_Skill_Names,                 // Skill names
        String_Skill_Descriptions,          // Skill descriptions
        
        // UI Text
        String_UI_ButtonText,               // UI button text
        String_UI_MenuText,                 // Menu text
        
        // === Item Assets ===
        
        // Item Icons
        Item_Icons_Weapon,                  // Weapon icons
        Item_Icons_Armor,                   // Armor icons
        Item_Icons_Accessory,               // Accessory icons
        Item_Icons_Consumable,              // Consumable item icons
        Item_Icons_Quest,                   // Quest item icons
        
        // === Effect Assets ===
        
        // Visual Effects
        Effect_Skill_Animations,            // Skill effect animations
        Effect_Damage_Numbers,              // Damage number graphics
        Effect_Status_Icons,                // Status effect icons
        
        // === Misc Assets ===
        
        // Character Creation
        Etc_CharCreation_Hair_Options,      // Available hair styles
        Etc_CharCreation_Face_Options,      // Available face options
        Etc_CharCreation_Class_Info,        // Character class information
        
        // Job Data
        Etc_Job_Icons,                      // Job class icons
        Etc_Job_Descriptions,               // Job descriptions
        
        // Count for iteration purposes
        ASSET_COUNT
    };
}

================
File: Util/HardwareInfo.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Configuration.h"

#include <Windows.h>
#include <IPHlpApi.h>

namespace ms
{
	class HardwareInfo
	{
	public:
		HardwareInfo()
		{
			size_t size = 18;

			// Hard Drive VolumeSerialNumber
			char* volumeSerialNumber = (char*)malloc(size);

			TCHAR szVolume[MAX_PATH + 1];
			TCHAR szFileSystem[MAX_PATH + 1];

			DWORD dwSerialNumber, dwMaxLen, dwSystemFlags;

			TCHAR szDrives[MAX_PATH + 1];
			DWORD dwLen = GetLogicalDriveStrings(MAX_PATH, szDrives);
			TCHAR* pLetter = szDrives;

			BOOL bSuccess;

			bSuccess = GetVolumeInformation(pLetter, szVolume, MAX_PATH, &dwSerialNumber, &dwMaxLen, &dwSystemFlags, szFileSystem, MAX_PATH);

			if (bSuccess)
			{
				sprintf_s(volumeSerialNumber, size, "%X%X", HIWORD(dwSerialNumber), LOWORD(dwSerialNumber));
			}
			else
			{
				printf("Cannot retrieve Volume information for %s\n", pLetter);
				free(volumeSerialNumber);
				return;
			}

			// HWID/MACS
			PIP_ADAPTER_INFO AdapterInfo;
			DWORD dwBufLen = sizeof(IP_ADAPTER_INFO);
			char* hwid = (char*)malloc(size);
			char* macs = (char*)malloc(size);

			AdapterInfo = (IP_ADAPTER_INFO*)malloc(sizeof(IP_ADAPTER_INFO));

			if (AdapterInfo == NULL)
			{
				printf("Error allocating memory needed to call GetAdaptersinfo\n");
				free(volumeSerialNumber);
				free(hwid);
				free(macs);
				return;
			}

			// Make an initial call to GetAdaptersInfo to get the necessary size into the dwBufLen variable
			if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW)
			{
				free(AdapterInfo);
				AdapterInfo = (IP_ADAPTER_INFO*)malloc(dwBufLen);

				if (AdapterInfo == NULL)
				{
					printf("Error allocating memory needed to call GetAdaptersinfo\n");
					free(volumeSerialNumber);
					free(hwid);
					free(macs);
					return;
				}
			}

			if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR)
			{
				// Contains pointer to current adapter info
				PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo;

				// Technically should look at pAdapterInfo->AddressLength and not assume it is 6
				sprintf_s(hwid, size, "%02X%02X%02X%02X%02X%02X",
					pAdapterInfo->Address[0], pAdapterInfo->Address[1],
					pAdapterInfo->Address[2], pAdapterInfo->Address[3],
					pAdapterInfo->Address[4], pAdapterInfo->Address[5]);

				Configuration::get().set_hwid(hwid, volumeSerialNumber);

				pAdapterInfo = pAdapterInfo->Next;

				if (pAdapterInfo)
				{
					// Technically should look at pAdapterInfo->AddressLength and not assume it is 6
					sprintf_s(macs, size, "%02X-%02X-%02X-%02X-%02X-%02X",
						pAdapterInfo->Address[0], pAdapterInfo->Address[1],
						pAdapterInfo->Address[2], pAdapterInfo->Address[3],
						pAdapterInfo->Address[4], pAdapterInfo->Address[5]);

					Configuration::get().set_macs(macs);
				}
			}

			free(AdapterInfo);
			free(volumeSerialNumber);
			free(hwid);
			free(macs);
		}
	};
}

================
File: Util/Lerp.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

namespace ms
{
	template <typename T>
	constexpr T lerp(T first, T second, float alpha)
	{
		return alpha <= 0.0f ? first
			: alpha >= 1.0f ? second
			: first == second ? first
			: static_cast<T>((1.0f - alpha) * first + alpha * second);
	}
}

================
File: Util/Misc.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

#include <locale>
#include <sstream>

namespace ms
{
	namespace string_format
	{
		void split_number(std::string& input)
		{
			for (size_t i = input.size(); i > 3; i -= 3)
				input.insert(i - 3, 1, ',');
		}

		std::string extend_id(int32_t id, size_t length)
		{
			return pad_string(std::to_string(id), length);
		}

		std::string pad_string(std::string str, size_t length)
		{
			if (str.size() < length)
				str.insert(0, length - str.size(), '0');

			return str;
		}

		void format_with_ellipsis(Text& input, int16_t width, uint16_t ellipsis_width, bool word_break)
		{
			if (input.get_text().empty() || width == 0 || input.width() <= width)
				return;

			uint16_t i = 0;
			std::string ellipsis;
			std::string text = input.get_text();

			while (i < ellipsis_width)
			{
				ellipsis += ".";
				i++;
			}

			while (input.width() > width)
			{
				if (word_break)
				{
					size_t space = text.find_last_of(' ');

					if (space != std::string::npos)
						text = text.substr(0, space + 1);

					if (text.back() == ' ')
						text.pop_back();
				}
				else
				{
					text.pop_back();
				}

				input.change_text(text + ' ' + ellipsis);
			}
		}

		std::string tolower(std::string str)
		{
			std::locale loc;
			std::stringstream ss;

			for (std::string::size_type i = 0; i < str.length(); ++i)
				ss << std::tolower(str[i], loc);

			return ss.str();
		}
	}

	namespace bytecode
	{
		bool compare(int32_t mask, int32_t value)
		{
			return (mask & value) != 0;
		}
	}

	namespace NxHelper
	{
		namespace Map
		{
			// TODO: nl::nx::String["Map.img"]["victoria"][160070000] is returning invalid data, yet the WZ file is fine.
			MapInfo get_map_info_by_id(int32_t mapid)
			{
				std::string map_category = get_map_category(mapid);
				nl::node map_info = nl::nx::String["Map.img"][map_category][mapid];

				return {
					map_info["mapDesc"],
					map_info["mapName"],
					map_info["streetName"],
					map_info["streetName"] + " : " + map_info["mapName"]
				};
			}

			std::string get_map_category(int32_t mapid)
			{
				if (mapid < 100000000)
					return "maple";

				if (mapid < 200000000)
					return "victoria";

				if (mapid < 300000000)
					return "ossyria";

				if (mapid < 540000000)
					return "elin";

				if (mapid < 600000000)
					return "singapore";

				if (mapid < 670000000)
					return "MasteriaGL";

				if (mapid < 682000000)
				{
					int32_t prefix3 = (mapid / 1000000) * 1000000;
					int32_t prefix4 = (mapid / 100000) * 100000;

					if (prefix3 == 674000000 || prefix4 == 680100000 || prefix4 == 889100000)
						return "etc";

					if (prefix3 == 677000000)
						return "Episode1GL";

					return "weddingGL";
				}

				if (mapid < 683000000)
					return "HalloweenGL";

				if (mapid < 800000000)
					return "event";

				if (mapid < 900000000)
					return "jp";

				return "etc";
			}

			std::unordered_map<int64_t, std::pair<std::string, std::string>> get_life_on_map(int32_t mapid)
			{
				std::unordered_map<int64_t, std::pair<std::string, std::string>> map_life;

				nl::node portal = get_map_node_name(mapid);

				for (nl::node life : portal["life"])
				{
					int64_t life_id = life["id"];
					std::string life_type = life["type"];
					uint8_t hide_life = life["hide"];

					if (!hide_life)
					{
						if (life_type == "m")
						{
							// Mob
							nl::node life_name = nl::nx::String["Mob.img"][life_id]["name"];

							std::string life_id_str = string_format::extend_id(life_id, 7);
							nl::node life_level = nl::nx::Mob[life_id_str + ".img"]["info"]["level"];

							if (life_name && life_level)
								map_life[life_id] = { life_type, life_name + "(Lv. " + life_level + ")" };
						}
						else if (life_type == "n")
						{
							// NPC
							if (nl::node life_name = nl::nx::String["Npc.img"][life_id]["name"])
								map_life[life_id] = { life_type, life_name };
						}
					}
				}

				return map_life;
			}

			nl::node get_map_node_name(int32_t mapid)
			{
				std::string prefix = std::to_string(mapid / 100000000);
				std::string mapid_str = string_format::extend_id(mapid, 9);

				// Try Map002 fallback, then direct Map (v83)
				nl::node map_node = nl::nx::Map002["Map"]["Map" + prefix][mapid_str + ".img"];
				if (map_node.name().empty()) {
					map_node = nl::nx::Map["Map"]["Map" + prefix][mapid_str + ".img"];
				}
				return map_node;
			}
		}
	}

	namespace single_console
	{
		void log_message(std::string message)
		{
			if (std::find(std::begin(log_history), std::end(log_history), message) == std::end(log_history))
			{
				log_history.push_back(message);

				LOG(LOG_DEBUG, message);
			}
		}
	}
}

================
File: Util/Misc.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Graphics/Text.h"

#include <iostream>
#include <unordered_map>

// Graphics Debug System
#define GRAPHICS_DEBUG 1
#if GRAPHICS_DEBUG
#define GDEBUG(msg) std::cout << "[GFX] " << msg << std::endl
#else
#define GDEBUG(msg)
#endif

namespace ms
{
	namespace string_conversion
	{
		template<typename T>
		inline T or_default(const std::string& str, T def)
		{
			try
			{
				int32_t intval = std::stoi(str);
				return static_cast<T>(intval);
			}
			catch (const std::exception& ex)
			{
				LOG(LOG_ERROR, __func__ << ": " << ex.what());

				return def;
			}
		}

		template<typename T>
		inline T or_zero(const std::string& str)
		{
			return or_default<T>(str, T(0));
		}
	};

	namespace string_format
	{
		// Format a number string so that each three decimal points are separated by a comma
		void split_number(std::string& input);

		// Prefix an id with zeros so that it has the minimum specified length
		std::string extend_id(int32_t id, size_t length);

		// Pad a string with leading zeros to a specified length
		std::string pad_string(std::string str, size_t length);

		// Cut off a string at a specified width with an ellipsis
		void format_with_ellipsis(Text& input, int16_t width, uint16_t ellipsis_width = 2U, bool word_break = false);

		// Convert a string to lowercase letters
		std::string tolower(std::string str);
	};

	namespace bytecode
	{
		// Check if a bit mask contains the specified value
		bool compare(int32_t mask, int32_t value);
	}

	namespace NxHelper
	{
		namespace Map
		{
			struct MapInfo
			{
				std::string description;
				std::string name;
				std::string street_name;
				std::string full_name;
			};

			// Returns all relative map info
			MapInfo get_map_info_by_id(int32_t mapid);

			// Returns the category of a map
			std::string get_map_category(int32_t mapid);

			// Returns a list of all life on a map (Mobs and NPCs)
			std::unordered_map<int64_t, std::pair<std::string, std::string>> get_life_on_map(int32_t mapid);

			// Returns the name of the node, under which the argument map id is in
			nl::node get_map_node_name(int32_t mapid);
		}
	}

	namespace single_console
	{
		void log_message(std::string message);

		static std::list<std::string> log_history;
	}
}

================
File: Util/NxFiles.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "NxFiles.h"
#include "AssetRegistry.h"
#include <iostream>
#include <fstream>

#ifdef USE_NX
#include <fstream>
#include <cstring>

#include <nlnx/node.hpp>
#include <nlnx/nx.hpp>
#include <nlnx/file.hpp>

namespace ms
{
	namespace NxFiles
	{
		Error init()
		{
			// Check for required files, but be more flexible with optional v87-missing files
			constexpr std::array<const char*, 8> required_files = {
				"Base.nx", "Character.nx", "Effect.nx", "Etc.nx",
				"Item.nx", "Map.nx", "UI.nx", "String.nx"
			};

			// Check required files
			for (auto filename : required_files)
				if (std::ifstream{ filename }.good() == false)
					return Error(Error::Code::MISSING_FILE, filename);

			// Check optional files and log warnings for missing ones
			for (auto filename : filenames)
			{
				if (std::ifstream{ filename }.good() == false)
				{
					// Skip if it's a required file (already checked above)
					bool is_required = false;
					for (auto required : required_files)
						if (std::strcmp(filename, required) == 0)
						{
							is_required = true;
							break;
						}
					if (!is_required)
					{
						// Log warning for missing optional file (would need logging system)
						// For now, continue without error
					}
				}
			}

			// Loading NX files
			try
			{
				nl::nx::load_all();
				// NX files loaded successfully
				
				// Verifying file access
				
				// Simple test to check if load_all actually loaded anything
				// Basic NX validation complete
				
				// Initialize the AssetRegistry after NX files are loaded
				// Initializing AssetRegistry
				AssetRegistry& registry = AssetRegistry::get();
				if (registry.load())
				{
					// AssetRegistry ready
				}
				else
				{
					// AssetRegistry initialization failed
				}
				
				// NX Structure exploration for debugging
				// Exploring NX structure
				
				// Check if comprehensive extraction is requested
				char* extract_all = nullptr;
				size_t len = 0;
				errno_t err = _dupenv_s(&extract_all, &len, "EXTRACT_ALL_NX");
				bool full_extraction = (err == 0 && extract_all && std::string(extract_all) == "1");
				if (extract_all) free(extract_all);
				
				// Disable extraction for testing login screen
				full_extraction = false;
				
				if (full_extraction) {
					std::cout << "[DEBUG] FULL NX EXTRACTION MODE - Creating detailed structure files..." << std::endl;
					
					// Create smart extraction function - focused and size-controlled
					auto extract_to_file = [](const nl::node& node, const std::string& nx_name, const std::string& path, int depth, std::ofstream& file, int& total_nodes) -> void {
						auto extract_recursive = [&](const nl::node& n, const std::string& p, int d, auto& self) -> void {
							// Smart depth limiting based on file type
							int max_depth = 4; // Default depth
							if (nx_name == "Map" || nx_name == "Character") max_depth = 3; // Large files
							else if (nx_name == "UI" || nx_name == "Item") max_depth = 5; // Important for asset registry
							else if (nx_name == "String") max_depth = 6; // Text data is compact
							
							if (d > max_depth) return;
							
							std::string indent(d * 2, ' ');
							std::string node_type;
							total_nodes++;
							
							// Determine node type with icons
							if (n.data_type() == nl::node::type::bitmap) node_type = "🖼️";
							else if (n.data_type() == nl::node::type::audio) node_type = "🔊";
							else if (n.data_type() == nl::node::type::string) node_type = "📝";
							else if (n.data_type() == nl::node::type::integer) node_type = "🔢";
							else if (n.data_type() == nl::node::type::real) node_type = "💯";
							else if (n.data_type() == nl::node::type::vector) node_type = "📍";
							else if (n.size() > 0) node_type = "📁";
							else node_type = "📄";
							
							file << indent << "├─ " << n.name() << " " << node_type;
							
							// Show child count for folders
							if (n.size() > 0) {
								file << " (" << n.size() << " items)";
							}
							
							// Add preview data for important leaf nodes
							if (n.size() == 0 && d <= 3) {
								try {
									if (n.data_type() == nl::node::type::string) {
										std::string str_val = n.get_string();
										if (str_val.length() < 30) {
											file << " = \"" << str_val << "\"";
										} else {
											file << " = \"" << str_val.substr(0, 27) << "...\"";
										}
									} else if (n.data_type() == nl::node::type::integer) {
										file << " = " << n.get_integer();
									} else if (n.data_type() == nl::node::type::vector) {
										auto vec = n.get_vector();
										file << " = (" << vec.first << ", " << vec.second << ")";
									}
								} catch (...) {
									// Ignore data extraction errors
								}
							}
							
							file << std::endl;
							
							// Smart child limiting based on depth and importance
							int child_limit = 50; // Default
							if (d == 0) child_limit = 20; // Root level - show overview
							else if (d == 1) child_limit = 30; // Second level - show structure
							else if (d >= 3) child_limit = 15; // Deep levels - be selective
							
							// Special handling for important UI nodes
							bool is_important = (nx_name == "UI" && (
								n.name().find("Login") != std::string::npos ||
								n.name().find("Title") != std::string::npos ||
								n.name().find("Button") != std::string::npos ||
								n.name().find("Bt") != std::string::npos
							));
							
							if (is_important) child_limit = 100; // Show more for important UI
							
							// Explore children with smart limiting
							int child_count = 0;
							int important_count = 0;
							
							for (const auto& child : n) {
								// Always show important items
								bool child_important = (child.name().find("Bt") != std::string::npos ||
													   child.name().find("Login") != std::string::npos ||
													   child.name().find("Title") != std::string::npos ||
													   child.name().find("backgrnd") != std::string::npos ||
													   child.name().find("frame") != std::string::npos);
								
								if (child_important) {
									important_count++;
									self(child, p + "/" + n.name(), d + 1, self);
								} else if (child_count < child_limit) {
									child_count++;
									self(child, p + "/" + n.name(), d + 1, self);
								} else if (child_count == child_limit) {
									file << indent << "  └─ ... (" << (n.size() - child_count - important_count) << " more items)" << std::endl;
									break;
								}
							}
						};
						
						extract_recursive(node, path, depth, extract_recursive);
					};
					
					// Create output directory
					system("mkdir nx_structures 2>nul");
					
					// Extract all major NX files
					std::vector<std::pair<std::string, const nl::node*>> nx_files = {
						{"UI", &nl::nx::UI},
						{"Map", &nl::nx::Map},
						{"Character", &nl::nx::Character},
						{"Item", &nl::nx::Item},
						{"Skill", &nl::nx::Skill},
						{"Effect", &nl::nx::Effect},
						{"Sound", &nl::nx::Sound},
						{"String", &nl::nx::String},
						{"Etc", &nl::nx::Etc},
						{"Base", &nl::nx::Base},
						{"Mob", &nl::nx::Mob},
						{"Npc", &nl::nx::Npc},
						{"Quest", &nl::nx::Quest},
						{"Reactor", &nl::nx::Reactor}
					};
					
					// Check for split files
					if (!nl::nx::Map001.name().empty()) {
						nx_files.push_back({"Map001", &nl::nx::Map001});
					}
					if (!nl::nx::Map002.name().empty()) {
						nx_files.push_back({"Map002", &nl::nx::Map002});
					}
					if (!nl::nx::Sound2.name().empty()) {
						nx_files.push_back({"Sound2", &nl::nx::Sound2});
					}
					
					// Extract each file
					for (const auto& nx_pair : nx_files) {
						const std::string& name = nx_pair.first;
						const nl::node& nx_node = *nx_pair.second;
						
						if (nx_node.size() == 0) {
							std::cout << "[DEBUG] Skipping " << name << " (empty/not loaded)" << std::endl;
							continue;
						}
						
						std::string filename = "nx_structures/" + name + "_current.txt";
						std::ofstream file(filename);
						
						if (!file.is_open()) {
							std::cout << "[DEBUG] Failed to create " << filename << std::endl;
							continue;
						}
						
						file << "🗂️ NX STRUCTURE ANALYSIS: " << name << ".nx" << std::endl;
						file << "📅 Generated: Current HeavenMS v83 Client Session" << std::endl;
						file << "🎯 Purpose: AssetRegistry Development & Asset Management" << std::endl;
						file << "================================================================================" << std::endl;
						file << "📊 Overview:" << std::endl;
						file << "   📦 Root children: " << nx_node.size() << std::endl;
						file << "   🏗️ Structure optimized for manageable file size" << std::endl;
						file << "   ⭐ Important assets prioritized (Login, UI, Buttons)" << std::endl;
						file << std::endl;
						
						int total_nodes = 0;
						extract_to_file(nx_node, name, name, 0, file, total_nodes);
						
						file << std::endl;
						file << "================================================================================" << std::endl;
						file << "Total nodes: " << total_nodes << std::endl;
						file << "================================================================================" << std::endl;
						
						file.close();
						std::cout << "[DEBUG] Extracted " << name << " (" << total_nodes << " nodes) -> " << filename << std::endl;
					}
					
					// Create enhanced summary file
					std::ofstream summary("nx_structures/📋_NX_CURRENT_SUMMARY.txt");
					summary << "🎮 HEAVENMS CLIENT - CURRENT NX STRUCTURE ANALYSIS" << std::endl;
					summary << "📅 Generated from live v83 nx files" << std::endl;
					summary << "🎯 Optimized for AssetRegistry development" << std::endl;
					summary << "================================================================================" << std::endl;
					summary << std::endl;
					
					summary << "📁 AVAILABLE NX FILES:" << std::endl;
					int total_available = 0;
					for (const auto& nx_pair : nx_files) {
						const nl::node& node = *nx_pair.second;
						if (node.size() > 0) {
							summary << "  ✅ " << nx_pair.first << "_current.txt - " << node.size() << " root items" << std::endl;
							total_available++;
						} else {
							summary << "  ❌ " << nx_pair.first << ".nx - NOT LOADED" << std::endl;
						}
					}
					
					summary << std::endl;
					summary << "🎯 KEY ASSETREGISTRY MAPPINGS:" << std::endl;
					summary << "  🔐 Login Buttons: UI.nx/Login.img/Title/Bt*" << std::endl;
					summary << "  🖼️ Login Background: UI.nx/Login.img/Notice/Loading/backgrnd" << std::endl;
					summary << "  👤 Character Select: UI.nx/Login.img/CharSelect/*" << std::endl;
					summary << "  🌍 World Select: UI.nx/Login.img/WorldSelect/*" << std::endl;
					summary << "  🗺️ Map Backgrounds: Map.nx/Back/*" << std::endl;
					summary << "  💰 Items: Item.nx/*" << std::endl;
					summary << "  👥 Characters: Character.nx/*" << std::endl;
					summary << "  ✨ Effects: Effect.nx/*" << std::endl;
					summary << std::endl;
					
					summary << "📋 STRUCTURE NOTES:" << std::endl;
					summary << "  📦 Architecture: v83 consolidated format" << std::endl;
					summary << "  🚫 No split files: Map001.nx/Map002.nx not used" << std::endl;
					summary << "  🏗️ UI consolidation: All login assets in UI.nx" << std::endl;
					summary << "  🎨 Button hierarchy: Title/* (not Title_new/*)" << std::endl;
					summary << "  📏 File sizes: Optimized for readability" << std::endl;
					summary << "  ⭐ Priority: Important assets (Login/UI/Buttons) emphasized" << std::endl;
					summary << std::endl;
					
					summary << "💡 USAGE TIPS:" << std::endl;
					summary << "  1. Each *_current.txt shows manageable subset of nx file" << std::endl;
					summary << "  2. Important assets (Login, Buttons) always included" << std::endl;
					summary << "  3. Use for AssetRegistry path development" << std::endl;
					summary << "  4. Icons show data types: 🖼️=bitmap 📁=folder 📝=string etc." << std::endl;
					summary << std::endl;
					
					summary << "📊 STATISTICS:" << std::endl;
					summary << "  🗂️ NX files documented: " << total_available << std::endl;
					summary << "  📅 Session: Current live extraction" << std::endl;
					
					summary.close();
					
					std::cout << "[DEBUG] === COMPLETE NX EXTRACTION FINISHED ===" << std::endl;
					std::cout << "[DEBUG] All structures saved to nx_structures/ directory" << std::endl;
					std::cout << "[DEBUG] Check COMPLETE_NX_SUMMARY.txt for overview" << std::endl;
				}
				
				// Helper lambda to explore nodes recursively (for console output)
				auto explore_node = [](const nl::node& node, const std::string& path, int depth, auto& self) -> void {
					if (depth > 3) return; // Limit depth to avoid spam
					
					std::string indent(depth * 2, ' ');
					std::cout << indent << "- " << node.name();
					if (node.size() > 0) {
						std::cout << " (" << node.size() << " children)";
					}
					std::cout << std::endl;
					
					// Show key children only
					int shown = 0;
					for (const auto& child : node) {
						if (shown++ >= 8 && depth > 0) break; // Limit output
						self(child, path + "/" + node.name(), depth + 1, self);
					}
				};
				
				// NX structure exploration complete
			}
			catch (const std::exception& ex)
			{
				static const std::string message = ex.what();

				return Error(Error::Code::NLNX, message.c_str());
			}

			// Removed strict UI version check for v87 compatibility
			// The previous check for "Login.img/WorldSelect/BtChannel/layer:bg"
			// would fail on v87 data which uses different UI structure
			
			return Error::Code::NONE;
		}
	}
}
#endif

================
File: Util/NxFiles.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../MapleStory.h"

#ifdef USE_NX
// NoLifeNx is now compiled from source, no need for pragma comment

#include "../Error.h"

#include <array>

namespace ms
{
	namespace NxFiles
	{
		// Number of needed files (v83 consolidated files only)
		constexpr uint8_t NUM_FILES = 18;

		// Names of the needed game files (v83 consolidated versions)
		constexpr std::array<const char*, NUM_FILES> filenames =
		{
			"Base.nx",
			"Character.nx",
			"Effect.nx",
			"Etc.nx",
			"Item.nx",
			"Map.nx",
			//"Map001.nx",    // v83: consolidated in Map.nx
			//"Map002.nx",    // v83: consolidated in Map.nx  
			"Map2.nx",
			"Mob.nx",
			//"Mob001.nx",    // v83: consolidated in Mob.nx
			//"Mob002.nx",    // v83: consolidated in Mob.nx
			//"Mob2.nx",      // v83: consolidated in Mob.nx
			"Morph.nx",
			"Npc.nx",
			"Quest.nx",
			"Reactor.nx",
			"Skill.nx",
			//"Skill001.nx",  // v83: consolidated in Skill.nx
			//"Skill002.nx",  // v83: consolidated in Skill.nx
			//"Skill003.nx",  // v83: consolidated in Skill.nx
			"Sound.nx",
			//"Sound001.nx",  // v83: consolidated in Sound.nx
			//"Sound002.nx",  // v83: consolidated in Sound.nx or Sound2.nx
			"Sound2.nx",
			"String.nx",
			"TamingMob.nx",
			"UI.nx"
			//"UI_000.nx"     // v83: not present
		};

		// Initialize NX
		// When successful test if the UI file is the correct version
		Error init();
	};
}
#endif

================
File: Util/QuadTree.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <functional>
#include <vector>
#include <unordered_map>

namespace ms
{
	template<typename K, typename V>
	class QuadTree
	{
	public:
		enum Direction
		{
			LEFT, RIGHT, UP, DOWN
		};

		QuadTree(std::function<Direction(const V&, const V&)> c)
		{
			root = 0;
			comparator = c;
		}

		QuadTree() : QuadTree(nullptr) {}

		void clear()
		{
			nodes.clear();

			root = 0;
		}

		void add(K key, V value)
		{
			K parent = 0;

			if (root)
			{
				K current = root;

				while (current)
				{
					parent = current;
					current = nodes[parent].addornext(key, value, comparator);
				}
			}
			else
			{
				root = key;
			}

			nodes.emplace(
				std::piecewise_construct,
				std::forward_as_tuple(key),
				std::forward_as_tuple(value, parent, 0, 0, 0, 0)
			);
		}

		void erase(K key)
		{
			if (!nodes.count(key))
				return;

			Node& toerase = nodes[key];

			std::vector<K> leaves;

			for (size_t i = LEFT; i <= DOWN; i++)
			{
				K leafkey = toerase[i];

				if (leafkey)
					leaves.push_back(leafkey);
			}

			K parent = toerase.parent;

			if (root == key)
				root = 0;
			else if (nodes.count(parent))
				nodes[parent].erase(key);

			nodes.erase(key);

			for (auto& leaf : leaves)
				readd(parent, leaf);
		}

		K findnode(const V& value, std::function<bool(const V&, const V&)> predicate)
		{
			if (root)
			{
				K key = findfrom(root, value, predicate);

				return predicate(value, nodes[key].value) ? key : 0;
			}
			else
			{
				return 0;
			}
		}

		V& operator [](K key)
		{
			return nodes[key].value;
		}

		const V& operator [](K key) const
		{
			return nodes.at(key).value;
		}

	private:
		K findfrom(K start, const V& value, std::function<bool(const V&, const V&)> predicate)
		{
			if (!start)
				return 0;

			bool fulfilled = predicate(value, nodes[start].value);
			Direction dir = comparator(value, nodes[start].value);

			if (dir == RIGHT)
			{
				K right = findfrom(nodes[start].right, value, predicate);

				if (right && predicate(value, nodes[right].value))
					return right;
				else
					return start;
			}
			else if (dir == DOWN)
			{
				K bottom = findfrom(nodes[start].bottom, value, predicate);

				if (bottom && predicate(value, nodes[bottom].value))
				{
					return bottom;
				}
				else if (fulfilled)
				{
					return start;
				}
				else
				{
					K right = findfrom(nodes[start].right, value, predicate);

					if (right && predicate(value, nodes[right].value))
						return right;
					else
						return start;
				}
			}
			else if (dir == UP)
			{
				K top = findfrom(nodes[start].top, value, predicate);

				if (top && predicate(value, nodes[top].value))
				{
					return top;
				}
				else if (fulfilled)
				{
					return start;
				}
				else
				{
					K right = findfrom(nodes[start].right, value, predicate);

					if (right && predicate(value, nodes[right].value))
						return right;
					else
						return start;
				}
			}
			else
			{
				K left = findfrom(nodes[start].left, value, predicate);

				if (left && predicate(value, nodes[left].value))
					return left;
				else if (fulfilled)
					return start;

				K bottom = findfrom(nodes[start].bottom, value, predicate);

				if (bottom && predicate(value, nodes[bottom].value))
					return bottom;
				else if (fulfilled)
					return start;

				K top = findfrom(nodes[start].top, value, predicate);

				if (top && predicate(value, nodes[top].value))
					return top;
				else if (fulfilled)
					return start;

				K right = findfrom(nodes[start].right, value, predicate);

				if (right && predicate(value, nodes[right].value))
					return right;
				else
					return start;
			}
		}

		void readd(K start, K key)
		{
			if (start)
			{
				K parent = 0;
				K current = start;

				while (current)
				{
					parent = current;
					current = nodes[parent].addornext(key, nodes[key].value, comparator);
				}

				nodes[key].parent = parent;
			}
			else if (start == root)
			{
				root = key;

				nodes[key].parent = 0;
			}
			else if (root)
			{
				readd(root, key);
			}
		}

		struct Node
		{
			V value;
			K parent;
			K left;
			K right;
			K top;
			K bottom;

			Node(const V& v, K p, K l, K r, K t, K b) : value(v), parent(p), left(l), right(r), top(t), bottom(b) {}
			Node() : Node(V(), 0, 0, 0, 0, 0) {}

			void erase(K key)
			{
				if (left == key)
					left = 0;
				else if (right == key)
					right = 0;
				else if (top == key)
					top = 0;
				else if (bottom == key)
					bottom = 0;
			}

			K addornext(K key, V val, std::function<Direction(const V&, const V&)> comparator)
			{
				Direction dir = comparator(val, value);
				K dirkey = leaf(dir);

				if (!dirkey)
				{
					switch (dir)
					{
					case LEFT:
						left = key;
						break;
					case RIGHT:
						right = key;
						break;
					case UP:
						top = key;
						break;
					case DOWN:
						bottom = key;
						break;
					}
				}

				return dirkey;
			}

			K leaf(Direction dir)
			{
				switch (dir)
				{
				case LEFT:
					return left;
				case RIGHT:
					return right;
				case UP:
					return top;
				case DOWN:
					return bottom;
				default:
					return 0;
				}
			}

			K operator [](size_t d)
			{
				auto dir = static_cast<Direction>(d);

				return leaf(dir);
			}
		};

		std::function<Direction(const V&, const V&)> comparator;
		std::unordered_map<K, Node> nodes;
		K root;
	};
}

================
File: Util/Randomizer.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cstdint>
#include <random>

namespace ms
{
	// Can be used to generate random numbers.
	class Randomizer
	{
	public:
		bool next_bool() const
		{
			return next_int(2) == 1;
		}

		bool below(float percent) const
		{
			return next_real(1.0f) < percent;
		}

		bool above(float percent) const
		{
			return next_real(1.0f) > percent;
		}

		template <class T>
		T next_real(T to) const
		{
			return next_real<T>(0, to);
		}

		template <class T>
		T next_real(T from, T to) const
		{
			if (from >= to)
				return from;

			std::uniform_real_distribution<T> range(from, to);
			std::random_device rd;
			std::default_random_engine engine{ rd() };

			return range(engine);
		}

		template <class T>
		T next_int(T to) const
		{
			return next_int<T>(0, to);
		}

		template <class T>
		T next_int(T from, T to) const
		{
			if (from >= to)
				return from;

			std::uniform_int_distribution<T> range(from, to - 1);
			std::random_device rd;
			std::default_random_engine engine{ rd() };

			return range(engine);
		}

		template <class E>
		E next_enum(E to = E::LENGTH) const
		{
			return next_enum(E(), to);
		}

		template <class E>
		E next_enum(E from, E to) const
		{
			auto next_underlying = next_int<std::underlying_type<E>::type>(from, to);

			return static_cast<E>(next_underlying);
		}
	};
}

================
File: Util/ScreenResolution.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Configuration.h"

#include <windef.h>
#include <WinUser.h>

namespace ms
{
	class ScreenResolution
	{
	public:
		ScreenResolution()
		{
			RECT desktop;

			// Get a handle to the desktop window
			const HWND hDesktop = GetDesktopWindow();

			// Get the size of screen to the variable desktop
			GetWindowRect(hDesktop, &desktop);

			// The top left corner will have coordinates (0, 0) and the bottom right corner will have coordinates (horizontal, vertical)
			Configuration::get().set_max_width(desktop.right);
			Configuration::get().set_max_height(desktop.bottom);

			// Get the state of the Caps Lock key
			int nVirtKey = GetKeyState(20);

			Configuration::get().set_caps_lock_enabled(nVirtKey);
		}
	};
}

================
File: Util/TimedBool.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../Constants.h"

#include <cstdint>

namespace ms
{
	class TimedBool
	{
	public:
		TimedBool()
		{
			value = false;
			delay = 0;
			last = 0;
		}

		explicit operator bool() const
		{
			return value;
		}

		void set_for(int64_t millis)
		{
			last = millis;
			delay = millis;
			value = true;
		}

		void update()
		{
			update(Constants::TIMESTEP);
		}

		void update(uint16_t timestep)
		{
			if (value)
			{
				if (timestep >= delay)
				{
					value = false;
					delay = 0;
				}
				else
				{
					delay -= timestep;
				}
			}
		}

		void operator = (bool b)
		{
			value = b;
			delay = 0;
			last = 0;
		}

		bool operator == (bool b) const
		{
			return value == b;
		}

		bool operator != (bool b) const
		{
			return value != b;
		}

		float alpha() const
		{
			return 1.0f - static_cast<float>(static_cast<float>(delay) / last);
		}

	private:
		int64_t last;
		int64_t delay;
		bool value;
	};
}

================
File: Util/UINodes.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UINodes.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>

namespace ms
{
	namespace UINodes
	{
		nl::node get_ui_node(const std::string& path)
		{
			// Try UI.nx first (base file)
			nl::node result = nl::nx::UI.resolve(path);
			if (result.data_type() != nl::node::type::none)
				return result;
			
			// Fallback to UI_000.nx (chunk file with actual data)
			result = nl::nx::UI_000.resolve(path);
			return result;
		}
		
		nl::node get_ui_img(const std::string& img_name)
		{
			std::string full_path = img_name;
			if (full_path.find(".img") == std::string::npos)
				full_path += ".img";
			
			return get_ui_node(full_path);
		}
		
		// Helper function for operator[] style access with fallback
		nl::node get_ui_child(const std::string& parent_path, const std::string& child_name)
		{
			// Try UI.nx first
			nl::node parent = nl::nx::UI.resolve(parent_path);
			if (parent.data_type() != nl::node::type::none)
			{
				nl::node child = parent[child_name];
				if (child.data_type() != nl::node::type::none)
					return child;
			}
			
			// Fallback to UI_000.nx
			parent = nl::nx::UI_000.resolve(parent_path);
			if (parent.data_type() != nl::node::type::none)
				return parent[child_name];
			
			return nl::node();
		}
	}
}
#endif

================
File: Util/UINodes.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../MapleStory.h"

#ifdef USE_NX
#include <nlnx/node.hpp>

namespace ms
{
	namespace UINodes
	{
		// Unified access to UI nodes from split archives
		// This function checks UI.nx first, then UI_000.nx as fallback
		// This handles modern split UI archives transparently
		nl::node get_ui_node(const std::string& path);
		
		// Helper for common UI access patterns
		nl::node get_ui_img(const std::string& img_name);
		
		// Resolve UI nodes with fallback to UI_000
		template<typename... Args>
		nl::node resolve_ui(Args&&... args);
	}
}
#endif

================
File: Util/WzFiles.cpp
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "WzFiles.h"

#ifndef USE_NX
#include <fstream>

namespace ms
{
	namespace WzFiles
	{
		Error init()
		{
			for (auto filename : filenames)
				if (std::ifstream{ filename }.good() == false)
					return Error(Error::Code::MISSING_FILE, filename);

			try
			{
				//nl::nx::load_all();
			}
			catch (const std::exception& ex)
			{
				static const std::string message = ex.what();

				return Error(Error::Code::WZ, message.c_str());
			}

			//constexpr const char* POSTCHAOS_BITMAP = "Login.img/WorldSelect/BtChannel/layer:bg";
			//
			//if (nl::nx::ui.resolve(POSTCHAOS_BITMAP).data_type() != nl::node::type::bitmap)
			//	return Error::Code::WRONG_UI_FILE;

			return Error::Code::NONE;
		}
	}
}
#endif

================
File: Util/WzFiles.h
================
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../MapleStory.h"

#ifndef USE_NX
#pragma comment(lib, "WzLib")

#include "../Error.h"

#include <array>
#include <string>

namespace ms
{
	namespace WzFiles
	{
		// Number of needed files
		constexpr uint8_t NUM_FILES = 28;

		// Names of the needed game files
		constexpr std::array<const char*, NUM_FILES> filenames =
		{
			"Base.wz",
			"Character.wz",
			"Effect.wz",
			"Etc.wz",
			"Item.wz",
			"Map.wz",
			"Map001.wz",
			"Map002.wz",
			"Map2.wz",
			"Mob.wz",
			"Mob001.wz",
			"Mob002.wz",
			"Mob2.wz",
			"Morph.wz",
			"Npc.wz",
			"Quest.wz",
			"Reactor.wz",
			"Skill.wz",
			"Skill001.wz",
			"Skill002.wz",
			"Skill003.wz",
			"Sound.wz",
			"Sound001.wz",
			"Sound002.wz",
			"Sound2.wz",
			"String.wz",
			"TamingMob.wz",
			"UI.wz"
		};

		// Initialize WZ
		// When successful test if the UI file is the correct version
		Error init();
	};
}

// TODO: Remove below once WZ is implemented and has these functions
namespace nl
{
	class bitmap
	{
	public:
		bitmap() = default;
		bitmap(bitmap const&) = default;

		void const* data() const { return 0; }
		uint16_t width() const { return 0; }
		uint16_t height() const { return 0; }
		size_t id() const { return 0; }
	};

	class audio
	{
	public:
		audio() = default;
		audio(audio const&) = default;

		void const* data() const { return 0; }
		uint32_t length() const { return 0; }
		size_t id() const { return 0; }
	};

	struct _file_data;
	typedef std::pair<int32_t, int32_t> vector2i;
	class node
	{
	public:
		using difference_type = ptrdiff_t;
		using value_type = node;
		using pointer = node;
		using reference = node&;
		using iterator_category = std::random_access_iterator_tag;
		struct data;
		enum class type : uint16_t {
			none = 0,
			integer = 1,
			real = 2,
			string = 3,
			vector = 4,
			bitmap = 5,
			audio = 6,
		};
		node() = default;
		node(node const&) {}
		node& operator=(node const&) = default;
		node begin() const { return node(); }
		node end() const { return node(); }
		node operator*() const { return node(); }
		node& operator++() { return *new node(); }
		node operator++(int) { return node(); }
		bool operator==(node const&) const { return false; }
		bool operator!=(node const&) const { return false; }
		bool operator<(node const&) const { return false; }
		explicit operator bool() const { return false; }
		node operator[](unsigned int) const { return node(); }
		node operator[](signed int) const { return node(); }
		node operator[](unsigned long) const { return node(); }
		node operator[](signed long) const { return node(); }
		node operator[](unsigned long long) const { return node(); }
		node operator[](signed long long) const { return node(); }
		node operator[](std::string const&) const { return node(); }
		node operator[](char const*) const { return node(); }
		node operator[](node const&) const { return node(); }
		operator unsigned char() const { return '0'; }
		operator signed char() const { return '0'; }
		operator unsigned short() const { return 0; }
		operator signed short() const { return 0; }
		operator unsigned int() const { return 0; }
		operator signed int() const { return 0; }
		operator unsigned long() const { return 0; }
		operator signed long() const { return 0; }
		operator unsigned long long() const { return 0; }
		operator signed long long() const { return 0; }
		operator float() const { return 0; }
		operator double() const { return 0; }
		operator long double() const { return 0; }
		operator std::string() const { return ""; }
		operator vector2i() const { return vector2i(); }
		operator bitmap() const { return bitmap(); }
		operator audio() const { return audio(); }
		int64_t get_integer(int64_t = 0) const { return 0; }
		double get_real(double = 0) const { return 0; }
		std::string get_string(std::string = "") const { return ""; }
		vector2i get_vector(vector2i = { 0, 0 }) const { return vector2i(); }
		bitmap get_bitmap() const { return bitmap(); }
		audio get_audio() const { return audio(); }
		bool get_bool() const { return false; }
		bool get_bool(bool) const { return false; }
		int32_t x() const { return 0; }
		int32_t y() const { return 0; }
		std::string name() const { return ""; }
		size_t size() const { return 0; }
		type data_type() const { return type::none; }
		node root() const { return node(); }
		node resolve(std::string) const { return node(); }

	private:
		node(data const*, _file_data const*) {}
		node get_child(char const*, uint16_t) const {}
		int64_t to_integer() const {}
		double to_real() const {}
		std::string to_string() const {}
		vector2i to_vector() const {}
		bitmap to_bitmap() const {}
		audio to_audio() const {}
		data const* m_data = nullptr;
		_file_data const* m_file = nullptr;
		//friend file;
	};

	inline std::string operator+(std::string, node) { return ""; }
	inline std::string operator+(char const*, node) { return ""; }
	inline std::string operator+(node, std::string) { return ""; }
	inline std::string operator+(node, char const*) { return ""; }

	namespace wz
	{
		static nl::node Base, Character, Effect, Etc, Item, Map, Map001, Map002, Map2, Mob, Mob001, Mob2, Morph, Npc, Quest, Reactor, Skill, Skill001, Skill002, Sound, Sound001, Sound2, String, TamingMob, UI;
	}
}
#endif

================
File: V87_COMPATIBILITY_CHANGES.md
================
# HeavenClient v87 Compatibility Changes

This document summarizes the changes made to enable HeavenClient to work with original MapleStory v87 WZ files.

## Overview

The original HeavenClient was designed for modern MapleStory data (v228+) and expected specific UI structures and assets that don't exist in v87. These changes implement fallback logic and compatibility layers to handle the older data format.

## Key Changes Made

### 1. NxFiles.cpp - Removed Strict Version Checking
**File**: `/mnt/c/HeavenClient/MapleStory-Client/Util/NxFiles.cpp`

- **Removed**: Strict UI version check that looked for "Login.img/WorldSelect/BtChannel/layer:bg"
- **Added**: Flexible file loading that only requires essential files (Base.nx, Character.nx, etc.)
- **Added**: Optional file checking with warnings instead of errors for missing v87-era files

**Impact**: Client no longer crashes with "WRONG_UI_FILE" error when using v87 data.

### 2. UIWorldSelect.cpp - Major UI Compatibility Updates
**File**: `/mnt/c/HeavenClient/MapleStory-Client/IO/UITypes/UIWorldSelect.cpp`

#### World Selection Structure
- **Added**: Fallback logic for missing modern UI structure (`BtWorld.release`, `BtChannel`)
- **Added**: v87-compatible world button creation using direct indexing (world0, world1, etc.)
- **Added**: Default positioning for v87 worlds when region data is missing

#### Channel Selection 
- **Added**: Auto-entry to channel 1 when modern channel UI is missing
- **Modified**: Button creation to check for asset existence before instantiation
- **Added**: Safe drawing of textures with empty-check guards

#### Background Loading
- **Added**: Fallback from Map data to UI data for login backgrounds
- **Added**: Graceful handling of missing background assets
- **Modified**: World mapping to use v87-appropriate worlds (no Reboot)

**Impact**: World selection works with v87's simpler UI structure, automatically entering worlds without complex channel selection.

### 3. UIChatBar.cpp - Chat UI Button Safety
**File**: `/mnt/c/HeavenClient/MapleStory-Client/IO/UITypes/UIChatBar.cpp`

- **Added**: Conditional button creation for post-v87 features (itemLink, chatEmoticon)
- **Added**: Dynamic button positioning to accommodate missing buttons
- **Modified**: Button existence checks before instantiation

**Impact**: Chat UI loads successfully even when v87 data lacks modern chat features.

## v87 Compatibility Features

### Automatic Fallbacks
1. **World Selection**: If modern channel UI missing → auto-enter channel 1
2. **Background Images**: If Map data missing → try UI data → continue without background
3. **UI Buttons**: If button assets missing → skip creation, continue without feature
4. **File Loading**: If optional files missing → log warning, continue loading

### Safe Drawing
- All texture drawing now checks for empty textures before attempting to draw
- Missing UI elements are gracefully skipped rather than causing crashes
- Bounds checking added for arrays and vectors

### v87-Specific Adaptations
- World list updated to v87-era worlds (Scania, Bera, Broa, Windia, Khaini)
- Removed dependencies on Reboot world features
- Simplified region handling for single-region v87 clients

## Files Modified

1. `/mnt/c/HeavenClient/MapleStory-Client/Util/NxFiles.cpp` - File loading and version checking
2. `/mnt/c/HeavenClient/MapleStory-Client/IO/UITypes/UIWorldSelect.cpp` - World/channel selection UI
3. `/mnt/c/HeavenClient/MapleStory-Client/IO/UITypes/UIChatBar.cpp` - Chat UI buttons

## Technical Implementation

### Error Handling Strategy
- **Before**: Strict validation, crash on missing assets
- **After**: Graceful degradation, continue with available assets

### UI Loading Strategy  
- **Before**: Expect specific modern UI paths
- **After**: Try modern paths first, fallback to v87 paths, skip if neither exists

### Asset Management
- **Before**: Assume all UI assets exist
- **After**: Check asset existence, provide defaults or skip features

## Testing Recommendations

When testing with v87 data:

1. **Login Flow**: Verify login screen appears without background errors
2. **World Selection**: Test world button functionality and auto-channel entry
3. **Chat Interface**: Confirm chat works without item link/emoticon buttons
4. **File Loading**: Check that only essential missing files cause errors

## Limitations

These changes enable basic functionality with v87 data but some features remain incompatible:

- **Modern UI Features**: Item linking, chat emoticons unavailable in v87
- **Post-v87 Content**: Reboot worlds, newer job classes not supported
- **Advanced Channel UI**: No channel population display or selection in v87 mode

## Future Enhancements

Potential improvements for better v87 support:

1. **Version Detection**: Auto-detect v87 vs modern data and adjust behavior
2. **Configuration**: Allow users to specify legacy mode for full v87 optimization  
3. **UI Reconstruction**: Create simplified v87-style UIs for missing elements
4. **Content Filtering**: Hide or disable post-v87 game features automatically

## Conclusion

These changes successfully enable HeavenClient to initialize and run with original v87 WZ files while maintaining compatibility with modern data. The client gracefully handles missing assets and provides a functional gaming experience appropriate to the v87 era.



================================================================
End of Codebase
================================================================
