This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: IO/UITypes/UIRaceSelect.cpp, IO/UITypes/UIRaceSelect.h, IO/UITypes/UICharSelect.cpp, IO/UITypes/UIExplorerCreation.cpp, IO/UITypes/UIExplorerCreation.h, IO/UITypes/UICygnusCreation.cpp, IO/UITypes/UICygnusCreation.h, IO/UITypes/UIAranCreation.cpp, IO/UITypes/UIAranCreation.h, IO/UIElement.cpp, IO/UIElement.h, IO/Components/MapleButton.cpp, IO/Components/MapleButton.h, IO/Components/AreaButton.cpp, IO/Components/AreaButton.h, Graphics/Texture.cpp, Graphics/Texture.h, Graphics/Sprite.cpp, Graphics/Sprite.h, Graphics/Animation.cpp, Graphics/Animation.h, Template/Point.h, Template/Rectangle.h, includes/NoLifeNx/nlnx/node.hpp, includes/NoLifeNx/nlnx/nx.hpp, nx_structures/UI_compressed.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
</notes>

<additional_info>
<user_provided_header>
MapleStory v83/v87 UIRaceSelect Implementation Research - Focused Codebase
</user_provided_header>

</additional_info>

</file_summary>

<directory_structure>
Graphics/Animation.cpp
Graphics/Animation.h
Graphics/Sprite.cpp
Graphics/Sprite.h
Graphics/Texture.cpp
Graphics/Texture.h
includes/NoLifeNx/nlnx/node.hpp
includes/NoLifeNx/nlnx/nx.hpp
IO/Components/AreaButton.cpp
IO/Components/AreaButton.h
IO/Components/MapleButton.cpp
IO/Components/MapleButton.h
IO/UIElement.cpp
IO/UIElement.h
IO/UITypes/UIAranCreation.h
IO/UITypes/UICharSelect.cpp
IO/UITypes/UICygnusCreation.h
IO/UITypes/UIExplorerCreation.h
IO/UITypes/UIRaceSelect.cpp
IO/UITypes/UIRaceSelect.h
nx_structures/UI_compressed.txt
Template/Point.h
Template/Rectangle.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Graphics/Animation.cpp">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Animation.h"

#include "../Constants.h"

#include "../Util/Misc.h"

#include <set>
#include <iostream>

namespace ms
{
	Frame::Frame(nl::node src)
	{
		std::cout << "[DEBUG FRAME] Creating frame from node: '" << src.name() 
		          << "', data type: " << static_cast<int>(src.data_type()) << std::endl;
		texture = src;
		std::cout << "[DEBUG FRAME] Texture created from node" << std::endl;
		bounds = src;
		head = src["head"];
		delay = src["delay"];

		if (delay == 0)
			delay = 100;

		bool hasa0 = src["a0"].data_type() == nl::node::type::integer;
		bool hasa1 = src["a1"].data_type() == nl::node::type::integer;

		if (hasa0 && hasa1)
		{
			opacities = { src["a0"], src["a1"] };
		}
		else if (hasa0)
		{
			uint8_t a0 = src["a0"];
			opacities = { a0, 255 - a0 };
		}
		else if (hasa1)
		{
			uint8_t a1 = src["a1"];
			opacities = { 255 - a1, a1 };
		}
		else
		{
			opacities = { 255, 255 };
		}

		bool hasz0 = src["z0"].data_type() == nl::node::type::integer;
		bool hasz1 = src["z1"].data_type() == nl::node::type::integer;

		if (hasz0 && hasz1)
			scales = { src["z0"], src["z1"] };
		else if (hasz0)
			scales = { src["z0"], 0 };
		else if (hasz1)
			scales = { 100, src["z1"] };
		else
			scales = { 100, 100 };
	}

	Frame::Frame()
	{
		delay = 0;
		opacities = { 0, 0 };
		scales = { 0, 0 };
	}

	void Frame::draw(const DrawArgument& args) const
	{
		texture.draw(args);
	}

	uint8_t Frame::start_opacity() const
	{
		return opacities.first;
	}

	uint16_t Frame::start_scale() const
	{
		return scales.first;
	}

	uint16_t Frame::get_delay() const
	{
		return delay;
	}

	Point<int16_t> Frame::get_origin() const
	{
		return texture.get_origin();
	}

	Point<int16_t> Frame::get_dimensions() const
	{
		return texture.get_dimensions();
	}

	Point<int16_t> Frame::get_head() const
	{
		return head;
	}

	Rectangle<int16_t> Frame::get_bounds() const
	{
		return bounds;
	}

	float Frame::opcstep(uint16_t timestep) const
	{
		return timestep * static_cast<float>(opacities.second - opacities.first) / delay;
	}

	float Frame::scalestep(uint16_t timestep) const
	{
		return timestep * static_cast<float>(scales.second - scales.first) / delay;
	}

	Animation::Animation(nl::node src)
	{
		bool istexture = src.data_type() == nl::node::type::bitmap;

		if (istexture)
		{
			frames.push_back(src);
		}
		else
		{
			std::set<int16_t> frameids;

			for (auto sub : src)
			{
				if (sub.data_type() == nl::node::type::bitmap)
				{
					int16_t fid = string_conversion::or_default<int16_t>(sub.name(), -1);

					if (fid >= 0)
						frameids.insert(fid);
				}
			}

			for (auto& fid : frameids)
			{
				auto sub = src[std::to_string(fid)];
				frames.push_back(sub);
			}

			if (frames.empty())
				frames.push_back(Frame());
		}

		animated = frames.size() > 1;
		zigzag = src["zigzag"].get_bool();

		reset();
	}

	Animation::Animation()
	{
		animated = false;
		zigzag = false;

		frames.push_back(Frame());

		reset();
	}

	void Animation::reset()
	{
		frame.set(0);
		opacity.set(frames[0].start_opacity());
		xyscale.set(frames[0].start_scale());
		delay = frames[0].get_delay();
		framestep = 1;
	}

	void Animation::draw(const DrawArgument& args, float alpha) const
	{
		int16_t interframe = frame.get(alpha);
		float interopc = opacity.get(alpha) / 255;
		float interscale = xyscale.get(alpha) / 100;

		bool modifyopc = interopc != 1.0f;
		bool modifyscale = interscale != 1.0f;

		if (modifyopc || modifyscale)
			frames[interframe].draw(args + DrawArgument(interscale, interscale, interopc));
		else
			frames[interframe].draw(args);
	}

	bool Animation::update()
	{
		return update(Constants::TIMESTEP);
	}

	bool Animation::update(uint16_t timestep)
	{
		const Frame& framedata = get_frame();

		opacity += framedata.opcstep(timestep);

		if (opacity.last() < 0.0f)
			opacity.set(0.0f);
		else if (opacity.last() > 255.0f)
			opacity.set(255.0f);

		xyscale += framedata.scalestep(timestep);

		if (xyscale.last() < 0.0f)
			opacity.set(0.0f);

		if (timestep >= delay)
		{
			int16_t lastframe = static_cast<int16_t>(frames.size() - 1);
			int16_t nextframe;
			bool ended;

			if (zigzag && lastframe > 0)
			{
				if (framestep == 1 && frame == lastframe)
				{
					framestep = -framestep;
					ended = false;
				}
				else if (framestep == -1 && frame == 0)
				{
					framestep = -framestep;
					ended = true;
				}
				else
				{
					ended = false;
				}

				nextframe = frame + framestep;
			}
			else
			{
				if (frame == lastframe)
				{
					nextframe = 0;
					ended = true;
				}
				else
				{
					nextframe = frame + 1;
					ended = false;
				}
			}

			uint16_t delta = timestep - delay;
			float threshold = static_cast<float>(delta) / timestep;
			frame.next(nextframe, threshold);

			delay = frames[nextframe].get_delay();

			if (delay >= delta)
				delay -= delta;

			opacity.set(frames[nextframe].start_opacity());
			xyscale.set(frames[nextframe].start_scale());

			return ended;
		}
		else
		{
			frame.normalize();

			delay -= timestep;

			return false;
		}
	}

	uint16_t Animation::get_delay(int16_t frame_id) const
	{
		return frame_id < frames.size() ? frames[frame_id].get_delay() : 0;
	}

	uint16_t Animation::getdelayuntil(int16_t frame_id) const
	{
		uint16_t total = 0;

		for (int16_t i = 0; i < frame_id; i++)
		{
			if (i >= frames.size())
				break;

			total += frames[frame_id].get_delay();
		}

		return total;
	}

	Point<int16_t> Animation::get_origin() const
	{
		return get_frame().get_origin();
	}

	Point<int16_t> Animation::get_dimensions() const
	{
		return get_frame().get_dimensions();
	}

	Point<int16_t> Animation::get_head() const
	{
		return get_frame().get_head();
	}

	Rectangle<int16_t> Animation::get_bounds() const
	{
		return get_frame().get_bounds();
	}

	const Frame& Animation::get_frame() const
	{
		return frames[frame.get()];
	}
}
</file>

<file path="Graphics/Animation.h">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Texture.h"

#include "../Template/Interpolated.h"
#include "../Template/Rectangle.h"

#include <vector>

namespace ms
{
	// A single frame within an animation.
	class Frame
	{
	public:
		Frame(nl::node src);
		Frame();

		void draw(const DrawArgument& args) const;

		uint8_t start_opacity() const;
		uint16_t start_scale() const;
		uint16_t get_delay() const;
		Point<int16_t> get_origin() const;
		Point<int16_t> get_dimensions() const;
		Point<int16_t> get_head() const;
		Rectangle<int16_t> get_bounds() const;
		float opcstep(uint16_t timestep) const;
		float scalestep(uint16_t timestep) const;

	private:
		Texture texture;
		uint16_t delay;
		std::pair<uint8_t, uint8_t> opacities;
		std::pair<int16_t, int16_t> scales;
		Rectangle<int16_t> bounds;
		Point<int16_t> head;
	};

	// Class which consists of multiple textures to make an Animation.
	class Animation
	{
	public:
		Animation(nl::node source);
		Animation();

		bool update();
		bool update(uint16_t timestep);
		void reset();

		void draw(const DrawArgument& arguments, float alpha) const;

		uint16_t get_delay(int16_t frame) const;
		uint16_t getdelayuntil(int16_t frame) const;
		Point<int16_t> get_origin() const;
		Point<int16_t> get_dimensions() const;
		Point<int16_t> get_head() const;
		Rectangle<int16_t> get_bounds() const;

	private:
		const Frame& get_frame() const;

		std::vector<Frame> frames;
		bool animated;
		bool zigzag;

		Nominal<int16_t> frame;
		Linear<float> opacity;
		Linear<float> xyscale;

		uint16_t delay;
		int16_t framestep;
		float opcstep;
	};
}
</file>

<file path="Graphics/Sprite.cpp">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Sprite.h"

namespace ms
{
	Sprite::Sprite(const Animation& a, const DrawArgument& args) : animation(a), stateargs(args) {}
	Sprite::Sprite(nl::node src, const DrawArgument& args) : animation(src), stateargs(args) {}
	Sprite::Sprite(nl::node src) : Sprite(src, {}) {}
	Sprite::Sprite() {}

	void Sprite::draw(Point<int16_t> parentpos, float alpha) const
	{
		auto absargs = stateargs + parentpos;
		animation.draw(absargs, alpha);
	}

	bool Sprite::update(uint16_t timestep)
	{
		return animation.update(timestep);
	}

	bool Sprite::update()
	{
		return animation.update();
	}

	int16_t Sprite::width() const
	{
		return get_dimensions().x();
	}

	int16_t Sprite::height() const
	{
		return get_dimensions().y();
	}

	Point<int16_t> Sprite::get_origin() const
	{
		return animation.get_origin();
	}

	Point<int16_t> Sprite::get_dimensions() const
	{
		return animation.get_dimensions();
	}
}
</file>

<file path="Graphics/Sprite.h">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Animation.h"

namespace ms
{
	// Combines an Animation with additional state
	class Sprite
	{
	public:
		Sprite(const Animation& animation, const DrawArgument& stateargs);
		Sprite(nl::node src, const DrawArgument& stateargs);
		Sprite(nl::node src);
		Sprite();

		void draw(Point<int16_t> parentpos, float alpha) const;
		bool update(uint16_t timestep);
		bool update();

		int16_t width() const;
		int16_t height() const;
		Point<int16_t> get_origin() const;
		Point<int16_t> get_dimensions() const;

	private:
		Animation animation;
		DrawArgument stateargs;
	};
}
</file>

<file path="Graphics/Texture.cpp">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "Texture.h"

#include "GraphicsGL.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

#include <iostream>

namespace ms
{
	Texture::Texture(nl::node src)
	{
		z_index = 0; // Default Z-index
		nl::node final_node = src;

		// --- NEW: Defensive Check for Unexpected Containers ---
		if (src && src.data_type() == nl::node::type::none && src.size() > 0) {
			// Container node received, searching for child bitmap 
			
			// Attempt to find a valid bitmap child, prioritizing "0"
			nl::node child_zero = src["0"];
			if (child_zero && child_zero.data_type() == nl::node::type::bitmap) {
				final_node = child_zero;
				// Using fallback child
			} else {
				for (const auto& child : src) {
					if (child.data_type() == nl::node::type::bitmap) {
						final_node = child;
						// Using child bitmap
						break;
					}
				}
			}
		}

		if (final_node && final_node.data_type() == nl::node::type::bitmap)
		{
			origin = final_node["origin"];
			// Read Z-depth for proper layering
			z_index = final_node["z"].get_integer(0);
			if (z_index == 0) {
				z_index = final_node["zM"].get_integer(0);
			}
			// Texture creation from node (debug output removed)

			if (final_node.root() == nl::nx::Map001)
			{
				const std::string& _outlink = final_node["_outlink"];

				if (!_outlink.empty())
				{
					size_t first = _outlink.find_first_of('/');

					if (first != std::string::npos)
					{
						const std::string& first_part = _outlink.substr(0, first);

						if (first_part == "Map")
						{
							const std::string& path = _outlink.substr(first + 1);
							nl::node foundOutlink = nl::nx::Map.resolve(path);

							if (foundOutlink)
								final_node = foundOutlink;
						}
					}
				}
			}

			// This is the critical conversion line, now performed on the correct node
			bitmap = final_node;
			
			// Bitmap assignment complete

			if (bitmap.id() == 0)
			{
				std::cout << "[ERROR] Failed to load bitmap for node: " << final_node.name() << std::endl;
			}

			dimensions = Point<int16_t>(bitmap.width(), bitmap.height());
			// Texture loaded successfully

			GraphicsGL::get().addbitmap(bitmap);
		}
		else
		{
			// Note: Invalid bitmap node (debug output suppressed)
		}
	}

	void Texture::draw(const DrawArgument& args) const
	{
		draw(args, Range<int16_t>(0, 0));
	}

	void Texture::draw(const DrawArgument& args, const Range<int16_t>& vertical) const
	{
		draw(args, vertical, Range<int16_t>(0, 0));
	}

	void Texture::draw(const DrawArgument& args, const Range<int16_t>& vertical, const Range<int16_t>& horizontal) const
	{
		if (!is_valid())
		{
			// Skipping draw: invalid texture
			return;
		}

		// Drawing texture 

		GraphicsGL::get().draw(
			bitmap,
			args.get_rectangle(origin, dimensions),
			vertical,
			horizontal,
			args.get_color(),
			args.get_angle()
		);
	}

	void Texture::shift(Point<int16_t> amount)
	{
		origin -= amount;
	}

	bool Texture::is_valid() const
	{
		return bitmap.id() > 0;
	}

	int16_t Texture::width() const
	{
		return dimensions.x();
	}

	int16_t Texture::height() const
	{
		return dimensions.y();
	}

	Point<int16_t> Texture::get_origin() const
	{
		return origin;
	}

	Point<int16_t> Texture::get_dimensions() const
	{
		return dimensions;
	}

	int Texture::get_z_index() const
	{
		return z_index;
	}
}
</file>

<file path="Graphics/Texture.h">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "DrawArgument.h"

#ifdef USE_NX
#include <nlnx/bitmap.hpp>
#endif

namespace ms
{
	// Represents a single image loaded from a of game data
	class Texture
	{
	public:
		Texture() {}
		Texture(nl::node source);
		~Texture() {}

		void draw(const DrawArgument& args) const;
		void draw(const DrawArgument& args, const Range<int16_t>& vertical) const;
		void draw(const DrawArgument& args, const Range<int16_t>& vertical, const Range<int16_t>& horizontal) const;
		void shift(Point<int16_t> amount);

		bool is_valid() const;
		int16_t width() const;
		int16_t height() const;
		Point<int16_t> get_origin() const;
		Point<int16_t> get_dimensions() const;
		int get_z_index() const;

	private:
		nl::bitmap bitmap;
		Point<int16_t> origin;
		Point<int16_t> dimensions;
		int z_index;
	};
}
</file>

<file path="includes/NoLifeNx/nlnx/node.hpp">
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

#pragma once
#include "nxfwd.hpp"
#include <string>
#include <cstdint>
#include <cstddef>

namespace nl {
    struct _file_data;
    typedef std::pair<int32_t, int32_t> vector2i;
    class node {
    public:
        using difference_type = ptrdiff_t;
        using value_type = node;
        using pointer = node;
        using reference = node &;
        using iterator_category = std::random_access_iterator_tag;
        struct data;
        //Type of node data
        enum class type : uint16_t {
            none = 0,
            integer = 1,
            real = 2,
            string = 3,
            vector = 4,
            bitmap = 5,
            audio = 6,
        };
        //Constructors
        node() = default;
        node(node const &);//Only reason this isn't defaulted is because msvc has issues
        node & operator=(node const &) = default;
        //These methods are primarily so nodes can be used as iterators and iterated over
        node begin() const;
        node end() const;
        node operator*() const;
        node & operator++();
        node operator++(int);
        bool operator==(node const &) const;
        bool operator!=(node const &) const;
        bool operator<(node const &) const;
        //This checks whether or not the node points to an actual node
        //Even if the node ends up being a null node, you can still use it safely
        //It'll just fall back to returning default values and more null nodes
        //However, if the file this node was obtained from was deleted
        //then the node becomes invalid and this operator cannot tell you that
        explicit operator bool() const;
        //Methods to access the children of the node by name
        //Note that the versions taking integers convert the integer to a string
        //They do not access the children by their integer index
        //If you wish to do that, use somenode.begin() + integer_index
        node operator[](unsigned int) const;
        node operator[](signed int) const;
        node operator[](unsigned long) const;
        node operator[](signed long) const;
        node operator[](unsigned long long) const;
        node operator[](signed long long) const;
        node operator[](std::string const &) const;
        node operator[](char const *) const;
        //This method uses the string value of the node, not the node's name
        node operator[](node const &) const;
        //Operators to easily cast a node to get the data
        //Allows things like string s = somenode
        //Will automatically cast between data types as needed
        //For example if the node has an integer value but you want a string
        //then the operator will automatically convert the integer to a string
        operator unsigned char() const;
        operator signed char() const;
        operator unsigned short() const;
        operator signed short() const;
        operator unsigned int() const;
        operator signed int() const;
        operator unsigned long() const;
        operator signed long() const;
        operator unsigned long long() const;
        operator signed long long() const;
        operator float() const;
        operator double() const;
        operator long double() const;
        operator std::string() const;
        operator vector2i() const;
        operator bitmap() const;
        operator audio() const;
        //Explicitly called versions of all the operators
        //When it takes a parameter, that is used as the default value
        //if a suitable data value cannot be found in the node
        int64_t get_integer(int64_t = 0) const;
        double get_real(double = 0) const;
        std::string get_string(std::string = "") const;
        vector2i get_vector(vector2i = {0, 0}) const;
        bitmap get_bitmap() const;
        audio get_audio() const;
        bool get_bool() const;
        bool get_bool(bool) const;
        //Returns the x and y coordinates of the vector data value
        int32_t x() const;
        int32_t y() const;
        //The name of the node
        std::string name() const;
        //The number of children in the node
        size_t size() const;
        //Gets the type of data contained within the node
        type data_type() const;
        //Returns the root node of the file this node was derived from
        node root() const;
        //Takes a '/' separated string, and resolves the given path
        node resolve(std::string) const;
    private:
        node(data const *, _file_data const *);
        node get_child(char const *, uint16_t) const;
        int64_t to_integer() const;
        double to_real() const;
        std::string to_string() const;
        vector2i to_vector() const;
        bitmap to_bitmap() const;
        audio to_audio() const;
        //Internal variables
        data const * m_data = nullptr;
        _file_data const * m_file = nullptr;
        friend file;
    };
    //More convenience string concatenation operators
    std::string operator+(std::string, node);
    std::string operator+(char const *, node);
    std::string operator+(node, std::string);
    std::string operator+(node, char const *);
}
</file>

<file path="includes/NoLifeNx/nlnx/nx.hpp">
//////////////////////////////////////////////////////////////////////////////
// NoLifeNx - Part of the NoLifeStory project                               //
// Copyright © 2013 Peter Atashian                                          //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "nxfwd.hpp"

namespace nl
{
	namespace nx
	{
		// Pre-defined nodes to access standard MapleStory style data
		// Make sure you called load_all first
		extern node Base, Character, Effect, Etc, Item, Map, Map001, Map002, Map2, Mob, Mob001, Mob002, Mob2, Morph, Npc, Quest, Reactor, Skill, Skill001, Skill002, Skill003, Sound, Sound001, Sound002, Sound2, String, TamingMob, UI;

		// Loads the pre-defined nodes from a standard setup of nx files for MapleStory
		// Only call this function once
		void load_all();
	}
}
</file>

<file path="IO/Components/AreaButton.cpp">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "AreaButton.h"

namespace ms
{
	AreaButton::AreaButton(Point<int16_t> pos, Point<int16_t> dim)
	{
		position = pos;
		dimension = dim;
		state = Button::State::NORMAL;
		active = true;
	}

	Rectangle<int16_t> AreaButton::bounds(Point<int16_t> parentpos) const
	{
		Point<int16_t> absp = position + parentpos;

		return Rectangle<int16_t>(absp, absp + dimension);
	}

	int16_t AreaButton::width() const
	{
		return dimension.x();
	}

	Point<int16_t> AreaButton::origin() const
	{
		return Point<int16_t>();
	}
}
</file>

<file path="IO/Components/AreaButton.h">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Button.h"

namespace ms
{
	// An invisible button which is only defined by it's area.
	class AreaButton : public Button
	{
	public:
		AreaButton(Point<int16_t> position, Point<int16_t> dimensions);

		void draw(Point<int16_t>) const {}
		void update() {}
		Rectangle<int16_t> bounds(Point<int16_t> parentpos) const;
		int16_t width() const;
		Point<int16_t> origin() const;
		Cursor::State send_cursor(bool, Point<int16_t>) { return Cursor::State::IDLE; }

	private:
		Point<int16_t> dimension;
	};
}
</file>

<file path="IO/Components/MapleButton.cpp">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "MapleButton.h"

namespace ms
{
	MapleButton::MapleButton(nl::node src, Point<int16_t> pos)
	{
		nl::node normal = src["normal"];

		if (normal.size() > 1)
			animations[Button::State::NORMAL] = normal;
		else
			textures[Button::State::NORMAL] = normal["0"];

		textures[Button::State::PRESSED] = src["pressed"]["0"];
		textures[Button::State::MOUSEOVER] = src["mouseOver"]["0"];
		textures[Button::State::DISABLED] = src["disabled"]["0"];

		active = true;
		position = pos;
		state = Button::State::NORMAL;
	}

	MapleButton::MapleButton(nl::node src, int16_t x, int16_t y) : MapleButton(src, Point<int16_t>(x, y)) {}
	MapleButton::MapleButton(nl::node src) : MapleButton(src, Point<int16_t>()) {}

	void MapleButton::draw(Point<int16_t> parentpos) const
	{
		if (active)
		{
			textures[state].draw(position + parentpos);
			animations[state].draw(position + parentpos, 1.0f);
		}
	}

	void MapleButton::update()
	{
		if (active)
			animations[state].update(6);
	}

	Rectangle<int16_t> MapleButton::bounds(Point<int16_t> parentpos) const
	{
		Point<int16_t> lt;
		Point<int16_t> rb;

		if (textures[state].is_valid())
		{
			lt = parentpos + position - textures[state].get_origin();
			rb = lt + textures[state].get_dimensions();
		}
		else
		{
			lt = parentpos + position - animations[state].get_origin();
			rb = lt + animations[state].get_dimensions();
		}

		return Rectangle<int16_t>(lt, rb);
	}

	int16_t MapleButton::width() const
	{
		return textures[state].width();
	}

	Point<int16_t> MapleButton::origin() const
	{
		return textures[state].get_origin();
	}
}
</file>

<file path="IO/Components/MapleButton.h">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Button.h"

namespace ms
{
	// A standard MapleStory button with 4 states and a texture for each state
	class MapleButton : public Button
	{
	public:
		MapleButton(nl::node src, Point<int16_t> position);
		MapleButton(nl::node src, int16_t x, int16_t y);
		MapleButton(nl::node src);

		void draw(Point<int16_t> position) const;
		void update();
		Rectangle<int16_t> bounds(Point<int16_t> parentpos) const;
		int16_t width() const;
		Point<int16_t> origin() const;
		Cursor::State send_cursor(bool, Point<int16_t>) { return Cursor::State::IDLE; }

	private:
		Texture textures[Button::State::NUM_STATES];
		Animation animations[Button::State::NUM_STATES];
	};
}
</file>

<file path="IO/UIElement.cpp">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIElement.h"

#include "../Audio/Audio.h"
#include <iostream>

namespace ms
{
	UIElement::UIElement(Point<int16_t> p, Point<int16_t> d, bool a) : position(p), dimension(d), active(a) {}
	UIElement::UIElement(Point<int16_t> p, Point<int16_t> d) : UIElement(p, d, true) {}
	UIElement::UIElement() : UIElement(Point<int16_t>(), Point<int16_t>()) {}

	void UIElement::draw(float alpha) const
	{
		draw_sprites(alpha);
		draw_buttons(alpha);
	}

	void UIElement::draw_sprites(float alpha) const
	{
		// Drawing sprites
		for (const Sprite& sprite : sprites)
		{
			// Drawing sprite
			sprite.draw(position, alpha);
		}
	}

	void UIElement::draw_buttons(float) const
	{
		for (auto& iter : buttons)
			if (const Button* button = iter.second.get())
				button->draw(position);
	}

	void UIElement::update()
	{
		for (auto& sprite : sprites)
			sprite.update();

		for (auto& iter : buttons)
			if (Button* button = iter.second.get())
				button->update();
	}

	void UIElement::makeactive()
	{
		active = true;
	}

	void UIElement::deactivate()
	{
		active = false;
	}

	bool UIElement::is_active() const
	{
		return active;
	}

	void UIElement::toggle_active()
	{
		if (active)
			deactivate();
		else
			makeactive();
	}

	bool UIElement::is_in_range(Point<int16_t> cursor_position) const
	{
		auto bounds = Rectangle<int16_t>(position, position + dimension);

		return bounds.contains(cursor_position);
	}

	void UIElement::remove_cursor()
	{
		for (auto& btit : buttons)
		{
			auto button = btit.second.get();

			if (button->get_state() == Button::State::MOUSEOVER)
				button->set_state(Button::State::NORMAL);
		}
	}

	Cursor::State UIElement::send_cursor(bool clicked, Point<int16_t> cursor_position)
	{
		Cursor::State ret = clicked ? Cursor::State::CLICKING : Cursor::State::IDLE;

		for (auto& btit : buttons)
		{
			if (btit.second->is_active() && btit.second->bounds(position).contains(cursor_position))
			{
				if (btit.second->get_state() == Button::State::NORMAL)
				{
					Sound(Sound::Name::BUTTONOVER).play();

					btit.second->set_state(Button::State::MOUSEOVER);
					ret = Cursor::State::CANCLICK;
				}
				else if (btit.second->get_state() == Button::State::MOUSEOVER)
				{
					if (clicked)
					{
						Sound(Sound::Name::BUTTONCLICK).play();

						btit.second->set_state(button_pressed(btit.first));

						ret = Cursor::State::IDLE;
					}
					else
					{
						ret = Cursor::State::CANCLICK;
					}
				}
			}
			else if (btit.second->get_state() == Button::State::MOUSEOVER)
			{
				btit.second->set_state(Button::State::NORMAL);
			}
		}

		return ret;
	}
}
</file>

<file path="IO/UIElement.h">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Components/Button.h"
#include "Components/Icon.h"

#include "../Graphics/Sprite.h"

namespace ms
{
	// Base class for all types of user interfaces on screen.
	class UIElement
	{
	public:
		using UPtr = std::unique_ptr<UIElement>;

		enum Type
		{
			NONE,
			START,
			LOGIN,
			TOS,
			GENDER,
			WORLDSELECT,
			REGION,
			CHARSELECT,
			LOGINWAIT,
			RACESELECT,
			CLASSCREATION,
			SOFTKEYBOARD,
			LOGINNOTICE,
			LOGINNOTICE_CONFIRM,
			STATUSMESSENGER,
			STATUSBAR,
			CHATBAR,
			BUFFLIST,
			NOTICE,
			NPCTALK,
			SHOP,
			STATSINFO,
			ITEMINVENTORY,
			EQUIPINVENTORY,
			SKILLBOOK,
			QUESTLOG,
			WORLDMAP,
			USERLIST,
			MINIMAP,
			CHANNEL,
			CHAT,
			CHATRANK,
			JOYPAD,
			EVENT,
			KEYCONFIG,
			OPTIONMENU,
			QUIT,
			CHARINFO,
			CASHSHOP,
			NUM_TYPES
		};

		virtual ~UIElement() {}

		virtual void draw(float inter) const;
		virtual void update();
		virtual void update_screen(int16_t new_width, int16_t new_height) {}

		void makeactive();
		void deactivate();
		bool is_active() const;

		virtual void toggle_active();
		virtual Button::State button_pressed(uint16_t buttonid) { return Button::State::DISABLED; }
		virtual bool send_icon(const Icon& icon, Point<int16_t> cursor_position) { return true; }

		virtual void doubleclick(Point<int16_t> cursorpos) {}
		virtual void rightclick(Point<int16_t> cursorpos) {}
		virtual bool is_in_range(Point<int16_t> cursor_position) const;
		virtual void remove_cursor();
		virtual Cursor::State send_cursor(bool clicked, Point<int16_t> cursor_position);
		virtual void send_scroll(double yoffset) {}
		virtual void send_key(int32_t keycode, bool pressed, bool escape) {}

		virtual UIElement::Type get_type() const = 0;

	protected:
		UIElement(Point<int16_t> position, Point<int16_t> dimension, bool active);
		UIElement(Point<int16_t> position, Point<int16_t> dimension);
		UIElement();

		void draw_sprites(float alpha) const;
		void draw_buttons(float alpha) const;

		std::map<uint16_t, std::unique_ptr<Button>> buttons;
		std::vector<Sprite> sprites;
		Point<int16_t> position;
		Point<int16_t> dimension;
		bool active;
	};
}
</file>

<file path="IO/UITypes/UIAranCreation.h">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "UICommonCreation.h"

namespace ms
{
	class UIAranCreation : public UICommonCreation
	{
	public:
		UIAranCreation() : UICommonCreation("2000") {}
	};
}
</file>

<file path="IO/UITypes/UICharSelect.cpp">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UICharSelect.h"

#include "UILoginNotice.h"
#include "UIRaceSelect.h"
#include "UIExplorerCreation.h"
#include "UISoftKey.h"
#include "UIWorldSelect.h"

#include "../UI.h"

#include "../Components/AreaButton.h"
#include "../Components/MapleButton.h"

#include "../../Configuration.h"

#include "../../Audio/Audio.h"
#include "../../Character/Job.h"

#include "../../Net/Packets/SelectCharPackets.h"
#include "../../Util/Misc.h"

#define NOMINMAX
#include <windows.h>

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UICharSelect::UICharSelect(std::vector<CharEntry> characters, int8_t characters_count, int32_t slots, int8_t require_pic) : UIElement(Point<int16_t>(0, 0), Point<int16_t>(800, 600)),
		characters(characters), characters_count(characters_count), slots(slots), require_pic(require_pic), tab_index(0), tab_active(false), tab_move(false), charslot_y(0), use_timestamp(false), burning_character(true), show_pic_btns(false)
	{
		try {
			NDEBUG("UICharSelect constructor started");
			std::string version_text = Configuration::get().get_version();
			version = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::LEMONGRASS, "Ver. " + version_text);

			NDEBUG("Loading Login UI nodes");
			nl::node Login = nl::nx::UI["Login.img"];
			nl::node Common = Login["Common"];
			version_pos = Common["version"]["pos"];

			selected_character = Setting<DefaultCharacter>::get().load();
			selected_page = selected_character / PAGESIZE;
			page_count = std::ceil((double)slots / (double)PAGESIZE);

			NDEBUG("Loading cursor and tab data");
			tab = nl::nx::UI["Basic.img"]["Cursor"]["18"]["0"];
			tab_move_pos = 0;

			tab_map[0] = Buttons::BtSelect;
			tab_map[1] = Buttons::BtNew;
			tab_map[2] = Buttons::BtDelete;

			NDEBUG("Loading CharSelect nodes");
			nl::node CharSelect = Login["CharSelect"];
			nl::node selectedWorld = CharSelect["selectedWorld"];
			nl::node pageNew = CharSelect["pageNew"];

			uint16_t world;
			uint8_t world_id = Configuration::get().get_worldid();
			uint8_t channel_id = Configuration::get().get_channelid();

			NDEBUG("Getting world info, world_id=" << static_cast<int>(world_id) << ", channel_id=" << static_cast<int>(channel_id));
			if (auto worldselect = UI::get().get_element<UIWorldSelect>())
				world = worldselect->get_worldbyid(world_id);

			NDEBUG("Loading world sprites");
			world_sprites.emplace_back(Common["selectWorld"]);
			world_sprites.emplace_back(selectedWorld["icon"][world]);
			world_sprites.emplace_back(selectedWorld["name"][world]);
			world_sprites.emplace_back(selectedWorld["ch"][channel_id]);

		// Try multiple paths for v83 compatibility
		NDEBUG("Loading character select background...");
		nl::node map = nl::nx::Map001["Back"]["UI_login.img"];
		if (map.name().empty()) {
			NDEBUG("Map001 path not found, trying Map path");
			// Try direct Map path (v83)
			map = nl::nx::Map["Back"]["UI_login.img"];
		}
		if (map.name().empty()) {
			NDEBUG("Map path not found, trying UI Login.img path");
			// Try UI Login.img path (alternative v83 location)  
			map = nl::nx::UI["Login.img"];
		}
		NDEBUG("Using map path: " << (map.name().empty() ? "EMPTY" : "FOUND"));
		nl::node back = map["back"];

		sprites.emplace_back(back["1"], Point<int16_t>(512, 384));

		for (nl::node node : map["ani"])
			sprites.emplace_back(node, Point<int16_t>(0, -2));

		sprites.emplace_back(back["2"], Point<int16_t>(512, 384));

		nl::node BurningNotice = Common["Burning"]["BurningNotice"];
		burning_notice = BurningNotice;
		burning_numPos = BurningNotice["numPos"];
		burning_count = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::CREAM, "1");

		charinfo = CharSelect["charInfo1"];

		nl::node charSlot = CharSelect["charSlot"];
		charslot = charSlot["0"];
		charslot_pos = charSlot["pos"];
		charslot_bounds = Rectangle<int16_t>(charSlot["worldInfoLT"], charSlot["worldInfoRB"]);

		pagebase = pageNew["base"]["0"];
		pagenumber = Charset(pageNew["number"], Charset::Alignment::LEFT);
		pagenumberpos = pageNew["numberpos"];
		pagepos = pageNew["pos"];

		signpost[0] = CharSelect["adventure"]["0"];
		signpost[1] = CharSelect["knight"]["0"];
		signpost[2] = CharSelect["aran"]["0"];

		nametag = CharSelect["nameTag"];
		if (nametag) {
			NDEBUG("Loaded nameTag successfully");
		} else {
			NDEBUG("WARNING: nameTag not found in CharSelect, nametags will not work");
		}

		nl::node BtNew = CharSelect["BtNew"];
		Texture BtNewTexture = Texture(BtNew["normal"]["0"]);
		Point<int16_t> BtNewDim = BtNewTexture.get_dimensions();
		BtNewPos = BtNewTexture.get_origin().abs();

		nl::node BtSelect = CharSelect["BtSelect"];
		Point<int16_t> BtSelectPos = Texture(BtSelect["normal"]["0"]).get_origin().abs();

		Point<int16_t> tab_adj = Point<int16_t>(107, 8);

		tab_pos[0] = tab_adj + BtSelectPos + Point<int16_t>(2, 0);
		tab_pos[1] = tab_adj + BtNewPos;
		tab_pos[2] = tab_adj + BtNewPos + Point<int16_t>(BtNewDim.x() - 1, 0);

		buttons[Buttons::BtSelect] = std::make_unique<MapleButton>(BtSelect);
		buttons[Buttons::BtNew] = std::make_unique<MapleButton>(BtNew);
		buttons[Buttons::BtDelete] = std::make_unique<MapleButton>(CharSelect["BtDelete"]);
		buttons[Buttons::BtPageL] = std::make_unique<MapleButton>(CharSelect["pageL"]);
		buttons[Buttons::BtPageR] = std::make_unique<MapleButton>(CharSelect["pageR"]);
		buttons[Buttons::BtChangePIC] = std::make_unique<MapleButton>(Common["BtChangePIC"]);
		buttons[Buttons::BtResetPIC] = std::make_unique<MapleButton>(Login["WorldSelect"]["BtResetPIC"]);
		buttons[Buttons::BtCharacter] = std::make_unique<MapleButton>(CharSelect["EditCharList"]["BtCharacter"]);
		buttons[Buttons::BtPreview] = std::make_unique<MapleButton>(Common["BtPreview"]);

		nl::node pos = CharSelect["pos"];
		nl::node avatarPos = pos["avatarPos"];
		avatarLT = avatarPos["avatarLT"];
		avatarRB = avatarPos["avatarRB"];
		avatarSpace = avatarPos["avatarSpace"];

		Point<int16_t> screen_adj = Point<int16_t>(0, 3);

		nl::node detailPos = pos["detailPos"];
		jobPos = detailPos["jobPos"];
		levelPos = detailPos["levelPos"];
		namePos = detailPos["namePos"];
		statDEXPos = detailPos["statDEXPos"];
		statINTPos = detailPos["statINTPos"];
		statLUKPos = detailPos["statLUKPos"];
		statSTRPos = detailPos["statSTRPos"];

		jobPos -= screen_adj;
		namePos -= Point<int16_t>(0, 5);
		statDEXPos -= screen_adj;
		statINTPos -= screen_adj;
		statLUKPos -= screen_adj;
		statSTRPos -= screen_adj;

		for (size_t i = 0; i < PAGESIZE; i++)
			buttons[Buttons::CHARACTER_SLOT0 + i] = std::make_unique<AreaButton>(get_character_slot_pos(i), avatarRB - avatarLT);

		if (require_pic == 0 || !show_pic_btns)
		{
			buttons[Buttons::BtChangePIC]->set_active(false);
			buttons[Buttons::BtResetPIC]->set_active(false);
		}

		levelset = Charset(CharSelect["lv"], Charset::Alignment::CENTER);
		namelabel = OutlinedText(Text::Font::A14B, Text::Alignment::CENTER, Color::Name::WHITE, Color::Name::IRISHCOFFEE);

		for (size_t i = 0; i < InfoLabel::NUM_LABELS; i++)
			infolabels[i] = OutlinedText(Text::Font::A11M, Text::Alignment::RIGHT, Color::Name::WHITE, Color::Name::TOBACCOBROWN);

		NDEBUG("About to process " << characters.size() << " characters");
		for (CharEntry& entry : characters)
		{
			NDEBUG("Processing character: " << entry.stats.name);
			NDEBUG("Character look data - female: " << entry.look.female << ", skin: " << static_cast<int>(entry.look.skin) << ", face: " << entry.look.faceid << ", hair: " << entry.look.hairid);
			NDEBUG("Character has " << entry.look.equips.size() << " equipment items");
			
			try {
				charlooks.emplace_back(entry.look);
				NDEBUG("Added charlook successfully");
			}
			catch (const std::invalid_argument& e) {
				NDEBUG("Invalid argument creating charlook for " << entry.stats.name << ": " << e.what());
			}
			catch (const std::exception& e) {
				NDEBUG("Exception creating charlook for " << entry.stats.name << ": " << e.what());
			}
			catch (...) {
				NDEBUG("Unknown exception creating charlook for " << entry.stats.name);
			}
			
			// Only create nametag if the nameTag node exists
			if (nametag) {
				NDEBUG("About to create nametag for " << entry.stats.name);
				// Try to create nametag and catch any exception
				try {
					nametags.emplace_back(nametag, Text::Font::A12M, entry.stats.name);
					NDEBUG("Nametag created successfully for " << entry.stats.name);
				}
				catch (const std::exception& e) {
					NDEBUG("Exception creating nametag for " << entry.stats.name << ": " << e.what());
				}
				catch (...) {
					NDEBUG("Unknown exception creating nametag for " << entry.stats.name);
				}
			} else {
				NDEBUG("Skipping nametag creation for " << entry.stats.name << " due to missing nameTag node");
			}
		}

		emptyslot_effect = CharSelect["character"]["0"];
		emptyslot = CharSelect["character"]["1"]["0"];

		selectedslot_effect[0] = CharSelect["effect"][0];
		selectedslot_effect[1] = CharSelect["effect"][1];

		charslotlabel = OutlinedText(Text::Font::A12M, Text::Alignment::LEFT, Color::Name::WHITE, Color::Name::JAMBALAYA);
		charslotlabel.change_text(get_slot_text());

		update_buttons();

		if (characters_count > 0)
		{
			if (selected_character < characters_count)
				update_selected_character();
			else
				select_last_slot();
		}

		if (Configuration::get().get_auto_login())
		{
			SelectCharPicPacket(
				Configuration::get().get_auto_pic(),
				Configuration::get().get_auto_cid()
			).dispatch();
		}
		
		NDEBUG("UICharSelect constructor completed successfully");
		}
		catch (const std::exception& e) {
			NDEBUG("UICharSelect constructor exception: " << e.what());
			throw;
		}
		catch (...) {
			NDEBUG("UICharSelect constructor unknown exception");
			throw;
		}
	}

	void UICharSelect::draw(float inter) const
	{
		UIElement::draw_sprites(inter);

		version.draw(position + version_pos - Point<int16_t>(0, 5));

		charslot.draw(position + charslot_pos - Point<int16_t>(0, charslot_y));
		charslotlabel.draw(position + charslot_pos + Point<int16_t>(113, 5 - charslot_y));

		for (Sprite sprite : world_sprites)
			sprite.draw(position, inter);

		std::string total = pad_number_with_leading_zero(page_count);
		std::string current = pad_number_with_leading_zero(selected_page + 1);

		std::list<uint8_t> fliplist = { 3, 4, 5, 9, 10, 11 };

		for (uint8_t i = 0; i < PAGESIZE; i++)
		{
			uint8_t index = i + selected_page * PAGESIZE;
			bool flip_character = std::find(fliplist.begin(), fliplist.end(), i) != fliplist.end();
			bool selectedslot = index == selected_character;

			if (index < characters_count)
			{
				Point<int16_t> charpos = get_character_slot_pos(i);
				DrawArgument chararg = DrawArgument(charpos, flip_character);

				// Only draw nametag if it exists
				if (index < nametags.size()) {
					nametags[index].draw(charpos + Point<int16_t>(2, 1));
				}

				const StatsEntry& character_stats = characters[index].stats;

				if (selectedslot)
				{
					selectedslot_effect[1].draw(charpos + Point<int16_t>(-5, 16), inter);
					charinfo.draw(position);

					std::string levelstr = std::to_string(character_stats.stats[MapleStat::Id::LEVEL]);
					int8_t lvy = 19;
					int16_t lvx = levelset.draw("201", levelPos + Point<int16_t>(-1, lvy));

					levelset.draw('l', levelPos + Point<int16_t>(-lvx - 3, lvy - 1));
					namelabel.draw(namePos);

					for (size_t i = 0; i < InfoLabel::NUM_LABELS; i++)
					{
						Point<int16_t> labelpos = get_infolabel_pos(i);
						infolabels[i].draw(labelpos);
					}
				}

				uint8_t j = 0;
				uint16_t job = character_stats.stats[MapleStat::Id::JOB];

				if (job >= 0 && job < 1000)
					j = 0;
				else if (job >= 1000 && job < 2000)
					j = 1;
				else if (job >= 2000 && job < 2200)
					j = 2;
				else
					j = 0;

				signpost[j].draw(chararg);
				
				// Only draw character look if it exists
				if (index < charlooks.size()) {
					charlooks[index].draw(chararg, inter);
				}

				if (selectedslot)
					selectedslot_effect[0].draw(charpos + Point<int16_t>(-5, -298), inter);
			}
			else if (i < slots)
			{
				Point<int16_t> emptyslotpos = get_character_slot_pos(i);

				emptyslot_effect.draw(emptyslotpos, inter);
				emptyslot.draw(DrawArgument(emptyslotpos, flip_character));
			}
		}

		UIElement::draw_buttons(inter);

		if (tab_active)
			tab.draw(position + tab_pos[tab_index] + Point<int16_t>(0, tab_move_pos));

		if (burning_character)
		{
			burning_notice.draw(position + BtNewPos, inter);
			burning_count.draw(position + BtNewPos + burning_numPos + Point<int16_t>(8, -4));
		}

		pagebase.draw(position + pagepos);
		pagenumber.draw(current.substr(0, 1), position + pagepos + Point<int16_t>(pagenumberpos[0]));
		pagenumber.draw(current.substr(1, 1), position + pagepos + Point<int16_t>(pagenumberpos[1]));
		pagenumber.draw(total.substr(0, 1), position + pagepos + Point<int16_t>(pagenumberpos[2]));
		pagenumber.draw(total.substr(1, 1), position + pagepos + Point<int16_t>(pagenumberpos[3]));
	}

	void UICharSelect::update()
	{
		UIElement::update();

		int16_t timestep_max = CHARSLOT_Y_MAX * Constants::TIMESTEP;

		if (use_timestamp)
		{
			if (show_timestamp)
			{
				if (timestamp > 0)
				{
					timestamp -= Constants::TIMESTEP;

					if (timestamp <= timestep_max)
						charslot_y += 1;
				}
			}
			else
			{
				if (timestamp <= timestep_max)
				{
					timestamp += Constants::TIMESTEP;

					if (charslot_y >= 0)
						charslot_y -= 1;
				}
			}
		}

		if (tab_move && tab_move_pos < 4)
			tab_move_pos += 1;

		if (tab_move && tab_move_pos == 4)
			tab_move = false;

		if (!tab_move && tab_move_pos > 0)
			tab_move_pos -= 1;

		for (CharLook& charlook : charlooks)
			charlook.update(Constants::TIMESTEP);

		for (Animation& effect : selectedslot_effect)
			effect.update();

		emptyslot_effect.update();

		if (burning_character)
			burning_notice.update();
	}

	void UICharSelect::doubleclick(Point<int16_t> cursorpos)
	{
		uint16_t button_index = selected_character + Buttons::CHARACTER_SLOT0;
		auto& btit = buttons[button_index];

		if (btit->is_active() && btit->bounds(position).contains(cursorpos) && btit->get_state() == Button::State::NORMAL && button_index >= Buttons::CHARACTER_SLOT0)
			button_pressed(Buttons::BtSelect);
	}

	Cursor::State UICharSelect::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		if (charslot_bounds.contains(cursorpos))
		{
			if (clicked)
			{
				if (use_timestamp)
					show_timestamp = !show_timestamp;

				return Cursor::State::CLICKING;
			}
		}

		Cursor::State ret = clicked ? Cursor::State::CLICKING : Cursor::State::IDLE;

		for (auto& btit : buttons)
		{
			if (btit.second->is_active() && btit.second->bounds(position).contains(cursorpos))
			{
				if (btit.second->get_state() == Button::State::NORMAL)
				{
					Sound(Sound::Name::BUTTONOVER).play();

					btit.second->set_state(Button::State::MOUSEOVER);
					ret = Cursor::State::CANCLICK;
				}
				else if (btit.second->get_state() == Button::State::MOUSEOVER)
				{
					if (clicked)
					{
						Sound(Sound::Name::BUTTONCLICK).play();

						btit.second->set_state(button_pressed(btit.first));

						if (tab_active && btit.first == tab_map[tab_index])
							btit.second->set_state(Button::State::MOUSEOVER);

						ret = Cursor::State::IDLE;
					}
					else
					{
						if (!tab_active || btit.first != tab_map[tab_index])
							ret = Cursor::State::CANCLICK;
					}
				}
			}
			else if (btit.second->get_state() == Button::State::MOUSEOVER)
			{
				if (!tab_active || btit.first != tab_map[tab_index])
					btit.second->set_state(Button::State::NORMAL);
			}
		}

		return ret;
	}

	void UICharSelect::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
			{
				button_pressed(Buttons::BtPreview);
			}
			else if (keycode == KeyAction::Id::RETURN)
			{
				if (tab_active)
				{
					uint16_t btn_index = tab_map[tab_index];

					auto& btn = buttons[btn_index];
					Button::State state = btn->get_state();

					if (state != Button::State::DISABLED)
						button_pressed(btn_index);
				}
				else
				{
					button_pressed(Buttons::BtSelect);
				}
			}
			else
			{
				if (keycode == KeyAction::Id::TAB)
				{
					uint8_t prev_tab = tab_index;

					if (!tab_active)
					{
						tab_active = true;

						if (!buttons[Buttons::BtSelect]->is_active())
							tab_index++;
					}
					else
					{
						tab_index++;

						if (tab_index > 2)
						{
							tab_active = false;
							tab_index = 0;
						}
					}

					tab_move = true;
					tab_move_pos = 0;

					auto& prev_btn = buttons[tab_map[prev_tab]];
					Button::State prev_state = prev_btn->get_state();

					if (prev_state != Button::State::DISABLED)
						prev_btn->set_state(Button::State::NORMAL);

					if (tab_active)
					{
						auto& btn = buttons[tab_map[tab_index]];
						Button::State state = btn->get_state();

						if (state != Button::State::DISABLED)
							btn->set_state(Button::State::MOUSEOVER);
					}
				}
				else
				{
					uint8_t selected_index = selected_character;
					uint8_t index_total = std::min(characters_count, static_cast<int8_t>((selected_page + 1) * PAGESIZE));

					uint8_t COLUMNS = 4;
					uint8_t columns = std::min(index_total, COLUMNS);

					uint8_t rows = std::floor((index_total - 1) / COLUMNS) + 1;

					int32_t current_col = 0;

					if (columns > 0)
					{
						div_t div = std::div(selected_index, columns);
						current_col = div.rem;
					}

					if (keycode == KeyAction::Id::UP)
					{
						uint8_t next_index = (selected_index - COLUMNS < 0 ? (selected_index - COLUMNS) + rows * COLUMNS : selected_index - COLUMNS);

						if (next_index == selected_character)
							return;

						if (next_index >= index_total)
							button_pressed(next_index - COLUMNS + Buttons::CHARACTER_SLOT0);
						else
							button_pressed(next_index + Buttons::CHARACTER_SLOT0);
					}
					else if (keycode == KeyAction::Id::DOWN)
					{
						uint8_t next_index = (selected_index + COLUMNS >= index_total ? current_col : selected_index + COLUMNS);

						if (next_index == selected_character)
							return;

						if (next_index > index_total)
							button_pressed(next_index + COLUMNS + Buttons::CHARACTER_SLOT0);
						else
							button_pressed(next_index + Buttons::CHARACTER_SLOT0);
					}
					else if (keycode == KeyAction::Id::LEFT)
					{
						if (selected_index != 0)
						{
							selected_index--;

							if (selected_index >= (selected_page + 1) * PAGESIZE - PAGESIZE)
								button_pressed(selected_index + Buttons::CHARACTER_SLOT0);
							else
								button_pressed(Buttons::BtPageL);
						}
					}
					else if (keycode == KeyAction::Id::RIGHT)
					{
						if (selected_index != characters_count - 1)
						{
							selected_index++;

							if (selected_index < index_total)
								button_pressed(selected_index + Buttons::CHARACTER_SLOT0);
							else
								button_pressed(Buttons::BtPageR);
						}
					}
				}
			}
		}
	}

	UIElement::Type UICharSelect::get_type() const
	{
		return TYPE;
	}

	void UICharSelect::add_character(CharEntry&& character)
	{
		charlooks.emplace_back(character.look);
		nametags.emplace_back(nametag, Text::Font::A13M, character.stats.name);
		characters.emplace_back(std::forward<CharEntry>(character));

		characters_count++;
	}

	void UICharSelect::post_add_character()
	{
		bool page_matches = (characters_count - 1) / PAGESIZE == selected_page;

		if (!page_matches)
			button_pressed(Buttons::BtPageR);

		update_buttons();

		if (characters_count > 1)
			select_last_slot();
		else
			update_selected_character();

		makeactive();

		charslotlabel.change_text(get_slot_text());
	}

	void UICharSelect::remove_character(int32_t id)
	{
		for (size_t i = 0; i < characters.size(); i++)
		{
			if (characters[i].id == id)
			{
				charlooks.erase(charlooks.begin() + i);
				nametags.erase(nametags.begin() + i);
				characters.erase(characters.begin() + i);

				characters_count--;

				charslotlabel.change_text(get_slot_text());

				if (selected_page > 0)
				{
					bool page_matches = (characters_count - 1) / PAGESIZE == selected_page;

					if (!page_matches)
						button_pressed(Buttons::BtPageL);
				}

				update_buttons();

				if (selected_character < characters_count)
					update_selected_character();
				else
					select_last_slot();

				return;
			}
		}
	}

	const CharEntry& UICharSelect::get_character(int32_t id)
	{
		for (CharEntry& character : characters)
			if (character.id == id)
				return character;

		LOG(LOG_DEBUG, "Invalid character id: [" << id << "]");

		static const CharEntry null_character = { {}, {}, 0 };

		return null_character;
	}

	Button::State UICharSelect::button_pressed(uint16_t buttonid)
	{
		switch (buttonid)
		{
			case Buttons::BtSelect:
			{
				if (characters.size() > 0)
				{
					Setting<DefaultCharacter>::get().save(selected_character);
					int32_t id = characters[selected_character].id;

					switch (require_pic)
					{
						case 0:
						{
							std::function<void()> onok = [&]()
							{
								request_pic();
							};

							UI::get().emplace<UILoginNotice>(UILoginNotice::Message::PIC_REQ, onok);
							break;
						}
						case 1:
						{
							std::function<void(const std::string&)> onok = [id](const std::string& pic)
							{
								SelectCharPicPacket(pic, id).dispatch();
							};

							UI::get().emplace<UISoftKey>(onok);
							break;
						}
						case 2:
						{
							SelectCharPacket(id).dispatch();
							break;
						}
					}
				}

				break;
			}
			case Buttons::BtNew:
			{
				Sound(Sound::Name::SCROLLUP).play();

				deactivate();

				tab_index = 0;
				tab_active = false;
				tab_move = false;
				tab_move_pos = 0;

				// v83/v87: Skip race selection, go directly to explorer creation
				UI::get().emplace<UIExplorerCreation>();
				break;
			}
			case Buttons::BtDelete:
			{
				int32_t id = characters[selected_character].id;

				switch (require_pic)
				{
					case 0:
					{
						std::function<void()> onok = [&]()
						{
							charslotlabel.change_text(get_slot_text());
						};

						UI::get().emplace<UILoginNotice>(UILoginNotice::Message::CHAR_DEL_FAIL_NO_PIC, onok);
						break;
					}
					case 1:
					{
						std::function<void()> oncancel = [&]()
						{
							charslotlabel.change_text(get_slot_text());
						};

						std::function<void()> onok = [&, id, oncancel]()
						{
							std::function<void(const std::string&)> onok = [&, id](const std::string& pic)
							{
								DeleteCharPicPacket(pic, id).dispatch();
							};

							UI::get().emplace<UISoftKey>(onok, oncancel);
						};

						const StatsEntry& character_stats = characters[selected_character].stats;
						uint16_t cjob = character_stats.stats[MapleStat::Id::JOB];

						if (cjob < 1000)
							UI::get().emplace<UILoginNotice>(UILoginNotice::Message::DELETE_CONFIRMATION, onok, oncancel);
						else
							UI::get().emplace<UILoginNotice>(UILoginNotice::Message::CASH_ITEMS_CONFIRM_DELETION, onok, oncancel);

						break;
					}
					case 2:
					{
						DeleteCharPacket(id).dispatch();
						break;
					}
				}

				break;
			}
			case Buttons::BtPageL:
			{
				uint8_t previous_page = selected_page;

				if (selected_page > 0)
					selected_page--;
				else
					selected_page = page_count - 1;

				if (previous_page != selected_page)
					update_buttons();

				select_last_slot();
				break;
			}
			case Buttons::BtPageR:
			{
				uint8_t previous_page = selected_page;

				if (selected_page < page_count - 1)
					selected_page++;
				else
					selected_page = 0;

				if (previous_page != selected_page)
				{
					update_buttons();

					button_pressed(Buttons::CHARACTER_SLOT0);
				}

				break;
			}
			case Buttons::BtChangePIC:
			{
				break;
			}
			case Buttons::BtResetPIC:
			{
				std::string url = Configuration::get().get_resetpic();

				ShellExecuteA(NULL, "open", url.c_str(), NULL, NULL, SW_SHOWNORMAL);
				break;
			}
			case Buttons::BtCharacter:
			{
				break;
			}
			case Buttons::BtPreview:
			{
				deactivate();

				Sound(Sound::Name::SCROLLUP).play();

				if (auto worldselect = UI::get().get_element<UIWorldSelect>())
					worldselect->makeactive();

				break;
			}
			default:
			{
				if (buttonid >= Buttons::CHARACTER_SLOT0)
				{
					uint8_t previous_character = selected_character;
					selected_character = buttonid - Buttons::CHARACTER_SLOT0 + selected_page * PAGESIZE;

					if (previous_character != selected_character)
					{
						if (previous_character < characters_count)
						{
							charlooks[previous_character].set_stance(Stance::Id::STAND1);
							nametags[previous_character].set_selected(false);
						}

						if (selected_character < characters_count)
							update_selected_character();
					}
				}

				break;
			}
		}

		return Button::State::NORMAL;
	}

	void UICharSelect::update_buttons()
	{
		for (uint8_t i = 0; i < PAGESIZE; i++)
		{
			uint8_t index = i + selected_page * PAGESIZE;

			if (index < characters_count)
				buttons[Buttons::CHARACTER_SLOT0 + i]->set_state(Button::State::NORMAL);
			else
				buttons[Buttons::CHARACTER_SLOT0 + i]->set_state(Button::State::DISABLED);
		}

		if (characters_count >= slots)
			buttons[Buttons::BtNew]->set_state(Button::State::DISABLED);
		else
			buttons[Buttons::BtNew]->set_state(Button::State::NORMAL);

		bool character_found = false;

		for (int8_t i = PAGESIZE - 1; i >= 0; i--)
		{
			uint8_t index = i + selected_page * PAGESIZE;

			if (index < characters_count)
			{
				character_found = true;

				break;
			}
		}

		buttons[Buttons::BtSelect]->set_active(character_found);
		buttons[Buttons::BtDelete]->set_state(character_found ? Button::State::NORMAL : Button::State::DISABLED);
	}

	void UICharSelect::update_selected_character()
	{
		Sound(Sound::Name::CHARSELECT).play();

		if (charlooks.size() > selected_character)
		{
			charlooks[selected_character].set_stance(Stance::Id::WALK1);
			nametags[selected_character].set_selected(true);

			const StatsEntry& character_stats = characters[selected_character].stats;

			namelabel.change_text(character_stats.name);

			for (size_t i = 0; i < InfoLabel::NUM_LABELS; i++)
				infolabels[i].change_text(get_infolabel(i, character_stats));
		}
	}

	void UICharSelect::select_last_slot()
	{
		for (int8_t i = PAGESIZE - 1; i >= 0; i--)
		{
			uint8_t index = i + selected_page * PAGESIZE;

			if (index < characters_count)
			{
				button_pressed(i + Buttons::CHARACTER_SLOT0);

				return;
			}
		}
	}

	std::string UICharSelect::get_slot_text()
	{
		if (use_timestamp)
		{
			show_timestamp = true;
			timestamp = 7 * 1000;
			charslot_y = 0;
		}

		return pad_number_with_leading_zero(characters_count) + "/" + pad_number_with_leading_zero(slots);
	}

	std::string UICharSelect::pad_number_with_leading_zero(uint8_t value) const
	{
		std::string return_val = std::to_string(value);
		
		// Only pad if the string is shorter than 2 characters
		if (return_val.length() < 2) {
			return_val.insert(return_val.begin(), 2 - return_val.length(), '0');
		}

		return return_val;
	}

	Point<int16_t> UICharSelect::get_character_slot_pos(size_t index) const
	{
		int16_t x = avatarSpace.x() * (index % 6);
		int16_t y = avatarSpace.y() * (index > 5);

		return Point<int16_t>(x, y) + avatarLT;
	}

	Point<int16_t> UICharSelect::get_infolabel_pos(size_t index) const
	{
		switch (index)
		{
			case InfoLabel::JOB:
				return jobPos;
			case InfoLabel::STR:
				return statSTRPos;
			case InfoLabel::DEX:
				return statDEXPos;
			case InfoLabel::INT:
				return statINTPos;
			case InfoLabel::LUK:
				return statLUKPos;
			case InfoLabel::NUM_LABELS:
			default:
				break;
		}

		return Point<int16_t>();
	}

	std::string UICharSelect::get_infolabel(size_t index, StatsEntry character_stats) const
	{
		switch (index)
		{
			case InfoLabel::JOB:
				return Job(character_stats.stats[MapleStat::Id::JOB]).get_name();
			case InfoLabel::STR:
				return std::to_string(character_stats.stats[MapleStat::Id::STR]);
			case InfoLabel::DEX:
				return std::to_string(character_stats.stats[MapleStat::Id::DEX]);
			case InfoLabel::INT:
				return std::to_string(character_stats.stats[MapleStat::Id::INT]);
			case InfoLabel::LUK:
				return std::to_string(character_stats.stats[MapleStat::Id::LUK]);
			case InfoLabel::NUM_LABELS:
				break;
			default:
				break;
		}

		return "";
	}

	void UICharSelect::request_pic()
	{
		std::function<void(const std::string&)> enterpic = [&](const std::string& entered_pic)
		{
			std::function<void(const std::string&)> verifypic = [&, entered_pic](const std::string& verify_pic)
			{
				if (entered_pic == verify_pic)
				{
					RegisterPicPacket(
						characters[selected_character].id,
						entered_pic
					).dispatch();
				}
				else
				{
					std::function<void()> onreturn = [&]()
					{
						request_pic();
					};

					UI::get().emplace<UILoginNotice>(UILoginNotice::Message::PASSWORD_IS_INCORRECT, onreturn);
				}
			};

			UI::get().emplace<UISoftKey>(verifypic, []() {}, "Please re-enter your new PIC.", Point<int16_t>(24, 0));
		};

		UI::get().emplace<UISoftKey>(enterpic, []() {}, "Your new PIC must at least be 6 characters long.", Point<int16_t>(24, 0));
	}
}
</file>

<file path="IO/UITypes/UICygnusCreation.h">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "UICommonCreation.h"

namespace ms
{
	class UICygnusCreation : public UICommonCreation
	{
	public:
		UICygnusCreation() : UICommonCreation("1000") {}
	};
}
</file>

<file path="IO/UITypes/UIExplorerCreation.h">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "UICommonCreation.h"

namespace ms
{
	class UIExplorerCreation : public UICommonCreation
	{
	public:
		UIExplorerCreation() : UICommonCreation("000") {}
	};
}
</file>

<file path="IO/UITypes/UIRaceSelect.cpp">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#include "UIRaceSelect.h"

#include "UIAranCreation.h"
#include "UICharSelect.h"
#include "UICygnusCreation.h"
#include "UIExplorerCreation.h"
#include "UILoginNotice.h"
#include "UIWorldSelect.h"

#include "../UI.h"

#include "../Components/AreaButton.h"
#include "../Components/MapleButton.h"

#include "../../Configuration.h"

#include "../../Audio/Audio.h"
#include "../../Util/Misc.h"

#ifdef USE_NX
#include <nlnx/nx.hpp>
#endif

namespace ms
{
	UIRaceSelect::UIRaceSelect() : UIElement(Point<int16_t>(0, 0), Point<int16_t>(800, 600))
	{
		std::string version_text = Configuration::get().get_version();
		version = Text(Text::Font::A12B, Text::Alignment::LEFT, Color::Name::LEMONGRASS, "Ver. " + version_text);
		version_pos = nl::nx::UI["Login.img"]["Common"]["version"]["pos"];

		nl::node Login = nl::nx::UI["Login.img"];
		nl::node Common = Login["Common"];
		nl::node RaceSelect = Login["RaceSelect"];

		// v83/v87 structure doesn't have make/pos nodes, use defaults
		pos = Point<int16_t>(400, 300);
		posZero = Point<int16_t>(400, 300);

		NDEBUG("UIRaceSelect constructor starting - v83/v87 structure");
		
		// v83/v87 doesn't have order node, use hardcoded available classes
		order.push_back(Classes::EXPLORERS);   // maps to "normal"
		order.push_back(Classes::CYGNUSKNIGHTS); // maps to "knight" 
		order.push_back(Classes::ARAN);        // maps to "aran"
				
		NDEBUG("order vector size (hardcoded for v83/v87): " << order.size());

		// v83/v87 structure doesn't have these nodes, skip them
		NDEBUG("Skipping hotlist/newlist/bgm nodes - not available in v83/v87");

		// Initialize class indices safely
		for (size_t i = 0; i < 6; i++) {
			if (i < order.size()) {
				class_index[i] = order[i];
			} else {
				class_index[i] = 0; // Default value if order doesn't have enough elements
			}
		}

		mouseover[0] = true;
		mouseover[1] = false;
		mouseover[2] = false;
		mouseover[3] = false;
		mouseover[4] = false;
		mouseover[5] = false;

		// v83/v87 structure: Use defaults for missing button nodes
		buttonIntervalX = 100; // Default spacing
		buttonPos = Point<int16_t>(50, 200); // Default position

		class_count = order.size();
		class_isdisabled = std::vector<bool>(class_count, false);
		class_disabled = std::vector<BoolPair<Texture>>(class_count);
		class_normal = std::vector<BoolPair<Texture>>(class_count);
		class_background = std::vector<Texture>(class_count);
		class_details = std::vector<Texture>(class_count);
		class_title = std::vector<Texture>(class_count);
		class_map = std::vector<uint16_t>(class_count);
		
		// Initialize class_isdisabled vector with proper size (CHASE is the last enum value)
		class_isdisabled = std::vector<bool>(Classes::CHASE + 1, false); // Size to accommodate all classes
		
		NDEBUG("Initializing class_isdisabled with size " << (Classes::CHASE + 1));
		class_isdisabled[Classes::EXPLORERS] = false;
		class_isdisabled[Classes::CYGNUSKNIGHTS] = false;
		class_isdisabled[Classes::ARAN] = false;

		// v83/v87 structure: Skip background nodes that don't exist
		NDEBUG("Skipping background nodes - using RaceSelect states directly");

		// v83/v87 structure: Set up class mapping directly for available states
		class_map[0] = Classes::EXPLORERS;   // "normal"
		class_map[1] = Classes::CYGNUSKNIGHTS; // "knight"
		class_map[2] = Classes::ARAN;        // "aran"

		// v83/v87 structure: Use available RaceSelect states for textures
		for (uint16_t i = 0; i < class_count; i++)
		{
			if (i == 0) { // EXPLORERS -> "normal"
				if (RaceSelect["normal"]) {
					class_normal[i][false] = RaceSelect["normal"];
					class_normal[i][true] = RaceSelect["normal"];
				}
			}
			else if (i == 1) { // CYGNUSKNIGHTS -> "knight"
				if (RaceSelect["knight"]) {
					class_normal[i][false] = RaceSelect["knight"];
					class_normal[i][true] = RaceSelect["knight"];
				}
			}
			else if (i == 2) { // ARAN -> "aran"
				if (RaceSelect["aran"]) {
					class_normal[i][false] = RaceSelect["aran"];
					class_normal[i][true] = RaceSelect["aran"];
				}
			}
		}

		// v83/v87 structure: Create buttons with available nodes only
		if (Common["BtStart"]) {
			buttons[Buttons::BtStart] = std::make_unique<MapleButton>(Common["BtStart"], Point<int16_t>(0, 1));
		}
		if (Common["BtPreview"]) {
			buttons[Buttons::BtPreview] = std::make_unique<MapleButton>(Common["BtPreview"]);
		}
		if (RaceSelect["BtSelect"]) {
			buttons[Buttons::BtMake] = std::make_unique<MapleButton>(RaceSelect["BtSelect"]);
		}
		// Skip left/right arrows - not available in v83/v87 structure

		// v83/v87 structure: Create area buttons with default dimensions
		for (size_t i = 0; i < class_count; i++) {
			Point<int16_t> default_dimensions(100, 50); // Default button size
			if (class_normal[0][true].is_valid()) {
				default_dimensions = class_normal[0][true].get_dimensions();
			}
			buttons[Buttons::CLASS0 + i] = std::make_unique<AreaButton>(get_class_pos(i), default_dimensions);
		}

		index_shift = 0;
		selected_index = 0;
		selected_class = class_index[selected_index];

		buttons[Buttons::BtLeftArrow]->set_state(Button::State::DISABLED);

		Sound(Sound::Name::RACESELECT).play();
	}

	void UIRaceSelect::draw(float inter) const
	{
		uint16_t corrected_index = get_corrected_class_index(selected_class);

		if (selected_class == Classes::ZERO)
			backZero.draw(position);
		else
			back.draw(position);

		UIElement::draw_sprites(inter);

		version.draw(position + version_pos - Point<int16_t>(0, 5));

		class_background[corrected_index].draw(position);

		if (selected_class == Classes::ZERO)
			class_details_backgroundZero.draw(position);
		else
			class_details_background.draw(position);

		class_details[corrected_index].draw(position);
		class_title[corrected_index].draw(position);

		for (nl::node node : hotlist)
		{
			if (node.get_integer() == selected_class)
			{
				if (selected_class == Classes::ZERO)
					hotlabelZero.draw(position, inter);
				else
					hotlabel.draw(position, inter);

				break;
			}
		}

		for (nl::node node : newlist)
		{
			if (node.get_integer() == selected_class)
			{
				newlabel.draw(position - Point<int16_t>(1, 0), inter);
				break;
			}
		}

		for (uint16_t i = 0; i < INDEX_COUNT; i++)
		{
			uint16_t cur_index = class_index[i];
			uint16_t cur_class = get_corrected_class_index(cur_index);

			bool selected = mouseover[i];
			bool disabled = class_isdisabled[cur_class];
			auto& found_class = disabled ? class_disabled : class_normal;
			Point<int16_t> button_pos = get_class_pos(i);
			Point<int16_t> pos_adj = (disabled && !selected) ? Point<int16_t>(0, 2) : Point<int16_t>(0, 0);
			found_class[cur_class][selected].draw(position + button_pos + pos_adj);

			for (nl::node node : hotlist)
			{
				if (node.get_integer() == cur_index)
				{
					hotbtn.draw(position + button_pos + hotbtnPos, inter);
					break;
				}
			}

			for (nl::node node : newlist)
			{
				if (node.get_integer() == cur_index)
				{
					newbtn.draw(position + button_pos + newbtnPos, inter);
					break;
				}
			}
		}

		nl::node dot_pos = Back2[corrected_index]["dot"];

		if (dot_pos)
		{
			dot.draw(DrawArgument(dot_pos["pos_ctrl"][dot_pos["ctrl"]]));
			dot.draw(DrawArgument(dot_pos["pos_def"][dot_pos["def"]]));
			dot.draw(DrawArgument(dot_pos["pos_pow"][dot_pos["pow"]]));
			dot.draw(DrawArgument(dot_pos["pos_spd"][dot_pos["spd"]]));
		}

		UIElement::draw_buttons(inter);

		back_ani.draw(position, inter);
	}

	void UIRaceSelect::update()
	{
		UIElement::update();

		hotlabel.update();
		hotlabelZero.update();
		newlabel.update();
		hotbtn.update();
		newbtn.update();

		if (selected_class == Classes::ZERO)
			buttons[Buttons::BtMake]->set_position(position + posZero);
		else
			buttons[Buttons::BtMake]->set_position(position + pos);

		back_ani.update();
	}

	Cursor::State UIRaceSelect::send_cursor(bool clicked, Point<int16_t> cursorpos)
	{
		for (auto& btit : buttons)
		{
			if (btit.second->is_active() && btit.second->bounds(position).contains(cursorpos))
			{
				if (btit.second->get_state() == Button::State::NORMAL)
				{
					Sound(Sound::Name::BUTTONOVER).play();

					if (btit.first >= Buttons::CLASS0)
						mouseover[btit.first - Buttons::CLASS0] = true;

					btit.second->set_state(Button::State::MOUSEOVER);
				}
				else if (btit.second->get_state() == Button::State::MOUSEOVER)
				{
					if (clicked)
					{
						Sound(Sound::Name::BUTTONCLICK).play();

						btit.second->set_state(button_pressed(btit.first));
					}
					else
					{
						if (btit.first >= Buttons::CLASS0)
							mouseover[btit.first - Buttons::CLASS0] = true;
					}
				}
			}
			else if (btit.second->get_state() == Button::State::MOUSEOVER)
			{
				if (btit.first >= Buttons::CLASS0)
					mouseover[btit.first - Buttons::CLASS0] = false;

				btit.second->set_state(Button::State::NORMAL);
			}
		}

		return Cursor::State::LEAF;
	}

	void UIRaceSelect::send_key(int32_t keycode, bool pressed, bool escape)
	{
		if (pressed)
		{
			if (escape)
			{
				show_charselect();
			}
			else if (keycode == KeyAction::Id::LEFT || keycode == KeyAction::Id::DOWN)
			{
				if (buttons[Buttons::BtLeftArrow]->get_state() == Button::State::NORMAL)
					button_pressed(Buttons::BtLeftArrow);
			}
			else if (keycode == KeyAction::Id::RIGHT || keycode == KeyAction::Id::UP)
			{
				if (buttons[Buttons::BtRightArrow]->get_state() == Button::State::NORMAL)
					button_pressed(Buttons::BtRightArrow);
			}
			else if (keycode == KeyAction::Id::RETURN)
			{
				button_pressed(Buttons::BtMake);
			}
		}
	}

	UIElement::Type UIRaceSelect::get_type() const
	{
		return TYPE;
	}

	bool UIRaceSelect::check_name(std::string name) const
	{
		nl::node ForbiddenName = nl::nx::Etc["ForbiddenName.img"];

		for (std::string forbiddenName : ForbiddenName)
		{
			std::string lName = to_lower(name);
			std::string fName = to_lower(forbiddenName);

			if (lName.find(fName) != std::string::npos)
				return false;
		}

		return true;
	}

	void UIRaceSelect::send_naming_result(bool nameused)
	{
		if (selected_class == Classes::EXPLORERS)
		{
			if (auto explorercreation = UI::get().get_element<UIExplorerCreation>())
				explorercreation->send_naming_result(nameused);
		}
		else if (selected_class == Classes::CYGNUSKNIGHTS)
		{
			if (auto cygnuscreation = UI::get().get_element<UICygnusCreation>())
				cygnuscreation->send_naming_result(nameused);
		}
		else if (selected_class == Classes::ARAN)
		{
			if (auto arancreation = UI::get().get_element<UIAranCreation>())
				arancreation->send_naming_result(nameused);
		}
	}

	Button::State UIRaceSelect::button_pressed(uint16_t buttonid)
	{
		if (buttonid == Buttons::BtStart)
		{
			show_worldselect();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtPreview)
		{
			show_charselect();

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtMake)
		{
			uint16_t corrected_index = get_corrected_class_index(selected_class);

			std::function<void()> okhandler = [&, corrected_index]()
			{
				if (!class_isdisabled[corrected_index])
				{
					Sound(Sound::Name::SCROLLUP).play();

					deactivate();

					if (selected_class == Classes::EXPLORERS)
						UI::get().emplace<UIExplorerCreation>();
					else if (selected_class == Classes::CYGNUSKNIGHTS)
						UI::get().emplace<UICygnusCreation>();
					else if (selected_class == Classes::ARAN)
						UI::get().emplace<UIAranCreation>();
				}
			};

			UI::get().emplace<UIClassConfirm>(selected_class, class_isdisabled[corrected_index], okhandler);

			return Button::State::NORMAL;
		}
		else if (buttonid == Buttons::BtLeftArrow)
		{
			uint16_t new_index = selected_index - 1;

			if (selected_index - index_shift == 0)
			{
				index_shift--;

				class_index[0] = order[new_index + 5 - Buttons::CLASS0];
				class_index[1] = order[new_index + 6 - Buttons::CLASS0];
				class_index[2] = order[new_index + 7 - Buttons::CLASS0];
				class_index[3] = order[new_index + 8 - Buttons::CLASS0];
				class_index[4] = order[new_index + 9 - Buttons::CLASS0];
				class_index[5] = order[new_index + 10 - Buttons::CLASS0];
			}

			select_class(new_index);

			return Button::State::IDENTITY;
		}
		else if (buttonid == Buttons::BtRightArrow)
		{
			uint16_t new_index = selected_index + 1;
			uint16_t selected = class_index[selected_index - index_shift];

			if (selected == class_index[5])
			{
				index_shift++;

				class_index[0] = order[new_index + 0 - Buttons::CLASS0];
				class_index[1] = order[new_index + 1 - Buttons::CLASS0];
				class_index[2] = order[new_index + 2 - Buttons::CLASS0];
				class_index[3] = order[new_index + 3 - Buttons::CLASS0];
				class_index[4] = order[new_index + 4 - Buttons::CLASS0];
				class_index[5] = order[new_index + 5 - Buttons::CLASS0];
			}

			select_class(new_index);

			return Button::State::IDENTITY;
		}
		else if (buttonid >= Buttons::CLASS0)
		{
			uint16_t index = buttonid - Buttons::CLASS0 + index_shift;

			select_class(index);

			return Button::State::IDENTITY;
		}
		else
		{
			return Button::State::DISABLED;
		}
	}

	void UIRaceSelect::select_class(uint16_t index)
	{
		uint16_t previous_index = selected_index;
		selected_index = index;

		if (previous_index != selected_index)
		{
			Sound(Sound::Name::RACESELECT).play();

			uint16_t previous = previous_index - index_shift;

			mouseover[previous] = false;
			buttons[previous + Buttons::CLASS0]->set_state(Button::State::NORMAL);

			uint16_t selected = selected_index - index_shift;

			selected_class = class_index[selected];
			mouseover[selected] = true;

			if (selected_class == Classes::KINESIS)
			{
				nl::node node = bgm[selected_class];
				std::string found_bgm = node["bgm"];
				std::size_t found_img = found_bgm.find(".img");

				if (found_img == std::string::npos)
				{
					std::size_t found_slash = found_bgm.find('/');

					if (found_slash != std::string::npos)
					{
						found_bgm.insert(found_slash, ".img");

						Music(found_bgm).play();
					}
				}
			}
			else if (class_index[previous] == Classes::KINESIS)
			{
				std::string LoginMusicNewtro = Configuration::get().get_login_music_newtro();

				Music(LoginMusicNewtro).play();
			}
		}
		else
		{
			button_pressed(Buttons::BtMake);
		}

		if (selected_index > 0)
			buttons[Buttons::BtLeftArrow]->set_state(Button::State::NORMAL);
		else
			buttons[Buttons::BtLeftArrow]->set_state(Button::State::DISABLED);

		if (selected_index < order.size() - 1)
			buttons[Buttons::BtRightArrow]->set_state(Button::State::NORMAL);
		else
			buttons[Buttons::BtRightArrow]->set_state(Button::State::DISABLED);
	}

	void UIRaceSelect::show_charselect()
	{
		Sound(Sound::Name::SCROLLUP).play();

		UI::get().remove(UIElement::Type::RACESELECT);

		if (auto charselect = UI::get().get_element<UICharSelect>())
			charselect->makeactive();
	}

	void UIRaceSelect::show_worldselect()
	{
		Sound(Sound::Name::SCROLLUP).play();

		UI::get().remove(UIElement::Type::RACESELECT);
		UI::get().remove(UIElement::Type::CHARSELECT);

		if (auto worldselect = UI::get().get_element<UIWorldSelect>())
			worldselect->makeactive();
	}

	Point<int16_t> UIRaceSelect::get_class_pos(size_t index) const
	{
		uint16_t x_adj = index * buttonIntervalX;

		return buttonPos + Point<int16_t>(x_adj, 0);
	}

	std::string UIRaceSelect::to_lower(std::string value) const
	{
		std::transform(value.begin(), value.end(), value.begin(), ::tolower);

		return value;
	}

	uint16_t UIRaceSelect::get_corrected_class_index(uint16_t index) const
	{
		for (uint16_t i = 0; i < class_count; i++)
			if (index == class_map[i])
				return i;

		LOG(LOG_DEBUG, "Failed to find corrected class index");

		return index;
	}
}
</file>

<file path="IO/UITypes/UIRaceSelect.h">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../UIElement.h"

#include "../Components/Textfield.h"

#include "../../Template/BoolPair.h"

namespace ms
{
	// Race selection screen
	class UIRaceSelect : public UIElement
	{
	public:
		static constexpr Type TYPE = UIElement::Type::RACESELECT;
		static constexpr bool FOCUSED = false;
		static constexpr bool TOGGLED = false;

		UIRaceSelect();

		void draw(float inter) const override;
		void update() override;

		Cursor::State send_cursor(bool clicked, Point<int16_t> cursorpos) override;
		void send_key(int32_t keycode, bool pressed, bool escape) override;

		UIElement::Type get_type() const override;

		bool check_name(std::string name) const;
		void send_naming_result(bool nameused);

	protected:
		Button::State button_pressed(uint16_t buttonid) override;

	private:
		void select_class(uint16_t index);
		void show_charselect();
		void show_worldselect();
		Point<int16_t> get_class_pos(size_t index) const;
		std::string to_lower(std::string value) const;
		uint16_t get_corrected_class_index(uint16_t index) const;

		static constexpr uint16_t INDEX_COUNT = 6;
		static constexpr uint16_t SELECTED_LIST = 35;

		enum Buttons : uint16_t
		{
			BtStart,
			BtPreview,
			BtMake,
			BtLeftArrow,
			BtRightArrow,
			CLASS0,
			CLASS1,
			CLASS2,
			CLASS3,
			CLASS4
		};

		enum Classes : uint16_t
		{
			RESISTANCE,
			EXPLORERS,
			CYGNUSKNIGHTS,
			ARAN,
			EVAN,
			MERCEDES,
			DEMON,
			PHANTOM,
			DUALBLADE,
			MIHILE,
			LUMINOUS,
			KAISER,
			ANGELICBUSTER,
			CANNONEER,
			XENON,
			ZERO,
			SHADE,
			PINKBEAN,
			KINESIS,
			CADENA,
			ILLIUM,
			ARK,
			PATHFINDER,
			HOYOUNG,
			ADELE,
			KAIN,
			YETI,
			LARA,
			JETT = 1000,
			HAYATO,
			KANNA,
			CHASE
		};

		Text version;
		Point<int16_t> version_pos;
		Point<int16_t> pos;
		Point<int16_t> posZero;
		std::vector<uint16_t> order;
		nl::node hotlist;
		nl::node newlist;
		nl::node bgm;
		nl::node Back2;
		Sprite hotlabel;
		Sprite hotlabelZero;
		Sprite newlabel;
		Point<int16_t> newlabelPos;
		Sprite hotbtn;
		Point<int16_t> hotbtnPos;
		Sprite newbtn;
		Point<int16_t> newbtnPos;
		uint16_t class_index[INDEX_COUNT];
		bool mouseover[INDEX_COUNT];
		uint16_t selected_class;
		uint16_t index_shift;
		uint16_t selected_index;
		uint16_t class_count;
		std::vector<bool> class_isdisabled;
		std::vector<BoolPair<Texture>> class_disabled;
		std::vector<BoolPair<Texture>> class_normal;
		std::vector<Texture> class_background;
		std::vector<Texture> class_details;
		std::vector<Texture> class_title;
		std::vector<uint16_t> class_map;
		Texture back;
		Texture backZero;
		Sprite back_ani;
		Texture class_details_background;
		Texture class_details_backgroundZero;
		Texture dot;
		int16_t buttonIntervalX;
		Point<int16_t> buttonPos;
	};
}
</file>

<file path="nx_structures/UI_compressed.txt">
UI.nx – compressed pattern form
Generated: 2025-07-13 19:55:24
Note: Use states & frames clauses to expand back to the original tree.

Basic.img
 ├─ BtCancel
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtCancel2
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtCancel3
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtClaim
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtClose
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtClose2
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtCoin
 │   states:{disabled,mouseOver,normal,pressed}
 │   anim:{1,4,1,1}
 ├─ BtComboBox
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtDecide
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtDel
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtDown
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtHide
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtHide2
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtHide3
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtMacro
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtMax
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtMax2
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtMin
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtMin2
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtNo
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtNo2
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtOK
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtOK2
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtOK3
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtQGiveup
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtReceive
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtSend
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtUP
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtYes
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtYes2
 │   states:{disabled,keyFocused,mouseOver,normal,pressed}
 │   frames:1
 ├─ ComboBox
 │   states:{disabled,mouseOver,normal,pressed,selected}
 │   frames:3
 ├─ ComboBox2
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ ComboBox3
 │   states:{disabled,mouseOver,normal,pressed,selected}
 │   frames:3
 ├─ ComboBox4
 │   states:{disabled,mouseOver,normal,pressed,selected}
 │   frames:3
 ├─ ComboBox5
 │   states:{disabled,mouseOver,normal,pressed,selected}
 │   frames:3
 ├─ Cursor
 │   states:{0,1,10,11,12,13,2,3,4,5,6,7,8,9}
 │   anim:{1,2,1,1,1,2,7,6,2,4,7,4,4,1}
 ├─ HScr
 │   states:{disabled,enabled}
 │   anim:{3,7}
 ├─ HScr2
 │   states:{disabled,enabled}
 │   anim:{3,7}
 ├─ HScr3
 │   states:{disabled,enabled}
 │   anim:{3,10}
 ├─ HScr4
 │   states:{disabled,enabled}
 │   anim:{3,10}
 ├─ HScr5
 │   states:{disabled,enabled}
 │   anim:{3,10}
 ├─ HScr6
 │   states:{disabled,enabled}
 │   anim:{3,7}
 ├─ ShowLevel
 │   states:{0,1,2,Bracket}
 │   anim:{11,11,11,1}

BuffIcon.img
 ├─ buff
 │   states:{incACC,incCraft,incEVA,incJump,incMAD,incMDD,incPAD,incPDD,incSpeed}
 │   frames:1
 ├─ united
 │   states:{anniversary,buff}
 │   frames:1

CashShop.img
 ├─ Base
 │   states:{Preview,PreviewOnOff,Tab,Tab2}
 │   anim:{3,2,6,10}
 ├─ CSChangeName
 │   states:{Base,BtCheck}
 │   anim:{2,4}
 ├─ CSChar
 │   states:{BtBuyAvatar,BtDefaultAvatar,BtTakeoffAvatar}
 │   frames:4
 ├─ CSEffect
 │   states:{effect,event,hot,new,sale,time}
 │   anim:{2,4,4,4,4,11}
 ├─ CSGift
 │   states:{BtBuddy,BtGuild,BtHide,Line}
 │   anim:{4,4,4,3}
 ├─ CSInventory
 │   states:{BtExConsume,BtExEquip,BtExEtc,BtExInstall,BtExTrunk}
 │   frames:4
 ├─ CSItemSearch
 │   states:{BtAllItem,BtBuy,BtCancel,BtSearch,PopUp,PopUp1}
 │   anim:{4,4,4,8,2,1}
 ├─ CSList
 │   states:{BtBuy,BtGift,BtRemove,BtReserve}
 │   frames:5
 ├─ CSLocker
 │   states:{BtRebate,BtRebate2}
 │   frames:4
 ├─ CSMemberShop
 │   states:{BtAgree,BtCancel,BtDisagree,BtOK,BtTested}
 │   frames:4
 ├─ CSNotice
 │   states:{0,1,2,3,4}
 │   anim:{5,1,1,1,5}
 ├─ CSStatus
 │   states:{BtCharge,BtCheck,BtCoupon,BtExit}
 │   frames:4
 ├─ CSTab
 │   states:{Tab}
 │   frames:9
 ├─ CSTransferWorld
 │   states:{Base}
 │   frames:2
 ├─ PicturePlate
 │   states:{BtClose,BtJoin,BtShortcut}
 │   frames:4

ChatBalloon.img
 ├─ 21
 │   states:{0,1,2}
 │   frames:10

GuildBBS.img
 ├─ GuildBBS
 │   states:{BtCancel,BtDelete,BtNotice,BtQuit,BtRegister,BtReply,BtReplyDelete,BtRetouch,BtWrite,Emoticon}
 │   anim:{4,4,4,4,4,4,4,4,4,12}

GuildMark.img
 ├─ BackGround
 │   states:{00001000,00001001,00001002,00001003,00001004,00001005,00001006,00001007,00001008,00001009,00001010,00001011,00001012,00001013,00001014,00001015,00001016,00001017,00001018,00001019,00001020,00001021,00001022,00001023,00001024,00001025,00001026,00001027,00001028,00001029,00001030}
 │   frames:15
 ├─ Mark
 │   states:{Animal,Etc,Letter,Pattern,Plant}
 │   anim:{225,225,225,225,105}

ITC.img
 ├─ Auction
 │   states:{BtBid}
 │   frames:4
 ├─ Base
 │   states:{Preview,Tab,Tab2}
 │   anim:{3,6,8}
 ├─ BtAuction
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtCharge
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtCheck
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtExit
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtSearch
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtSell
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ Buy
 │   states:{BtRegistration,BtSell,Item,Tab,backgrnd4}
 │   anim:{4,4,1,5,4}
 ├─ MyPage
 │   states:{BtBuy,BtBuy1,BtCancel,BtDelete,Tab}
 │   frames:4
 ├─ Sell
 │   states:{BtBuy,BtCancel,BtRegistration,BtShoppingBasket,Tab,check,down,up}
 │   anim:{4,4,4,4,5,1,4,4}
 ├─ Sort
 │   states:{Normal_Asc,Normal_Desc,Pressed_Asc,Pressed_Desc}
 │   frames:4

Login.img
 ├─ BtCancel
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtOk
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ CharSelect
 │   states:{BtDelete,BtNew,BtSelect,adventure,aran,character,effect,icon,knight,nameTag,pageL,pageR,scroll}
 │   anim:{10,10,10,1,1,9,11,9,1,6,2,2,16}
 ├─ Common
 │   states:{BtDisableSPW,BtEnableSPW,BtExit,BtStart,BtStart2,BtWselect,SoftKey,loginlocation,shadow,step}
 │   anim:{5,5,5,5,4,5,1,2,1,5}
 ├─ Gender
 │   states:{BtNo,BtYes,DropBox,backgrnd,scroll,text}
 │   anim:{4,4,3,3,6,2}
 ├─ NewChar
 │   states:{BtCheck,BtLeft,BtNo,BtRight,BtYes,avatarSel,dice,scroll}
 │   anim:{4,4,4,4,4,18,4,8}
 ├─ NewCharAran
 │   states:{BtCheck,BtLeft,BtNo,BtRight,BtYes,avatarSel,dice,scroll}
 │   anim:{4,4,4,4,4,18,4,8}
 ├─ NewCharKnight
 │   states:{BtCheck,BtLeft,BtNo,BtRight,BtYes,avatarSel,dice,scroll}
 │   anim:{4,4,4,4,4,18,4,8}
 ├─ Notice
 │   states:{BtExit,BtNexon,BtNo,BtNo1,BtRestart,BtYes,BtYes1,Loading,backgrnd,text}
 │   anim:{4,4,4,4,4,4,4,12,3,15}
 ├─ Pincode
 │   states:{BtChgPin,BtLogin,BtNo,BtYes,backgrnd,text}
 │   anim:{4,4,4,4,3,9}
 ├─ RaceSelect
 │   states:{BtSelect,aran,aran1,knight,normal,textGL}
 │   anim:{4,3,3,3,3,1}
 ├─ Title
 │   states:{BtEmailLost,BtEmailSave,BtGuestLogin,BtHomePage,BtLogin,BtLoginIDLost,BtLoginIDSave,BtNew,BtPasswdLost,BtQuit,check,effect}
 │   anim:{4,4,4,4,4,4,4,4,4,4,2,15}
 ├─ ViewAllChar
 │   states:{BtEnter,BtVAC,Job,Select,WorldIcons,backgrnd}
 │   anim:{4,4,1,6,15,4}
 ├─ WorldNotice
 │   states:{Balloon,BalloonForLoginProcess,Events,Populated}
 │   anim:{14,20,1,2}
 ├─ WorldSelect
 │   states:{BtGoworld,BtViewAll,BtViewChoice,BtWorld,alert,channel,scroll,world}
 │   anim:{7,4,4,1,1,30,8,15}

MapleTV.img
 ├─ TVmedia
 │   states:{0,1,2}
 │   frames:15

NameTag.img
 ├─ medal
 │   states:{0,1,10,11,12,13,14,15,16,17,18,19,2,20,21,22,23,24,25,26,27,28,29,3,30,31,32,33,34,4,40,41,42,43,44,45,46,47,48,49,5,50,51,52,53,54,55,56,57,58}
 │   frames:3
 ├─ pet
 │   states:{10,11,13,14,15,16,18,19,20,21,22,24,25,26,27,3,30,31,32,33,34,35,36,37,38,39,4,5,50,51,6,7,8,9}
 │   frames:3

StatusBar.img
 ├─ BtClaim
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtMenu
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtNPT
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtShop
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtShort
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtWhisper
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ EquipKey
 │   states:{ani,disabled,mouseOver,normal,pressed}
 │   anim:{2,1,1,1,1}
 ├─ InvenKey
 │   states:{ani,disabled,mouseOver,normal,pressed}
 │   anim:{2,1,1,1,1}
 ├─ KeySet
 │   states:{ani,disabled,mouseOver,normal,pressed}
 │   anim:{2,1,1,1,1}
 ├─ QuickSlot
 │   states:{ani,disabled,mouseOver,normal,pressed}
 │   anim:{2,1,1,1,1}
 ├─ QuickSlotD
 │   states:{ani,disabled,mouseOver,normal,pressed}
 │   anim:{2,1,1,1,1}
 ├─ SkillKey
 │   states:{ani,disabled,mouseOver,normal,pressed}
 │   anim:{2,1,1,1,1}
 ├─ StatKey
 │   states:{ani,disabled,mouseOver,normal,pressed}
 │   anim:{2,1,1,1,1}
 ├─ gauge
 │   states:{hpFlash,mpFlash}
 │   frames:5

UIWindow.img
 ├─ Admin
 │   states:{Block}
 │   frames:1
 ├─ AdminClaim
 │   states:{BtCClaim,BtCancel,BtClaim,BtPClaim}
 │   frames:4
 ├─ AranSkillGuide
 │   states:{BtClose}
 │   frames:4
 ├─ AriantMatch
 │   states:{Result,characterIcon}
 │   anim:{14,6}
 ├─ ArtMegaphone
 │   states:{BtEx,BtPreView}
 │   frames:4
 ├─ AvatarMegaphone
 │   states:{BtCancel,BtOk}
 │   frames:4
 ├─ Book
 │   states:{BtClose,BtNext,BtPrev}
 │   frames:4
 ├─ BtUIClose
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ BtUIClose2
 │   states:{disabled,mouseOver,normal,pressed}
 │   frames:1
 ├─ CancelRequests
 │   states:{AskContinueCancel,CancelCharacterTransfer,CancelNameChange}
 │   anim:{1,3,3}
 ├─ CashGachapon
 │   states:{BtClose,BtOpen,EffectJackpot,EffectNormal}
 │   anim:{4,4,15,15}
 ├─ CashTradingRoom
 │   states:{BtCancel,BtCoin,BtReset,BtTrade}
 │   anim:{4,7,4,4}
 ├─ Channel
 │   states:{BtCancel,BtChange,ch,world}
 │   anim:{4,4,15,15}
 ├─ CharacterClone
 │   states:{Archer,BtBack,BtCancel,BtFinish,BtLeft,BtNext,BtRight,Magician,Pirate,Thief,Warrior}
 │   anim:{2,4,4,4,4,4,4,2,2,2,2}
 ├─ Claim
 │   states:{BtCClaim,BtCancel,BtClaim,BtPClaim}
 │   frames:4
 ├─ ContextMenu
 │   states:{BtAlertGM,BtBlock,BtCashTrade,BtClaim,BtFamily,BtGuild,BtInfo,BtParty,BtSave,BtTrade,BtWhisper}
 │   frames:4
 ├─ Coupon
 │   states:{text}
 │   frames:2
 ├─ Delivery
 │   states:{Tab}
 │   frames:6
 ├─ DualMobGauge
 │   states:{Mob}
 │   frames:1
 ├─ EnchantSkill
 │   states:{Effect}
 │   frames:15
 ├─ EnergyBar
 │   states:{Gage,effect}
 │   anim:{2,7}
 ├─ EntrustedShop
 │   states:{BtArrange,BtArrange2,BtArrange_3,BtCoin}
 │   anim:{4,4,4,7}
 ├─ Equip
 │   states:{BtCashshop,BtDetail,BtPet1,BtPet2,BtPet3,BtPetEquipHide,BtPetEquipShow}
 │   anim:{14,4,4,4,4,4,4}
 ├─ EventWindow
 │   states:{backgrnd}
 │   frames:9
 ├─ ExceptionItemSearch
 │   states:{BtDelete,BtSave,BtSearch}
 │   frames:4
 ├─ FadeYesNo
 │   states:{BtCancel,BtOK,icon7}
 │   anim:{4,4,1}
 ├─ Family
 │   states:{BtClose,BtFamilyPrecept,BtJuniorEntry,BtLeft,BtOK,BtRight,BtSpecial,BtTree,RightIcon}
 │   anim:{4,4,4,4,4,4,4,4,5}
 ├─ FamilyTree
 │   states:{BtBye,BtClose,BtJuniorEntry,BtLeft,BtRight,PlateLeader,PlateOthers}
 │   anim:{4,4,4,4,4,2,2}
 ├─ FloatNotice
 │   states:{0,1,10,11,12,13,14,15,16,17,18,19,2,20,21,22,23,24,25,26,27,28,29,3,30,31,32,33,34,35,36,37,38,39,4,40,41,42,44,5,6,7,8,9}
 │   frames:3
 ├─ GMBoard
 │   states:{BtClose,Loading,NoticeIcon}
 │   anim:{4,5,10}
 ├─ GameMenu
 │   states:{BtChannel,BtGameOpt,BtQuit,BtSkin,BtSysOpt}
 │   frames:4
</file>

<file path="Template/Point.h">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "../MapleStory.h"

#ifdef USE_NX
#include <nlnx/node.hpp>
#else
#include "../Util/WzFiles.h"
#endif

namespace ms
{
	template <class T>
	class Point
	{
	public:
		// Construct a point from a vector property
		Point(nl::node src)
		{
			a = static_cast<T>(src.x());
			b = static_cast<T>(src.y());
		}

		// Construct a point from the specified coordinates
		constexpr Point(T first, T second) : a(first), b(second) {}

		// Construct a point with coordinates (0, 0)
		constexpr Point() : Point(0, 0) {}

		// Return the x-coordinate
		constexpr T x() const
		{
			return a;
		}

		// Return the y-coordinate
		constexpr T y() const
		{
			return b;
		}

		// Return the inner product
		constexpr T length() const
		{
			return static_cast<T>(
				std::sqrt(a * a + b * b)
				);
		}

		// Check whether the coordinates are equal
		constexpr bool straight() const
		{
			return a == b;
		}

		// Return a string representation of the point
		std::string to_string() const
		{
			return "(" + std::to_string(a) + "," + std::to_string(b) + ")";
		}

		// Return the distance to another point
		constexpr T distance(Point<T> v) const
		{
			return Point<T>(a - v.a, b - v.b).length();
		}

		// Set the x-coordinate
		void set_x(T v)
		{
			a = v;
		}

		// Set the y-coordinate
		void set_y(T v)
		{
			b = v;
		}

		// Shift the x-coordinate by the specified amount
		void shift_x(T v)
		{
			a += v;
		}

		// Shift the y-coordinate by the specified amount
		void shift_y(T v)
		{
			b += v;
		}

		// Shift the coordinates by the specified amounts
		void shift(T x, T y)
		{
			a += x;
			b += y;
		}

		// Shift the this point by the amounts defined by another point
		// Equivalent to += operator
		void shift(Point<T> v)
		{
			a += v.a;
			b += v.b;
		}

		// Take the absolute value of the point
		Point<T> abs()
		{
			return {
				static_cast<T>(std::abs(a)),
				static_cast<T>(std::abs(b))
			};
		}

		// Check whether point is equivalent to the specified point
		constexpr bool operator == (const Point<T>& v) const
		{
			return a == v.a && b == v.b;
		}

		// Check whether point is not equivalent to the specified point
		constexpr bool operator != (const Point<T>& v) const
		{
			return !(*this == v);
		}

		// Shift the this point by the amounts defined by another point
		void operator += (Point<T> v)
		{
			a += v.a;
			b += v.b;
		}

		// Shift the this point in reverse direction by the amounts defined by another point
		void operator -= (Point<T> v)
		{
			a -= v.a;
			b -= v.b;
		}

		// Return a point whose coordinates are the negation of this point's coordinates
		constexpr Point<T> operator - () const
		{
			return { -a, -b };
		}

		// Return a point whose coordinates have been added the specified amount
		constexpr Point<T> operator + (T v) const
		{
			return { a + v, b + v };
		}

		// Return a point whose coordinates have been subtracted the specified amount
		constexpr Point<T> operator - (T v) const
		{
			return { a - v, b - v };
		}

		// Return a point whose coordinates have been multiplied by the specified amount
		constexpr Point<T> operator * (T v) const
		{
			return { a * v, b * v };
		}

		// Return a point whose coordinates have been divided by the specified amount
		constexpr Point<T> operator / (T v) const
		{
			return { a / v, b / v };
		}

		// Return a point whose coordinates are the sum of this and another points coordinates
		constexpr Point<T> operator + (Point<T> v) const
		{
			return { a + v.a, b + v.b };
		}

		// Return a point whose coordinates are the difference of this and another points coordinates
		constexpr Point<T> operator - (Point<T> v) const
		{
			return { a - v.a, b - v.b };
		}

		// Return a point whose coordinates are the product of this and another points coordinates
		constexpr Point<T> operator * (Point<T> v) const
		{
			return { a / v.a, b / v.b };
		}

		// Return a point whose coordinates are the division of this and another points coordinates
		constexpr Point<T> operator / (Point<T> v) const
		{
			return {
				a / (v.a == 0 ? 1 : v.a),
				b / (v.b == 0 ? 1 : v.b)
			};
		}

	private:
		T a;
		T b;
	};
}
</file>

<file path="Template/Rectangle.h">
//////////////////////////////////////////////////////////////////////////////////
//	This file is part of the continued Journey MMORPG client					//
//	Copyright (C) 2015-2019  Daniel Allendorf, Ryan Payton						//
//																				//
//	This program is free software: you can redistribute it and/or modify		//
//	it under the terms of the GNU Affero General Public License as published by	//
//	the Free Software Foundation, either version 3 of the License, or			//
//	(at your option) any later version.											//
//																				//
//	This program is distributed in the hope that it will be useful,				//
//	but WITHOUT ANY WARRANTY; without even the implied warranty of				//
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the				//
//	GNU Affero General Public License for more details.							//
//																				//
//	You should have received a copy of the GNU Affero General Public License	//
//	along with this program.  If not, see <https://www.gnu.org/licenses/>.		//
//////////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Point.h"
#include "Range.h"

namespace ms
{
	template <class T>
	class Rectangle
	{
	public:
		Rectangle(nl::node sourceLeftTop, nl::node sourceRightBottom) : left_top(sourceLeftTop), right_bottom(sourceRightBottom) {}
		Rectangle(nl::node source) : left_top(source["lt"]), right_bottom(source["rb"]) {}

		constexpr Rectangle(Point<T> leftTop, Point<T> rightBottom) : left_top(leftTop), right_bottom(rightBottom) {}
		constexpr Rectangle(T left, T right, T top, T bottom) : left_top(left, top), right_bottom(right, bottom) {}
		constexpr Rectangle() {}

		constexpr T width() const
		{
			return std::abs(left() - right());
		}

		constexpr T height() const
		{
			return std::abs(top() - bottom());
		}

		constexpr T left() const
		{
			return left_top.x();
		}

		constexpr T top() const
		{
			return left_top.y();
		}

		constexpr T right() const
		{
			return right_bottom.x();
		}

		constexpr T bottom() const
		{
			return right_bottom.y();
		}

		constexpr bool contains(const Point<T>& v) const
		{
			return
				!straight() &&
				v.x() >= left() && v.x() <= right() &&
				v.y() >= top() && v.y() <= bottom();
		}

		constexpr bool overlaps(const Rectangle<T>& ar) const
		{
			return
				get_horizontal().overlaps(Range<T>(ar.left(), ar.right())) &&
				get_vertical().overlaps(Range<T>(ar.top(), ar.bottom()));
		}

		constexpr bool straight() const
		{
			return left_top == right_bottom;
		}

		constexpr bool empty() const
		{
			return left_top.straight() && right_bottom.straight() && straight();
		}

		constexpr const Point<T>& get_left_top() const
		{
			return left_top;
		}

		constexpr const Point<T>& get_right_bottom() const
		{
			return right_bottom;
		}

		constexpr Range<T> get_horizontal() const
		{
			return { left(), right() };
		}

		constexpr Range<T> get_vertical() const
		{
			return { top(), bottom() };
		}

		void shift(const Point<T>& v)
		{
			left_top = left_top + v;
			right_bottom = right_bottom + v;
		}

	private:
		Point<T> left_top;
		Point<T> right_bottom;
	};
}
</file>

</files>
