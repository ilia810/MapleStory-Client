Great, I’ll analyze the full save/load flow, pinpoint where and why corrupted map IDs are being stored, highlight any existing hardcoded defaults (and recommend removing them), and outline a robust fix strategy that avoids brittle workarounds.

I'll get back to you with a full report including causes, suggested architectural improvements, and critical null-check/mapping behaviors to audit or correct.


# Character Map Persistence Flow Analysis (MapleStory v83/v87 Hybrid)

## Overview of Map Persistence Flow

**Map Change (In-Game):** When a player triggers a map change (e.g. entering a portal), the client sends a change-map packet to the server. The server handles this in `ChangeMapHandler` by transferring the character to the new map and updating the character’s current map ID. In code, `Character.changeMapInternal()` is called, which sets the character’s `map` object to the new `MapleMap` and **updates the stored map ID** via `setMapId(to.getId())`. Immediately after a successful portal warp, the server calls `chr.saveCharToDB(false)` to persist the new location to the database. This flow ensures that during normal gameplay, map transitions update both the in-memory character state and (ideally) the database record promptly.

**Character Save to Database:** The method `Character.saveCharToDB()` is responsible for writing the character’s state (including map) to the MySQL database. It determines which map ID to save under various conditions:

* If the character is not currently in a map (e.g. during a transition or in the Cash Shop) then it falls back to the last known `mapid` field in memory. This is meant to use the last stable map ID when the actual `map` object isn’t active.
* Otherwise, if the current map has a **forced return map** (some special maps auto-send players to a safe map upon logout or death), it saves that forced return map ID.
* If no forced return applies, it checks if the player is dead (`getHp() < 1`); if so, it saves the map’s designated **return map** (the normal respawn town). In all other cases it saves the **current map’s ID**.

This logic means the *intended* saved map ID can sometimes differ from the map the player is physically in – for example, if you log off in an event map with a forcedReturn set, the server will save the forcedReturn map (often a town) instead of the event map itself. Finally, the chosen `mapToSave` is written to the DB (prepared statement `ps.setInt(21, mapToSave)`).

**Character Load (Login):** On login, the server reads the character’s saved map ID from the database and attempts to load that map. The code `Character.loadCharFromDB(..., channelserver=true)` will call `mapFactory.getMap(savedMapId)`. If the requested map data cannot be found (more on this below), the server does **not** throw an exception – instead `MapFactory.getMap()` returns `null`. The character is then assigned a fallback location. In `Character.loadCharFromDB` (for channel server context) and again in `Character.newClient()`, we see a **hardcoded fallback to Henesys** (`MapId.HENESYS`, which is 100000000) whenever the map load fails:

* In `loadCharFromDB`: if `ret.map` comes back null, the code sets `ret.map = mapManager.getMap(MapId.HENESYS)` (though notably it does **not** update `ret.mapid` in this method).
* In `Character.newClient()`: after the player object is fully associated with the new session, it logs the attempt to load the map and if `this.map` is null (indicating the map didn’t load), it logs an error and assigns `this.map = ...getMap(MapId.HENESYS)`, **also explicitly setting `this.mapid = MapId.HENESYS`** as a correction.

At this point, the server will send a **SetField** packet instructing the client to enter the map. Depending on the packet mode, the server may either include the map ID in the packet or rely on the client’s character stats. This brings us to the client side of the handshake.

**Client-Side Map Load:** The MapleStory client receives the SetField packet and uses it to transition the game stage to the new map. In the provided HeavenClient code, `SetFieldHandler::handle()` checks two mode bytes in the packet to decide how to proceed:

* If `mode1 == 0 && mode2 == 0`, it treats this as a standard **map change**. The handler reads the new map ID directly from the packet and a portal ID, then calls `change_map()` to transition. This likely corresponds to server-initiated warps (portals, teleports) where the server explicitly provides the destination.
* Otherwise (nonzero mode), it calls `set_field()` without reading a map ID from the packet. In this path, the client assumes it is re-entering the world (e.g. after login or channel change) and uses the character’s stored stats for map and portal. The code calls `player.get_stats().get_mapid()` and `get_portal()` to retrieve the last known map and spawn point. **This is where things go wrong if the stats contain an invalid map ID.**

## Root Causes of Map Persistence Failures

1. **Map Load Failures Due to Missing Data:** The primary cause of players respawning in Henesys every time is that the server often fails to load the saved map, triggering the hardcoded Henesys fallback. The `MapFactory.loadMapFromWz()` method can return `null` if the WZ data for a map is missing or invalid. In our case, the hybrid v83/v87 setup likely has some map IDs in the database that do not exist or cannot be read with the current WZ files (for example, v87 maps not present in v83 data). Whenever `getMap(savedMapId)` returns null, the server defaults the character’s location to Henesys on login. This means **any time a player logs out on an “unknown” map**, they will be relocated to Henesys on next login. Over time, this made it seem like “always Henesys regardless of logout location,” especially if many maps were affected by WZ mismatches.

2. **Invalid/Corrupted Map IDs in the Database:** Some characters ended up with bizarre map IDs in the database (e.g. 390625, 67499489). These values are *not* legitimate MapleStory map codes – they appear to be artifacts of a bug. One strong clue is that **390625 is exactly 100000000 / 256**, suggesting a missing byte or bit-shift error (100000000 in hex is 0x05F5E100; dropping the lowest 8 bits yields 0x05F5E1 = 390625). Similarly, 67499489 in hex is 0x0405F5E1, which looks like an extra byte (0x04) prefixed to 0x05F5E1. This pattern suggests that at some point the map ID might have been mis-packed with an extra field (possibly a channel or world identifier) or truncated. The likely source is a **server-side bug in saving or loading the map ID**:

   * It could be an error in how the server writes the map ID to the database (e.g. using the wrong parameter index in `ps.setInt()`, mixing up the `map` and `spawnpoint` fields). If the map ID and spawnpoint got swapped or combined, the stored value could become corrupted. The `characters` schema shows `map` and `spawnpoint` as separate INT columns – if a coding error wrote a combined value into `map`, that might explain the high numbers.
   * Another possibility is a **race condition** where an outdated `mapid` field was saved. For instance, if a player changed maps but the `mapid` in memory wasn’t updated in time or a save happened during a transition, the saved value might be incorrect. The `mapTransitioning` flag is set true during warp, but if an autosave thread ignored this, it might capture a partial state.
   * The presence of 0x04 in 0x0405F5E1 might correspond to a channel ID being inadvertently included. If, for example, channel 4 was involved and got concatenated with the map ID bytes, it indicates a logical error in constructing the value. In short, **somewhere in the save/load pipeline an extra byte or misalignment crept in**, producing those corrupted IDs.

3. **Hardcoded Fallbacks and Brittle Defaults:** The code relies on hardcoded default map IDs in multiple places. Henesys (100000000) is used as a universal “safe” map without context:

   * On the **server**: Fallback to Henesys occurs whenever a map can’t be loaded or when `newClient` finds `map == null`. This is a one-size-fits-all approach – it doesn’t consider where the player was or should logically go. Even if a map simply fails to load due to a temporary issue, the player gets sent to Henesys. There is also a constant `MapId.NONE = 999999999` used to denote an invalid map or “no map”, which is another magic number that the code checks against.
   * On the **client**: There is a **temporary fix** in `SetFieldHandler::set_field()` that explicitly checks if the map ID is `390625` or `67499489` or out of normal range (> 999,999,999 or negative) and then **forces it to 100000000 (Henesys)**. This is a clear indicator of a hardcoded fallback on the client side. It’s essentially masking the symptom by teleporting the player to Henesys whenever an obviously invalid map number is about to be used.

   These hardcoded fallbacks, while preventing crashes or stuck characters, are brittle. They make Henesys a catch-all spawn point, even in cases where a different safe map would make more sense (or where the issue should be handled by fixing the underlying data). Moreover, because they are scattered in code, they can lead to inconsistent state: for example, the server might think it corrected the map to Henesys, but if it didn’t inform the client properly, the client’s own code does a redundant correction (or vice versa).

4. **Desynchronization Between Client and Server Map State:** There appears to be a subtle client/server negotiation issue during login that allows a **map ID mismatch to persist silently**. Specifically, if the server falls back to Henesys on login, it sets the character’s mapid server-side to 100000000. However, the client may still be holding the original (possibly corrupted) map ID in the character stats that came from the login server or DB. The SetField packet for initial login likely uses the `set_field()` path (non-zero mode bytes), meaning the client will use its local `player.get_stats().get_mapid()` value. If that value was *not* updated to Henesys by the time the client uses it, the client ends up seeing an invalid number. Indeed, the client’s temp fix kicks in, logging an error and overriding to 100000000. This indicates the server did not fully synchronize the corrected map ID to the client before the client tried to load the map. The outcome is the client and server ultimately agree on Henesys (since the client forces it too), but the process is “silent” in terms of user-facing feedback – the player just finds themselves in Henesys without an obvious explanation. Meanwhile, the underlying issue (the bad map ID in the DB or in transit) remains unaddressed.

5. **Timing and Save Order (Possible Race Conditions):** We need to verify if `saveCharToDB()` is *truly* called at all the right times. The code snippet in `ChangeMapHandler` ensures a save on portal travel, but what about other scenarios:

   * **Regular Logout/Disconnect:** Typically, the server saves a character when they logout or disconnect. If a player simply exits without changing maps again, the last known map should be saved. If the server’s logout handler wasn’t properly calling saveCharToDB, or if an exception occurred, the DB might not update. Given the symptoms, it’s worth ensuring the logout routine calls `saveCharToDB()` (likely it does, but this should be confirmed).
   * **Auto-Save Intervals:** If the server relies on periodic auto-saves, a long interval or disabled auto-save could let players change maps and log off before the next save, leaving the DB with the old map (as noted in the config guide, too infrequent auto-saves mean “map changes might not persist”). The presence of explicit save on portal mitigates this for portal uses, but consider warps that don’t use `ChangeMapHandler`: for example, GMs warping players, or special event teleports. If those bypass the normal handler and don’t call save, the map might only be recorded in memory. A crash or quick logout thereafter could fail to persist the new map.
   * **Map Transition Edge Cases:** The `changeMapInternal` logic sets a flag `mapTransitioning` to true and removes the player from the old map before adding to the new one. If an auto-save thread or logout happened in that narrow window where the character was in between maps (with `map` possibly null or still old, and `mapid` not yet updated until after the null check), it might save an incorrect state. The code does guard by only updating `mapid` after confirming the character is still present in the world storage, to avoid updating a ghost on disconnect. But in the case the character did disconnect mid-warp, `mapid` might never get set to the new map. Later, the disconnect save would use the old `mapid` (since `map` would be null by then), thus saving a potentially stale or even invalid value. This race could contribute to the corrupted IDs if, say, the old map object was already gone and `mapid` field had a remnant value.

6. **Null or “None” Map Handling:** The server uses a special constant `MapId.NONE = 999999999` to signify an invalid map or absence of map. If any logic mistakenly set a character’s mapid to this value (or greater, as a sentinel), it would be treated as “no map” and likely trigger a fallback. The client-side check `if (mapid > 999999999)` would catch such a value as well. We should ensure that *no legitimate scenario* leaves a character with mapid = 999999999 in the DB. The current code in `saveCharToDB` does not explicitly set mapid to 999999999 anywhere; it’s only used for comparisons. However, a map with a forcedReturn might use MapId.NONE to mean “no specific forced return”. If a bug caused the code to save `map.getForcedReturnId()` even when it was NONE, it could save 999999999 to the DB. The saving logic actually checks `if (map.getForcedReturnId() != MapId.NONE)`, so it won’t intentionally save 999999999. Nonetheless, we should consider if a *null map* scenario might mistakenly carry a NONE value. The MapFactory returning null leads to the fallback rather than setting mapid to NONE, which is good. Overall, null maps are handled by swapping to Henesys on both server and client, which is safe in that it prevents crashes – but it’s *silently destructive* to the player’s intended location. There’s no user-facing alert like “Map not found, moved to Henesys”; it just happens in the background (logged on the server at most).

## Points in Code Where Map IDs Can Corrupt or Default Unsafely

* **Client `SetFieldHandler` Fallback:** As mentioned, the client explicitly looks for known bad IDs and force-resets them. This is at best a band-aid. The code path shows the client receiving an unexpected `mapid` (390625, 67499489, etc.) and logging an error that it’s invalid, then defaulting `mapid = 100000000` (Heneysys) and even updating the client’s own CharStats to that effect. This indicates the client has no better data-driven way to decide a fallback – it’s literally checking against hardcoded problematic values. **Why they appear:** These values likely came straight from the character’s stats (populated from the DB or login info) as discussed. The presence of this code tells us the client had been encountering those numbers enough to warrant a hardcoded check.

* **Server Login Fallback (`loadCharFromDB` / `newClient`):** The server uses hardcoded Henesys fallback whenever `mapFactory.getMap(id)` fails. In `loadCharFromDB`, after reading the saved `ret.mapid` from DB, it attempts to load the map and if it’s null, immediately grabs map 100000000. In `newClient`, it does similarly and also resets the character’s `mapid` field to 100000000 to ensure consistency. These are **hardcoded defaults** in code. If tomorrow we wanted Lith Harbor as default, we’d have to alter constants and recompile. More importantly, it doesn’t distinguish *why* the map failed to load – it could be a transient issue, a non-existent map, or a configuration problem – yet the result is always Henesys.

* **Map Save Logic (Forced Returns and Null):** While not a “corruption” per se, the `saveCharToDB` logic can cause a player’s saved map to differ from their actual last map in-game:

  * If a map has a `forcedReturnId` (set in the WZ data for certain maps like event maps, beginner zones, etc.), the code will **save that ID instead of the current map**. For example, if `map.getForcedReturnId()` is Henesys (100000000), the player will always be saved to Henesys regardless of where they actually logged out on that map. This is intentional design (to prevent spawning inside special maps), but it can be confusing if overused or misconfigured.
  * The check for `map == null` or cash shop open means if the character isn’t actively in a world map at save time, it falls back to the last known `mapid` in their stats. This is potentially dangerous if `mapid` wasn’t updated correctly. A specific risky case is if `mapid` was never set to a valid map because the player disconnected mid-transition – then `mapid` might still hold an old or even nonsense value and that gets saved. There’s no validation here on whether `mapid` is a plausible value; it trusts it.

* **MapFactory and WZ Handling:** The `MapFactory.getMap()` logic will return `null` if it can’t load the map data. The code comment even notes “This causes the Henesys fallback”. The unsafe part is that `null` propagates out, relying on the calling code to handle it. Currently, the only handling is the fallback to Henesys; there’s no attempt to **validate the map ID before usage** or to resolve it in a smarter way. Additionally, if `mapSource.getData(mapName)` throws a `NullPointerException` or similar, it might not be caught at this layer (though in our repomix they added a null check and log). If an NPE occurs unhandled, it could abort the load process and possibly default the map to 0 or leave it unchanged, which could then be saved or used incorrectly. The config notes warned to watch for NPEs in MapFactory as well.

## Why Players Were Always Returning to Henesys

Bringing the above together: **the root cause was a combination of missing map data and a flawed persistence cycle.** Many characters had saved map IDs that the server simply could not resolve (either due to WZ file mismatches or previous corruption). Each login, the server would dutifully try `getMap(badId)`, fail, and default to Henesys. The player would see Henesys every time because the underlying issue (the invalid map in the DB) never got fixed by the current code. In fact, the code doesn’t ever attempt to update the DB when it does the fallback-on-login. Notice that in `newClient`, after detecting a null map and switching to Henesys, **it does not immediately save** the corrected mapid back to the database. So if the player *did nothing* (e.g. they log in and out without changing maps), the DB might still contain the old invalid ID. The Henesys background appearing even at the world select screen is likely a side-effect of the client having Henesys data preloaded due to this repeated fallback. Possibly the client Stage was set active with Henesys even before the character entered the game (perhaps because the server sent a map in the handshake or the client preloaded the last map background). The Stage rendering code only draws if state is ACTIVE; seeing Henesys at world select implies the client thought a map was active when it shouldn’t be – probably another quirk of using a default map as fallback during character login initialization.

In summary, **every time a character’s saved map couldn’t be loaded, the server teleported them to Henesys**. And because the save timing was not correcting the DB promptly, the “bad” map ID persisted in the database, causing the cycle to repeat next login. The client-side safeguards hid some of the oddities (preventing crashes from invalid IDs) but also reinforced the behavior of always ending up in Henesys.

## Recommended Fixes and Improvements

To resolve these issues, a multi-pronged approach is needed, focusing on data validation, removing magic fallbacks, and ensuring robust save/load timing:

* **Validate Map IDs Before Saving:** The server should never write obviously invalid map IDs to the database. We can add a check in `saveCharToDB` before executing the save. For example, verify that `mapToSave` corresponds to a real map in `MapFactory` (or at least is within expected numeric ranges). If not, replace it with a safe default *at that moment* and log a warning. This would catch scenarios where `mapid` field might be corrupt or where a forcedReturn ID is bad. Essentially, rather than blindly `ps.setInt(21, mapToSave)`, do:

  ```java
  if (mapToSave <= 0 || mapToSave >= MAX_MAPID || mapFactory.getMap(mapToSave) == null) {
      log.error("Aborting save of invalid map ID {} for {} – using fallback.", mapToSave, getName());
      mapToSave = getSafeFallbackMapId(); // e.g. a method to get a default
  }
  ps.setInt(mapIndex, mapToSave);
  ```

  *MAX\_MAPID* could be a defined upper bound (slightly above the highest legit map id) or simply check against MapId.NONE. `getSafeFallbackMapId()` could consult configuration or character data (see next point) rather than a hardcoded Henesys.

* **Use Data-Driven Fallbacks (Avoid Hardcoding Henesys):** Remove the direct references to `MapId.HENESYS` for fallback and replace them with a configurable or context-aware solution:

  * Consider using each map’s defined **return map** as the first fallback. For example, if a map fails to load, it likely has a returnMap (most maps in Maple WZ have an “info/returnMap” field pointing to a town). If we can’t load the map to read its returnMap, we might have a lookup table of known returnMap values (this could be populated at server start for all maps present in WZ). Using the return map is more natural than sending everyone to Henesys. For instance, if a character was in an Ellinia forest map that is missing from WZ, its return town is Ellinia; we should send them there if possible.
  * Provide a **configuration setting** for default spawn map. The server config (world.properties or similar) might already have a “defaultSpawnMap” which could be used instead of always 100000000. This way, if the admin wants a different default, they change a config, not code. Replacing `MapId.HENESYS` with something like `ServerConfig.getDefaultMap()` would be more flexible.
  * If a character’s saved map is invalid, another idea is to fall back to their job or origin town (e.g., beginners to Maple Island, mages to Ellinia, etc.), but that adds complexity. A simpler maintainable approach is a single configurable fallback plus using returnMaps for finer granularity.
  * **On the client side**, rather than hardcoding specific bad IDs, the client could be made to trust the server’s packet more. Ideally, the server should *always send a valid map ID in SetField packets*, even on login, so the client never has to use `player.get_stats().get_mapid()` for that. If the protocol allows, unify the SetField handling to always include the mapId. Then the client’s `set_field()` could simply validate that ID exists in its map data (to catch any discrepancy) and log an error if not, but not have a baked list of numbers. Since client modifications are harder if we want to keep compatibility, the main fix is server-side: don’t let those bad IDs reach the client in the first place.

* **Synchronous Update of MapID on Transitions:** Ensure that whenever a map change is initiated, the character’s in-memory `mapid` field is updated *immediately and safely*. The `changeMapInternal` already sets `setMapId(to.getId())` at the right time in normal cases. We should double-check any other code paths that change maps:

  * If there are scripting APIs or GM commands that warp characters, they should also call `setMapId()` and ideally `saveCharToDB()` afterwards.
  * For channel changes or cross-world transfers (if any in this version), make sure the destination map ID is carried over correctly.
  * By doing this, even if a disconnect happens soon after, the `mapid` in CharStats is correct and can be saved. The `mapTransitioning` flag could be leveraged: for example, the disconnect handler can detect if a transition was mid-flight and decide to wait a moment or to use the target mapid if known.

* **Improve Save Timing and Reduce Race Conditions:** To combat stale saves:

  * **Always save on logout/disconnect.** It’s likely implemented, but verify. If not, add a call to `saveCharToDB` in the logout routine (ensuring not to conflict with autosave).
  * Use a shorter autosave interval or at least ensure autosave cannot overwrite a newer map with an old one. One way is to have `saveCharToDB` check a timestamp of last map change – if the last change happened after the last autosave tick, then proceed, otherwise maybe skip or at least re-fetch current mapid.
  * As a safety, you might only allow one save at a time per character (the method is synchronized, which helps). Logging around saves can help detect if an autosave happened right around a warp. The config suggestions include logging “AUTO-SAVE start” and “completed” with map info – implementing those would show if, say, an autosave saved an outdated map just after a warp.
  * If an inconsistency is detected (e.g., saving mapid that doesn’t match the `map.getId()` currently), log it loudly. The existing log already prints both values (mapToSave vs. mapid field vs. map object). Reviewing those logs can reveal if the `mapid` field and actual map diverge unexpectedly, which would hint at race conditions.

* **Handle Null Maps More Gracefully:** Instead of just dumping players to Henesys when a map is missing:

  * Log an alert for GMs or administrators whenever this happens (the code does log an error in `newClient`, which is good). We can enhance this by also logging the *original intended map ID* that failed to load (that’s already in the log message) and perhaps notifying the player. For example, send a notice to the player like, *“The map you were in is unavailable. You have been moved to Henesys.”* This at least makes it transparent.
  * Consider automatically correcting the database when this fallback occurs. After doing `this.mapid = MapId.HENESYS` in `newClient`, we could call a save or queue a save so that the DB is updated to 100000000. That way, the next login doesn’t repeat the cycle. However, careful: we should only do this if we are confident the original map is truly invalid. If the failure was due to a temporary issue (say a file not loaded due to startup race), we wouldn’t want to permanently override the player’s saved map. This is where a data-driven approach helps: if we know the map doesn’t exist at all, it’s fine to update their saved location. If it’s a transient issue, maybe we shouldn’t. Perhaps a compromise is to not save immediately, but if the player remains in Henesys for the session and logs out, then that logout save will naturally write Henesys. So as long as logout save works, the DB will correct itself on a normal exit. The key is ensuring that save *does* occur.

* **Client/Server Map ID Synchronization:** To prevent the client from ever seeing a bogus mapid like 390625, the server should ensure the character’s stats sent to the client are updated. In a typical MapleStory flow, the login server loads the character (perhaps with `channelserver=false` in `loadCharFromDB`) and then the channel server does a fresh load. It’s possible the client’s character info (including `mapid`) was populated from the first load (with the bad ID), and then the channel corrected it. We need to send the updated mapid to the client. This could be done by including the mapId in the SetField packet unconditionally, or by sending a secondary packet updating the character’s stats. The simpler approach: modify the server’s packet assembly for SetField on login to always use `player.getMapId()` from the server’s current character object. After `newClient()`, the `player.getMapId()` will return Henesys if a fallback happened (because we set `mapid` in newClient). If the server then sends that value, the client’s `change_map` path could be used uniformly. In short, **eliminate the `set_field()` branch that relies on client-stored mapid**, or ensure the client stat is updated. Since altering the protocol might be beyond scope, at least keep the client fallback code as a last resort, but it shouldn’t trigger if the above measures are taken.

* **Eliminate Magic Numbers:** Replace specific numeric checks in code with named constants or data checks:

  * The client’s check for `mapid > 999999999` is effectively checking for `MapId.NONE` overflow. Use the same constant on client side if possible (so it’s clear it’s checking for “NONE”).
  * Remove the explicit `== 390625` and `== 67499489` checks once the root cause is fixed. These should never occur once the server stops sending bad IDs. In the interim, one could generalize the check: e.g., “if mapid is not found in client’s map directory” then request a fallback. That would be more robust than specific values.
  * On server side, avoid using 100000000 in many places. Define a fallbackMap variable (configurable) and use it in `loadCharFromDB` and `newClient`. This makes it easier to change and also clearer that it’s the “Fallback Map”. The code already uses `MapId.HENESYS` constant; one improvement is to load that from config at runtime rather than a compile-time constant.

* **Additional Logging and Monitoring:** The investigation highlighted how crucial logs are. We should integrate the suggested log additions to catch issues in the future. For example:

  * Log every map change with source and destination: *“Map change: <char> from <oldMapId> to <newMapId>”*.
  * Log at login: *“Player login: <char> at map <mapId> (from DB)”*.
  * Expand the error logging in MapFactory: it already logs when map data is null; also catch exceptions and log them with the map ID.
  * The `saveCharToDB` log that prints mapid vs map object is extremely useful; ensure it remains or even use it to alert if those two differ unexpectedly (which could point to a missed update).
  * Consider implementing an audit trail (as hinted by the SQL snippet) of map changes, so you can retrospectively see what map was saved when for a character. This can help diagnose if, say, an autosave wrote a weird value at some timestamp.

## Verification and Testing

After applying fixes, it’s important to verify that the issues are resolved:

* **Session Persistence:** A character who logs out in a valid map should reappear in the same map on login. Create a new character (starts at default), move to several maps (including a few obscure ones), log out and back in, and confirm the spawn location matches the last map – not always Henesys.

* **No More Corrupt IDs:** Run the provided SQL query to check for invalid map IDs in the `characters` table after some gameplay. The expectation is that values like 390625 or large out-of-range numbers no longer appear. All map IDs should correspond to real maps. If any None/999999999 appears, ensure it’s handled immediately.

* **Graceful Fallbacks:** Intentionally place a character in a map that is known to be missing (you can simulate this by editing their DB entry to a dummy map and logging in). The server should now choose a fallback based on the new logic (e.g., return map or configured default). The client should get a clear instruction to go there. Ideally, the player could be informed via a message. Check that the DB gets updated to this fallback map (so if the player logs out again, it doesn’t keep the invalid ID). Also verify the client no longer needs to apply its hardcoded fix – its logs should no longer show the “Invalid map ID detected” error from `SetFieldHandler`.

* **Concurrent and Edge Cases:** Try rapid map transitions and immediate logouts to see if any slip through without saving. For example, go through a portal and force-close the client immediately. On relogin, see if the map persisted or not. With a robust saving strategy, even abrupt disconnects after changing map should not revert to old locations or produce corrupt data. If issues still occur, consider making the map save even *earlier* in the transition (e.g., update the DB right when starting a transition, with a flag, then adjust if needed).

By addressing the above, the character’s last location should reliably persist, and the system will be safer and more maintainable. In short, we remove hidden surprises (like always waking up in Henesys) and replace them with intentional, logged, and configurable behavior – ensuring the game world feels consistent and debug-friendly moving forward.

**Sources:**

* MapleStory v83/v87 Hybrid – Key client code for map loading and SetField handling, showing the client’s temporary fix for corrupted map IDs.
* Server-side character management code (Cosmic v83): map transition updates and database save logic, and login-time map fallback in `newClient()`.
* MapFactory handling of map data and fallback behavior.
* Configuration and logs guidance which informed the need for autosave checks and additional debug logging.
